{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Redes, Protocolos e Interfaces. Laboratorio de Sistemas Inteligentes Calendario LSI Lab. D\u00eda T\u00edtulo 0 13/04 Introducci\u00f3n y entorno experimental 1 13/04 Introducci\u00f3n a TFLite en la Raspberry Pi 2 20/04 Clasificaci\u00f3n de im\u00e1genes 3 27/04 Detecci\u00f3n de objetos 4 04/05 Segmentacion de objetos 5 11/05 Segmentaci\u00f3n de objetos] 6 18/05 Reconocimiento de voz] 7 25/05 Reconocimiento de voz Calendario RPI-I Pr\u00e1ctica D\u00eda T\u00edtulo 1 05/10 Introducci\u00f3n al entorno de desarrollo 12/10 FESTIVO 2 19/10 WiFi. Conceptos b\u00e1sicos 3 26/10 WiFi. Conceptos avanzados (WiFi Mesh, provisionamiento y ahorro de energ\u00eda) 02/11 FESTIVO 09/11 FESTIVO 4 16/11 Bluetooth Low Energy 5 30/11 BLE Mesh 07/12 FESTIVO 6 14/11 6LowPAN (Simulaci\u00f3n) 7 28/12 6LowPAN (SensorTag) 8 21/12 LoRA Calendario RPI-II Pr\u00e1ctica D\u00eda T\u00edtulo 1 01/10 Sockets TCP/UDP (Linux) 2 08/10 Sockets TCP/UDP (ESP32) 3 15/10 TLS y DTLS 4 22/10 Websockets 5 29/11 Servidores REST y representaci\u00f3n de la informaci\u00f3n (JSON y CBOR) 6 05/11 MQTT (I) 6 12/11 MQTT (II) 7 19/11 CoAP 8 26/11 LWM2M (I) 8 03/12 LWM2M (II) 9 10/12 Node-RED 10 17/12 Entornos Cloud / Frameworks IoT","title":"Calendario"},{"location":"#redes-protocolos-e-interfaces-laboratorio-de-sistemas-inteligentes","text":"","title":"Redes, Protocolos e Interfaces. Laboratorio de Sistemas Inteligentes"},{"location":"#calendario-lsi","text":"Lab. D\u00eda T\u00edtulo 0 13/04 Introducci\u00f3n y entorno experimental 1 13/04 Introducci\u00f3n a TFLite en la Raspberry Pi 2 20/04 Clasificaci\u00f3n de im\u00e1genes 3 27/04 Detecci\u00f3n de objetos 4 04/05 Segmentacion de objetos 5 11/05 Segmentaci\u00f3n de objetos] 6 18/05 Reconocimiento de voz] 7 25/05 Reconocimiento de voz","title":"Calendario LSI"},{"location":"#calendario-rpi-i","text":"Pr\u00e1ctica D\u00eda T\u00edtulo 1 05/10 Introducci\u00f3n al entorno de desarrollo 12/10 FESTIVO 2 19/10 WiFi. Conceptos b\u00e1sicos 3 26/10 WiFi. Conceptos avanzados (WiFi Mesh, provisionamiento y ahorro de energ\u00eda) 02/11 FESTIVO 09/11 FESTIVO 4 16/11 Bluetooth Low Energy 5 30/11 BLE Mesh 07/12 FESTIVO 6 14/11 6LowPAN (Simulaci\u00f3n) 7 28/12 6LowPAN (SensorTag) 8 21/12 LoRA","title":"Calendario RPI-I"},{"location":"#calendario-rpi-ii","text":"Pr\u00e1ctica D\u00eda T\u00edtulo 1 01/10 Sockets TCP/UDP (Linux) 2 08/10 Sockets TCP/UDP (ESP32) 3 15/10 TLS y DTLS 4 22/10 Websockets 5 29/11 Servidores REST y representaci\u00f3n de la informaci\u00f3n (JSON y CBOR) 6 05/11 MQTT (I) 6 12/11 MQTT (II) 7 19/11 CoAP 8 26/11 LWM2M (I) 8 03/12 LWM2M (II) 9 10/12 Node-RED 10 17/12 Entornos Cloud / Frameworks IoT","title":"Calendario RPI-II"},{"location":"LSI/Lab0/","text":"Laboratorio 0. Entorno experimental Objetivos Preparar el entorno experimental. Completar la configuraci\u00f3n del sistema. Probar el correcto funcionamiento tanto del Software como del Hardware. Demostrar la capacidad de procesamiento tanto de la placa Raspberry Pi como del acelerador EdgeTPU de Google. Introducci\u00f3n El entorno experimental que se va a emplear en esta parte de la asignatura est\u00e1 compuesto de los siguientes elementos: Hardware Kit Raspberry Pi 4 Placa Raspberry Pi 4 con un SoC Broadcom BCM2711 con las siguientes caracter\u00edsticas: Quad core de Cortex-A72, ARM v8 de 64-bit, @1.5GHz (+ info ) Alimentador USB-C Cable micro-HDMI a HDMI Tarjeta uSD de alta velocidad Kit aceleraci\u00f3n Acelerador Coral USB (+ info ) C\u00e1mara para Raspberry Pi v2 Software Raspbian OS 64 bits - Distribuci\u00f3n Linux basada en Debian adaptada a la Raspberry Pi en su versi\u00f3n de 64 bits (beta) OpenCV 4.5.1 - Librer\u00eda de visi\u00f3n por computador TensorFlow 2.4 - Librer\u00eda de Aprendizaje M\u00e1quina TensorFlowLite - versi\u00f3n para sistemas Edge/Mobile A continuaci\u00f3n se proporcionan las instrucciones para configurar y probar el entorno experimental. Preparaci\u00f3n SD Para simplificar el proceso de instalaci\u00f3n se proporciona una imagen comprimida del sistema operativo con el software necesario pre-instalado. No obstante, si alguien desea realizar el proceso de instalaci\u00f3n completo por su cuenta, puede seguir las instrucciones de la web de Q-engineering , que suelen ser bastante completas y actualizadas. A continuaci\u00f3n se detallan los pasos a seguir para grabar la imagen de la tarjeta SD que hemos preparado.. Descargar e instalar un programa para flashear tarjetas SD: Raspberry Pi Imager (recomendado) BalenaEtcher Descargar la imagen comprimida del siguiente enlace lsi-rpi4-img.gz Nota: Alternativamente cabr\u00eda la posibilidad de usar la imagen que ofrece Q-engineering en su repositorio de GitHub: A Raspberry Pi 4 64-bit OS image of several frameworks and deep-learning examples Empleado un lector/escritor de tarjetas SD escribir la imagen a disco: Seleccionar la tarjeta SD sobre la que se desea escribir (64GB) Seleccionar sistema operativo: \"Use custom\" y localizar el fichero de la imagen comprimida previamente descargada (no es necesario descomprimirla previamente) Realizar la escritura (puede tardar bastantes minutos) Conexi\u00f3n, arranque y configuraci\u00f3n Realizar la conexi\u00f3n de los dispositivos Conectar el teclado y el rat\u00f3n a los puertos USB 2.0, dejando al menos uno de los puertos USB 3.0 libre para el acelerador Google Coral (tienen un remate azul) Conectar el monitor mediante el cable micro-HDMI a HDMI Insertar la tarjeta SD grabada previamente Conectar la c\u00e1mara \"Raspberry Pi Camera Module v2\" (sensor Sony IMX219, interfaz CSI-2, resoluci\u00f3n 3280 x 2464 p\u00edxeles, 30fps) Para informaci\u00f3n m\u00e1s precisa de la conexi\u00f3n se puede consultar el siguiente video. Conectar alimentaci\u00f3n (cable USB-C) y comprobar el correcto arranque del equipo Acceder a la Wifi con SSID=UCM y con las credenciales UCM propias El procedimiento es an\u00e1logo a cualquier otro computador, se accede a la wifi y posteriormente se abre un navegador y se introducen las credenciales (+ info ) Configurar la raspi con la utilidad raspi-config sudo raspi-config Opciones del sistema S3- Clave usuario pi S4 - Nombre del equipo Opciones de interfaz P1 - Activar c\u00e1mara P2 - Activar SSH para conexi\u00f3n remota P3 - Activar VNC (opcional) Finalizar y reiniciar el equipo Demos b\u00e1sicas Comprobar la correcta detecci\u00f3n de la c\u00e1mara $ vcgencmd get_camera supported=1 detected=1 Comprobar temperatura (opcional) $ vcgencmd measure_temp temp=39.9'C Probar un ejemplo completo (c\u00e1mara + OpenCV + TensorFlowLite) El siguiente ejemplo de Qengineering ilustra realizar una segmentaci\u00f3n de im\u00e1ganes empleado el modelo DeepLab v3 (fuente: github ) cd ~/Test/TensorFlow_Lite_Segmentation_RPi_64-bit bin/Release/TestUnet ] Otros ejemplos precompiladosde Qengineering TensorFlow_Lite_Pose_RPi_64-bits : detecci\u00f3n de postura corporal TensorFlow_Lite_SSD_RPi_64-bits : detecci\u00f3n de objetos Nota: Se trata de proyectos CodeBlocks, para compilarlos de nuevo es preciso abrir el correspondiente proyecto ( *.cbp ) En ambos casos utilizan videos en lugar de captura de c\u00e1mara. Para usar la c\u00e1mara es preciso modificar la l\u00ednea VideoCapture(0); y recompilar el proyecto. Demo Google Coral Configuraci\u00f3n necesaria para usar el acelerador Google Coral A\u00f1adir usuario pi al grupo plugdev (para no tener que ejecutar los programas como root ) sudo usermod -aG plugdev $USER Instalar las fuentes de paquetes. echo \"deb https://packages.cloud.google.com/apt coral-edgetpu-stable main\" | sudo tee \\ /etc/apt/sources.list.d/coral-edgetpu.list curl https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add - sudo apt-get update Instalar la librer\u00eda de soporte, para la que hay dos opciones incompatibles libedgetpu1-std y libedgetpu1-max (m\u00e1xima frecuencia y temperatura): sudo apt-get install libedgetpu1-max Demo En el directorio ~/Test/TensorFlow-Lite-Object-Detection-on-Android-and-Raspberry-Pi se proporciona un ejemplo de uso del acelerador Google Coral (fuente: github ) a continuaci\u00f3n se indican las instrucciones para probarlo: S\u00edn EdgeTPU (i.e. Google Coral): cd ~/Tests/TensorFlow-Lite-Object-Detection-on-Android-and-Raspberry-Pi python3 TFLite_detection_webcam.py --modeldir=Sample_TFLite_model Con EdgeTPU: A\u00f1adir usuario pi al grupo plugdev (para no tener que ejecutar el script como root ): sudo usermod -aG plugdev $USER Descarga modelo espec\u00edfico: wget https://dl.google.com/coral/canned_models/mobilenet_ssd_v2_coco_quant_postprocess_edgetpu.tflite mv mobilenet_ssd_v2_coco_quant_postprocess_edgetpu.tflite Sample_TFLite_model/edgetpu.tflite Conectar EdgeTPU a un puerto USB 3.0. Ejecutar la versi\u00f3n EdgeTPU python3 TFLite_detection_webcam.py --modeldir=Sample_TFLite_model --edgetpu","title":"Laboratorio 0"},{"location":"LSI/Lab0/#laboratorio-0-entorno-experimental","text":"","title":"Laboratorio 0. Entorno experimental"},{"location":"LSI/Lab0/#objetivos","text":"Preparar el entorno experimental. Completar la configuraci\u00f3n del sistema. Probar el correcto funcionamiento tanto del Software como del Hardware. Demostrar la capacidad de procesamiento tanto de la placa Raspberry Pi como del acelerador EdgeTPU de Google.","title":"Objetivos"},{"location":"LSI/Lab0/#introduccion","text":"El entorno experimental que se va a emplear en esta parte de la asignatura est\u00e1 compuesto de los siguientes elementos: Hardware Kit Raspberry Pi 4 Placa Raspberry Pi 4 con un SoC Broadcom BCM2711 con las siguientes caracter\u00edsticas: Quad core de Cortex-A72, ARM v8 de 64-bit, @1.5GHz (+ info ) Alimentador USB-C Cable micro-HDMI a HDMI Tarjeta uSD de alta velocidad Kit aceleraci\u00f3n Acelerador Coral USB (+ info ) C\u00e1mara para Raspberry Pi v2 Software Raspbian OS 64 bits - Distribuci\u00f3n Linux basada en Debian adaptada a la Raspberry Pi en su versi\u00f3n de 64 bits (beta) OpenCV 4.5.1 - Librer\u00eda de visi\u00f3n por computador TensorFlow 2.4 - Librer\u00eda de Aprendizaje M\u00e1quina TensorFlowLite - versi\u00f3n para sistemas Edge/Mobile A continuaci\u00f3n se proporcionan las instrucciones para configurar y probar el entorno experimental.","title":"Introducci\u00f3n"},{"location":"LSI/Lab0/#preparacion-sd","text":"Para simplificar el proceso de instalaci\u00f3n se proporciona una imagen comprimida del sistema operativo con el software necesario pre-instalado. No obstante, si alguien desea realizar el proceso de instalaci\u00f3n completo por su cuenta, puede seguir las instrucciones de la web de Q-engineering , que suelen ser bastante completas y actualizadas. A continuaci\u00f3n se detallan los pasos a seguir para grabar la imagen de la tarjeta SD que hemos preparado.. Descargar e instalar un programa para flashear tarjetas SD: Raspberry Pi Imager (recomendado) BalenaEtcher Descargar la imagen comprimida del siguiente enlace lsi-rpi4-img.gz Nota: Alternativamente cabr\u00eda la posibilidad de usar la imagen que ofrece Q-engineering en su repositorio de GitHub: A Raspberry Pi 4 64-bit OS image of several frameworks and deep-learning examples Empleado un lector/escritor de tarjetas SD escribir la imagen a disco: Seleccionar la tarjeta SD sobre la que se desea escribir (64GB) Seleccionar sistema operativo: \"Use custom\" y localizar el fichero de la imagen comprimida previamente descargada (no es necesario descomprimirla previamente) Realizar la escritura (puede tardar bastantes minutos)","title":"Preparaci\u00f3n SD"},{"location":"LSI/Lab0/#conexion-arranque-y-configuracion","text":"Realizar la conexi\u00f3n de los dispositivos Conectar el teclado y el rat\u00f3n a los puertos USB 2.0, dejando al menos uno de los puertos USB 3.0 libre para el acelerador Google Coral (tienen un remate azul) Conectar el monitor mediante el cable micro-HDMI a HDMI Insertar la tarjeta SD grabada previamente Conectar la c\u00e1mara \"Raspberry Pi Camera Module v2\" (sensor Sony IMX219, interfaz CSI-2, resoluci\u00f3n 3280 x 2464 p\u00edxeles, 30fps) Para informaci\u00f3n m\u00e1s precisa de la conexi\u00f3n se puede consultar el siguiente video. Conectar alimentaci\u00f3n (cable USB-C) y comprobar el correcto arranque del equipo Acceder a la Wifi con SSID=UCM y con las credenciales UCM propias El procedimiento es an\u00e1logo a cualquier otro computador, se accede a la wifi y posteriormente se abre un navegador y se introducen las credenciales (+ info ) Configurar la raspi con la utilidad raspi-config sudo raspi-config Opciones del sistema S3- Clave usuario pi S4 - Nombre del equipo Opciones de interfaz P1 - Activar c\u00e1mara P2 - Activar SSH para conexi\u00f3n remota P3 - Activar VNC (opcional) Finalizar y reiniciar el equipo","title":"Conexi\u00f3n, arranque y configuraci\u00f3n"},{"location":"LSI/Lab0/#demos-basicas","text":"Comprobar la correcta detecci\u00f3n de la c\u00e1mara $ vcgencmd get_camera supported=1 detected=1 Comprobar temperatura (opcional) $ vcgencmd measure_temp temp=39.9'C Probar un ejemplo completo (c\u00e1mara + OpenCV + TensorFlowLite) El siguiente ejemplo de Qengineering ilustra realizar una segmentaci\u00f3n de im\u00e1ganes empleado el modelo DeepLab v3 (fuente: github ) cd ~/Test/TensorFlow_Lite_Segmentation_RPi_64-bit bin/Release/TestUnet ] Otros ejemplos precompiladosde Qengineering TensorFlow_Lite_Pose_RPi_64-bits : detecci\u00f3n de postura corporal TensorFlow_Lite_SSD_RPi_64-bits : detecci\u00f3n de objetos Nota: Se trata de proyectos CodeBlocks, para compilarlos de nuevo es preciso abrir el correspondiente proyecto ( *.cbp ) En ambos casos utilizan videos en lugar de captura de c\u00e1mara. Para usar la c\u00e1mara es preciso modificar la l\u00ednea VideoCapture(0); y recompilar el proyecto.","title":"Demos b\u00e1sicas"},{"location":"LSI/Lab0/#demo-google-coral","text":"","title":"Demo Google Coral"},{"location":"LSI/Lab0/#configuracion-necesaria-para-usar-el-acelerador-google-coral","text":"A\u00f1adir usuario pi al grupo plugdev (para no tener que ejecutar los programas como root ) sudo usermod -aG plugdev $USER Instalar las fuentes de paquetes. echo \"deb https://packages.cloud.google.com/apt coral-edgetpu-stable main\" | sudo tee \\ /etc/apt/sources.list.d/coral-edgetpu.list curl https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add - sudo apt-get update Instalar la librer\u00eda de soporte, para la que hay dos opciones incompatibles libedgetpu1-std y libedgetpu1-max (m\u00e1xima frecuencia y temperatura): sudo apt-get install libedgetpu1-max","title":"Configuraci\u00f3n necesaria para usar el acelerador Google Coral"},{"location":"LSI/Lab0/#demo","text":"En el directorio ~/Test/TensorFlow-Lite-Object-Detection-on-Android-and-Raspberry-Pi se proporciona un ejemplo de uso del acelerador Google Coral (fuente: github ) a continuaci\u00f3n se indican las instrucciones para probarlo:","title":"Demo"},{"location":"LSI/Lab0/#sin-edgetpu-ie-google-coral","text":"cd ~/Tests/TensorFlow-Lite-Object-Detection-on-Android-and-Raspberry-Pi python3 TFLite_detection_webcam.py --modeldir=Sample_TFLite_model","title":"S\u00edn EdgeTPU (i.e. Google Coral):"},{"location":"LSI/Lab0/#con-edgetpu","text":"A\u00f1adir usuario pi al grupo plugdev (para no tener que ejecutar el script como root ): sudo usermod -aG plugdev $USER Descarga modelo espec\u00edfico: wget https://dl.google.com/coral/canned_models/mobilenet_ssd_v2_coco_quant_postprocess_edgetpu.tflite mv mobilenet_ssd_v2_coco_quant_postprocess_edgetpu.tflite Sample_TFLite_model/edgetpu.tflite Conectar EdgeTPU a un puerto USB 3.0. Ejecutar la versi\u00f3n EdgeTPU python3 TFLite_detection_webcam.py --modeldir=Sample_TFLite_model --edgetpu","title":"Con EdgeTPU:"},{"location":"LSI/Lab1/","text":"Laboratorio 1. Introducci\u00f3n a TFLite sobre la Raspberry Pi Objetivos Estudiar las APIs Python y C++ de OpenCV para realizar capturas desde c\u00e1mara y para realizar transformaciones b\u00e1sicas en im\u00e1genes capturadas. Desarrollar una aplicaci\u00f3n b\u00e1sica de clasificaci\u00f3n de im\u00e1genes combinando las APIs de OpenCV y TFLite desde Python y desde C++. Acelerar el proceso de inferencia utilizando el acelerador Google Coral. Dise\u00f1ar e implementar una aplicaci\u00f3n b\u00e1sica para detecci\u00f3n de objetos. Puedes obtener los ficheros necesarios para el desarrollo de la pr\u00e1ctica aqu\u00ed . Interacci\u00f3n con la c\u00e1mara v\u00eda OpenCV Existen m\u00faltiples APIs para acceder a la c\u00e1mara proporcionada junto a la Raspberry Pi en el entorno experimental. Picamera es una API espec\u00edfica y de c\u00f3digo abierto que proporciona una interfaz Python para el m\u00f3dulo de c\u00e1mara de la Raspberry Pi. El problema radica en su especificidad para este tipo de hardware , que limita su aplicaci\u00f3n o portabilidad a otros. OpenCV proporciona, como parte integral de su API b\u00e1sica (tanto desde Python como desde C++ ) una interfaz completa para la interacci\u00f3n con c\u00e1maras web, que se describe a continuaci\u00f3n. Captura de v\u00eddeos desde la c\u00e1mara En primer lugar, realizaremos una captura de flujo de v\u00eddeo desde la c\u00e1mara, utilizando la API de OpenCV en Python, realizando una transformaci\u00f3n b\u00e1sica y mostrando el flujo de v\u00eddeo transformado. En Python, para realizar la captura de v\u00eddeo, necesitaremos un objeto de tipo VideoCapture ; su \u00fanico argumento puede ser o bien un \u00edndice de dispositivo o un fichero de v\u00eddeo. Un \u00edndice de dispositivo es simplemente un identificador \u00fanico para cada una de las c\u00e1maras conectadas al equipo: import numpy as np import cv2 # 0. Configura camara 0. cap = cv2.VideoCapture(0) while(True): # 1. Adquisicion de frame (TODO: temporizar la adquisicion y reportar Frames por Segundo (FPS)). ret, frame = cap.read() # 2. Operaciones sobre el frame (transformaciones. TODO: investigar resize y otras transformaciones). gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) # 3. Mostramos el frame resultante. cv2.imshow('frame',gray) if cv2.waitKey(1) & 0xFF == ord('q'): break # 4. Liberamos la captura y destruimos ventanas. cap.release() cv2.destroyAllWindows() cap.read() devuelve un valor booleano en funci\u00f3n de si el frame fue le\u00eddo correctamente o no. Podemos, por tanto, comprobar la finalizaci\u00f3n de un flujo de v\u00eddeo utilizando dicho valor de retorno. Es posible acceder aalgunas de las caracter\u00edsitcas del v\u00eddeo utilizando el m\u00e9todo cap.get(propId) , donde propId es un n\u00famero entre 0 y 18. Cada n\u00famero denota una propiedad del v\u00eddeo (si dicha propiedad se puede aplicar al v\u00eddeo en cuesti\u00f3n). Para m\u00e1s informaci\u00f3n, consulta la p\u00e1gina de documentaci\u00f3n de OpenCV . Algunos de estos valores pueden ser modificados a trav\u00e9s de la funci\u00f3n cap.set(propId, value) . Por ejemplo, podemos comprobar la anchura y altura de un frame utilizando cap.get(cv.CAP_PROP_FRAME_WIDTH) y cap.get(cv.CAP_PROP_FRAME_HEIGHT) . Podemos, por ejemplo, fijar la resoluci\u00f3n de la captura utilizando ret = cap.set(cv.CAP_PROP_FRAME_WIDTH,320) y ret = cap.set(cv.CAP_PROP_FRAME_HEIGHT,240) . Tarea Ejecuta el anterior script (est\u00e1 incluido en el paquete proporcionado) utilizando python3 . Estudia el c\u00f3digo y modif\u00edcalo para introducir nuevas transformaciones en las im\u00e1genes capturadas (tranformaci\u00f3n a otros espacios de color, redimensionado de im\u00e1genes, etc.) Para ello, deber\u00e1s consultar la documentaci\u00f3n de OpenCV. Tarea Temporiza el tiempo de adquisici\u00f3n ( cap.read() ) y rep\u00f3rtalo a trav\u00e9s de l\u00ednea de comandos, reportando no s\u00f3lo el tiempo, sino los fotogramas por segundo (FPS) obtenidos. Desde C++, la l\u00f3gica de captura es muy similar, como tambi\u00e9n lo es la API utilizada: // OpenCV includes. #include <opencv2/core.hpp> #include <opencv2/videoio.hpp> #include <opencv2/highgui.hpp> // Other includes. #include <iostream> #include <stdio.h> using namespace cv; using namespace std; int main(int, char**) { // 0. Declaracion de variables (vease documentacion de Mat). Mat frame; VideoCapture cap; // 1. Configuramos camara 0. int deviceID = 0; // 0 = open default camera int apiID = cv::CAP_ANY; // 0 = autodetect default API cap.open(deviceID, apiID); // 2. Check error. if (!cap.isOpened()) { cerr << \"ERROR abriendo camara.\\n\"; return -1; } // 3. Bucle de adquisicion. cout << \"Comenzando adquisicion...\" << endl << \"Presiona cualquier tecla para terminar...\" << endl; for (;;) { // 4. Adquisicion de frame (TODO: temporizar la adquisicion y reportar Frames por Segundo (FPS)). cap.read(frame); // TODO: Investigar transformaciones en C++ (ver documentacion). // 5. Check error. if (frame.empty()) { cerr << \"ERROR! blank frame grabbed\\n\"; break; } // 6. Mostramos frame en ventana. imshow(\"Stream\", frame); if (waitKey(5) >= 0) break; } // 7. La camara se liberara en el destructor. return 0; } Para compilar y enlazar el anterior c\u00f3digo, nos ayudaremos de la herramienta pkg-config , que nos ayudar\u00e1 a fijar los flags de compilaci\u00f3n y enlazado para programas que utilicen OpenCV. Como curiosidad, observa la salida de la siguiente ejecuci\u00f3n: pi@raspberrypi:~/Test/Lab1/Camera/CPP $ pkg-config --cflags --libs opencv4 -I/usr/local/include/opencv4 -L/usr/local/lib -lopencv_gapi -lopencv_stitching -lopencv_aruco -lopencv_bgsegm -lopencv_bioinspired -lopencv_ccalib -lopencv_dnn_objdetect -lopencv_dnn_superres -lopencv_dpm -lopencv_highgui -lopencv_face -lopencv_freetype -lopencv_fuzzy -lopencv_hdf -lopencv_hfs -lopencv_img_hash -lopencv_intensity_transform -lopencv_line_descriptor -lopencv_mcc -lopencv_quality -lopencv_rapid -lopencv_reg -lopencv_rgbd -lopencv_saliency -lopencv_stereo -lopencv_structured_light -lopencv_phase_unwrapping -lopencv_superres -lopencv_optflow -lopencv_surface_matching -lopencv_tracking -lopencv_datasets -lopencv_text -lopencv_dnn -lopencv_plot -lopencv_videostab -lopencv_videoio -lopencv_xfeatures2d -lopencv_shape -lopencv_ml -lopencv_ximgproc -lopencv_video -lopencv_xobjdetect -lopencv_objdetect -lopencv_calib3d -lopencv_imgcodecs -lopencv_features2d -lopencv_flann -lopencv_xphoto -lopencv_photo -lopencv_imgproc -lopencv_core Estas son las opciones, flags y bibliotecas que ser\u00e1 necesario incluir en el proceso de compilaci\u00f3n de cualquier prorama OpenCV. As\u00ed, para compilar el anterior programa, puedes utilizar la orden: g++ programa.cpp -o programa.x `pkg-config --cflags --libs opencv4` Tarea Compila y ejecuta el anterior programa (est\u00e1 incluido en el paquete proporcionado). Estudia el c\u00f3digo y modif\u00edcalo para introducir nuevas transformaciones en las im\u00e1genes capturadas (tranformaci\u00f3n a otros espacios de color, redimensionado de im\u00e1genes, etc). Para ello, deber\u00e1s consultar la documentaci\u00f3n de OpenCV. Tarea Temporiza el tiempo de adquisici\u00f3n ( cap.read(frame) ) y rep\u00f3rtalo a trav\u00e9s de l\u00ednea de comandos, mostrando no s\u00f3lo el tiempo, sino los fotogramas por segundo (FPS) obtenidos. Tanto en el caso de C++ como de Python, experimenta con distintas resoluciones de captura. \u00bfCu\u00e1l es la resoluci\u00f3n m\u00e1xima soportada por la c\u00e1mara que os proporcionamos? Reproducci\u00f3n de un v\u00eddeo desde fichero Para reproducir un v\u00eddeo almacenado en un fichero, el procedimiento a seguir es similar a la captura desde c\u00e1mara, pero reemplazando el \u00edndice de c\u00e1mara por un nombre de fichero. Utilizaremos la funci\u00f3n cv.waitKey() con un valor apropiado: si es demasiado corto, el v\u00eddeo se reproducir\u00e1 demasiado r\u00e1pidamente; si es demasiado largo, el v\u00eddeo se reproducir\u00e1 demasiado lentamente: import numpy as np import cv2 as cv cap = cv.VideoCapture('vtest.avi') while cap.isOpened(): ret, frame = cap.read() if not ret: print(\"Error, saliendo...\") break gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY) cv.imshow('frame', gray) if cv.waitKey(1) == ord('q'): break cap.release() cv.destroyAllWindows() Almacenamiento de un v\u00eddeo en disco Para almacenar un frame capturado desde c\u00e1mara en disco, utilizaremos cv.imwrite() (busca y estudia su documentaci\u00f3n, y modifica los c\u00f3digos anteriores para realizar una \"fotograf\u00eda\" desde la c\u00e1mara). Para almacenar un v\u00eddeo, es necesario algo de trabajo adicional. En primera lugar, crearemos un objeto de tipo VideoWriter , especificando el nombre del fichero de salida deseado. A continuaci\u00f3n, especificaremos el llamado c\u00f3digo FourCC , resoluci\u00f3n deseada y frames por segundo deseados. El \u00faltimo de los argumentos de la invocaci\u00f3n es el flag isColor , que nos permitir\u00e1 determinar si el codificador de v\u00eddeo espera un frame en color o en escala de grises (v\u00e9ase la documentaci\u00f3n de la funci\u00f3n para m\u00e1s informaci\u00f3n). FourCC es un c\u00f3digo de 4 bytes que permite especificar el codec de v\u00eddeo deseado. Puedes obtener la lista de todos los codigos en fourcc.org . As\u00ed, por ejemplo, para utilizar XVID, usar\u00edamos: fourcc = cv.VideoWriter_fourcc(*'XVID') El siguiente c\u00f3digo captura desde la c\u00e1mara, rota cada frame en la direcci\u00f3n vertical, y almacena el v\u00eddeo resultante: import numpy as np import cv2 as cv cap = cv.VideoCapture(0) # Definimos el codec y creamos el objeto VideoWriter. fourcc = cv.VideoWriter_fourcc(*'XVID') out = cv.VideoWriter('output.avi', fourcc, 20.0, (640, 480)) while cap.isOpened(): ret, frame = cap.read() if not ret: print(\"Error, saliendo...\") break frame = cv.flip(frame, 0) # Escribimos el frame rotado. out.write(frame) cv.imshow('frame', frame) if cv.waitKey(1) == ord('q'): break cap.release() out.release() cv.destroyAllWindows() TensorFlow Lite Una vez estudiados de forma b\u00e1sica los c\u00f3digos que nos permiten realizar capturas e interacci\u00f3n desde la c\u00e1mara proporcionada, veremos c\u00f3mo aplicar un modelo preentrenado al mismo, que nos permitir\u00e1 realizar un proceso de clasificaci\u00f3n de los objetos mostrados en el flujo de v\u00eddeo. N\u00f3tese que el objetivo de esta pr\u00e1ctica no es estudiar en profundidad el proceso en s\u00ed de clasificaci\u00f3n, sino simplemente servir como una primera toma de contacto con la biblioteca TensorFlow Lite . TFLite es un conjunto de herramientas que perimtan ejecutar modelos entrenados TensorFlow en dispostivos m\u00f3viles, empotrados y en entornos IoT. A diferencia de Tensorflow, TFLite permite realizar procesos de inferencia con tiempos de latencia muy reducidos, y un footprint tambi\u00e9n muy reducido. TFLite consta de dos componentes principales: El int\u00e9rprete de TFLite , que ejecuta modelos especialmente optimizados en distintos tipos de hardware , incluyendo tel\u00e9fonos m\u00f3viles, dispositivos Linux empotrados (e.g. Raspberry Pi) y microcontroladores. El conversor de TFLite , que convierte modelos TensorFlow para su posterior uso por parte del int\u00e9rprete, y que puede introducir optimizaciones para reducir el tama\u00f1o del modelo y aumentar el rendimiento. En este primer laboratorio no incidiremos ni en la creaci\u00f3n de modelos ni en su conversi\u00f3n a formato tflite propio del framework (veremos estas fases en futuros laboratorios); as\u00ed, partiremos de modelos ya entrenados y convertidos, ya que el \u00fanico objetivo en este punto es la familiarizaci\u00f3n con el entorno. Las principales caracter\u00edsticas de inter\u00e9s de TFLite son: Un int\u00e9rprete especialmente optimizado para tareas de Machine Learning en dispositivos de bajo rendimiento, con soporte para un amplio subconjunto de operadores disponibles en TensorFlow optimizados para aplicaciones ejecutadas en dicho tipo de dispositivos, enfocados a una reducci\u00f3n del tama\u00f1o del binario final. Soporte para m\u00faltiples plataformas, desde dispositivos Android a IOS, pasando por Linux sobre dispositivos empotrados, o microcontroladores. APIs para m\u00faltiples lenguajes, incluyendo Java, Swift, Objective-C, C++ y Python (estos dos \u00faltimos ser\u00e1n de nuestro especial inter\u00e9s). Alto rendimiento, con soporte para aceleraci\u00f3n hardware sobre dispositivos aceleradores (en nuestro caso, sobre Google Coral) y kernels optmizados para cada tipo de dispositivo. Herramientas de optimizaci\u00f3n de modelos, que incluyen cuantizaci\u00f3n , t\u00e9cnica qu estudiaremos en futuros laboratorios, imprescindible para integrar el uso de aceleradores como la Google Coral. Un formato de almacenamiento eficiente, utilizando FlatBuffer optimizado para una reducci\u00f3n de tama\u00f1o y en aras de la portabilidad entre dispositivos Un conjunto amplio de modelos preentrenados disponibles directamente para su uso en inferencia. El flujo b\u00e1sico de trabajo cuando estamos desarrollando una aplicaci\u00f3n basada en TFLite se basa en cuatro modelos principales: Selecci\u00f3n de modelo preentrenado o creaci\u00f3n/entrenamiento sobre un nuevo modelo. T\u00edpicamente utilizando frameworks existentes, como TensorFlow. Conversi\u00f3n del modelo, utilizando el conversor de TFLite desde Python para adaptarlo a las especificidades de TFLite. Despliegue en el dispositivo, utilizando las APIs del lenguaje seleccionado, e invocando al int\u00e9rprete de TFLite. Optimizaci\u00f3n del modelo (si es necesaria), utilizando el Toolkit de Optimizaci\u00f3n de Modelos , para reducir el tama\u00f1o del modelo e incrementar su eficiencia (t\u00edpicamente a cambio de cierta p\u00e9rdida en precisi\u00f3n). Clasificaci\u00f3n b\u00e1sica de im\u00e1genes usando TFLite En esta parte del laboratorio, mostraremos el flujo de trabajo b\u00e1sico para aplicar un modelo de clasificaci\u00f3n (basado en la red neuronal Mobilenet), que interact\u00fae con im\u00e1genes tomadas directamente desde la c\u00e1mara web integrada en la Raspberry Pi. Tarea Los ficheros que estudiaremos en esta parte est\u00e1n disponibles en el directorio Clasificacion del paquete proporcionado. Como hemos dicho, el objetivo del laboratorio es aplicar inferencia sobre un modelo ya preentrenado, por lo que no incidiremos en la estructura interna del mismo. Sin embargo, es conveniente saber que Mobilenet es una familia de redes neuronales de convoluci\u00f3n dise\u00f1adas para ser peque\u00f1as en tama\u00f1o, y de baja latencia en inferencia, aplicables a procesos de clasificaci\u00f3n, detecci\u00f3n o segementaci\u00f3n de im\u00e1genes, entre otras muchas aplicaciones. En nuestro caso, la red Mobilenet v1 1.0_224 es una red de convoluci\u00f3n que acepta im\u00e1genes de dimensi\u00f3n 224 x 224 y tres canales (RGB), entrenada para devolver la probabilidad de pertenencia a cada una de las 1001 clases para la que ha sido preentrenada. Antes de comenzar, descarga el modelo, fichero de etiquetas y dem\u00e1s requisitios invocando al script download.sh proporcionado: bash download.sh Modelos Esta ejecuci\u00f3n, si todo ha ido bien, descargar\u00e1 en el directorio Modelos tres ficheros que utilizaremos en el resto del laboratorio: mobilenet_v1_1.0_224_quant.tflite : modelo preentrenado y cuantizado MobileNet. mobilenet_v1_1.0_224_quant_edgetpu.tflite : modelo preentrenado y cuantizado MobileNet, compilado con soporte para Google Coral. labels_mobilenet_quant_v1_224.txt : fichero de descripci\u00f3n de etiquetas (clases), con el nombre de una clase por l\u00ednea. La posici\u00f3n de estas l\u00edneas coincide con cada una de las (1001) posiciones del tensor de salida. Desarrollo utilizando Python El c\u00f3digo classify_opencv.py contiene el c\u00f3digo necesario para realizar inferencia (clasificaci\u00f3n) de im\u00e1genes partiendo de capturas de fotogramas desde la c\u00e1mara de la Raspberry Pi, que revisamos paso a paso a continuaci\u00f3n: Invocaci\u00f3n y argumentos Observa el inicio de la funci\u00f3n main proporcionada: def main(): parser = argparse.ArgumentParser( formatter_class=argparse.ArgumentDefaultsHelpFormatter) parser.add_argument( '--model', help='File path of .tflite file.', required=True) parser.add_argument( '--labels', help='File path of labels file.', required=True) args = parser.parse_args() El programa recibir\u00e1, de forma obligatoria, dos argumentos: * El modelo a aplicar, en formato `tflite` (FlatBuffer), a trav\u00e9s del par\u00e1metro `--model`. * El fichero de etiquetas, en formato texto con una etiqueta por l\u00ednea. Este fichero no es estrictamente obligatorio, pero nos permite mostrar no s\u00f3lo el n\u00famero de clase inferida, sino tambi\u00e9n su texto asociado. As\u00ed, podremos ejecutar el programa directamente utilizando la orden (suponiendo que ambos ficheros residen en el directorio ../Modelos ): python3 classify_opencv.py --model ../Modelos/mobilenet_v1_1.0_224_quant_edgetpu.tflite --labels ../Modelos/labels_mobilenet_quant_v1_224.txt Tarea Comprueba el correcto funcionamiento del c\u00f3digo sobre tu Raspberry Pi. Si todo ha ido bien, deber\u00edas ver una ventana mostrando la salida de la c\u00e1mara con cierta informaci\u00f3n sobreimpresionada, y para cada fotograma, el resultado de la inferencia a trav\u00e9s de l\u00ednea de comandos. La funci\u00f3n load_labels simplemente lee el fichero de etiqueta y las almacena en memoria para su posterior procesamiento tras la inferencia. Preparaci\u00f3n del int\u00e9rprete TFLite El siguiente paso es la preparaci\u00f3n del int\u00e9rprete de TFLite: interpreter = Interpreter(args.model) Observa que el \u00fanico par\u00e1metro proporcionado es el nombre del modelo a cargar en formato TFLite. Observa tambi\u00e9n que necesitaremos cargar los m\u00f3dulos correspondientes a TFLite antes de hacer uso de esta funci\u00f3n: from tflite_runtime.interpreter import Interpreter A continuaci\u00f3n, obtenemos informaci\u00f3n sobre el tensor de entrada del modelo reci\u00e9n cargado, utilizando la funci\u00f3n get_input_details , y consultando la propiedad shape de dicha entrada. Esto nos devolver\u00e1 en las variables widght y height los tama\u00f1os de imagen esperados por el modelo. A partir de ahora, puedes consultar la forma de trabajar con la API de Python a trav\u00e9s de la documentaci\u00f3n oficial . Utilizaremos esta informaci\u00f3n para redimensionar la imagen capturada de la c\u00e1mara como paso previo a la invocaci\u00f3n del modelo. Inferencia En el bucle principal de captura, se invoca a la funci\u00f3n classify_image . Esta es una funci\u00f3n propia, que recibe simplemente el int\u00e9rprete TFLite construido y la imagen capturada, pero cuyo cuerpo contiene cierta funcionalidad de inter\u00e9s: ## Invoke model and process output (quantization-aware). def classify_image(interpreter, image, top_k=1): \"\"\"Returns a sorted array of classification results.\"\"\" set_input_tensor(interpreter, image) interpreter.invoke() output_details = interpreter.get_output_details()[0] output = np.squeeze(interpreter.get_tensor(output_details['index'])) # If the model is quantized (uint8 data), then dequantize the results if output_details['dtype'] == np.uint8: scale, zero_point = output_details['quantization'] output = scale * (output - zero_point) ordered = np.argpartition(-output, top_k) return [(i, output[i]) for i in ordered[:top_k]] Observa que la funci\u00f3n opera en varias fases. En primer lugar, se obtiene una referencia al tensor de entrada del modelo (invocando a la funci\u00f3n propia set_input_tensor ). En este caso, se copia, elemento a elemento, la imagen de entrada ( image ) a dicho tensor: ## Establish input tensor from an image (copying). def set_input_tensor(interpreter, image): tensor_index = interpreter.get_input_details()[0]['index'] input_tensor = interpreter.tensor(tensor_index)()[0] input_tensor[:, :] = image Volviendo a la funci\u00f3n classify_image , una vez copiada la entrada al tensor de entrada del modelo, se invoca al modelo TFLite ( interpreter.invoke() ). Este es el proceso de inferencia o aplicaci\u00f3n del modelo , y su tiempo de respuesta es cr\u00edtico. Por \u00faltimo, se procesa la salida (tensor de salida). En caso de ser una salida cuantizada (esto es, el tipo de cada elemento del array de salida es uint8_t , veremos m\u00e1s sobre cuantizaci\u00f3n en futuros laboratorios), \u00e9sta debe procesarse de forma acorde a los par\u00e1metros de cuantizaci\u00f3n utilizados. Al final, la funci\u00f3n devolver\u00e1 un array de tuplas con la posici\u00f3n/clase ( i ) y la probabilidad de pertenencia del objeto observado a dicha clase ( output[i] ). Tarea Imprime por pantalla la informaci\u00f3n sobre el tensor de entrada y el tensor de salida y analiza la salida proporcionada. Obs\u00e9rvese que, de forma previa a la invocaci\u00f3n del modelo, la im\u00e1gen capturada se ha reescalado de forma acorde al tama\u00f1o del tensor de entrada del modelo: image = cv2.resize(frame, (224, 224), interpolation = cv2.INTER_AREA) Postprocesamiento Por \u00faltimo, el programa sobreimpresiona informaci\u00f3n sobre etiqueta de clasificaci\u00f3n, probabilidad de pertenencia a la clase y tiempo de inferencia sobre el propio frame , mostrando la imagen resultante: cv2.putText(frame, '%s %.2f\\n%.1fms' % ( labels[label_id], prob, elapsed_ms ), bottomLeftCornerOfText, font, fontScale, fontColor, lineType) cv2.imshow('image',frame) Uso de Google Coral Para utilizar el acelerador Google Coral (que debe estar conectado a la Raspberry Pi), realizaremos ciertas modificaciones en el c\u00f3digo, que en este caso son m\u00ednimas. En primer lugar, a\u00f1adiremos un import en nuestro fichero: from tflite_runtime.interpreter import load_delegate A continuaci\u00f3n, reemplazaremos la construcci\u00f3n del int\u00e9rprete: interpreter = Interpreter(args.model) Por la especificaci\u00f3n de una biblioteca delegada para realizar la inferencia sobre la Google Coral: interpreter = Interpreter(args.model, experimental_delegates=[load_delegate('libedgetpu.so.1.0')]) El fichero libedgetpu.so.1.0 viene ya instalado en la imagen proporcionada, aunque es directamente instalable siguiendo las instrucciones de instalaci\u00f3n proporcionadas por el fabricante. Finalmente, ser\u00e1 necesario aplicar un modelo especialmente compilado para la Google Coral. Normalmente, este modelo se obtiene utilizando el compilador de la Edge TPU , pero en este caso se descarga y proporciona mediante el script download.sh . El nombre del modelo es mobilenet_v1_1.0_224_quant_edgetpu.tflite . As\u00ed, podremos ejecutar sobre la Edge TPU usando: python3 classify_opencv.py \\ --model /tmp/mobilenet_v1_1.0_224_quant_edgetpu.tflite \\ --labels /tmp/labels_mobilenet_quant_v1_224.txt Tarea Compara los tiempos de ejecuci\u00f3n de la inferencia utilizando el procesdor de prop\u00f3sito general frente al rendimiento utilizando la Google Coral. \u00bfQu\u00e9 ganancia de rendimiento observas? Desarrollo utilizando C++ El rendimiento es un factor determinante en aplicaciones Edge computing , por lo que resultar\u00e1 interesante disponer de una base desarrollada en C++ sobre la que trabajar para el ejemplo de clasificaci\u00f3n. El fichero classification.cpp proporciona un flujo de trabajo completo para realizar una clasificaci\u00f3n de im\u00e1genes similar a la realizada anteriormente usando la API de Python. En primer lugar, compila y ejecuta el programa para validar su funcionamiento: g++ classification.cpp -I /home/pi/tensorflow/ /home/pi/tensorflow/tensorflow/lite/tools/make/gen/linux_aarch64/lib/libtensorflow-lite.a -lpthread -ldl `pkg-config --cflags --libs opencv4` -o classification.x ./classification.x Observa que se utiliza la biblioteca libtensorflow-lite.a , disponible en cualquier instalaci\u00f3n TensorFlow. La salida est\u00e1 preparada para mostrar el c\u00f3digo num\u00e9rico de la clase detectada con mayor probabilidad, dicha probabilidad, y la descripci\u00f3n textual de la clase. El c\u00f3digo desarrollado es similar, paso a paso, al descrito para Python, por lo que no se incidir\u00e1 en los detalles m\u00e1s all\u00e1 de la API utilizada : Ficheros de cabecera Incluiremos ficheros de cabecera gen\u00e9ricos, para OpenCV y para TFLite: #include <stdio.h> // TFLite includes. #include \"tensorflow/lite/interpreter.h\" #include \"tensorflow/lite/kernels/register.h\" #include \"tensorflow/lite/model.h\" #include \"tensorflow/lite/tools/gen_op_registration.h\" // OpenCV includes. #include <opencv2/core.hpp> #include <opencv2/videoio.hpp> #include <opencv2/imgproc.hpp> #include <opencv2/highgui.hpp> #include <iostream> #include <fstream> #include <stdio.h> // C++ sorting utils. #include <vector> #include <numeric> // std::iota #include <algorithm> // std::sort, std::stable_sort Carga del modelo desde un fichero En este ejemplo, se realiza la carga del modelo directamente desde un fichero en disco, utilizando la rutina BuildFromFile : // 1. Cargamos modelo desde un fichero. std::unique_ptr<tflite::FlatBufferModel> model = tflite::FlatBufferModel::BuildFromFile(\"../Modelos/mobilenet_v1_1.0_224_quant.tflite\"); if(!model){ printf(\"Failed to mmap model\\n\"); exit(0); } // 2. Construimos el iterprete TFLite. tflite::ops::builtin::BuiltinOpResolver resolver; std::unique_ptr<tflite::Interpreter> interpreter; tflite::InterpreterBuilder(*model.get(), resolver)(&interpreter); // 3. Alojamos espacio para tensores. interpreter->AllocateTensors(); Observa que, en el anterior fragmento de c\u00f3digo, adem\u00e1s de la carga del modelo, se construye un int\u00e9rprete utilizando la clase InterpreterBuilder , y se aloja espacio para los tensores necesarios para aplicar el modelo. Caracaterizaci\u00f3n de tensores de entrada y salida Como hemos hecho en el c\u00f3digo Python, ser\u00e1 necesario realizar una caracterizaci\u00f3n de los tensores de entrada y salida. El primero, para copiar nuestra imagen capturada desde c\u00e1mara; el segundo, para procesar la salida obtenida: // 4. Identificamos el tensor de entrada y de salida. int input_number = interpreter->inputs()[0]; uint8_t * input_tensor = interpreter->typed_tensor<uint8_t>(input_number); int output_number = interpreter->outputs()[0]; uint8_t * output_tensor = interpreter->typed_tensor<uint8_t>(output_number); Tarea \u00bfCu\u00e1l es el \u00edndice de los tensores de entrada y salida generados? Coinciden con los observados al mostrar por pantalla la informaci\u00f3n sobre ellos en el c\u00f3digo Python. Invocaci\u00f3n del modelo TFLite Tras comenzar con la captura de v\u00eddeo y redimensionar la imagen de entrada, copiaremos al tensor de entrada la imagen capturada, pixel a pixel: // 8. Copiamos imagen al tensor de entrada. for (int i = 0; i < 224*224; ++i) { input_tensor[3*i + 0] = frame.at<cv::Vec3b>(i)[0]; input_tensor[3*i + 1] = frame.at<cv::Vec3b>(i)[1]; input_tensor[3*i + 2] = frame.at<cv::Vec3b>(i)[2]; } A continuaci\u00f3n, invocamos al modelo: // 9. Invocamos al modelo. if (interpreter->Invoke() != kTfLiteOk) { cerr << \"Failed to invoke tflite!\"; exit(-1); } Clasificaci\u00f3n y an\u00e1lisis de salida El proceso de an\u00e1lisis de salida es ligeramente distinto al usado en Python, aunque sigue una filosof\u00eda similar. En primer lugar, analizamos el tensor de salida: // 10. Analizamos el tama\u00f1o del tensor de salida. TfLiteIntArray* output_dims = interpreter->tensor(output_number)->dims; auto output_size = output_dims->data[output_dims->size - 1]; cout << output_size << endl; Como en el caso de Python, en funci\u00f3n de la cuantizaci\u00f3n de la salida, deberemos procesarla de forma acorde (trataremos la cuantizaci\u00f3n en futuros laboratorios). En cualquier caso, el array logits contiene la probabilidad de pertenencia a cada una de las 1001 clases disponibles. El c\u00f3digo que se os proporciona ordena dicho array y muestra por pantalla la clase m\u00e1s probable, junto a su probabilidad asociada. Tarea Temporiza, utilizando la rutinas de la clase chrono de C++, el proceso de inferencia, y comp\u00e1ralo con el de la versi\u00f3n Python. Tarea De forma opcional, investiga c\u00f3mo sobreimpresionar la informaci\u00f3n asociada al proceso de inferencia (clase, probabilidad y tiempo) de forma similar a c\u00f3mo lo hicimos en Python. En futuros laboratorios veremos tambi\u00e9n c\u00f3mo utilizar el acelerador Google Coral desde c\u00f3digo C++. Detecci\u00f3n de objetos usando TFLite Como segundo caso de uso, proporcionamos un programa completo para la detecci\u00f3n de objetos utilizando una red neuronal de convoluci\u00f3n ya entrenada (MobileNet SSD). El ejemplo proporcionado, que utiliza la API de Python, es equivalente en estructura al observado para clasificaci\u00f3n de im\u00e1genes, pero en este caso, la red neuronal nos proporciona cuatro tensores de salida en lugar de uno, como puedes observar en la funci\u00f3n detect_objects : def detect_objects(interpreter, image, threshold): \"\"\"Returns a list of detection results, each a dictionary of object info.\"\"\" set_input_tensor(interpreter, image) interpreter.invoke() # Get all output details boxes = get_output_tensor(interpreter, 0) classes = get_output_tensor(interpreter, 1) scores = get_output_tensor(interpreter, 2) count = int(get_output_tensor(interpreter, 3)) results = [] for i in range(count): if scores[i] >= threshold: result = { 'bounding_box': boxes[i], 'class_id': classes[i], 'score': scores[i] } results.append(result) return results Observa que, tras la invocaci\u00f3n del modelo, se obtienen cuatro tensores de salida, que respectivamente almacenan las cajas o bounding boxes de los objetos detectados, la identificaci\u00f3n de la clase a la que pertenecen, el score de pertenencia a dichas clases y el n\u00famero de objetos detectado, mostr\u00e1ndose dicha informaci\u00f3n por pantalla. La funci\u00f3n annotate_bojects superpone la bounding box en la imagen capturada, mostrando el resultado. El resto de funcionalidad del ejemplo es exactamente igual al descrito para la clasificaci\u00f3n de im\u00e1genes. Tarea Comprueba el funcionamiento del ejemplo proporcionado, haciendo ver m\u00faltiples objetos cotidianos a trav\u00e9s de la c\u00e1mara. Juega en el par\u00e1metro --threshold , que indica el umbral de score m\u00ednimo para considerar la detecci\u00f3n de un objeto. Tarea Transforma el c\u00f3digo para utilizar el acelerador Google Coral y realiza una comparativa de tiempos de inferencia. Tarea Obt\u00e9n una implementaci\u00f3n en C++ del c\u00f3digo de detecci\u00f3n de objetos. En principio, esta implementaci\u00f3n no ser\u00e1 necesaria hasta el laboratorio correspondiente a detecci\u00f3n de objetos, pero resulta conveniente adelantar esta tarea a este laboratorio inicial.","title":"Laboratorio 1"},{"location":"LSI/Lab1/#laboratorio-1-introduccion-a-tflite-sobre-la-raspberry-pi","text":"","title":"Laboratorio 1. Introducci\u00f3n a TFLite sobre la Raspberry Pi"},{"location":"LSI/Lab1/#objetivos","text":"Estudiar las APIs Python y C++ de OpenCV para realizar capturas desde c\u00e1mara y para realizar transformaciones b\u00e1sicas en im\u00e1genes capturadas. Desarrollar una aplicaci\u00f3n b\u00e1sica de clasificaci\u00f3n de im\u00e1genes combinando las APIs de OpenCV y TFLite desde Python y desde C++. Acelerar el proceso de inferencia utilizando el acelerador Google Coral. Dise\u00f1ar e implementar una aplicaci\u00f3n b\u00e1sica para detecci\u00f3n de objetos. Puedes obtener los ficheros necesarios para el desarrollo de la pr\u00e1ctica aqu\u00ed .","title":"Objetivos"},{"location":"LSI/Lab1/#interaccion-con-la-camara-via-opencv","text":"Existen m\u00faltiples APIs para acceder a la c\u00e1mara proporcionada junto a la Raspberry Pi en el entorno experimental. Picamera es una API espec\u00edfica y de c\u00f3digo abierto que proporciona una interfaz Python para el m\u00f3dulo de c\u00e1mara de la Raspberry Pi. El problema radica en su especificidad para este tipo de hardware , que limita su aplicaci\u00f3n o portabilidad a otros. OpenCV proporciona, como parte integral de su API b\u00e1sica (tanto desde Python como desde C++ ) una interfaz completa para la interacci\u00f3n con c\u00e1maras web, que se describe a continuaci\u00f3n.","title":"Interacci\u00f3n con la c\u00e1mara v\u00eda OpenCV"},{"location":"LSI/Lab1/#captura-de-videos-desde-la-camara","text":"En primer lugar, realizaremos una captura de flujo de v\u00eddeo desde la c\u00e1mara, utilizando la API de OpenCV en Python, realizando una transformaci\u00f3n b\u00e1sica y mostrando el flujo de v\u00eddeo transformado. En Python, para realizar la captura de v\u00eddeo, necesitaremos un objeto de tipo VideoCapture ; su \u00fanico argumento puede ser o bien un \u00edndice de dispositivo o un fichero de v\u00eddeo. Un \u00edndice de dispositivo es simplemente un identificador \u00fanico para cada una de las c\u00e1maras conectadas al equipo: import numpy as np import cv2 # 0. Configura camara 0. cap = cv2.VideoCapture(0) while(True): # 1. Adquisicion de frame (TODO: temporizar la adquisicion y reportar Frames por Segundo (FPS)). ret, frame = cap.read() # 2. Operaciones sobre el frame (transformaciones. TODO: investigar resize y otras transformaciones). gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) # 3. Mostramos el frame resultante. cv2.imshow('frame',gray) if cv2.waitKey(1) & 0xFF == ord('q'): break # 4. Liberamos la captura y destruimos ventanas. cap.release() cv2.destroyAllWindows() cap.read() devuelve un valor booleano en funci\u00f3n de si el frame fue le\u00eddo correctamente o no. Podemos, por tanto, comprobar la finalizaci\u00f3n de un flujo de v\u00eddeo utilizando dicho valor de retorno. Es posible acceder aalgunas de las caracter\u00edsitcas del v\u00eddeo utilizando el m\u00e9todo cap.get(propId) , donde propId es un n\u00famero entre 0 y 18. Cada n\u00famero denota una propiedad del v\u00eddeo (si dicha propiedad se puede aplicar al v\u00eddeo en cuesti\u00f3n). Para m\u00e1s informaci\u00f3n, consulta la p\u00e1gina de documentaci\u00f3n de OpenCV . Algunos de estos valores pueden ser modificados a trav\u00e9s de la funci\u00f3n cap.set(propId, value) . Por ejemplo, podemos comprobar la anchura y altura de un frame utilizando cap.get(cv.CAP_PROP_FRAME_WIDTH) y cap.get(cv.CAP_PROP_FRAME_HEIGHT) . Podemos, por ejemplo, fijar la resoluci\u00f3n de la captura utilizando ret = cap.set(cv.CAP_PROP_FRAME_WIDTH,320) y ret = cap.set(cv.CAP_PROP_FRAME_HEIGHT,240) . Tarea Ejecuta el anterior script (est\u00e1 incluido en el paquete proporcionado) utilizando python3 . Estudia el c\u00f3digo y modif\u00edcalo para introducir nuevas transformaciones en las im\u00e1genes capturadas (tranformaci\u00f3n a otros espacios de color, redimensionado de im\u00e1genes, etc.) Para ello, deber\u00e1s consultar la documentaci\u00f3n de OpenCV. Tarea Temporiza el tiempo de adquisici\u00f3n ( cap.read() ) y rep\u00f3rtalo a trav\u00e9s de l\u00ednea de comandos, reportando no s\u00f3lo el tiempo, sino los fotogramas por segundo (FPS) obtenidos. Desde C++, la l\u00f3gica de captura es muy similar, como tambi\u00e9n lo es la API utilizada: // OpenCV includes. #include <opencv2/core.hpp> #include <opencv2/videoio.hpp> #include <opencv2/highgui.hpp> // Other includes. #include <iostream> #include <stdio.h> using namespace cv; using namespace std; int main(int, char**) { // 0. Declaracion de variables (vease documentacion de Mat). Mat frame; VideoCapture cap; // 1. Configuramos camara 0. int deviceID = 0; // 0 = open default camera int apiID = cv::CAP_ANY; // 0 = autodetect default API cap.open(deviceID, apiID); // 2. Check error. if (!cap.isOpened()) { cerr << \"ERROR abriendo camara.\\n\"; return -1; } // 3. Bucle de adquisicion. cout << \"Comenzando adquisicion...\" << endl << \"Presiona cualquier tecla para terminar...\" << endl; for (;;) { // 4. Adquisicion de frame (TODO: temporizar la adquisicion y reportar Frames por Segundo (FPS)). cap.read(frame); // TODO: Investigar transformaciones en C++ (ver documentacion). // 5. Check error. if (frame.empty()) { cerr << \"ERROR! blank frame grabbed\\n\"; break; } // 6. Mostramos frame en ventana. imshow(\"Stream\", frame); if (waitKey(5) >= 0) break; } // 7. La camara se liberara en el destructor. return 0; } Para compilar y enlazar el anterior c\u00f3digo, nos ayudaremos de la herramienta pkg-config , que nos ayudar\u00e1 a fijar los flags de compilaci\u00f3n y enlazado para programas que utilicen OpenCV. Como curiosidad, observa la salida de la siguiente ejecuci\u00f3n: pi@raspberrypi:~/Test/Lab1/Camera/CPP $ pkg-config --cflags --libs opencv4 -I/usr/local/include/opencv4 -L/usr/local/lib -lopencv_gapi -lopencv_stitching -lopencv_aruco -lopencv_bgsegm -lopencv_bioinspired -lopencv_ccalib -lopencv_dnn_objdetect -lopencv_dnn_superres -lopencv_dpm -lopencv_highgui -lopencv_face -lopencv_freetype -lopencv_fuzzy -lopencv_hdf -lopencv_hfs -lopencv_img_hash -lopencv_intensity_transform -lopencv_line_descriptor -lopencv_mcc -lopencv_quality -lopencv_rapid -lopencv_reg -lopencv_rgbd -lopencv_saliency -lopencv_stereo -lopencv_structured_light -lopencv_phase_unwrapping -lopencv_superres -lopencv_optflow -lopencv_surface_matching -lopencv_tracking -lopencv_datasets -lopencv_text -lopencv_dnn -lopencv_plot -lopencv_videostab -lopencv_videoio -lopencv_xfeatures2d -lopencv_shape -lopencv_ml -lopencv_ximgproc -lopencv_video -lopencv_xobjdetect -lopencv_objdetect -lopencv_calib3d -lopencv_imgcodecs -lopencv_features2d -lopencv_flann -lopencv_xphoto -lopencv_photo -lopencv_imgproc -lopencv_core Estas son las opciones, flags y bibliotecas que ser\u00e1 necesario incluir en el proceso de compilaci\u00f3n de cualquier prorama OpenCV. As\u00ed, para compilar el anterior programa, puedes utilizar la orden: g++ programa.cpp -o programa.x `pkg-config --cflags --libs opencv4` Tarea Compila y ejecuta el anterior programa (est\u00e1 incluido en el paquete proporcionado). Estudia el c\u00f3digo y modif\u00edcalo para introducir nuevas transformaciones en las im\u00e1genes capturadas (tranformaci\u00f3n a otros espacios de color, redimensionado de im\u00e1genes, etc). Para ello, deber\u00e1s consultar la documentaci\u00f3n de OpenCV. Tarea Temporiza el tiempo de adquisici\u00f3n ( cap.read(frame) ) y rep\u00f3rtalo a trav\u00e9s de l\u00ednea de comandos, mostrando no s\u00f3lo el tiempo, sino los fotogramas por segundo (FPS) obtenidos. Tanto en el caso de C++ como de Python, experimenta con distintas resoluciones de captura. \u00bfCu\u00e1l es la resoluci\u00f3n m\u00e1xima soportada por la c\u00e1mara que os proporcionamos?","title":"Captura de v\u00eddeos desde la c\u00e1mara"},{"location":"LSI/Lab1/#reproduccion-de-un-video-desde-fichero","text":"Para reproducir un v\u00eddeo almacenado en un fichero, el procedimiento a seguir es similar a la captura desde c\u00e1mara, pero reemplazando el \u00edndice de c\u00e1mara por un nombre de fichero. Utilizaremos la funci\u00f3n cv.waitKey() con un valor apropiado: si es demasiado corto, el v\u00eddeo se reproducir\u00e1 demasiado r\u00e1pidamente; si es demasiado largo, el v\u00eddeo se reproducir\u00e1 demasiado lentamente: import numpy as np import cv2 as cv cap = cv.VideoCapture('vtest.avi') while cap.isOpened(): ret, frame = cap.read() if not ret: print(\"Error, saliendo...\") break gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY) cv.imshow('frame', gray) if cv.waitKey(1) == ord('q'): break cap.release() cv.destroyAllWindows()","title":"Reproducci\u00f3n de un v\u00eddeo desde fichero"},{"location":"LSI/Lab1/#almacenamiento-de-un-video-en-disco","text":"Para almacenar un frame capturado desde c\u00e1mara en disco, utilizaremos cv.imwrite() (busca y estudia su documentaci\u00f3n, y modifica los c\u00f3digos anteriores para realizar una \"fotograf\u00eda\" desde la c\u00e1mara). Para almacenar un v\u00eddeo, es necesario algo de trabajo adicional. En primera lugar, crearemos un objeto de tipo VideoWriter , especificando el nombre del fichero de salida deseado. A continuaci\u00f3n, especificaremos el llamado c\u00f3digo FourCC , resoluci\u00f3n deseada y frames por segundo deseados. El \u00faltimo de los argumentos de la invocaci\u00f3n es el flag isColor , que nos permitir\u00e1 determinar si el codificador de v\u00eddeo espera un frame en color o en escala de grises (v\u00e9ase la documentaci\u00f3n de la funci\u00f3n para m\u00e1s informaci\u00f3n). FourCC es un c\u00f3digo de 4 bytes que permite especificar el codec de v\u00eddeo deseado. Puedes obtener la lista de todos los codigos en fourcc.org . As\u00ed, por ejemplo, para utilizar XVID, usar\u00edamos: fourcc = cv.VideoWriter_fourcc(*'XVID') El siguiente c\u00f3digo captura desde la c\u00e1mara, rota cada frame en la direcci\u00f3n vertical, y almacena el v\u00eddeo resultante: import numpy as np import cv2 as cv cap = cv.VideoCapture(0) # Definimos el codec y creamos el objeto VideoWriter. fourcc = cv.VideoWriter_fourcc(*'XVID') out = cv.VideoWriter('output.avi', fourcc, 20.0, (640, 480)) while cap.isOpened(): ret, frame = cap.read() if not ret: print(\"Error, saliendo...\") break frame = cv.flip(frame, 0) # Escribimos el frame rotado. out.write(frame) cv.imshow('frame', frame) if cv.waitKey(1) == ord('q'): break cap.release() out.release() cv.destroyAllWindows()","title":"Almacenamiento de un v\u00eddeo en disco"},{"location":"LSI/Lab1/#tensorflow-lite","text":"Una vez estudiados de forma b\u00e1sica los c\u00f3digos que nos permiten realizar capturas e interacci\u00f3n desde la c\u00e1mara proporcionada, veremos c\u00f3mo aplicar un modelo preentrenado al mismo, que nos permitir\u00e1 realizar un proceso de clasificaci\u00f3n de los objetos mostrados en el flujo de v\u00eddeo. N\u00f3tese que el objetivo de esta pr\u00e1ctica no es estudiar en profundidad el proceso en s\u00ed de clasificaci\u00f3n, sino simplemente servir como una primera toma de contacto con la biblioteca TensorFlow Lite . TFLite es un conjunto de herramientas que perimtan ejecutar modelos entrenados TensorFlow en dispostivos m\u00f3viles, empotrados y en entornos IoT. A diferencia de Tensorflow, TFLite permite realizar procesos de inferencia con tiempos de latencia muy reducidos, y un footprint tambi\u00e9n muy reducido. TFLite consta de dos componentes principales: El int\u00e9rprete de TFLite , que ejecuta modelos especialmente optimizados en distintos tipos de hardware , incluyendo tel\u00e9fonos m\u00f3viles, dispositivos Linux empotrados (e.g. Raspberry Pi) y microcontroladores. El conversor de TFLite , que convierte modelos TensorFlow para su posterior uso por parte del int\u00e9rprete, y que puede introducir optimizaciones para reducir el tama\u00f1o del modelo y aumentar el rendimiento. En este primer laboratorio no incidiremos ni en la creaci\u00f3n de modelos ni en su conversi\u00f3n a formato tflite propio del framework (veremos estas fases en futuros laboratorios); as\u00ed, partiremos de modelos ya entrenados y convertidos, ya que el \u00fanico objetivo en este punto es la familiarizaci\u00f3n con el entorno. Las principales caracter\u00edsticas de inter\u00e9s de TFLite son: Un int\u00e9rprete especialmente optimizado para tareas de Machine Learning en dispositivos de bajo rendimiento, con soporte para un amplio subconjunto de operadores disponibles en TensorFlow optimizados para aplicaciones ejecutadas en dicho tipo de dispositivos, enfocados a una reducci\u00f3n del tama\u00f1o del binario final. Soporte para m\u00faltiples plataformas, desde dispositivos Android a IOS, pasando por Linux sobre dispositivos empotrados, o microcontroladores. APIs para m\u00faltiples lenguajes, incluyendo Java, Swift, Objective-C, C++ y Python (estos dos \u00faltimos ser\u00e1n de nuestro especial inter\u00e9s). Alto rendimiento, con soporte para aceleraci\u00f3n hardware sobre dispositivos aceleradores (en nuestro caso, sobre Google Coral) y kernels optmizados para cada tipo de dispositivo. Herramientas de optimizaci\u00f3n de modelos, que incluyen cuantizaci\u00f3n , t\u00e9cnica qu estudiaremos en futuros laboratorios, imprescindible para integrar el uso de aceleradores como la Google Coral. Un formato de almacenamiento eficiente, utilizando FlatBuffer optimizado para una reducci\u00f3n de tama\u00f1o y en aras de la portabilidad entre dispositivos Un conjunto amplio de modelos preentrenados disponibles directamente para su uso en inferencia. El flujo b\u00e1sico de trabajo cuando estamos desarrollando una aplicaci\u00f3n basada en TFLite se basa en cuatro modelos principales: Selecci\u00f3n de modelo preentrenado o creaci\u00f3n/entrenamiento sobre un nuevo modelo. T\u00edpicamente utilizando frameworks existentes, como TensorFlow. Conversi\u00f3n del modelo, utilizando el conversor de TFLite desde Python para adaptarlo a las especificidades de TFLite. Despliegue en el dispositivo, utilizando las APIs del lenguaje seleccionado, e invocando al int\u00e9rprete de TFLite. Optimizaci\u00f3n del modelo (si es necesaria), utilizando el Toolkit de Optimizaci\u00f3n de Modelos , para reducir el tama\u00f1o del modelo e incrementar su eficiencia (t\u00edpicamente a cambio de cierta p\u00e9rdida en precisi\u00f3n).","title":"TensorFlow Lite"},{"location":"LSI/Lab1/#clasificacion-basica-de-imagenes-usando-tflite","text":"En esta parte del laboratorio, mostraremos el flujo de trabajo b\u00e1sico para aplicar un modelo de clasificaci\u00f3n (basado en la red neuronal Mobilenet), que interact\u00fae con im\u00e1genes tomadas directamente desde la c\u00e1mara web integrada en la Raspberry Pi. Tarea Los ficheros que estudiaremos en esta parte est\u00e1n disponibles en el directorio Clasificacion del paquete proporcionado. Como hemos dicho, el objetivo del laboratorio es aplicar inferencia sobre un modelo ya preentrenado, por lo que no incidiremos en la estructura interna del mismo. Sin embargo, es conveniente saber que Mobilenet es una familia de redes neuronales de convoluci\u00f3n dise\u00f1adas para ser peque\u00f1as en tama\u00f1o, y de baja latencia en inferencia, aplicables a procesos de clasificaci\u00f3n, detecci\u00f3n o segementaci\u00f3n de im\u00e1genes, entre otras muchas aplicaciones. En nuestro caso, la red Mobilenet v1 1.0_224 es una red de convoluci\u00f3n que acepta im\u00e1genes de dimensi\u00f3n 224 x 224 y tres canales (RGB), entrenada para devolver la probabilidad de pertenencia a cada una de las 1001 clases para la que ha sido preentrenada. Antes de comenzar, descarga el modelo, fichero de etiquetas y dem\u00e1s requisitios invocando al script download.sh proporcionado: bash download.sh Modelos Esta ejecuci\u00f3n, si todo ha ido bien, descargar\u00e1 en el directorio Modelos tres ficheros que utilizaremos en el resto del laboratorio: mobilenet_v1_1.0_224_quant.tflite : modelo preentrenado y cuantizado MobileNet. mobilenet_v1_1.0_224_quant_edgetpu.tflite : modelo preentrenado y cuantizado MobileNet, compilado con soporte para Google Coral. labels_mobilenet_quant_v1_224.txt : fichero de descripci\u00f3n de etiquetas (clases), con el nombre de una clase por l\u00ednea. La posici\u00f3n de estas l\u00edneas coincide con cada una de las (1001) posiciones del tensor de salida.","title":"Clasificaci\u00f3n b\u00e1sica de im\u00e1genes usando TFLite"},{"location":"LSI/Lab1/#desarrollo-utilizando-python","text":"El c\u00f3digo classify_opencv.py contiene el c\u00f3digo necesario para realizar inferencia (clasificaci\u00f3n) de im\u00e1genes partiendo de capturas de fotogramas desde la c\u00e1mara de la Raspberry Pi, que revisamos paso a paso a continuaci\u00f3n:","title":"Desarrollo utilizando Python"},{"location":"LSI/Lab1/#invocacion-y-argumentos","text":"Observa el inicio de la funci\u00f3n main proporcionada: def main(): parser = argparse.ArgumentParser( formatter_class=argparse.ArgumentDefaultsHelpFormatter) parser.add_argument( '--model', help='File path of .tflite file.', required=True) parser.add_argument( '--labels', help='File path of labels file.', required=True) args = parser.parse_args() El programa recibir\u00e1, de forma obligatoria, dos argumentos: * El modelo a aplicar, en formato `tflite` (FlatBuffer), a trav\u00e9s del par\u00e1metro `--model`. * El fichero de etiquetas, en formato texto con una etiqueta por l\u00ednea. Este fichero no es estrictamente obligatorio, pero nos permite mostrar no s\u00f3lo el n\u00famero de clase inferida, sino tambi\u00e9n su texto asociado. As\u00ed, podremos ejecutar el programa directamente utilizando la orden (suponiendo que ambos ficheros residen en el directorio ../Modelos ): python3 classify_opencv.py --model ../Modelos/mobilenet_v1_1.0_224_quant_edgetpu.tflite --labels ../Modelos/labels_mobilenet_quant_v1_224.txt Tarea Comprueba el correcto funcionamiento del c\u00f3digo sobre tu Raspberry Pi. Si todo ha ido bien, deber\u00edas ver una ventana mostrando la salida de la c\u00e1mara con cierta informaci\u00f3n sobreimpresionada, y para cada fotograma, el resultado de la inferencia a trav\u00e9s de l\u00ednea de comandos. La funci\u00f3n load_labels simplemente lee el fichero de etiqueta y las almacena en memoria para su posterior procesamiento tras la inferencia.","title":"Invocaci\u00f3n y argumentos"},{"location":"LSI/Lab1/#preparacion-del-interprete-tflite","text":"El siguiente paso es la preparaci\u00f3n del int\u00e9rprete de TFLite: interpreter = Interpreter(args.model) Observa que el \u00fanico par\u00e1metro proporcionado es el nombre del modelo a cargar en formato TFLite. Observa tambi\u00e9n que necesitaremos cargar los m\u00f3dulos correspondientes a TFLite antes de hacer uso de esta funci\u00f3n: from tflite_runtime.interpreter import Interpreter A continuaci\u00f3n, obtenemos informaci\u00f3n sobre el tensor de entrada del modelo reci\u00e9n cargado, utilizando la funci\u00f3n get_input_details , y consultando la propiedad shape de dicha entrada. Esto nos devolver\u00e1 en las variables widght y height los tama\u00f1os de imagen esperados por el modelo. A partir de ahora, puedes consultar la forma de trabajar con la API de Python a trav\u00e9s de la documentaci\u00f3n oficial . Utilizaremos esta informaci\u00f3n para redimensionar la imagen capturada de la c\u00e1mara como paso previo a la invocaci\u00f3n del modelo.","title":"Preparaci\u00f3n del int\u00e9rprete TFLite"},{"location":"LSI/Lab1/#inferencia","text":"En el bucle principal de captura, se invoca a la funci\u00f3n classify_image . Esta es una funci\u00f3n propia, que recibe simplemente el int\u00e9rprete TFLite construido y la imagen capturada, pero cuyo cuerpo contiene cierta funcionalidad de inter\u00e9s: ## Invoke model and process output (quantization-aware). def classify_image(interpreter, image, top_k=1): \"\"\"Returns a sorted array of classification results.\"\"\" set_input_tensor(interpreter, image) interpreter.invoke() output_details = interpreter.get_output_details()[0] output = np.squeeze(interpreter.get_tensor(output_details['index'])) # If the model is quantized (uint8 data), then dequantize the results if output_details['dtype'] == np.uint8: scale, zero_point = output_details['quantization'] output = scale * (output - zero_point) ordered = np.argpartition(-output, top_k) return [(i, output[i]) for i in ordered[:top_k]] Observa que la funci\u00f3n opera en varias fases. En primer lugar, se obtiene una referencia al tensor de entrada del modelo (invocando a la funci\u00f3n propia set_input_tensor ). En este caso, se copia, elemento a elemento, la imagen de entrada ( image ) a dicho tensor: ## Establish input tensor from an image (copying). def set_input_tensor(interpreter, image): tensor_index = interpreter.get_input_details()[0]['index'] input_tensor = interpreter.tensor(tensor_index)()[0] input_tensor[:, :] = image Volviendo a la funci\u00f3n classify_image , una vez copiada la entrada al tensor de entrada del modelo, se invoca al modelo TFLite ( interpreter.invoke() ). Este es el proceso de inferencia o aplicaci\u00f3n del modelo , y su tiempo de respuesta es cr\u00edtico. Por \u00faltimo, se procesa la salida (tensor de salida). En caso de ser una salida cuantizada (esto es, el tipo de cada elemento del array de salida es uint8_t , veremos m\u00e1s sobre cuantizaci\u00f3n en futuros laboratorios), \u00e9sta debe procesarse de forma acorde a los par\u00e1metros de cuantizaci\u00f3n utilizados. Al final, la funci\u00f3n devolver\u00e1 un array de tuplas con la posici\u00f3n/clase ( i ) y la probabilidad de pertenencia del objeto observado a dicha clase ( output[i] ). Tarea Imprime por pantalla la informaci\u00f3n sobre el tensor de entrada y el tensor de salida y analiza la salida proporcionada. Obs\u00e9rvese que, de forma previa a la invocaci\u00f3n del modelo, la im\u00e1gen capturada se ha reescalado de forma acorde al tama\u00f1o del tensor de entrada del modelo: image = cv2.resize(frame, (224, 224), interpolation = cv2.INTER_AREA)","title":"Inferencia"},{"location":"LSI/Lab1/#postprocesamiento","text":"Por \u00faltimo, el programa sobreimpresiona informaci\u00f3n sobre etiqueta de clasificaci\u00f3n, probabilidad de pertenencia a la clase y tiempo de inferencia sobre el propio frame , mostrando la imagen resultante: cv2.putText(frame, '%s %.2f\\n%.1fms' % ( labels[label_id], prob, elapsed_ms ), bottomLeftCornerOfText, font, fontScale, fontColor, lineType) cv2.imshow('image',frame)","title":"Postprocesamiento"},{"location":"LSI/Lab1/#uso-de-google-coral","text":"Para utilizar el acelerador Google Coral (que debe estar conectado a la Raspberry Pi), realizaremos ciertas modificaciones en el c\u00f3digo, que en este caso son m\u00ednimas. En primer lugar, a\u00f1adiremos un import en nuestro fichero: from tflite_runtime.interpreter import load_delegate A continuaci\u00f3n, reemplazaremos la construcci\u00f3n del int\u00e9rprete: interpreter = Interpreter(args.model) Por la especificaci\u00f3n de una biblioteca delegada para realizar la inferencia sobre la Google Coral: interpreter = Interpreter(args.model, experimental_delegates=[load_delegate('libedgetpu.so.1.0')]) El fichero libedgetpu.so.1.0 viene ya instalado en la imagen proporcionada, aunque es directamente instalable siguiendo las instrucciones de instalaci\u00f3n proporcionadas por el fabricante. Finalmente, ser\u00e1 necesario aplicar un modelo especialmente compilado para la Google Coral. Normalmente, este modelo se obtiene utilizando el compilador de la Edge TPU , pero en este caso se descarga y proporciona mediante el script download.sh . El nombre del modelo es mobilenet_v1_1.0_224_quant_edgetpu.tflite . As\u00ed, podremos ejecutar sobre la Edge TPU usando: python3 classify_opencv.py \\ --model /tmp/mobilenet_v1_1.0_224_quant_edgetpu.tflite \\ --labels /tmp/labels_mobilenet_quant_v1_224.txt Tarea Compara los tiempos de ejecuci\u00f3n de la inferencia utilizando el procesdor de prop\u00f3sito general frente al rendimiento utilizando la Google Coral. \u00bfQu\u00e9 ganancia de rendimiento observas?","title":"Uso de Google Coral"},{"location":"LSI/Lab1/#desarrollo-utilizando-c","text":"El rendimiento es un factor determinante en aplicaciones Edge computing , por lo que resultar\u00e1 interesante disponer de una base desarrollada en C++ sobre la que trabajar para el ejemplo de clasificaci\u00f3n. El fichero classification.cpp proporciona un flujo de trabajo completo para realizar una clasificaci\u00f3n de im\u00e1genes similar a la realizada anteriormente usando la API de Python. En primer lugar, compila y ejecuta el programa para validar su funcionamiento: g++ classification.cpp -I /home/pi/tensorflow/ /home/pi/tensorflow/tensorflow/lite/tools/make/gen/linux_aarch64/lib/libtensorflow-lite.a -lpthread -ldl `pkg-config --cflags --libs opencv4` -o classification.x ./classification.x Observa que se utiliza la biblioteca libtensorflow-lite.a , disponible en cualquier instalaci\u00f3n TensorFlow. La salida est\u00e1 preparada para mostrar el c\u00f3digo num\u00e9rico de la clase detectada con mayor probabilidad, dicha probabilidad, y la descripci\u00f3n textual de la clase. El c\u00f3digo desarrollado es similar, paso a paso, al descrito para Python, por lo que no se incidir\u00e1 en los detalles m\u00e1s all\u00e1 de la API utilizada :","title":"Desarrollo utilizando C++"},{"location":"LSI/Lab1/#ficheros-de-cabecera","text":"Incluiremos ficheros de cabecera gen\u00e9ricos, para OpenCV y para TFLite: #include <stdio.h> // TFLite includes. #include \"tensorflow/lite/interpreter.h\" #include \"tensorflow/lite/kernels/register.h\" #include \"tensorflow/lite/model.h\" #include \"tensorflow/lite/tools/gen_op_registration.h\" // OpenCV includes. #include <opencv2/core.hpp> #include <opencv2/videoio.hpp> #include <opencv2/imgproc.hpp> #include <opencv2/highgui.hpp> #include <iostream> #include <fstream> #include <stdio.h> // C++ sorting utils. #include <vector> #include <numeric> // std::iota #include <algorithm> // std::sort, std::stable_sort","title":"Ficheros de cabecera"},{"location":"LSI/Lab1/#carga-del-modelo-desde-un-fichero","text":"En este ejemplo, se realiza la carga del modelo directamente desde un fichero en disco, utilizando la rutina BuildFromFile : // 1. Cargamos modelo desde un fichero. std::unique_ptr<tflite::FlatBufferModel> model = tflite::FlatBufferModel::BuildFromFile(\"../Modelos/mobilenet_v1_1.0_224_quant.tflite\"); if(!model){ printf(\"Failed to mmap model\\n\"); exit(0); } // 2. Construimos el iterprete TFLite. tflite::ops::builtin::BuiltinOpResolver resolver; std::unique_ptr<tflite::Interpreter> interpreter; tflite::InterpreterBuilder(*model.get(), resolver)(&interpreter); // 3. Alojamos espacio para tensores. interpreter->AllocateTensors(); Observa que, en el anterior fragmento de c\u00f3digo, adem\u00e1s de la carga del modelo, se construye un int\u00e9rprete utilizando la clase InterpreterBuilder , y se aloja espacio para los tensores necesarios para aplicar el modelo.","title":"Carga del modelo desde un fichero"},{"location":"LSI/Lab1/#caracaterizacion-de-tensores-de-entrada-y-salida","text":"Como hemos hecho en el c\u00f3digo Python, ser\u00e1 necesario realizar una caracterizaci\u00f3n de los tensores de entrada y salida. El primero, para copiar nuestra imagen capturada desde c\u00e1mara; el segundo, para procesar la salida obtenida: // 4. Identificamos el tensor de entrada y de salida. int input_number = interpreter->inputs()[0]; uint8_t * input_tensor = interpreter->typed_tensor<uint8_t>(input_number); int output_number = interpreter->outputs()[0]; uint8_t * output_tensor = interpreter->typed_tensor<uint8_t>(output_number); Tarea \u00bfCu\u00e1l es el \u00edndice de los tensores de entrada y salida generados? Coinciden con los observados al mostrar por pantalla la informaci\u00f3n sobre ellos en el c\u00f3digo Python.","title":"Caracaterizaci\u00f3n de tensores de entrada y salida"},{"location":"LSI/Lab1/#invocacion-del-modelo-tflite","text":"Tras comenzar con la captura de v\u00eddeo y redimensionar la imagen de entrada, copiaremos al tensor de entrada la imagen capturada, pixel a pixel: // 8. Copiamos imagen al tensor de entrada. for (int i = 0; i < 224*224; ++i) { input_tensor[3*i + 0] = frame.at<cv::Vec3b>(i)[0]; input_tensor[3*i + 1] = frame.at<cv::Vec3b>(i)[1]; input_tensor[3*i + 2] = frame.at<cv::Vec3b>(i)[2]; } A continuaci\u00f3n, invocamos al modelo: // 9. Invocamos al modelo. if (interpreter->Invoke() != kTfLiteOk) { cerr << \"Failed to invoke tflite!\"; exit(-1); }","title":"Invocaci\u00f3n del modelo TFLite"},{"location":"LSI/Lab1/#clasificacion-y-analisis-de-salida","text":"El proceso de an\u00e1lisis de salida es ligeramente distinto al usado en Python, aunque sigue una filosof\u00eda similar. En primer lugar, analizamos el tensor de salida: // 10. Analizamos el tama\u00f1o del tensor de salida. TfLiteIntArray* output_dims = interpreter->tensor(output_number)->dims; auto output_size = output_dims->data[output_dims->size - 1]; cout << output_size << endl; Como en el caso de Python, en funci\u00f3n de la cuantizaci\u00f3n de la salida, deberemos procesarla de forma acorde (trataremos la cuantizaci\u00f3n en futuros laboratorios). En cualquier caso, el array logits contiene la probabilidad de pertenencia a cada una de las 1001 clases disponibles. El c\u00f3digo que se os proporciona ordena dicho array y muestra por pantalla la clase m\u00e1s probable, junto a su probabilidad asociada. Tarea Temporiza, utilizando la rutinas de la clase chrono de C++, el proceso de inferencia, y comp\u00e1ralo con el de la versi\u00f3n Python. Tarea De forma opcional, investiga c\u00f3mo sobreimpresionar la informaci\u00f3n asociada al proceso de inferencia (clase, probabilidad y tiempo) de forma similar a c\u00f3mo lo hicimos en Python. En futuros laboratorios veremos tambi\u00e9n c\u00f3mo utilizar el acelerador Google Coral desde c\u00f3digo C++.","title":"Clasificaci\u00f3n y an\u00e1lisis de salida"},{"location":"LSI/Lab1/#deteccion-de-objetos-usando-tflite","text":"Como segundo caso de uso, proporcionamos un programa completo para la detecci\u00f3n de objetos utilizando una red neuronal de convoluci\u00f3n ya entrenada (MobileNet SSD). El ejemplo proporcionado, que utiliza la API de Python, es equivalente en estructura al observado para clasificaci\u00f3n de im\u00e1genes, pero en este caso, la red neuronal nos proporciona cuatro tensores de salida en lugar de uno, como puedes observar en la funci\u00f3n detect_objects : def detect_objects(interpreter, image, threshold): \"\"\"Returns a list of detection results, each a dictionary of object info.\"\"\" set_input_tensor(interpreter, image) interpreter.invoke() # Get all output details boxes = get_output_tensor(interpreter, 0) classes = get_output_tensor(interpreter, 1) scores = get_output_tensor(interpreter, 2) count = int(get_output_tensor(interpreter, 3)) results = [] for i in range(count): if scores[i] >= threshold: result = { 'bounding_box': boxes[i], 'class_id': classes[i], 'score': scores[i] } results.append(result) return results Observa que, tras la invocaci\u00f3n del modelo, se obtienen cuatro tensores de salida, que respectivamente almacenan las cajas o bounding boxes de los objetos detectados, la identificaci\u00f3n de la clase a la que pertenecen, el score de pertenencia a dichas clases y el n\u00famero de objetos detectado, mostr\u00e1ndose dicha informaci\u00f3n por pantalla. La funci\u00f3n annotate_bojects superpone la bounding box en la imagen capturada, mostrando el resultado. El resto de funcionalidad del ejemplo es exactamente igual al descrito para la clasificaci\u00f3n de im\u00e1genes. Tarea Comprueba el funcionamiento del ejemplo proporcionado, haciendo ver m\u00faltiples objetos cotidianos a trav\u00e9s de la c\u00e1mara. Juega en el par\u00e1metro --threshold , que indica el umbral de score m\u00ednimo para considerar la detecci\u00f3n de un objeto. Tarea Transforma el c\u00f3digo para utilizar el acelerador Google Coral y realiza una comparativa de tiempos de inferencia. Tarea Obt\u00e9n una implementaci\u00f3n en C++ del c\u00f3digo de detecci\u00f3n de objetos. En principio, esta implementaci\u00f3n no ser\u00e1 necesaria hasta el laboratorio correspondiente a detecci\u00f3n de objetos, pero resulta conveniente adelantar esta tarea a este laboratorio inicial.","title":"Detecci\u00f3n de objetos usando TFLite"},{"location":"RPI-I/P1/","text":"Pr\u00e1ctica 1. Introducci\u00f3n al entorno de desarrollo ESP-IDF Objetivos Conocer dos entornos b\u00e1sicos de desarrollo para el ESP32: uno basado en l\u00ednea de comandos, y otro en la herramienta PlatformIO Ser capaz de compilar, flashear y monitorizar proyectos sencillos basados en ESP-IDF Entender el funcionamiento b\u00e1sico de una aplicaci\u00f3n ESP-IDF que haga uso de las capacidades WiFi del ESP32 Personalizar variables de configuraci\u00f3n de proyectos ESP-IDF Responder a eventos b\u00e1sicos de red en ESP-IDF Introducci\u00f3n ESP-IDF ( Espressif IoT Development Framework ) es el entorno de desarrollo oficial de Espressif para los SoCs ESP32 y ESP32-S. Este entorno de desarrollo y conjunto de herramientas permite desarrollar firmwares eficientes para dichas placas utilizando las interfaces de comunicaci\u00f3n WiFi y Bluetooth, as\u00ed como gestionar m\u00faltiples caracter\u00edsticas de los SoCs que iremos desgranando en futuras pr\u00e1cticas. ESP-IDF utiliza como base FreeRTOS para la construcci\u00f3n del firmware , aunque a\u00f1ade multitud de componentes para ofrecer un soporte de mayor nivel para la interacci\u00f3n con protocolos de comunicaci\u00f3n de bajo y alto nivel, la mayor\u00eda de ellos enfocados al \u00e1mbito de comunicaci\u00f3n en Internet de las Cosas. La presente pr\u00e1ctica pretende ser una introducci\u00f3n b\u00e1sica a la puesta en marcha del entorno de desarrollo ESP-IDF sobre un sistema operativo Linux, ofreciendo dos alternativas b\u00e1sicas: l\u00ednea de comandos y un plugin espec\u00edfico para VSCode (PlatformIO). Adem\u00e1s, veremos de forma superficial la estructura b\u00e1sica de un programa sencillo desarrollado usando ESP-IDF, as\u00ed como ejemplos b\u00e1sicos para la puesta en marcha de la interfaz WiFi sobre una placa ESP32. Recuerda La presente pr\u00e1ctica no tiene tarea entregable asociada m\u00e1s all\u00e1 de una memoria justificativa del trabajo realizado. Por tanto, recuerda apuntar y reportar los pasos y tareas realizadas durante su desarrollo para plasmarlas en una breve memoria entregable final. Flujo de trabajo. Entorno basado en l\u00ednea de comandos Instalaci\u00f3n de prerequisitos ESP-IDF requiere ciertos paquetes software instalados en el sistema para poder desarrollar los c\u00f3digos y descargarlos sobre el ESP32. Se muestran a continuaci\u00f3n los requisitos y modo de instalaci\u00f3n para m\u00e1quinas Ubuntu/Debian (como la m\u00e1quina virtual del curso), aunque la documentaci\u00f3n de ESP-IDF incluye instrucciones para otras distribuciones y sistemas operativos, incluyendo Windows y MacOS. En tu m\u00e1quina virtual, instala los paquetes necesarios utilizando (como superusuario): sudo apt-get install git wget flex bison gperf python python3-pip python-setuptools cmake ninja-build ccache libffi-dev libssl-dev dfu-util Adem\u00e1s, es necesario, en todo caso, que el usuario que est\u00e9s utilizando pertenezca al grupo dialout (puedes editar el fichero /etc/group a\u00f1adiendo a tu usuario a la l\u00ednea que indica el grupo correspondiente, e iniciando de nuevo tu sesi\u00f3n). Instala y configura Python 3 para su uso por defecto en tu distribuci\u00f3n: sudo apt-get install python3 python3-pip python3-setuptools sudo update-alternatives --install /usr/bin/python python /usr/bin/python3 10 Obtenci\u00f3n de ESP-IDF Utilizaremos las versiones de ESP-IDF a obtener directamente desde el repositorio Github oficial (concretamente, en su versi\u00f3n 4.1). Para ello, ejecuta desde tu directorio de inicio: mkdir -p ~/esp cd ~/esp git clone --recursive https://github.com/espressif/esp-idf.git cd esp-idf git fetch git checkout release/v4.1 git pull git submodule update --init --recursive Instalaci\u00f3n de herramientas adicionales Desde el directorio esp-idf , ejecuta el script install.sh para instalar las herramientas ( toolchain ) espec\u00edficas para tu versi\u00f3n: sh install.sh Preparaci\u00f3n del entorno Tras el inicio de cada sesi\u00f3n, deber\u00e1s establecer valores correctos para ciertas variables de entorno. Afortunadamente, se proporciona un script ( export.sh ) que te permitir\u00e1 establecerlas de forma autom\u00e1tica: . export.sh Puedes a\u00f1adir esta l\u00ednea en cualquier fichero de inicio de sesi\u00f3n para no tener que ejecutar el comando cada vez. En cualquier caso, en este punto deber\u00edas tener acceso a un programa llamado idf.py , a trav\u00e9s del cual gestionaremos el flujo de trabajo. Compru\u00e9balo y observa si la version de IDF con la que est\u00e1s trabajando es efectivamente la 4.1 (el n\u00famero de subversi\u00f3n podr\u00eda variar en tu salida): $ idf.py --version ESP-IDF v4.1-332-g7b7c64107 Preparaci\u00f3n del proyecto En esta primera parte, nos basaremos en un ejemplo sencillo de c\u00f3digo desarrollado en base a ESP-IDF. No es el objetivo de esta pr\u00e1ctica analizar en detalle los la estructura de dicho c\u00f3digo (al menos de momento), sino utilizarlo para ilustrar el flujo de trabajo t\u00edpico en un proyecto ESP-IDF. Recuerda Tras la ejecuci\u00f3n del script export.sh , tendr\u00e1s definida una variable de entorno llamada IDF_PATH . Consulta su valor y comprueba que apunta, efectivamente, al directorio de instalaci\u00f3n de IDF. La utilizaremos a partir de ahora para referirnos a \u00e9l. Para empezar, toma el ejemplo hello_world proporcionado como parte de la instalaci\u00f3n b\u00e1sica de IDF, y c\u00f3pialo en cualquier directorio del sistema de ficheros: cp -R $IDF_PATH/examples/get-started/hello_world $HOME/ cd $HOME/hello_world Compilaci\u00f3n El proceso de compilaci\u00f3n b\u00e1sico utiliza el script idf.py : idf.py build Si todo ha ido bien, en el directorio build se habr\u00e1n generado los objetos y binarios listos para ser flasheados en el ESP32. Flasheado El proceso de flasheado b\u00e1sico utiliza el script idf.py : idf.py -p PUERTO flash En este punto, el ESP32 debe estar conectado utilizando el cable microUSB, y si est\u00e1s trabajando en una m\u00e1quina virtual, debe haberse hecho visible a la misma (por ejemplo, en VirtualBox, a trav\u00e9s del men\u00fa Dispositivos->USB->Silicon Labs USB to UART Bridge Controller ). En todo caso, la salida del comando dmesg tras la conexi\u00f3n del dispositivo te proporcionar\u00e1 informaci\u00f3n sobre el PUERTO que debes utilizar en el proceso de flasheado y montorizaci\u00f3n posterior. Monitorizaci\u00f3n Si todo ha ido bien, el proceso de monitorizaci\u00f3n nos permitir\u00e1 observar la salida del programa que tenemos ejecutando en la placa. Para ello, de nuevo, usamos el script idf.py : idf.py -p PUERTO monitor Nota Comprueba que, efectivamente, puedes realizar el proceso de compilaci\u00f3n, flasheado y monitorizaci\u00f3n del programa sobre la placa ESP32. Recuerda que el bot\u00f3n EN , justo al lado del conector microUSB, forzar\u00e1 un reseteo de la misma. Flujo de trabajo. Entorno basado en PlatformIO El anterior flujo de trabajo puede tambi\u00e9n desarrollarse desde otros entornos de desarrollo. En nuestro caso, se muestran a continuaci\u00f3n los pasos principales para la integraci\u00f3n de ESP-IDF con VSCode, utilizando la plataforma PlatformIO . Las m\u00e1quinas virtuales proporcionadas en el curso ya tienen instalada la \u00faltima versi\u00f3n de PlatformIO y ESP-IDF, por lo que se refiere al lector a la documentaci\u00f3n oficial de PlatformIO para llevar a cabo dicha instalaci\u00f3n en otros sistemas operativos. Configuraci\u00f3n de un proyecto La forma m\u00e1s sencilla de crear un nuevo proyecto consiste en pulsar el bot\u00f3n PlatformIO Home situado en la parte inferior de la pantalla: A continuaci\u00f3n, clica en New Project y selecciona como placa de desarrollo ESP DevkitC o Espressif ESP32 Dev Module . Selecciona ESP-IDF como framework de desarrollo para el proyecto: Adici\u00f3n de ficheros a un proyecto Crea un nuevo fichero main.c (si no existe) en el directorio src de tu proyecto, o modifica el que ya existe utilizando, por ejemplo, el siguiente c\u00f3digo: #include <string.h> #include \"freertos/FreeRTOS.h\" #include \"freertos/task.h\" #include \"esp_system.h\" #include \"esp_wifi.h\" #include \"esp_event.h\" #include \"esp_log.h\" #include \"nvs_flash.h\" #include \"lwip/err.h\" #include \"lwip/sys.h\" #define EXAMPLE_ESP_WIFI_SSID \"mywifissid\" #define EXAMPLE_ESP_WIFI_PASS \"mywifipass\" #define EXAMPLE_MAX_STA_CONN (3) static const char *TAG = \"wifi softAP\"; static void wifi_event_handler(void* arg, esp_event_base_t event_base, int32_t event_id, void* event_data) { if (event_id == WIFI_EVENT_AP_STACONNECTED) { wifi_event_ap_staconnected_t* event = (wifi_event_ap_staconnected_t*) event_data; ESP_LOGI(TAG, \"station \"MACSTR\" join, AID=%d\", MAC2STR(event->mac), event->aid); } else if (event_id == WIFI_EVENT_AP_STADISCONNECTED) { wifi_event_ap_stadisconnected_t* event = (wifi_event_ap_stadisconnected_t*) event_data; ESP_LOGI(TAG, \"station \"MACSTR\" leave, AID=%d\", MAC2STR(event->mac), event->aid); } } void wifi_init_softap() { tcpip_adapter_init(); ESP_ERROR_CHECK(esp_event_loop_create_default()); wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT(); ESP_ERROR_CHECK(esp_wifi_init(&cfg)); ESP_ERROR_CHECK(esp_event_handler_register(WIFI_EVENT, ESP_EVENT_ANY_ID, &wifi_event_handler, NULL)); wifi_config_t wifi_config = { .ap = { .ssid = EXAMPLE_ESP_WIFI_SSID, .ssid_len = strlen(EXAMPLE_ESP_WIFI_SSID), .password = EXAMPLE_ESP_WIFI_PASS, .max_connection = EXAMPLE_MAX_STA_CONN, .authmode = WIFI_AUTH_WPA_WPA2_PSK }, }; if (strlen(EXAMPLE_ESP_WIFI_PASS) == 0) { wifi_config.ap.authmode = WIFI_AUTH_OPEN; } ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_AP)); ESP_ERROR_CHECK(esp_wifi_set_config(ESP_IF_WIFI_AP, &wifi_config)); ESP_ERROR_CHECK(esp_wifi_start()); ESP_LOGI(TAG, \"wifi_init_softap finished. SSID:%s password:%s\", EXAMPLE_ESP_WIFI_SSID, EXAMPLE_ESP_WIFI_PASS); } void app_main() { //Initialize NVS esp_err_t ret = nvs_flash_init(); if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) { ESP_ERROR_CHECK(nvs_flash_erase()); ret = nvs_flash_init(); } ESP_ERROR_CHECK(ret); ESP_LOGI(TAG, \"ESP_WIFI_MODE_AP\"); wifi_init_softap(); } De momento no analizaremos el funcionamiento del c\u00f3digo (lo haremos m\u00e1s adelante) pero b\u00e1sicamente establece un Punto de Acceso inal\u00e1mbrico abierto a conexiones autenticadas v\u00eda WPA2. Compilaci\u00f3n del proyecto Para compilar del proyecto, despliega la paleta de comandos (men\u00fa View -> Command Palette ) y ejecuta la orden PlatformIO: Build desde ella. Tambi\u00e9n puedes presionar el bot\u00f3n Build (con forma de check ) en la barra inferior de PlatformIO: Si todo ha ido bien, deber\u00edas ver un mensaje final similar al siguiente en la terminal del sistema: Flasheado del proyecto Para llevar a cabo el proceso de subida ( upload ) del proyecto a la placa, podemos utilizar la orden PlatformIO: Upload a trav\u00e9s de la paleta de comandos, o bien presionar el bot\u00f3n correspondiente en la barra inferior (con un s\u00edmbolo de flecha a izquierda): Monitorizaci\u00f3n del proyecto Por \u00faltimo, podemos monitorizar el proyecto utilizando la orden PlatformIO: Monitor de la paleta de comandos o a trav\u00e9s de la barra inferior, usando el bot\u00f3n con un enchufe como s\u00edmbolo: An\u00e1lisis de un proyecto sencillo ( Hola, mundo ) en ESP-IDF Nota Las siguientes tareas pueden realizarse desde l\u00ednea de comandos o utilizando PlatformIO. Para familiarizarse con en entorno de bajo nivel, sin embargo, se sugiere el uso de l\u00ednea de comandos. Observa la estructura general del directorio hello_world que compilaste anteriormente. Espec\u00edficamente, nos interesar\u00e1 inspeccionar la estructura b\u00e1sica de un programa principal para ESP-IDF, en este caso hello_world_main.c . #include <stdio.h> #include \"sdkconfig.h\" #include \"freertos/FreeRTOS.h\" #include \"freertos/task.h\" #include \"esp_system.h\" #include \"esp_spi_flash.h\" void app_main(void) { printf(\"Hello world!\\n\"); /* Print chip information */ esp_chip_info_t chip_info; esp_chip_info(&chip_info); printf(\"This is %s chip with %d CPU cores, WiFi%s%s, \", CONFIG_IDF_TARGET, chip_info.cores, (chip_info.features & CHIP_FEATURE_BT) ? \"/BT\" : \"\", (chip_info.features & CHIP_FEATURE_BLE) ? \"/BLE\" : \"\"); printf(\"silicon revision %d, \", chip_info.revision); printf(\"%dMB %s flash\\n\", spi_flash_get_chip_size() / (1024 * 1024), (chip_info.features & CHIP_FEATURE_EMB_FLASH) ? \"embedded\" : \"external\"); printf(\"Minimum free heap size: %d bytes\\n\", esp_get_minimum_free_heap_size()); for (int i = 10; i >= 0; i--) { printf(\"Restarting in %d seconds...\\n\", i); vTaskDelay(1000 / portTICK_PERIOD_MS); } printf(\"Restarting now.\\n\"); fflush(stdout); esp_restart(); } A alto nivel, la funci\u00f3n app_main es el punto de entrada a todo programa desarrollado usando ESP-IDF. De modo m\u00e1s espec\u00edfico, tras la carga del sistema , la llamada tarea principal ( main task ) ejecuta el c\u00f3digo proporcionado por el usuario e implementado en la funci\u00f3n app_main . Tanto el tama\u00f1o de pila asignado como la prioridad de esta tarea puede ser configuradas por el desarrollador a trav\u00e9s del sistema de configuraci\u00f3n de ESP-IDF (lo veremos m\u00e1s adelante). Normalmente, esta funci\u00f3n se utiliza para llevar a cabo tareas iniciales de configuraci\u00f3n o para crear y lanzar a ejecuci\u00f3n otras tareas. De cualquier modo (como es el caso), se puede implementar cualquier funcionalidad dentro de la funci\u00f3n app_main . En este ejemplo, se muestra en primer lugar informaci\u00f3n gen\u00e9rica sobre el SoC que est\u00e1 ejecutando el firmware : /* Print chip information */ esp_chip_info_t chip_info; esp_chip_info(&chip_info); printf(\"This is %s chip with %d CPU cores, WiFi%s%s, \", CONFIG_IDF_TARGET, chip_info.cores, (chip_info.features & CHIP_FEATURE_BT) ? \"/BT\" : \"\", (chip_info.features & CHIP_FEATURE_BLE) ? \"/BLE\" : \"\"); printf(\"silicon revision %d, \", chip_info.revision); printf(\"%dMB %s flash\\n\", spi_flash_get_chip_size() / (1024 * 1024), (chip_info.features & CHIP_FEATURE_EMB_FLASH) ? \"embedded\" : \"external\"); printf(\"Minimum free heap size: %d bytes\\n\", esp_get_minimum_free_heap_size()); A continuaci\u00f3n, dentro de un bucle sencillo, el sistema muestra un mensaje y difiere la ejecuci\u00f3n de la tarea durante un per\u00edodo determinado de tiempo utilizando la funci\u00f3n vTaskDelay de FreeRTOS. Esta funci\u00f3n recibe el n\u00famero de ticks de reloj que se desea utilizar, por lo que el tiempo real que la tarea diferir\u00e1 su ejecuci\u00f3n depende de la duraci\u00f3n de dicho tick . Por ello, la constante portTIC_PERIOD_MS puede utilizarse para calcular dicho tiempo: for (int i = 10; i >= 0; i--) { printf(\"Restarting in %d seconds...\\n\", i); vTaskDelay(1000 / portTICK_PERIOD_MS); } Finalmente, la tarea reinicia el sistema tras la finalizaci\u00f3n de la tarea principal: printf(\"Restarting now.\\n\"); fflush(stdout); esp_restart(); Tarea Modifica el per\u00edodo de suspensi\u00f3n de la tarea para que sea mayor o menor, y comprueba que efectivamente esto modifica el comportamiento del firmware cargado. Modifica el programa para que se muestre tambi\u00e9n por pantalla si el SoC tiene capacidades WiFi y si incluye memoria FLASH (para ello, puedes consultar la siguiente p\u00e1gina ). Creaci\u00f3n de tareas El anterior proyecto puede replantearse para que no sea la tarea principal la que ejecute la l\u00f3gica del programa. Para ello, es necesario introducir brevemente la API b\u00e1sica para gesti\u00f3n (en nuestro caso, creaci\u00f3n) de tareas. Ver\u00e1s muchos m\u00e1s detalles sobre esta API en la asignatura ANIOT, por lo que no veremos aqu\u00ed m\u00e1s detalles de los estrictamente necesarios. La funci\u00f3n xTaskCreate (incluida en task.h ) permite la creaci\u00f3n de nuevas tareas: BaseType_t xTaskCreate( TaskFunction_t pvTaskCode, const char * const pcName, configSTACK_DEPTH_TYPE usStackDepth, void *pvParameters, UBaseType_t uxPriority, TaskHandle_t *pxCreatedTask ); Concretamente, crea una nueva tarea y la a\u00f1ade a la lista de tareas listas para ejecuci\u00f3n, recibiendo como par\u00e1metros: pvTaskCode : Puntero a la funci\u00f3n de entrada para la tarea. Las tareas suelen implementarse como un bucle infinito, y no deber\u00eda, en su cuerpo, retornar o simplemente finalizar abruptamente. En cambio, una tarea puede ser destruida externamente a trav\u00e9s de su manejador (\u00faltimo par\u00e1metro en la creaci\u00f3n), o internamente (desde el propio c\u00f3digo de la tarea), tal y como se muestra en el siguiente ejemplo extra\u00eddo directamente desde la documentaci\u00f3n de FreeRTOS: void vATaskFunction( void *pvParameters ) { for( ;; ) { -- Task application code here. -- } /* Tasks must not attempt to return from their implementing function or otherwise exit. In newer FreeRTOS port attempting to do so will result in an configASSERT() being called if it is defined. If it is necessary for a task to exit then have the task call vTaskDelete( NULL ) to ensure its exit is clean. */ vTaskDelete( NULL ); } pcName : Nombre (en forma de cadena) descriptivo de la tarea a ejecutar, t\u00edpicamente usado en tiempo de depuraci\u00f3n. usStackDepth : N\u00famero de palabras a alojar para utilizar como pila para la tarea. pvParameters : Par\u00e1metros a proporcionar a la funci\u00f3n de entrada para la tarea. uxPriority : Prioridad asignada a la tarea. pxCreatedTask : Manejador opcional para la tarea. As\u00ed, la funcionalidad del programa Hola, mundo que hemos analizado anteriormente, podr\u00eda reestrcturarse en base a una \u00fanica tarea: void hello_task(void *pvParameter) { printf(\"Hello world!\\n\"); for (int i = 10; i >= 0; i--) { printf(\"Restarting in %d seconds...\\n\", i); vTaskDelay(1000 / portTICK_RATE_MS); } printf(\"Restarting now.\\n\"); fflush(stdout); esp_restart(); } Que podr\u00eda ser creada desde la tarea principal: void app_main() { nvs_flash_init(); xTaskCreate( &hello_task, \"hello_task\", 2048, NULL, 5, NULL ); } Tarea Implementa una modificaci\u00f3n del programa hello_world que implemente y planifique dos tareas independientes con distinta funcionalidad (en este caso, es suficiente con mostrar por pantalla alg\u00fan mensaje) y distintos tiempos de suspensi\u00f3n. Comprueba que, efectivamente, ambas tareas se ejecutan concurrentemente. Personalizaci\u00f3n del proyecto ESP-IDF utiliza la biblioteca kconfiglib para proporcionar un sistema de configuracion de proyectos en tiempo de compilaci\u00f3n sencillo y extensible. Para ilustrar su funcionamiento, utilizaremos el ejemplo blink que puedes encontrar en la distribuci\u00f3n de ESP-IDF que has clonado anteriormente (copia el ejemplo en cualquier punto de tu jerarqu\u00eda de directorios antes de comenzar). Para configurar un proyecto ESP-IDF, simplemente utiliza la siguiente orden: idf.py menuconfig La ejecuci\u00f3n de la orden anterior te permitir\u00e1 navegar por un conjunto de opciones de car\u00e1cter general, que te permitir\u00e1n configurar las caracter\u00edsticas espec\u00edficas del proyecto a compilar (por ejemplo, seleccionando los componentes que deseas habilitar en la construcci\u00f3n del mismo). Tarea Navega por las opciones que aparecen en los men\u00fas de configuraci\u00f3n para familiarizarte con ellos. Los utilizar\u00e1s en futuras pr\u00e1cticas. En el proyecto blink , observa que una de las opciones del men\u00fa de navegaci\u00f3n, llamada Example configuration , incluye una opci\u00f3n llamada Blink GPIO number . M\u00e1s all\u00e1 de su funcionalidad (define el n\u00famero de pin GPIO a activar/desactivar para iluminar un LED), es de inter\u00e9s para nosotros el hecho de que esta opci\u00f3n de configuraci\u00f3n definir\u00e1 en tiempo de compilaci\u00f3n el valor de una constante (en este caso CONFIG_BLINK_GPIO ) que podemos utilizar directamente en cualquier fichero de nuestro proyecto. Nota Observa el uso que da el c\u00f3digo del proyecto blink a la constante CONFIG_BLINK_GPIO . Esta opci\u00f3n de configuraci\u00f3n no forma parte de las opciones por defecto de ESP-IDF, sino que ha sido a\u00f1adida por los desarrolladores del proyecto blink . Observa y estudia el formato y contenido del fichero main/Kconfig.projbuild que se proporciona como parte del fichero. En \u00e9l, se definen las caracter\u00edsticas (nombre, rango, valor por defecto y descripcion) de la opci\u00f3n de configuraci\u00f3n a definir. Tarea Modifica el proyecto hello_world para que defina dos opciones de configuraci\u00f3n que permitir\u00e1n definir el tiempo de espera de cada una de las dos tareas que hayas definido en tu anterior soluci\u00f3n. Haz uso de ellas en tu c\u00f3digo y comprueba que efectivamente su modificaci\u00f3n a trav\u00e9s del sistema de men\u00fas permite una personalizaci\u00f3n del comportamiento de tus c\u00f3digos. Gesti\u00f3n de redes WiFi. Ejemplo 1. Escaneado de redes WiFi A modo de ejemplo, y en preparaci\u00f3n para los c\u00f3digos con los que trabajaremos en futuras pr\u00e1cticas, vamos a analizar a continuaci\u00f3n un ejemplo concreto de firmware cuya tarea es el escaneado de redes inal\u00e1mbricas al alcance del ESP32, y su reporte a trav\u00e9s del puerto serie del mismo. Para cada red escaneada, se reportar\u00e1n sus caracter\u00edsticas principales. Tarea Compila, flashea y monitoriza el ejemplo scan situado en el directorio examples/wifi/scan . Recuerda copiarlo antes a cualquier otro directorio de tu home . Antes de compilarlo, modifica el n\u00famero m\u00e1ximo de redes a escanear a trav\u00e9s del men\u00fa de configuraci\u00f3n del ejemplo para ampliarlo a 20. Crea un punto de acceso WiFi con tu tel\u00e9fono m\u00f3vil y observa que, efectivamente, es escaneado por el ejemplo. Observa su funcionamiento. Realmente, el firmware simplemente escanea un subconjunto de las redes disponibles, reportando algunas de sus caracter\u00edsticas (por ejemplo, SSID, modo de autenticaci\u00f3n o canal primario). Tarea Analiza el c\u00f3digo de la funci\u00f3n wifi_scan (tarea principal). Espec\u00edficamente, c\u00e9ntrate en las l\u00edneas que permiten activar y configurar el escaneado de redes. Intenta entender el funcionamiento general del programa, consultando y apuntando el cometido de cada l\u00ednea, con especial inter\u00e9s a aquellas funciones con prefijo esp_wifi_* . Anota en la memoria entregable el cometido de cada una de ellas, consultando la documentaci\u00f3n oficial . Gesti\u00f3n de redes WiFi. Ejemplo 2. Gesti\u00f3n de eventos de red El segundo ejemplo consiste en la creaci\u00f3n de un firmware para conexi\u00f3n del ESP32 a un punto de acceso existente. Este ejemplo nos permitir\u00e1 observar, a grandes rasgos, el sistema de gesti\u00f3n de eventos en FreeRTOS/ESP-IDF, que estudiar\u00e1s en m\u00e1s detalle en ANIOT y que permite gestionar, entre otros, las respuestas a eventos de red, como por ejemplo la obtenci\u00f3n de direcci\u00f3n IP o la conexi\u00f3n exitosa a un punto de acceso. Tarea Compila, flashea y monitoriza el ejemplo station situado en el directorio examples/wifi/getting_started . Recuerda copiarlo antes a cualquier otro directorio de tu home . Antes de compilarlo, modifica el SSID de la red al que conectar\u00e1, as\u00ed como la contrase\u00f1a elegida (puedes usar el mismo punto de acceso que creaste anteriormente como objetivo de tu conexi\u00f3n) a trav\u00e9s del sistema de men\u00fas de configuraci\u00f3n. Observa su funcionamiento. El firmware simplemente inicializa el dispositivo en modo station (en contraposici\u00f3n al modo Access Point , que veremos en la pr\u00f3xima sesi\u00f3n), realizando una conexi\u00f3n al punto de acceso preconfigurado a trav\u00e9s del men\u00fa de configuraci\u00f3n. Analiza el c\u00f3digo de la funci\u00f3n wifi_init_sta . Esta funci\u00f3n, que implementa la tarea principal, se divide b\u00e1sicamente en dos partes: Gesti\u00f3n de eventos . Observa el mecanismo mediante el cual se registra y se asocia la recepci\u00f3n de un evento a la ejecuci\u00f3n de un manejador o funci\u00f3n determinada. Pregunta \u00bfQu\u00e9 eventos se asocian a la ejecuci\u00f3n de qu\u00e9 funci\u00f3n en el firmware que est\u00e1s estudiando? Configuraci\u00f3n de la conexi\u00f3n a un punto de acceso . La configuraci\u00f3n de la conexi\u00f3n se realiza a trav\u00e9s de los campos correspondientes de una estructura de tipo wifi_config_t . Observa los campos b\u00e1sicos que necesita, c\u00f3mo fuerza el uso de WPA2 y c\u00f3mo recoge los datos de conexi\u00f3n (SSID y contrase\u00f1a) a trav\u00e9s del sistema de configuraci\u00f3n. Observa tambi\u00e9n c\u00f3mo, una vez realizadas dichas personalizaciones, inicializa el sistema de comunicaci\u00f3n inal\u00e1mbrica a trav\u00e9s de esp_wifi_start() . Consulta la documentaci\u00f3n relativa a dichas funciones y anota en tu memoria entregable aquellos aspectos que consideres m\u00e1s relevantes. Tarea Modifica el firmware para que el handler de tratamiento de la obtenci\u00f3n de una direcci\u00f3n IP sea independiente del tratamiento del resto de eventos del sistema WiFi que ya se est\u00e1n considerando. Comprueba que, efectivamente sigue observ\u00e1ndose la salida asociada a dicho evento, aun cuando ambas funciones sean independientes. Entrega o a\u00f1ade a la memoria el c\u00f3digo modificado.","title":"Pr\u00e1ctica 1"},{"location":"RPI-I/P1/#practica-1-introduccion-al-entorno-de-desarrollo-esp-idf","text":"","title":"Pr\u00e1ctica 1. Introducci\u00f3n al entorno de desarrollo ESP-IDF"},{"location":"RPI-I/P1/#objetivos","text":"Conocer dos entornos b\u00e1sicos de desarrollo para el ESP32: uno basado en l\u00ednea de comandos, y otro en la herramienta PlatformIO Ser capaz de compilar, flashear y monitorizar proyectos sencillos basados en ESP-IDF Entender el funcionamiento b\u00e1sico de una aplicaci\u00f3n ESP-IDF que haga uso de las capacidades WiFi del ESP32 Personalizar variables de configuraci\u00f3n de proyectos ESP-IDF Responder a eventos b\u00e1sicos de red en ESP-IDF","title":"Objetivos"},{"location":"RPI-I/P1/#introduccion","text":"ESP-IDF ( Espressif IoT Development Framework ) es el entorno de desarrollo oficial de Espressif para los SoCs ESP32 y ESP32-S. Este entorno de desarrollo y conjunto de herramientas permite desarrollar firmwares eficientes para dichas placas utilizando las interfaces de comunicaci\u00f3n WiFi y Bluetooth, as\u00ed como gestionar m\u00faltiples caracter\u00edsticas de los SoCs que iremos desgranando en futuras pr\u00e1cticas. ESP-IDF utiliza como base FreeRTOS para la construcci\u00f3n del firmware , aunque a\u00f1ade multitud de componentes para ofrecer un soporte de mayor nivel para la interacci\u00f3n con protocolos de comunicaci\u00f3n de bajo y alto nivel, la mayor\u00eda de ellos enfocados al \u00e1mbito de comunicaci\u00f3n en Internet de las Cosas. La presente pr\u00e1ctica pretende ser una introducci\u00f3n b\u00e1sica a la puesta en marcha del entorno de desarrollo ESP-IDF sobre un sistema operativo Linux, ofreciendo dos alternativas b\u00e1sicas: l\u00ednea de comandos y un plugin espec\u00edfico para VSCode (PlatformIO). Adem\u00e1s, veremos de forma superficial la estructura b\u00e1sica de un programa sencillo desarrollado usando ESP-IDF, as\u00ed como ejemplos b\u00e1sicos para la puesta en marcha de la interfaz WiFi sobre una placa ESP32. Recuerda La presente pr\u00e1ctica no tiene tarea entregable asociada m\u00e1s all\u00e1 de una memoria justificativa del trabajo realizado. Por tanto, recuerda apuntar y reportar los pasos y tareas realizadas durante su desarrollo para plasmarlas en una breve memoria entregable final.","title":"Introducci\u00f3n"},{"location":"RPI-I/P1/#flujo-de-trabajo-entorno-basado-en-linea-de-comandos","text":"","title":"Flujo de trabajo. Entorno basado en l\u00ednea de comandos"},{"location":"RPI-I/P1/#instalacion-de-prerequisitos","text":"ESP-IDF requiere ciertos paquetes software instalados en el sistema para poder desarrollar los c\u00f3digos y descargarlos sobre el ESP32. Se muestran a continuaci\u00f3n los requisitos y modo de instalaci\u00f3n para m\u00e1quinas Ubuntu/Debian (como la m\u00e1quina virtual del curso), aunque la documentaci\u00f3n de ESP-IDF incluye instrucciones para otras distribuciones y sistemas operativos, incluyendo Windows y MacOS. En tu m\u00e1quina virtual, instala los paquetes necesarios utilizando (como superusuario): sudo apt-get install git wget flex bison gperf python python3-pip python-setuptools cmake ninja-build ccache libffi-dev libssl-dev dfu-util Adem\u00e1s, es necesario, en todo caso, que el usuario que est\u00e9s utilizando pertenezca al grupo dialout (puedes editar el fichero /etc/group a\u00f1adiendo a tu usuario a la l\u00ednea que indica el grupo correspondiente, e iniciando de nuevo tu sesi\u00f3n). Instala y configura Python 3 para su uso por defecto en tu distribuci\u00f3n: sudo apt-get install python3 python3-pip python3-setuptools sudo update-alternatives --install /usr/bin/python python /usr/bin/python3 10","title":"Instalaci\u00f3n de prerequisitos"},{"location":"RPI-I/P1/#obtencion-de-esp-idf","text":"Utilizaremos las versiones de ESP-IDF a obtener directamente desde el repositorio Github oficial (concretamente, en su versi\u00f3n 4.1). Para ello, ejecuta desde tu directorio de inicio: mkdir -p ~/esp cd ~/esp git clone --recursive https://github.com/espressif/esp-idf.git cd esp-idf git fetch git checkout release/v4.1 git pull git submodule update --init --recursive","title":"Obtenci\u00f3n de ESP-IDF"},{"location":"RPI-I/P1/#instalacion-de-herramientas-adicionales","text":"Desde el directorio esp-idf , ejecuta el script install.sh para instalar las herramientas ( toolchain ) espec\u00edficas para tu versi\u00f3n: sh install.sh","title":"Instalaci\u00f3n de herramientas adicionales"},{"location":"RPI-I/P1/#preparacion-del-entorno","text":"Tras el inicio de cada sesi\u00f3n, deber\u00e1s establecer valores correctos para ciertas variables de entorno. Afortunadamente, se proporciona un script ( export.sh ) que te permitir\u00e1 establecerlas de forma autom\u00e1tica: . export.sh Puedes a\u00f1adir esta l\u00ednea en cualquier fichero de inicio de sesi\u00f3n para no tener que ejecutar el comando cada vez. En cualquier caso, en este punto deber\u00edas tener acceso a un programa llamado idf.py , a trav\u00e9s del cual gestionaremos el flujo de trabajo. Compru\u00e9balo y observa si la version de IDF con la que est\u00e1s trabajando es efectivamente la 4.1 (el n\u00famero de subversi\u00f3n podr\u00eda variar en tu salida): $ idf.py --version ESP-IDF v4.1-332-g7b7c64107","title":"Preparaci\u00f3n del entorno"},{"location":"RPI-I/P1/#preparacion-del-proyecto","text":"En esta primera parte, nos basaremos en un ejemplo sencillo de c\u00f3digo desarrollado en base a ESP-IDF. No es el objetivo de esta pr\u00e1ctica analizar en detalle los la estructura de dicho c\u00f3digo (al menos de momento), sino utilizarlo para ilustrar el flujo de trabajo t\u00edpico en un proyecto ESP-IDF. Recuerda Tras la ejecuci\u00f3n del script export.sh , tendr\u00e1s definida una variable de entorno llamada IDF_PATH . Consulta su valor y comprueba que apunta, efectivamente, al directorio de instalaci\u00f3n de IDF. La utilizaremos a partir de ahora para referirnos a \u00e9l. Para empezar, toma el ejemplo hello_world proporcionado como parte de la instalaci\u00f3n b\u00e1sica de IDF, y c\u00f3pialo en cualquier directorio del sistema de ficheros: cp -R $IDF_PATH/examples/get-started/hello_world $HOME/ cd $HOME/hello_world","title":"Preparaci\u00f3n del proyecto"},{"location":"RPI-I/P1/#compilacion","text":"El proceso de compilaci\u00f3n b\u00e1sico utiliza el script idf.py : idf.py build Si todo ha ido bien, en el directorio build se habr\u00e1n generado los objetos y binarios listos para ser flasheados en el ESP32.","title":"Compilaci\u00f3n"},{"location":"RPI-I/P1/#flasheado","text":"El proceso de flasheado b\u00e1sico utiliza el script idf.py : idf.py -p PUERTO flash En este punto, el ESP32 debe estar conectado utilizando el cable microUSB, y si est\u00e1s trabajando en una m\u00e1quina virtual, debe haberse hecho visible a la misma (por ejemplo, en VirtualBox, a trav\u00e9s del men\u00fa Dispositivos->USB->Silicon Labs USB to UART Bridge Controller ). En todo caso, la salida del comando dmesg tras la conexi\u00f3n del dispositivo te proporcionar\u00e1 informaci\u00f3n sobre el PUERTO que debes utilizar en el proceso de flasheado y montorizaci\u00f3n posterior.","title":"Flasheado"},{"location":"RPI-I/P1/#monitorizacion","text":"Si todo ha ido bien, el proceso de monitorizaci\u00f3n nos permitir\u00e1 observar la salida del programa que tenemos ejecutando en la placa. Para ello, de nuevo, usamos el script idf.py : idf.py -p PUERTO monitor Nota Comprueba que, efectivamente, puedes realizar el proceso de compilaci\u00f3n, flasheado y monitorizaci\u00f3n del programa sobre la placa ESP32. Recuerda que el bot\u00f3n EN , justo al lado del conector microUSB, forzar\u00e1 un reseteo de la misma.","title":"Monitorizaci\u00f3n"},{"location":"RPI-I/P1/#flujo-de-trabajo-entorno-basado-en-platformio","text":"El anterior flujo de trabajo puede tambi\u00e9n desarrollarse desde otros entornos de desarrollo. En nuestro caso, se muestran a continuaci\u00f3n los pasos principales para la integraci\u00f3n de ESP-IDF con VSCode, utilizando la plataforma PlatformIO . Las m\u00e1quinas virtuales proporcionadas en el curso ya tienen instalada la \u00faltima versi\u00f3n de PlatformIO y ESP-IDF, por lo que se refiere al lector a la documentaci\u00f3n oficial de PlatformIO para llevar a cabo dicha instalaci\u00f3n en otros sistemas operativos.","title":"Flujo de trabajo. Entorno basado en PlatformIO"},{"location":"RPI-I/P1/#configuracion-de-un-proyecto","text":"La forma m\u00e1s sencilla de crear un nuevo proyecto consiste en pulsar el bot\u00f3n PlatformIO Home situado en la parte inferior de la pantalla: A continuaci\u00f3n, clica en New Project y selecciona como placa de desarrollo ESP DevkitC o Espressif ESP32 Dev Module . Selecciona ESP-IDF como framework de desarrollo para el proyecto:","title":"Configuraci\u00f3n de un proyecto"},{"location":"RPI-I/P1/#adicion-de-ficheros-a-un-proyecto","text":"Crea un nuevo fichero main.c (si no existe) en el directorio src de tu proyecto, o modifica el que ya existe utilizando, por ejemplo, el siguiente c\u00f3digo: #include <string.h> #include \"freertos/FreeRTOS.h\" #include \"freertos/task.h\" #include \"esp_system.h\" #include \"esp_wifi.h\" #include \"esp_event.h\" #include \"esp_log.h\" #include \"nvs_flash.h\" #include \"lwip/err.h\" #include \"lwip/sys.h\" #define EXAMPLE_ESP_WIFI_SSID \"mywifissid\" #define EXAMPLE_ESP_WIFI_PASS \"mywifipass\" #define EXAMPLE_MAX_STA_CONN (3) static const char *TAG = \"wifi softAP\"; static void wifi_event_handler(void* arg, esp_event_base_t event_base, int32_t event_id, void* event_data) { if (event_id == WIFI_EVENT_AP_STACONNECTED) { wifi_event_ap_staconnected_t* event = (wifi_event_ap_staconnected_t*) event_data; ESP_LOGI(TAG, \"station \"MACSTR\" join, AID=%d\", MAC2STR(event->mac), event->aid); } else if (event_id == WIFI_EVENT_AP_STADISCONNECTED) { wifi_event_ap_stadisconnected_t* event = (wifi_event_ap_stadisconnected_t*) event_data; ESP_LOGI(TAG, \"station \"MACSTR\" leave, AID=%d\", MAC2STR(event->mac), event->aid); } } void wifi_init_softap() { tcpip_adapter_init(); ESP_ERROR_CHECK(esp_event_loop_create_default()); wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT(); ESP_ERROR_CHECK(esp_wifi_init(&cfg)); ESP_ERROR_CHECK(esp_event_handler_register(WIFI_EVENT, ESP_EVENT_ANY_ID, &wifi_event_handler, NULL)); wifi_config_t wifi_config = { .ap = { .ssid = EXAMPLE_ESP_WIFI_SSID, .ssid_len = strlen(EXAMPLE_ESP_WIFI_SSID), .password = EXAMPLE_ESP_WIFI_PASS, .max_connection = EXAMPLE_MAX_STA_CONN, .authmode = WIFI_AUTH_WPA_WPA2_PSK }, }; if (strlen(EXAMPLE_ESP_WIFI_PASS) == 0) { wifi_config.ap.authmode = WIFI_AUTH_OPEN; } ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_AP)); ESP_ERROR_CHECK(esp_wifi_set_config(ESP_IF_WIFI_AP, &wifi_config)); ESP_ERROR_CHECK(esp_wifi_start()); ESP_LOGI(TAG, \"wifi_init_softap finished. SSID:%s password:%s\", EXAMPLE_ESP_WIFI_SSID, EXAMPLE_ESP_WIFI_PASS); } void app_main() { //Initialize NVS esp_err_t ret = nvs_flash_init(); if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) { ESP_ERROR_CHECK(nvs_flash_erase()); ret = nvs_flash_init(); } ESP_ERROR_CHECK(ret); ESP_LOGI(TAG, \"ESP_WIFI_MODE_AP\"); wifi_init_softap(); } De momento no analizaremos el funcionamiento del c\u00f3digo (lo haremos m\u00e1s adelante) pero b\u00e1sicamente establece un Punto de Acceso inal\u00e1mbrico abierto a conexiones autenticadas v\u00eda WPA2.","title":"Adici\u00f3n de ficheros a un proyecto"},{"location":"RPI-I/P1/#compilacion-del-proyecto","text":"Para compilar del proyecto, despliega la paleta de comandos (men\u00fa View -> Command Palette ) y ejecuta la orden PlatformIO: Build desde ella. Tambi\u00e9n puedes presionar el bot\u00f3n Build (con forma de check ) en la barra inferior de PlatformIO: Si todo ha ido bien, deber\u00edas ver un mensaje final similar al siguiente en la terminal del sistema:","title":"Compilaci\u00f3n del proyecto"},{"location":"RPI-I/P1/#flasheado-del-proyecto","text":"Para llevar a cabo el proceso de subida ( upload ) del proyecto a la placa, podemos utilizar la orden PlatformIO: Upload a trav\u00e9s de la paleta de comandos, o bien presionar el bot\u00f3n correspondiente en la barra inferior (con un s\u00edmbolo de flecha a izquierda):","title":"Flasheado del proyecto"},{"location":"RPI-I/P1/#monitorizacion-del-proyecto","text":"Por \u00faltimo, podemos monitorizar el proyecto utilizando la orden PlatformIO: Monitor de la paleta de comandos o a trav\u00e9s de la barra inferior, usando el bot\u00f3n con un enchufe como s\u00edmbolo:","title":"Monitorizaci\u00f3n del proyecto"},{"location":"RPI-I/P1/#analisis-de-un-proyecto-sencillo-hola-mundo-en-esp-idf","text":"Nota Las siguientes tareas pueden realizarse desde l\u00ednea de comandos o utilizando PlatformIO. Para familiarizarse con en entorno de bajo nivel, sin embargo, se sugiere el uso de l\u00ednea de comandos. Observa la estructura general del directorio hello_world que compilaste anteriormente. Espec\u00edficamente, nos interesar\u00e1 inspeccionar la estructura b\u00e1sica de un programa principal para ESP-IDF, en este caso hello_world_main.c . #include <stdio.h> #include \"sdkconfig.h\" #include \"freertos/FreeRTOS.h\" #include \"freertos/task.h\" #include \"esp_system.h\" #include \"esp_spi_flash.h\" void app_main(void) { printf(\"Hello world!\\n\"); /* Print chip information */ esp_chip_info_t chip_info; esp_chip_info(&chip_info); printf(\"This is %s chip with %d CPU cores, WiFi%s%s, \", CONFIG_IDF_TARGET, chip_info.cores, (chip_info.features & CHIP_FEATURE_BT) ? \"/BT\" : \"\", (chip_info.features & CHIP_FEATURE_BLE) ? \"/BLE\" : \"\"); printf(\"silicon revision %d, \", chip_info.revision); printf(\"%dMB %s flash\\n\", spi_flash_get_chip_size() / (1024 * 1024), (chip_info.features & CHIP_FEATURE_EMB_FLASH) ? \"embedded\" : \"external\"); printf(\"Minimum free heap size: %d bytes\\n\", esp_get_minimum_free_heap_size()); for (int i = 10; i >= 0; i--) { printf(\"Restarting in %d seconds...\\n\", i); vTaskDelay(1000 / portTICK_PERIOD_MS); } printf(\"Restarting now.\\n\"); fflush(stdout); esp_restart(); } A alto nivel, la funci\u00f3n app_main es el punto de entrada a todo programa desarrollado usando ESP-IDF. De modo m\u00e1s espec\u00edfico, tras la carga del sistema , la llamada tarea principal ( main task ) ejecuta el c\u00f3digo proporcionado por el usuario e implementado en la funci\u00f3n app_main . Tanto el tama\u00f1o de pila asignado como la prioridad de esta tarea puede ser configuradas por el desarrollador a trav\u00e9s del sistema de configuraci\u00f3n de ESP-IDF (lo veremos m\u00e1s adelante). Normalmente, esta funci\u00f3n se utiliza para llevar a cabo tareas iniciales de configuraci\u00f3n o para crear y lanzar a ejecuci\u00f3n otras tareas. De cualquier modo (como es el caso), se puede implementar cualquier funcionalidad dentro de la funci\u00f3n app_main . En este ejemplo, se muestra en primer lugar informaci\u00f3n gen\u00e9rica sobre el SoC que est\u00e1 ejecutando el firmware : /* Print chip information */ esp_chip_info_t chip_info; esp_chip_info(&chip_info); printf(\"This is %s chip with %d CPU cores, WiFi%s%s, \", CONFIG_IDF_TARGET, chip_info.cores, (chip_info.features & CHIP_FEATURE_BT) ? \"/BT\" : \"\", (chip_info.features & CHIP_FEATURE_BLE) ? \"/BLE\" : \"\"); printf(\"silicon revision %d, \", chip_info.revision); printf(\"%dMB %s flash\\n\", spi_flash_get_chip_size() / (1024 * 1024), (chip_info.features & CHIP_FEATURE_EMB_FLASH) ? \"embedded\" : \"external\"); printf(\"Minimum free heap size: %d bytes\\n\", esp_get_minimum_free_heap_size()); A continuaci\u00f3n, dentro de un bucle sencillo, el sistema muestra un mensaje y difiere la ejecuci\u00f3n de la tarea durante un per\u00edodo determinado de tiempo utilizando la funci\u00f3n vTaskDelay de FreeRTOS. Esta funci\u00f3n recibe el n\u00famero de ticks de reloj que se desea utilizar, por lo que el tiempo real que la tarea diferir\u00e1 su ejecuci\u00f3n depende de la duraci\u00f3n de dicho tick . Por ello, la constante portTIC_PERIOD_MS puede utilizarse para calcular dicho tiempo: for (int i = 10; i >= 0; i--) { printf(\"Restarting in %d seconds...\\n\", i); vTaskDelay(1000 / portTICK_PERIOD_MS); } Finalmente, la tarea reinicia el sistema tras la finalizaci\u00f3n de la tarea principal: printf(\"Restarting now.\\n\"); fflush(stdout); esp_restart(); Tarea Modifica el per\u00edodo de suspensi\u00f3n de la tarea para que sea mayor o menor, y comprueba que efectivamente esto modifica el comportamiento del firmware cargado. Modifica el programa para que se muestre tambi\u00e9n por pantalla si el SoC tiene capacidades WiFi y si incluye memoria FLASH (para ello, puedes consultar la siguiente p\u00e1gina ).","title":"An\u00e1lisis de un proyecto sencillo (Hola, mundo) en ESP-IDF"},{"location":"RPI-I/P1/#creacion-de-tareas","text":"El anterior proyecto puede replantearse para que no sea la tarea principal la que ejecute la l\u00f3gica del programa. Para ello, es necesario introducir brevemente la API b\u00e1sica para gesti\u00f3n (en nuestro caso, creaci\u00f3n) de tareas. Ver\u00e1s muchos m\u00e1s detalles sobre esta API en la asignatura ANIOT, por lo que no veremos aqu\u00ed m\u00e1s detalles de los estrictamente necesarios. La funci\u00f3n xTaskCreate (incluida en task.h ) permite la creaci\u00f3n de nuevas tareas: BaseType_t xTaskCreate( TaskFunction_t pvTaskCode, const char * const pcName, configSTACK_DEPTH_TYPE usStackDepth, void *pvParameters, UBaseType_t uxPriority, TaskHandle_t *pxCreatedTask ); Concretamente, crea una nueva tarea y la a\u00f1ade a la lista de tareas listas para ejecuci\u00f3n, recibiendo como par\u00e1metros: pvTaskCode : Puntero a la funci\u00f3n de entrada para la tarea. Las tareas suelen implementarse como un bucle infinito, y no deber\u00eda, en su cuerpo, retornar o simplemente finalizar abruptamente. En cambio, una tarea puede ser destruida externamente a trav\u00e9s de su manejador (\u00faltimo par\u00e1metro en la creaci\u00f3n), o internamente (desde el propio c\u00f3digo de la tarea), tal y como se muestra en el siguiente ejemplo extra\u00eddo directamente desde la documentaci\u00f3n de FreeRTOS: void vATaskFunction( void *pvParameters ) { for( ;; ) { -- Task application code here. -- } /* Tasks must not attempt to return from their implementing function or otherwise exit. In newer FreeRTOS port attempting to do so will result in an configASSERT() being called if it is defined. If it is necessary for a task to exit then have the task call vTaskDelete( NULL ) to ensure its exit is clean. */ vTaskDelete( NULL ); } pcName : Nombre (en forma de cadena) descriptivo de la tarea a ejecutar, t\u00edpicamente usado en tiempo de depuraci\u00f3n. usStackDepth : N\u00famero de palabras a alojar para utilizar como pila para la tarea. pvParameters : Par\u00e1metros a proporcionar a la funci\u00f3n de entrada para la tarea. uxPriority : Prioridad asignada a la tarea. pxCreatedTask : Manejador opcional para la tarea. As\u00ed, la funcionalidad del programa Hola, mundo que hemos analizado anteriormente, podr\u00eda reestrcturarse en base a una \u00fanica tarea: void hello_task(void *pvParameter) { printf(\"Hello world!\\n\"); for (int i = 10; i >= 0; i--) { printf(\"Restarting in %d seconds...\\n\", i); vTaskDelay(1000 / portTICK_RATE_MS); } printf(\"Restarting now.\\n\"); fflush(stdout); esp_restart(); } Que podr\u00eda ser creada desde la tarea principal: void app_main() { nvs_flash_init(); xTaskCreate( &hello_task, \"hello_task\", 2048, NULL, 5, NULL ); } Tarea Implementa una modificaci\u00f3n del programa hello_world que implemente y planifique dos tareas independientes con distinta funcionalidad (en este caso, es suficiente con mostrar por pantalla alg\u00fan mensaje) y distintos tiempos de suspensi\u00f3n. Comprueba que, efectivamente, ambas tareas se ejecutan concurrentemente.","title":"Creaci\u00f3n de tareas"},{"location":"RPI-I/P1/#personalizacion-del-proyecto","text":"ESP-IDF utiliza la biblioteca kconfiglib para proporcionar un sistema de configuracion de proyectos en tiempo de compilaci\u00f3n sencillo y extensible. Para ilustrar su funcionamiento, utilizaremos el ejemplo blink que puedes encontrar en la distribuci\u00f3n de ESP-IDF que has clonado anteriormente (copia el ejemplo en cualquier punto de tu jerarqu\u00eda de directorios antes de comenzar). Para configurar un proyecto ESP-IDF, simplemente utiliza la siguiente orden: idf.py menuconfig La ejecuci\u00f3n de la orden anterior te permitir\u00e1 navegar por un conjunto de opciones de car\u00e1cter general, que te permitir\u00e1n configurar las caracter\u00edsticas espec\u00edficas del proyecto a compilar (por ejemplo, seleccionando los componentes que deseas habilitar en la construcci\u00f3n del mismo). Tarea Navega por las opciones que aparecen en los men\u00fas de configuraci\u00f3n para familiarizarte con ellos. Los utilizar\u00e1s en futuras pr\u00e1cticas. En el proyecto blink , observa que una de las opciones del men\u00fa de navegaci\u00f3n, llamada Example configuration , incluye una opci\u00f3n llamada Blink GPIO number . M\u00e1s all\u00e1 de su funcionalidad (define el n\u00famero de pin GPIO a activar/desactivar para iluminar un LED), es de inter\u00e9s para nosotros el hecho de que esta opci\u00f3n de configuraci\u00f3n definir\u00e1 en tiempo de compilaci\u00f3n el valor de una constante (en este caso CONFIG_BLINK_GPIO ) que podemos utilizar directamente en cualquier fichero de nuestro proyecto. Nota Observa el uso que da el c\u00f3digo del proyecto blink a la constante CONFIG_BLINK_GPIO . Esta opci\u00f3n de configuraci\u00f3n no forma parte de las opciones por defecto de ESP-IDF, sino que ha sido a\u00f1adida por los desarrolladores del proyecto blink . Observa y estudia el formato y contenido del fichero main/Kconfig.projbuild que se proporciona como parte del fichero. En \u00e9l, se definen las caracter\u00edsticas (nombre, rango, valor por defecto y descripcion) de la opci\u00f3n de configuraci\u00f3n a definir. Tarea Modifica el proyecto hello_world para que defina dos opciones de configuraci\u00f3n que permitir\u00e1n definir el tiempo de espera de cada una de las dos tareas que hayas definido en tu anterior soluci\u00f3n. Haz uso de ellas en tu c\u00f3digo y comprueba que efectivamente su modificaci\u00f3n a trav\u00e9s del sistema de men\u00fas permite una personalizaci\u00f3n del comportamiento de tus c\u00f3digos.","title":"Personalizaci\u00f3n del proyecto"},{"location":"RPI-I/P1/#gestion-de-redes-wifi-ejemplo-1-escaneado-de-redes-wifi","text":"A modo de ejemplo, y en preparaci\u00f3n para los c\u00f3digos con los que trabajaremos en futuras pr\u00e1cticas, vamos a analizar a continuaci\u00f3n un ejemplo concreto de firmware cuya tarea es el escaneado de redes inal\u00e1mbricas al alcance del ESP32, y su reporte a trav\u00e9s del puerto serie del mismo. Para cada red escaneada, se reportar\u00e1n sus caracter\u00edsticas principales. Tarea Compila, flashea y monitoriza el ejemplo scan situado en el directorio examples/wifi/scan . Recuerda copiarlo antes a cualquier otro directorio de tu home . Antes de compilarlo, modifica el n\u00famero m\u00e1ximo de redes a escanear a trav\u00e9s del men\u00fa de configuraci\u00f3n del ejemplo para ampliarlo a 20. Crea un punto de acceso WiFi con tu tel\u00e9fono m\u00f3vil y observa que, efectivamente, es escaneado por el ejemplo. Observa su funcionamiento. Realmente, el firmware simplemente escanea un subconjunto de las redes disponibles, reportando algunas de sus caracter\u00edsticas (por ejemplo, SSID, modo de autenticaci\u00f3n o canal primario). Tarea Analiza el c\u00f3digo de la funci\u00f3n wifi_scan (tarea principal). Espec\u00edficamente, c\u00e9ntrate en las l\u00edneas que permiten activar y configurar el escaneado de redes. Intenta entender el funcionamiento general del programa, consultando y apuntando el cometido de cada l\u00ednea, con especial inter\u00e9s a aquellas funciones con prefijo esp_wifi_* . Anota en la memoria entregable el cometido de cada una de ellas, consultando la documentaci\u00f3n oficial .","title":"Gesti\u00f3n de redes WiFi. Ejemplo 1. Escaneado de redes WiFi"},{"location":"RPI-I/P1/#gestion-de-redes-wifi-ejemplo-2-gestion-de-eventos-de-red","text":"El segundo ejemplo consiste en la creaci\u00f3n de un firmware para conexi\u00f3n del ESP32 a un punto de acceso existente. Este ejemplo nos permitir\u00e1 observar, a grandes rasgos, el sistema de gesti\u00f3n de eventos en FreeRTOS/ESP-IDF, que estudiar\u00e1s en m\u00e1s detalle en ANIOT y que permite gestionar, entre otros, las respuestas a eventos de red, como por ejemplo la obtenci\u00f3n de direcci\u00f3n IP o la conexi\u00f3n exitosa a un punto de acceso. Tarea Compila, flashea y monitoriza el ejemplo station situado en el directorio examples/wifi/getting_started . Recuerda copiarlo antes a cualquier otro directorio de tu home . Antes de compilarlo, modifica el SSID de la red al que conectar\u00e1, as\u00ed como la contrase\u00f1a elegida (puedes usar el mismo punto de acceso que creaste anteriormente como objetivo de tu conexi\u00f3n) a trav\u00e9s del sistema de men\u00fas de configuraci\u00f3n. Observa su funcionamiento. El firmware simplemente inicializa el dispositivo en modo station (en contraposici\u00f3n al modo Access Point , que veremos en la pr\u00f3xima sesi\u00f3n), realizando una conexi\u00f3n al punto de acceso preconfigurado a trav\u00e9s del men\u00fa de configuraci\u00f3n. Analiza el c\u00f3digo de la funci\u00f3n wifi_init_sta . Esta funci\u00f3n, que implementa la tarea principal, se divide b\u00e1sicamente en dos partes: Gesti\u00f3n de eventos . Observa el mecanismo mediante el cual se registra y se asocia la recepci\u00f3n de un evento a la ejecuci\u00f3n de un manejador o funci\u00f3n determinada. Pregunta \u00bfQu\u00e9 eventos se asocian a la ejecuci\u00f3n de qu\u00e9 funci\u00f3n en el firmware que est\u00e1s estudiando? Configuraci\u00f3n de la conexi\u00f3n a un punto de acceso . La configuraci\u00f3n de la conexi\u00f3n se realiza a trav\u00e9s de los campos correspondientes de una estructura de tipo wifi_config_t . Observa los campos b\u00e1sicos que necesita, c\u00f3mo fuerza el uso de WPA2 y c\u00f3mo recoge los datos de conexi\u00f3n (SSID y contrase\u00f1a) a trav\u00e9s del sistema de configuraci\u00f3n. Observa tambi\u00e9n c\u00f3mo, una vez realizadas dichas personalizaciones, inicializa el sistema de comunicaci\u00f3n inal\u00e1mbrica a trav\u00e9s de esp_wifi_start() . Consulta la documentaci\u00f3n relativa a dichas funciones y anota en tu memoria entregable aquellos aspectos que consideres m\u00e1s relevantes. Tarea Modifica el firmware para que el handler de tratamiento de la obtenci\u00f3n de una direcci\u00f3n IP sea independiente del tratamiento del resto de eventos del sistema WiFi que ya se est\u00e1n considerando. Comprueba que, efectivamente sigue observ\u00e1ndose la salida asociada a dicho evento, aun cuando ambas funciones sean independientes. Entrega o a\u00f1ade a la memoria el c\u00f3digo modificado.","title":"Gesti\u00f3n de redes WiFi. Ejemplo 2. Gesti\u00f3n de eventos de red"},{"location":"RPI-I/P2/","text":"Pr\u00e1ctica 2. Soporte WiFi en el ESP32 Objetivos Conocer el flujo de trabajo del driver WiFi en ESP-IDF. Analizar las diferencias entre un firmware desarrollado para trabajar en modo station y en modo AP . Desarrollar un firmware combinado para que funcione en modo AP y station de forma simult\u00e1nea. Conocer los mecanismos de escaneado de redes en ESP-IDF. Conectar a redes v\u00eda WPA2 Enterprise desde el ESP32 ( eduroam ). Introducci\u00f3n Las bibliotecas y componentes de soporte WiFi en ESP-IDF proporcionan soporte para configurar y monitorizar la conexi\u00f3n 802.11 sobre placas ESP32. Este soporte incluye configuraciones para: Modo station (modo cliente WiFi, o STA ). En este caso, el ESP32 conecta con un punto de acceso preconfigurado. Modo AP (tambi\u00e9n denominado softAP o modo Punto de Acceso ). En este caso, son las estaciones las que conectan al ESP32. Modo combinado AP-STA, donde el ESP32 es act\u00faa de forma concurrente como Punto de Acceso y cliente WiFi conectado a otro punto de acceso. Varios modos de seguridad tanto en modo cliente como en modo AP (WPA, WPA2, WEP, etc.) Escaneado de puntos de acceso (activo y pasivo). Provisionamiento de claves y modo WPS. Modo promiscuo para monitorizaci\u00f3n de paquetes IEEE 802.11. En la presente pr\u00e1ctica, a trav\u00e9s de ejemplos b\u00e1sicos, estudiaremos las caracter\u00edsticas principales soportadas por el driver WiFi sobre el ESP32. Todas estas caracter\u00edsticas pueden ser utilizadas a posteriori para el desarrollo de c\u00f3digos y proyectos m\u00e1s complejos con m\u00ednimas modificaciones. Modelo de programaci\u00f3n del driver WiFi en ESP-IDF El modelo de programaci\u00f3n del driver WiFi en ESP-IDF sigue un modelo de programaci\u00f3n sencillo que se puede resumir en la siguiente imagen: Puede considerarse que el driver WiFi es una caja negra que desconoce cualquier detalle de la aplicaci\u00f3n a mayor nivel, por ejemplo de la pila TCP/IP, las tareas de aplicaci\u00f3n, los eventos, etc. El c\u00f3digo de las tareas de aplicaci\u00f3n generalmente invoca a la API WiFi para inicializar el dispositivo inal\u00e1mbrico y tratar eventos espec\u00edficos cuando resulta necesario. El driver WiFi recibe invocaciones a su API, las procesa y emite eventos a la aplicaci\u00f3n. El tratamiento de eventos WiFi se basa en la biblioteca de eventos esp_event ; los eventos se env\u00edan por parte del driver a bucle de tratamiento de eventos por defecto . La aplicaci\u00f3n procesa estos eventos en funciones callback registradas previamente a trav\u00e9s de la funci\u00f3n esp_event_handler_register() . Alg\u00fan tipo de eventos es tambi\u00e9n procesado por el componente esp_netif para proporcionar reacciones por defecto ante su recepci\u00f3n; un ejemplo claro sucede de forma transparente cuando un dispositivo se conecta a un AP, momento en el cual esp_netif arranca un cliente DHCP para obtener una direcci\u00f3n IP sin intervenci\u00f3n del c\u00f3digo de usuario (aunque este comportamiento por defecto puede ser personalizado para, por ejemplo, asignar una direcci\u00f3n IP est\u00e1ticamente). Nota Toda la API mencionada a continuaci\u00f3n se encuentra descrita en profundidad en este enlace . Se aconseja disponer de esta informaci\u00f3n durante el proceso de desarrollo y tambi\u00e9n en el propio desarrollo de la pr\u00e1ctica. Eventos WiFi Se listan a continuaci\u00f3n algunos de los ejemplos m\u00e1s utilizados en la gesti\u00f3n de conexiones WiFi, que utilizaremos en los ejemplos posteriores. WIFI_EVENT_SCAN_DONE Este evento se env\u00eda autom\u00e1ticamente en la invocaci\u00f3n de esp_wifi_scan_start() , en los siguientes escenarios: El escaneado de redes se completa, es decir, se ha encontrado el punto de acceso (AP) objetivo. El escaneado de redes finaliza tras la invocaci\u00f3n de esp_wifi_scan_stop() . Se invoca al inicio de un nuevo escaneo (mediante la rutina esp_wifi_scan_start() ) antes de finalizar un escaneado previo. Este nuevo escaneado se superpondr\u00e1 al anterior y se emitir\u00e1 el evento. El evento no se emite cuando el escaneado se fuerza mediante la invocaci\u00f3n a esp_wifi_connect() . Ante la recepci\u00f3n de este evento, no se lanza ning\u00fan proceso espec\u00edfico como respuesta. La aplicaci\u00f3n necesitar\u00e1 invocar normalmente a esp_wifi_scan_get_ap_num() y a esp_wifi_scan_get_ap_records() para recoger la lista de APs escaneados y liberar los recursos (memoria) que se aloja en el proceso de escaneado. WIFI_EVENT_STA_START Este evento se env\u00eda cuando, tras la invocaci\u00f3n a esp_wifi_start() , \u00e9sta devuelve ESP_OK . Tras la recepci\u00f3n de este evento, se inicializa la interfaz de red, por lo que normalmente, tras la recepci\u00f3n de este evento se est\u00e1 listo para invocar a esp_wifi_connect() para comenzar el proceso de conexi\u00f3n con un punto de acceso (AP). WIFI_EVENT_STA_STOP Este evento se env\u00eda cuando, tras la invocaci\u00f3n a esp_wifi_stop() , \u00e9sta devuelve ESP_OK . Tras la recepci\u00f3n de este evento, se libera la direcci\u00f3n IP, se detiene el cliente DHCP y se liberan las conexiones TCP/UDP existentes. Normalmente no se trata desde el punto de vista de la aplicaci\u00f3n. WIFI_EVENT_STA_CONNECTED Este evento se env\u00eda cuando, tras la invocaci\u00f3n a esp_wifi_connect() , \u00e9sta devuelve ESP_OK . Tras la recepci\u00f3n de este evento, arranca un cliente DHCP para la obtenci\u00f3n de una direcci\u00f3n IP. A continuaci\u00f3n, si todo ha ido bien, el driver WiFi est\u00e1 listo para enviar y recibir datos. Dicho instante es el adecuado para comenzar con la l\u00f3gica de la aplicaci\u00f3n, siempre que \u00e9sta no dependa de la correcta obtenci\u00f3n de una direcci\u00f3n IP. Si este es el caso, ser\u00e1 necesario esperar a la obtenci\u00f3n de la misma esperando al evento WIFI_EVENT_STA_GOT_IP . WIFI_EVENT_STA_DISCONNECTED Este evento se genera en los siguientes escenarios: Cuando se invoca a las funciones esp_wifi_disconnect() , esp_wifi_stop() , esp_wifi_deinit() o esp_wifi_restart() y la estaci\u00f3n est\u00e1 conectada al punto de acceso. Cuando se invoca a esp_wifi_connect() , pero el driver WiFi no consigue configurar una conexi\u00f3n con el AP debido a cualquier raz\u00f3n (por ejemplo, el escaneo no puede encontrar el AP objetivo, el proceso de autenticaci\u00f3n no tiene \u00e9xito, etc. Si hay m\u00e1s de un AP con el mismo SSID, el evento se emite s\u00f3lo cuando el dispositivo no puede conectar a ninguno de los APs encontrados. Cuando la conexi\u00f3n WiFi se interrumpe, por ejemplo porque el dispositivo pierde N beacons emitidos por el AP, el AP expulsa al dispositivo, el modo de autenticaci\u00f3n cambia, etc. Resulta com\u00fan que la rutina de tratamiento del evento trate de invocar de nuevo a la funci\u00f3n esp_wifi_connect() para reintentar la conexi\u00f3n. WIFI_EVENT_STA_GOT_IP Este evento se emite cuando el cliente DHCP obtiene una direcci\u00f3n IPv4 desde un servidor DHCP, o cuando se modifica su direcci\u00f3n IPv4. El evento significa que todo est\u00e1 listo y que la aplicaci\u00f3n puede continuar con sus tareas (por ejemplo, creaci\u00f3n de sockets, inicializaci\u00f3n de protocolos, etc.) La direcci\u00f3n IPv4 podr\u00eda modificarse por alguna de las siguientes razones: El cliente DHCP no puede renovar la direcci\u00f3n IPv4 tras su expiraci\u00f3n (los servidores DHCP suelen conceder direcciones IP durante un tiempo limitado). El cliente DHCP se asocia a otra direcci\u00f3n. Se modifica la direcci\u00f3n IPv4 asignada est\u00e1ticamente (no v\u00eda DHCP). Normalmente, cuando la IP cambia, todos los sockets asociados a ella quedar\u00e1n en un estado no utilizable. As\u00ed, la recepci\u00f3n de este evento se suele aprovechar para cerrar y a continuaci\u00f3n recrear todos los sockets abiertos. WIFI_EVENT_STA_LOST_IP Evento emitido cuando una direcci\u00f3n IPv4 se convierte en una direcci\u00f3n inv\u00e1lida. El evento no se emite inmediatamente tras la desconexi\u00f3n WiFi, sino que inicializa un temporizador de tipo address lost . Si se obtiene una IP antes de su expiraci\u00f3n, el evento no se emite. En otro caso, se emite justo en el instante de expirci\u00f3n del temporizador. Normalmente, las aplicaciones no deben tratar este evento (suele usarse en tareas de depuraci\u00f3n). WIFI_EVENT_AP_START Emitido en el inicio de un AP (punto de acceso). WIFI_EVENT_AP_STACONNECTED Cuando un dispositivo ( station ) se conecta a un AP, \u00e9ste emite el event WIFI_EVENT_AP_STACONNECTED . Es posible ignorarlo, o aprovecharlo para obtener informaci\u00f3n sobre la estaci\u00f3n conectada, por ejemplo. WIFI_EVENT_AP_STADISCONNECTED Este evento se genera en los siguientes escenarios: La aplicaci\u00f3n invoca a esp_wifi_disconnect() o esp_wifi_deauth_sta() para desconectarla manualmente del punto de acceso. El driver WiFi expulsa al dispositivo ( station ), por ejemplo en una situaci\u00f3n en la que el AP no ha recibido paquetes en los \u00faltimos minutos. Cuando ocurre este evento, la aplicaci\u00f3n necesitar\u00eda (idealmente) tomar las medidas necesarias asociadas al mismo, por ejemplo, cerrar los sockets abiertos. Modo Station La siguiente figura describe, a grandes rasgos, algunos de los escenarios principales que pueden darse en modo station : Se analizan a continuaci\u00f3n las fases principales en este tipo de firmware (no todas tienen que estar necesariamente presentes en cualquier escenario). Fase 1: inicializaci\u00f3n WiFi La tarea principal invoca a esp_netif_init() para crear la pila IP y realizar las tareas de inicializaci\u00f3n pertinentes. La tarea principal invoca a esp_event_loop_create() para crear e inicializar el sistema de eventos. La tarea principal invoca a esp_netif_create_default_wifi_sta() para crear la interfaz de red que asocia el dispositivo con la pila TCP/IP. La tarea principal invoca a esp_wifi_init() para crear la tarea que manejar\u00e1 la conexi\u00f3n WiFi e inicializa el driver WiFi. Por \u00faltimo, se invoca (si as\u00ed se desea, aunque es lo m\u00e1s com\u00fan) a la API para la creaci\u00f3n de la tarea o tareas de aplicaci\u00f3n. Esta secuencia es la recomendada para la inicializaci\u00f3n del sistema de comunicaci\u00f3n WiFi, pero no es estrictamente obligatorio seguirla en dicho orden o en su totalidad. Por ejemplo, se podr\u00eda crear directamente una tarea de aplicaci\u00f3n (paso 5) y realizar la configuraci\u00f3n en su cuerpo, o se puede diferir su creaci\u00f3n hasta la obtenci\u00f3n de una direcci\u00f3n IP. Fase 2: configuraci\u00f3n WiFi Una vez inicializado el driver WiFi, comienza su configuraci\u00f3n. En este escenario, el modo debe fijarse a station a trav\u00e9s de una invocaci\u00f3n a esp_wifi_set_mode(WIFI_MODE_STA) . Es posible invocar a continuaci\u00f3n a otras rutinas de tipo esp_wifi_set_xxx() para configurar par\u00e1metros adicionales (pa\u00eds, ancho de banda, modo de protocolo, ...). Para m\u00e1s informaci\u00f3n sobre los modos de operaci\u00f3n ( station , AP o modo combinado station/AP , consulta el siguiente enlace ). Generalmente, es necesario configurar el driver WiFi antes de establecer una conexi\u00f3n, pero no es obligatorio: es posible reconfigurarlo en cualquier momento, siempre que el driver est\u00e9 correctamente incializado. En cualquier caso, si la configuraci\u00f3n no tiene que modificarse tras la conexi\u00f3n, es mejor realizarla en este punto, porque algunos de los par\u00e1metros que pueden variar forzar\u00e1n una reconexi\u00f3n WiFi, aspecto que es mejor evitar. La rutina esp_wifi_set_config() permite configurar los aspectos b\u00e1sicos de la conexi\u00f3n WiFi. Por ejemplo, el c\u00f3digo: wifi_config_t wifi_config = { .sta = { .ssid = EXAMPLE_ESP_WIFI_SSID, .password = EXAMPLE_ESP_WIFI_PASS, .threshold.authmode = WIFI_AUTH_WPA2_PSK, .pmf_cfg = { .capable = true, .required = false }, }, }; ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA) ); ESP_ERROR_CHECK(esp_wifi_set_config(ESP_IF_WIFI_STA, &wifi_config) ); Realiza una configuraci\u00f3n b\u00e1sica WiFi proporcionando SSID, contrase\u00f1a y modo de autenticaci\u00f3n antes de configurar la conexi\u00f3n. Fase 3: inicio WiFi Invocaci\u00f3n a esp_wifi_start() para iniciar el driver WiFi. El driver WiFi envia un evento WIFI_EVENT_STA_START , que ser\u00e1 tratado por la tarea de gesti\u00f3n de eventos por defecto para realizar las tareas necesarias e invocar\u00e1 a la runtina de tratamiento del evento a nivel de aplicaci\u00f3n. La aplicaci\u00f3n deber\u00e1 tratar el evento WIFI_EVENT_STA_START , invocando (se recomienda) a esp_wifi_connect() . Fase 4: conexi\u00f3n WiFi Una vez invocada esp_wifi_connect() , el dirver WiFi comienza un proceso interno de escaneado/conexi\u00f3n. Si dicho proceso tiene \u00e9xito, se genera un evento WIFI_EVENT_STA_CONNECTED . Autom\u00e1ticamente se invoca al cliente DHCP y comienza el proceso de obtenci\u00f3n de direcci\u00f3n IP. Generalmente, la aplicaci\u00f3n no suele responder a este evento, pero podr\u00eda por ejemplo imprimirse un mensaje por pantalla a modo de depuraci\u00f3n. En el segundo paso, la conexi\u00f3n podr\u00eda fallar, por ejemplo, si la contrase\u00f1a proporcionada es incorrecta. En dicho caso, se env\u00eda un evento de tipo WIFI_EVENT_STA_DISCONNECTED y se proporcionar\u00e1 la causa del error. En el paso 6 se trata este aspecto. Fase 5: obtenci\u00f3n de IP Una vez inicializado el cliente DHCP (paso 4.2) comienza la fase de obtenci\u00f3n de IP. Si se recibe con \u00e9xito una IP desde el servidor DHCP, se emite un evento de tipo IP_EVENT_STA_GOT_IP) . La aplicaci\u00f3n trar\u00e1 este evento de forma acorde. Realmente, en este punto puede comenzar la l\u00f3gica de red de la aplicaci\u00f3n, incluyendo, por ejemplo, la creaci\u00f3n de sockets TCP/UDP. Es imprescindible la recepci\u00f3n de una direcci\u00f3n IP antes de la inicializaci\u00f3n de sockets. Fase 6: desconexi\u00f3n WiFi Cuando finaliza de forma abrupta una conexi\u00f3n WiFi, por ejemplo al apagar el punto de acceso (AP), si la calidad de recepci\u00f3n (RSSI) es baja, etc. se emite un evento WIFI_EVENT_STA_DISCONNECTED . La tarea de aplicaci\u00f3n deber\u00eda tratar este evento para, t\u00edpicamente, reintentar la conexi\u00f3n a trav\u00e9s de una invocaci\u00f3n a esp_wifi_reconnect() . Fase 7: cambio de IP Cuando la direcci\u00f3n IP asignada a un dispositivo cambia, se emite un evento de tipo IP_EVENT_STA_GOT_IP . Por defecto, y de forma autom\u00e1tica, se activa el campo ip_change de la estructura de tipo ip_event_got_ip_t que acompa\u00f1a al evento. La aplicaci\u00f3n deber\u00eda tomar las medidas necesarias (por ejemplo, recreaci\u00f3n de sockets) para mantenerse en un estado consistente. Fase 8: terminaci\u00f3n WiFi Invocaci\u00f3n a esp_wifi_disconnect() para desconectar la conexi\u00f3n en marcha. Invocaci\u00f3n a esp_wifi_stop() para parar el driver WiFi. Invocaci\u00f3n a esp_wifi_deinit() para descargar el driver WiFi. An\u00e1lisis de un ejemplo ( wifi/getting_started/station ) Tarea Analiza el ejemplo station , comp\u00edlalo y flashealo. Estudia el tratamiento de eventos que realiza, y c\u00f3mo estos son emitidos para casos reales. Para ello, conecta tu ESP32 con un punto de acceso existente, otro inexistente, apaga el punto de acceso mientras la IP est\u00e1 concedida, y analiza los eventos generados y su respuesta. Si no existe respuesta a alguno de ellos, a\u00f1\u00e1dela. Documenta las observaciones que consideres de inter\u00e9s y las posibles modificaciones realizadas en tu memoria. Modo Punto de Acceso La siguiente figura describe, a grandes rasgos, algunos de los escenarios principales que pueden darse en modo AP (access point) : El flujo de trabajo es muy similar al del modo station , con la diferencia b\u00e1sica del tipo de configuraci\u00f3n WiFi a realizar ( WIFI_MODE_AP ) y obviamente los par\u00e1metros de configuraci\u00f3n. Observa el siguiente ejemplo de configuraci\u00f3n: wifi_config_t wifi_config = { .ap = { .ssid = EXAMPLE_ESP_WIFI_SSID, .ssid_len = strlen(EXAMPLE_ESP_WIFI_SSID), .channel = EXAMPLE_ESP_WIFI_CHANNEL, .password = EXAMPLE_ESP_WIFI_PASS, .max_connection = EXAMPLE_MAX_STA_CONN, .authmode = WIFI_AUTH_WPA_WPA2_PSK }, }; if (strlen(EXAMPLE_ESP_WIFI_PASS) == 0) { wifi_config.ap.authmode = WIFI_AUTH_OPEN; } ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_AP)); ESP_ERROR_CHECK(esp_wifi_set_config(ESP_IF_WIFI_AP, &wifi_config)); Para m\u00e1s informaci\u00f3n sobre los par\u00e1metros de configuraci\u00f3n de un punto de acceso, consulta este enlace . An\u00e1lisis de un ejemplo ( wifi/getting_started/softAP ) Tarea Analiza el ejemplo softAP , comp\u00edlalo y flashealo. Estudia el tratamiento de eventos que realiza, y c\u00f3mo estos son emitidos para casos reales. Para ello, conecta distintos clientes ( stations ), bien sean ESP32 o cualquier otro dispositivo, y analiza los eventos generados y su respuesta. Si no existe respuesta a alguno de ellos, a\u00f1\u00e1dela. Documenta las observaciones que consideres de inter\u00e9s y las posibles modificaciones realizadas en tu memoria. Modo combinado Station/Punto de Acceso ESP-IDF soporta un modo mixto de conexi\u00f3n, en el que el ESP32 es a la vez un punto de acceso (AP) y una estaci\u00f3n ( station ). Este modo se configura utilizando el par\u00e1metro ESP_MODE_APSTA en la invocaci\u00f3n a la rutina esp_wifi_set_mode() . Adem\u00e1s, obviamente el firmware combinado requerir\u00e1 la creaci\u00f3n de dos estructuras de tipo wifi_config_t , una con los datos asociados al punto de acceso (campo .ap ) y otra con los campos asociados a la station (campo .sta ). A continuaci\u00f3n, ser\u00e1 necesario invocar a la rutina de configuraci\u00f3n ( esp_wifi_set_config ) con cada una de dichas estructuras (por \u00faltimo, tambi\u00e9n es necesario invocar a la inicializaci\u00f3n de netif tanto en modo station -- esp_netif_create_default_wifi_sta() -- como en modo AP -- esp_netif_create_default_wifi_ap() ). Ejercicio: desarrollo de un nodo mixto station/AP Tarea Modifica el ejemplo station para que el ESP32 se comporte a la vez como estaci\u00f3n y como punto de acceso. A\u00f1ade las opciones de configuraci\u00f3n necesarias para que todos los par\u00e1metros se puedan modificar v\u00eda menuconfig . Comprueba que el ESP32 efectivamente se conecta al punto de acceso y que a la vez es posible conectar otro dispositivo al mismo (por ejemplo, tu tel\u00e9fono m\u00f3vil). Adjunta en la entrega tanto el c\u00f3digo como evidencias de su correcto funcionamiento. Escaneado de redes WiFi Modos de escaneado de redes WiFi El modo de escaneo de redes WiFi (es decir, la invocaci\u00f3n de la rutina esp_wifi_scan_start() ) s\u00f3lo est\u00e1 soportada en la actualidad en modo station o station+AP . En este modo, se da soporte a distintos tipos de escaneado de redes, v\u00e9ase: Escaneado activo: El escaneado se desarrolla mediante el env\u00edo de paquetes probe y esperando respuesta, de forma activa. Escaneado pasivo: El escaneado se desarrolla simplemente escuchando en cada canal y esperando el env\u00edo por parte de los APs de paquetes de balizamiento ( beacons ). El modo activo o pasivo puede configurarse desde la aplicaci\u00f3n, mediante el campo scan_type de la estrcutura wifi_scan_config_t (lo ver\u00e1s en el siguiente ejemplo). Escaneado en primer plano: : Se utiliza cuando no hay conexi\u00f3n WiFi activa en el momento del escaneado. No es, por tanto, directamente configurable. Escaneado en segundo plano: Se utiliza cuando hay conexi\u00f3n WiFi activa en el momento del escaneado. No es, por tanto, directamente configurable. Escaneado de todos los canales: Escanea SSIDs en todos los canales. La forma de activarlo es mediante el valor 0 en el campo correspondiente de wifi_scan_config_t . Escaneado de canal espec\u00edfico: Escanea \u00fanicamente en un canal. As\u00ed, existen 8 modos distintos de escaneado de red WiFi, resultantes de la combinaci\u00f3n de los anteriores modos, llamados: All-Channel Background Active Scan. All-Channel Background Passive Scan. All-Channel Foreground Active Scan. All-Channel Foreground Passive Scan. Specific-Channel Background Active Scan. Specific-Channel Background Passive Scan. Specific-Channel Foreground Active Scan. Specific-Channel Foreground Passive Scan. Configuraci\u00f3n de escaneado de redes WiFi Para configurar una sesi\u00f3n de escaneado, se utilizan los campos correspondientes de la estructura de tipo wifi_scan_config_t , proporcionada a la rutina esp_wifi_scan_start() , que es la encargada de iniciar la sesi\u00f3n. Los campos de dicha estructura son: ssid : Si SSID no es NULL, s\u00f3lo se escanea en b\u00fasqueda de este ssid . channel : Si es 0, se realiza un escaneado de todos los canales. En caso contrario, s\u00f3lo se escanea el canal especificado. show_hidden : Si es 0, se ignoran los AP con SSID oculto. En caso contrario se consideran SSIDs normales, y por tanto se muestran. scan_type : Si tma el valor WIFI_SCAN_TYPE_ACTIVE realiza un escaneado activo. En cualquier otro caso, el escaneado es pasivo. scan_time : Especifica el tiempo de escaneado por canal. Escaneado de todos los canales en primer plano. Ejemplo de flujo El siguiente escenario describe un escaneado b\u00e1sico sobre todos los canales en primer plano (recuerda que \u00fanicamente puede ocurrir en modo station si todav\u00eda no hay conexi\u00f3n a un AP). Fase 1: Configuraci\u00f3n del escaneado Se invoca a la rutina esp_wifi_set_country() para establecer el pa\u00eds donde se est\u00e1 desarrollando el escaneado (opcional). Se invoca a esp_wifi_scan_start() para configurar el escaneado. Para ello, se utilizan los par\u00e1metros por defecto o se configuran tal y como se ha especificado en la secci\u00f3n anterior. En este caso, el tipo de escaneado exige fijar el SSID y canal a 0. Fase 2: Fase de escaneado El driver WiFi cambia al canal 1 y emite (en caso de escaneado activo) en modo broadcast un paquete de tipo probe request . En caso de escaneado pasivo, seguir\u00e1 escuchando en el canal 1 durante un tiempo determinado a la espera de beacons . En cualquier caso, el valor por defecto de espera es de 120 milisengundos. El driver cambia al canal 2 y repite el proceso. El proceso se repite para N canales, donde N viene configurado seg\u00fan el pa\u00eds en el que se lleva a cabo el an\u00e1lisis. Fase 3: Fase de an\u00e1lisis de resultados Cuando todos los canales se han escaneado, se emite un evento de tipo WIFI_EVENT_SCAN_DONE . La aplicaci\u00f3n, a trav\u00e9s del callback correspondiente, recibe y procesa los resultados. Se invoca a esp_wifi_scan_get_ap_num() para obtener el n\u00famero de APs que se han encontrado. A continuaci\u00f3n, aloja suficientes entradas e invoca a esp_wifi_scan_get_ap_records() para obtener la informaci\u00f3n de cada AP. An\u00e1lisis de un ejemplo ( wifi/scan ) Analiza el ejemplo de escaneado, e intenta observar el flujo de trabajo detallado anteriormente. Tarea Compila, flashea y ejecuta el ejemplo de escaneado. Observa si los resultados son los esperados en el laboratorio o en un entorno dom\u00e9stico. Modifica el c\u00f3digo para conseguir distintos tipos de escaneado, asegur\u00e1ndote, por ejemplo, de que si fijas un canal espec\u00edfico en el que tu punto de acceso est\u00e1 trabajando, \u00e9ste es detectado corretamente. Estudia y modifica los tiempos de espera en el escaneado y observa su efecto en el tiempo total de escaneado. Documenta las modificaciones realizadas y las observaciones que consideres de inter\u00e9s. Conexi\u00f3n a una red WPA2 Enterprise ( eduroam ) Las \u00faltimas versiones de ESP-IDF permiten la conexi\u00f3n a redes con autenticaci\u00f3n RADIUS, como por ejemplo eduroam . Aunque los detalles de configuraci\u00f3n y desarrollo de un ejemplo concreto van m\u00e1s all\u00e1 del objetivo de la pr\u00e1ctica, es deseable realizar una prueba de conexi\u00f3n a eduroam en el laboratorio, ya que nos resultar\u00e1 de utilidad de cara a futuras pr\u00e1cticas. Como preparaci\u00f3n, debemos utilizar la \u00faltima versi\u00f3n de ESP-IDF, disponible en Github, en lugar de la versi\u00f3n 4.1 que has utilizado hasta ahora. Para ello, en un directorio independiente del que has utilizado hasta ahora instala la \u00faltima versi\u00f3n de ESP-IDF siguiendo las mismas instrucciones que en la instalaci\u00f3n incial, pero clonando la rama master del repositorio, es decir, ejecutando la siguiente instrucci\u00f3n exclusivamente: git clone --recursive https://github.com/espressif/esp-idf.git En lugar de las cadena de ordenes que usaste en la primera pr\u00e1ctica: ## NO EJECUTAR ESTAS ORDENES EN LA NUEVA INSTALACI\u00d3N git clone --recursive https://github.com/espressif/esp-idf.git cd esp-idf git fetch git checkout release/v4.1 git pull git submodule update --init --recursive En cualquier caso, tras la ejecuci\u00f3n anterior, deber\u00e1s instalar las dependencias de nuevo y a continuaci\u00f3n exportar las variables de entorno correctas: sh install.sh . export.sh Conexi\u00f3n a eduroam ( wifi/wpa2_enterprise ) Para conectar a eduroam nuestro ESP32, necesitaremos seguir los siguientes pasos: Descarga el certificado de la CA de la UCM desde este enlace . Copia el fichero descargado, con nombre eduroam.crt al directorio main , y as\u00edgnale el nombre wpa2_ca.pem . Configura el proyecto a trav\u00e9s de idf.py menuconfig con los siguientes par\u00e1metros: SSID: eduroam Validate server: activo EAP method: TTLS Phase2 method for TTLS: PAP EAP ID: anonymous@ucm.es EAP USERNAME: tuusuario@ucm.es EAP PASSWORD: (tu contrase\u00f1a UCM) Tarea Configura, compila y ejecuta el ejemplo de autenticaci\u00f3n y adjunta una captura de pantalla que demuestre la correcta conexi\u00f3n a eduroam .","title":"Pr\u00e1ctica 2"},{"location":"RPI-I/P2/#practica-2-soporte-wifi-en-el-esp32","text":"","title":"Pr\u00e1ctica 2. Soporte WiFi en el ESP32"},{"location":"RPI-I/P2/#objetivos","text":"Conocer el flujo de trabajo del driver WiFi en ESP-IDF. Analizar las diferencias entre un firmware desarrollado para trabajar en modo station y en modo AP . Desarrollar un firmware combinado para que funcione en modo AP y station de forma simult\u00e1nea. Conocer los mecanismos de escaneado de redes en ESP-IDF. Conectar a redes v\u00eda WPA2 Enterprise desde el ESP32 ( eduroam ).","title":"Objetivos"},{"location":"RPI-I/P2/#introduccion","text":"Las bibliotecas y componentes de soporte WiFi en ESP-IDF proporcionan soporte para configurar y monitorizar la conexi\u00f3n 802.11 sobre placas ESP32. Este soporte incluye configuraciones para: Modo station (modo cliente WiFi, o STA ). En este caso, el ESP32 conecta con un punto de acceso preconfigurado. Modo AP (tambi\u00e9n denominado softAP o modo Punto de Acceso ). En este caso, son las estaciones las que conectan al ESP32. Modo combinado AP-STA, donde el ESP32 es act\u00faa de forma concurrente como Punto de Acceso y cliente WiFi conectado a otro punto de acceso. Varios modos de seguridad tanto en modo cliente como en modo AP (WPA, WPA2, WEP, etc.) Escaneado de puntos de acceso (activo y pasivo). Provisionamiento de claves y modo WPS. Modo promiscuo para monitorizaci\u00f3n de paquetes IEEE 802.11. En la presente pr\u00e1ctica, a trav\u00e9s de ejemplos b\u00e1sicos, estudiaremos las caracter\u00edsticas principales soportadas por el driver WiFi sobre el ESP32. Todas estas caracter\u00edsticas pueden ser utilizadas a posteriori para el desarrollo de c\u00f3digos y proyectos m\u00e1s complejos con m\u00ednimas modificaciones.","title":"Introducci\u00f3n"},{"location":"RPI-I/P2/#modelo-de-programacion-del-driver-wifi-en-esp-idf","text":"El modelo de programaci\u00f3n del driver WiFi en ESP-IDF sigue un modelo de programaci\u00f3n sencillo que se puede resumir en la siguiente imagen: Puede considerarse que el driver WiFi es una caja negra que desconoce cualquier detalle de la aplicaci\u00f3n a mayor nivel, por ejemplo de la pila TCP/IP, las tareas de aplicaci\u00f3n, los eventos, etc. El c\u00f3digo de las tareas de aplicaci\u00f3n generalmente invoca a la API WiFi para inicializar el dispositivo inal\u00e1mbrico y tratar eventos espec\u00edficos cuando resulta necesario. El driver WiFi recibe invocaciones a su API, las procesa y emite eventos a la aplicaci\u00f3n. El tratamiento de eventos WiFi se basa en la biblioteca de eventos esp_event ; los eventos se env\u00edan por parte del driver a bucle de tratamiento de eventos por defecto . La aplicaci\u00f3n procesa estos eventos en funciones callback registradas previamente a trav\u00e9s de la funci\u00f3n esp_event_handler_register() . Alg\u00fan tipo de eventos es tambi\u00e9n procesado por el componente esp_netif para proporcionar reacciones por defecto ante su recepci\u00f3n; un ejemplo claro sucede de forma transparente cuando un dispositivo se conecta a un AP, momento en el cual esp_netif arranca un cliente DHCP para obtener una direcci\u00f3n IP sin intervenci\u00f3n del c\u00f3digo de usuario (aunque este comportamiento por defecto puede ser personalizado para, por ejemplo, asignar una direcci\u00f3n IP est\u00e1ticamente). Nota Toda la API mencionada a continuaci\u00f3n se encuentra descrita en profundidad en este enlace . Se aconseja disponer de esta informaci\u00f3n durante el proceso de desarrollo y tambi\u00e9n en el propio desarrollo de la pr\u00e1ctica.","title":"Modelo de programaci\u00f3n del driver WiFi en ESP-IDF"},{"location":"RPI-I/P2/#eventos-wifi","text":"Se listan a continuaci\u00f3n algunos de los ejemplos m\u00e1s utilizados en la gesti\u00f3n de conexiones WiFi, que utilizaremos en los ejemplos posteriores. WIFI_EVENT_SCAN_DONE Este evento se env\u00eda autom\u00e1ticamente en la invocaci\u00f3n de esp_wifi_scan_start() , en los siguientes escenarios: El escaneado de redes se completa, es decir, se ha encontrado el punto de acceso (AP) objetivo. El escaneado de redes finaliza tras la invocaci\u00f3n de esp_wifi_scan_stop() . Se invoca al inicio de un nuevo escaneo (mediante la rutina esp_wifi_scan_start() ) antes de finalizar un escaneado previo. Este nuevo escaneado se superpondr\u00e1 al anterior y se emitir\u00e1 el evento. El evento no se emite cuando el escaneado se fuerza mediante la invocaci\u00f3n a esp_wifi_connect() . Ante la recepci\u00f3n de este evento, no se lanza ning\u00fan proceso espec\u00edfico como respuesta. La aplicaci\u00f3n necesitar\u00e1 invocar normalmente a esp_wifi_scan_get_ap_num() y a esp_wifi_scan_get_ap_records() para recoger la lista de APs escaneados y liberar los recursos (memoria) que se aloja en el proceso de escaneado. WIFI_EVENT_STA_START Este evento se env\u00eda cuando, tras la invocaci\u00f3n a esp_wifi_start() , \u00e9sta devuelve ESP_OK . Tras la recepci\u00f3n de este evento, se inicializa la interfaz de red, por lo que normalmente, tras la recepci\u00f3n de este evento se est\u00e1 listo para invocar a esp_wifi_connect() para comenzar el proceso de conexi\u00f3n con un punto de acceso (AP). WIFI_EVENT_STA_STOP Este evento se env\u00eda cuando, tras la invocaci\u00f3n a esp_wifi_stop() , \u00e9sta devuelve ESP_OK . Tras la recepci\u00f3n de este evento, se libera la direcci\u00f3n IP, se detiene el cliente DHCP y se liberan las conexiones TCP/UDP existentes. Normalmente no se trata desde el punto de vista de la aplicaci\u00f3n. WIFI_EVENT_STA_CONNECTED Este evento se env\u00eda cuando, tras la invocaci\u00f3n a esp_wifi_connect() , \u00e9sta devuelve ESP_OK . Tras la recepci\u00f3n de este evento, arranca un cliente DHCP para la obtenci\u00f3n de una direcci\u00f3n IP. A continuaci\u00f3n, si todo ha ido bien, el driver WiFi est\u00e1 listo para enviar y recibir datos. Dicho instante es el adecuado para comenzar con la l\u00f3gica de la aplicaci\u00f3n, siempre que \u00e9sta no dependa de la correcta obtenci\u00f3n de una direcci\u00f3n IP. Si este es el caso, ser\u00e1 necesario esperar a la obtenci\u00f3n de la misma esperando al evento WIFI_EVENT_STA_GOT_IP . WIFI_EVENT_STA_DISCONNECTED Este evento se genera en los siguientes escenarios: Cuando se invoca a las funciones esp_wifi_disconnect() , esp_wifi_stop() , esp_wifi_deinit() o esp_wifi_restart() y la estaci\u00f3n est\u00e1 conectada al punto de acceso. Cuando se invoca a esp_wifi_connect() , pero el driver WiFi no consigue configurar una conexi\u00f3n con el AP debido a cualquier raz\u00f3n (por ejemplo, el escaneo no puede encontrar el AP objetivo, el proceso de autenticaci\u00f3n no tiene \u00e9xito, etc. Si hay m\u00e1s de un AP con el mismo SSID, el evento se emite s\u00f3lo cuando el dispositivo no puede conectar a ninguno de los APs encontrados. Cuando la conexi\u00f3n WiFi se interrumpe, por ejemplo porque el dispositivo pierde N beacons emitidos por el AP, el AP expulsa al dispositivo, el modo de autenticaci\u00f3n cambia, etc. Resulta com\u00fan que la rutina de tratamiento del evento trate de invocar de nuevo a la funci\u00f3n esp_wifi_connect() para reintentar la conexi\u00f3n. WIFI_EVENT_STA_GOT_IP Este evento se emite cuando el cliente DHCP obtiene una direcci\u00f3n IPv4 desde un servidor DHCP, o cuando se modifica su direcci\u00f3n IPv4. El evento significa que todo est\u00e1 listo y que la aplicaci\u00f3n puede continuar con sus tareas (por ejemplo, creaci\u00f3n de sockets, inicializaci\u00f3n de protocolos, etc.) La direcci\u00f3n IPv4 podr\u00eda modificarse por alguna de las siguientes razones: El cliente DHCP no puede renovar la direcci\u00f3n IPv4 tras su expiraci\u00f3n (los servidores DHCP suelen conceder direcciones IP durante un tiempo limitado). El cliente DHCP se asocia a otra direcci\u00f3n. Se modifica la direcci\u00f3n IPv4 asignada est\u00e1ticamente (no v\u00eda DHCP). Normalmente, cuando la IP cambia, todos los sockets asociados a ella quedar\u00e1n en un estado no utilizable. As\u00ed, la recepci\u00f3n de este evento se suele aprovechar para cerrar y a continuaci\u00f3n recrear todos los sockets abiertos. WIFI_EVENT_STA_LOST_IP Evento emitido cuando una direcci\u00f3n IPv4 se convierte en una direcci\u00f3n inv\u00e1lida. El evento no se emite inmediatamente tras la desconexi\u00f3n WiFi, sino que inicializa un temporizador de tipo address lost . Si se obtiene una IP antes de su expiraci\u00f3n, el evento no se emite. En otro caso, se emite justo en el instante de expirci\u00f3n del temporizador. Normalmente, las aplicaciones no deben tratar este evento (suele usarse en tareas de depuraci\u00f3n). WIFI_EVENT_AP_START Emitido en el inicio de un AP (punto de acceso). WIFI_EVENT_AP_STACONNECTED Cuando un dispositivo ( station ) se conecta a un AP, \u00e9ste emite el event WIFI_EVENT_AP_STACONNECTED . Es posible ignorarlo, o aprovecharlo para obtener informaci\u00f3n sobre la estaci\u00f3n conectada, por ejemplo. WIFI_EVENT_AP_STADISCONNECTED Este evento se genera en los siguientes escenarios: La aplicaci\u00f3n invoca a esp_wifi_disconnect() o esp_wifi_deauth_sta() para desconectarla manualmente del punto de acceso. El driver WiFi expulsa al dispositivo ( station ), por ejemplo en una situaci\u00f3n en la que el AP no ha recibido paquetes en los \u00faltimos minutos. Cuando ocurre este evento, la aplicaci\u00f3n necesitar\u00eda (idealmente) tomar las medidas necesarias asociadas al mismo, por ejemplo, cerrar los sockets abiertos.","title":"Eventos WiFi"},{"location":"RPI-I/P2/#modo-station","text":"La siguiente figura describe, a grandes rasgos, algunos de los escenarios principales que pueden darse en modo station : Se analizan a continuaci\u00f3n las fases principales en este tipo de firmware (no todas tienen que estar necesariamente presentes en cualquier escenario). Fase 1: inicializaci\u00f3n WiFi La tarea principal invoca a esp_netif_init() para crear la pila IP y realizar las tareas de inicializaci\u00f3n pertinentes. La tarea principal invoca a esp_event_loop_create() para crear e inicializar el sistema de eventos. La tarea principal invoca a esp_netif_create_default_wifi_sta() para crear la interfaz de red que asocia el dispositivo con la pila TCP/IP. La tarea principal invoca a esp_wifi_init() para crear la tarea que manejar\u00e1 la conexi\u00f3n WiFi e inicializa el driver WiFi. Por \u00faltimo, se invoca (si as\u00ed se desea, aunque es lo m\u00e1s com\u00fan) a la API para la creaci\u00f3n de la tarea o tareas de aplicaci\u00f3n. Esta secuencia es la recomendada para la inicializaci\u00f3n del sistema de comunicaci\u00f3n WiFi, pero no es estrictamente obligatorio seguirla en dicho orden o en su totalidad. Por ejemplo, se podr\u00eda crear directamente una tarea de aplicaci\u00f3n (paso 5) y realizar la configuraci\u00f3n en su cuerpo, o se puede diferir su creaci\u00f3n hasta la obtenci\u00f3n de una direcci\u00f3n IP. Fase 2: configuraci\u00f3n WiFi Una vez inicializado el driver WiFi, comienza su configuraci\u00f3n. En este escenario, el modo debe fijarse a station a trav\u00e9s de una invocaci\u00f3n a esp_wifi_set_mode(WIFI_MODE_STA) . Es posible invocar a continuaci\u00f3n a otras rutinas de tipo esp_wifi_set_xxx() para configurar par\u00e1metros adicionales (pa\u00eds, ancho de banda, modo de protocolo, ...). Para m\u00e1s informaci\u00f3n sobre los modos de operaci\u00f3n ( station , AP o modo combinado station/AP , consulta el siguiente enlace ). Generalmente, es necesario configurar el driver WiFi antes de establecer una conexi\u00f3n, pero no es obligatorio: es posible reconfigurarlo en cualquier momento, siempre que el driver est\u00e9 correctamente incializado. En cualquier caso, si la configuraci\u00f3n no tiene que modificarse tras la conexi\u00f3n, es mejor realizarla en este punto, porque algunos de los par\u00e1metros que pueden variar forzar\u00e1n una reconexi\u00f3n WiFi, aspecto que es mejor evitar. La rutina esp_wifi_set_config() permite configurar los aspectos b\u00e1sicos de la conexi\u00f3n WiFi. Por ejemplo, el c\u00f3digo: wifi_config_t wifi_config = { .sta = { .ssid = EXAMPLE_ESP_WIFI_SSID, .password = EXAMPLE_ESP_WIFI_PASS, .threshold.authmode = WIFI_AUTH_WPA2_PSK, .pmf_cfg = { .capable = true, .required = false }, }, }; ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA) ); ESP_ERROR_CHECK(esp_wifi_set_config(ESP_IF_WIFI_STA, &wifi_config) ); Realiza una configuraci\u00f3n b\u00e1sica WiFi proporcionando SSID, contrase\u00f1a y modo de autenticaci\u00f3n antes de configurar la conexi\u00f3n. Fase 3: inicio WiFi Invocaci\u00f3n a esp_wifi_start() para iniciar el driver WiFi. El driver WiFi envia un evento WIFI_EVENT_STA_START , que ser\u00e1 tratado por la tarea de gesti\u00f3n de eventos por defecto para realizar las tareas necesarias e invocar\u00e1 a la runtina de tratamiento del evento a nivel de aplicaci\u00f3n. La aplicaci\u00f3n deber\u00e1 tratar el evento WIFI_EVENT_STA_START , invocando (se recomienda) a esp_wifi_connect() . Fase 4: conexi\u00f3n WiFi Una vez invocada esp_wifi_connect() , el dirver WiFi comienza un proceso interno de escaneado/conexi\u00f3n. Si dicho proceso tiene \u00e9xito, se genera un evento WIFI_EVENT_STA_CONNECTED . Autom\u00e1ticamente se invoca al cliente DHCP y comienza el proceso de obtenci\u00f3n de direcci\u00f3n IP. Generalmente, la aplicaci\u00f3n no suele responder a este evento, pero podr\u00eda por ejemplo imprimirse un mensaje por pantalla a modo de depuraci\u00f3n. En el segundo paso, la conexi\u00f3n podr\u00eda fallar, por ejemplo, si la contrase\u00f1a proporcionada es incorrecta. En dicho caso, se env\u00eda un evento de tipo WIFI_EVENT_STA_DISCONNECTED y se proporcionar\u00e1 la causa del error. En el paso 6 se trata este aspecto. Fase 5: obtenci\u00f3n de IP Una vez inicializado el cliente DHCP (paso 4.2) comienza la fase de obtenci\u00f3n de IP. Si se recibe con \u00e9xito una IP desde el servidor DHCP, se emite un evento de tipo IP_EVENT_STA_GOT_IP) . La aplicaci\u00f3n trar\u00e1 este evento de forma acorde. Realmente, en este punto puede comenzar la l\u00f3gica de red de la aplicaci\u00f3n, incluyendo, por ejemplo, la creaci\u00f3n de sockets TCP/UDP. Es imprescindible la recepci\u00f3n de una direcci\u00f3n IP antes de la inicializaci\u00f3n de sockets. Fase 6: desconexi\u00f3n WiFi Cuando finaliza de forma abrupta una conexi\u00f3n WiFi, por ejemplo al apagar el punto de acceso (AP), si la calidad de recepci\u00f3n (RSSI) es baja, etc. se emite un evento WIFI_EVENT_STA_DISCONNECTED . La tarea de aplicaci\u00f3n deber\u00eda tratar este evento para, t\u00edpicamente, reintentar la conexi\u00f3n a trav\u00e9s de una invocaci\u00f3n a esp_wifi_reconnect() . Fase 7: cambio de IP Cuando la direcci\u00f3n IP asignada a un dispositivo cambia, se emite un evento de tipo IP_EVENT_STA_GOT_IP . Por defecto, y de forma autom\u00e1tica, se activa el campo ip_change de la estructura de tipo ip_event_got_ip_t que acompa\u00f1a al evento. La aplicaci\u00f3n deber\u00eda tomar las medidas necesarias (por ejemplo, recreaci\u00f3n de sockets) para mantenerse en un estado consistente. Fase 8: terminaci\u00f3n WiFi Invocaci\u00f3n a esp_wifi_disconnect() para desconectar la conexi\u00f3n en marcha. Invocaci\u00f3n a esp_wifi_stop() para parar el driver WiFi. Invocaci\u00f3n a esp_wifi_deinit() para descargar el driver WiFi.","title":"Modo Station"},{"location":"RPI-I/P2/#analisis-de-un-ejemplo-wifigetting_startedstation","text":"Tarea Analiza el ejemplo station , comp\u00edlalo y flashealo. Estudia el tratamiento de eventos que realiza, y c\u00f3mo estos son emitidos para casos reales. Para ello, conecta tu ESP32 con un punto de acceso existente, otro inexistente, apaga el punto de acceso mientras la IP est\u00e1 concedida, y analiza los eventos generados y su respuesta. Si no existe respuesta a alguno de ellos, a\u00f1\u00e1dela. Documenta las observaciones que consideres de inter\u00e9s y las posibles modificaciones realizadas en tu memoria.","title":"An\u00e1lisis de un ejemplo (wifi/getting_started/station)"},{"location":"RPI-I/P2/#modo-punto-de-acceso","text":"La siguiente figura describe, a grandes rasgos, algunos de los escenarios principales que pueden darse en modo AP (access point) : El flujo de trabajo es muy similar al del modo station , con la diferencia b\u00e1sica del tipo de configuraci\u00f3n WiFi a realizar ( WIFI_MODE_AP ) y obviamente los par\u00e1metros de configuraci\u00f3n. Observa el siguiente ejemplo de configuraci\u00f3n: wifi_config_t wifi_config = { .ap = { .ssid = EXAMPLE_ESP_WIFI_SSID, .ssid_len = strlen(EXAMPLE_ESP_WIFI_SSID), .channel = EXAMPLE_ESP_WIFI_CHANNEL, .password = EXAMPLE_ESP_WIFI_PASS, .max_connection = EXAMPLE_MAX_STA_CONN, .authmode = WIFI_AUTH_WPA_WPA2_PSK }, }; if (strlen(EXAMPLE_ESP_WIFI_PASS) == 0) { wifi_config.ap.authmode = WIFI_AUTH_OPEN; } ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_AP)); ESP_ERROR_CHECK(esp_wifi_set_config(ESP_IF_WIFI_AP, &wifi_config)); Para m\u00e1s informaci\u00f3n sobre los par\u00e1metros de configuraci\u00f3n de un punto de acceso, consulta este enlace .","title":"Modo Punto de Acceso"},{"location":"RPI-I/P2/#analisis-de-un-ejemplo-wifigetting_startedsoftap","text":"Tarea Analiza el ejemplo softAP , comp\u00edlalo y flashealo. Estudia el tratamiento de eventos que realiza, y c\u00f3mo estos son emitidos para casos reales. Para ello, conecta distintos clientes ( stations ), bien sean ESP32 o cualquier otro dispositivo, y analiza los eventos generados y su respuesta. Si no existe respuesta a alguno de ellos, a\u00f1\u00e1dela. Documenta las observaciones que consideres de inter\u00e9s y las posibles modificaciones realizadas en tu memoria.","title":"An\u00e1lisis de un ejemplo (wifi/getting_started/softAP)"},{"location":"RPI-I/P2/#modo-combinado-stationpunto-de-acceso","text":"ESP-IDF soporta un modo mixto de conexi\u00f3n, en el que el ESP32 es a la vez un punto de acceso (AP) y una estaci\u00f3n ( station ). Este modo se configura utilizando el par\u00e1metro ESP_MODE_APSTA en la invocaci\u00f3n a la rutina esp_wifi_set_mode() . Adem\u00e1s, obviamente el firmware combinado requerir\u00e1 la creaci\u00f3n de dos estructuras de tipo wifi_config_t , una con los datos asociados al punto de acceso (campo .ap ) y otra con los campos asociados a la station (campo .sta ). A continuaci\u00f3n, ser\u00e1 necesario invocar a la rutina de configuraci\u00f3n ( esp_wifi_set_config ) con cada una de dichas estructuras (por \u00faltimo, tambi\u00e9n es necesario invocar a la inicializaci\u00f3n de netif tanto en modo station -- esp_netif_create_default_wifi_sta() -- como en modo AP -- esp_netif_create_default_wifi_ap() ).","title":"Modo combinado Station/Punto de Acceso"},{"location":"RPI-I/P2/#ejercicio-desarrollo-de-un-nodo-mixto-stationap","text":"Tarea Modifica el ejemplo station para que el ESP32 se comporte a la vez como estaci\u00f3n y como punto de acceso. A\u00f1ade las opciones de configuraci\u00f3n necesarias para que todos los par\u00e1metros se puedan modificar v\u00eda menuconfig . Comprueba que el ESP32 efectivamente se conecta al punto de acceso y que a la vez es posible conectar otro dispositivo al mismo (por ejemplo, tu tel\u00e9fono m\u00f3vil). Adjunta en la entrega tanto el c\u00f3digo como evidencias de su correcto funcionamiento.","title":"Ejercicio: desarrollo de un nodo mixto station/AP"},{"location":"RPI-I/P2/#escaneado-de-redes-wifi","text":"","title":"Escaneado de redes WiFi"},{"location":"RPI-I/P2/#modos-de-escaneado-de-redes-wifi","text":"El modo de escaneo de redes WiFi (es decir, la invocaci\u00f3n de la rutina esp_wifi_scan_start() ) s\u00f3lo est\u00e1 soportada en la actualidad en modo station o station+AP . En este modo, se da soporte a distintos tipos de escaneado de redes, v\u00e9ase: Escaneado activo: El escaneado se desarrolla mediante el env\u00edo de paquetes probe y esperando respuesta, de forma activa. Escaneado pasivo: El escaneado se desarrolla simplemente escuchando en cada canal y esperando el env\u00edo por parte de los APs de paquetes de balizamiento ( beacons ). El modo activo o pasivo puede configurarse desde la aplicaci\u00f3n, mediante el campo scan_type de la estrcutura wifi_scan_config_t (lo ver\u00e1s en el siguiente ejemplo). Escaneado en primer plano: : Se utiliza cuando no hay conexi\u00f3n WiFi activa en el momento del escaneado. No es, por tanto, directamente configurable. Escaneado en segundo plano: Se utiliza cuando hay conexi\u00f3n WiFi activa en el momento del escaneado. No es, por tanto, directamente configurable. Escaneado de todos los canales: Escanea SSIDs en todos los canales. La forma de activarlo es mediante el valor 0 en el campo correspondiente de wifi_scan_config_t . Escaneado de canal espec\u00edfico: Escanea \u00fanicamente en un canal. As\u00ed, existen 8 modos distintos de escaneado de red WiFi, resultantes de la combinaci\u00f3n de los anteriores modos, llamados: All-Channel Background Active Scan. All-Channel Background Passive Scan. All-Channel Foreground Active Scan. All-Channel Foreground Passive Scan. Specific-Channel Background Active Scan. Specific-Channel Background Passive Scan. Specific-Channel Foreground Active Scan. Specific-Channel Foreground Passive Scan.","title":"Modos de escaneado de redes WiFi"},{"location":"RPI-I/P2/#configuracion-de-escaneado-de-redes-wifi","text":"Para configurar una sesi\u00f3n de escaneado, se utilizan los campos correspondientes de la estructura de tipo wifi_scan_config_t , proporcionada a la rutina esp_wifi_scan_start() , que es la encargada de iniciar la sesi\u00f3n. Los campos de dicha estructura son: ssid : Si SSID no es NULL, s\u00f3lo se escanea en b\u00fasqueda de este ssid . channel : Si es 0, se realiza un escaneado de todos los canales. En caso contrario, s\u00f3lo se escanea el canal especificado. show_hidden : Si es 0, se ignoran los AP con SSID oculto. En caso contrario se consideran SSIDs normales, y por tanto se muestran. scan_type : Si tma el valor WIFI_SCAN_TYPE_ACTIVE realiza un escaneado activo. En cualquier otro caso, el escaneado es pasivo. scan_time : Especifica el tiempo de escaneado por canal.","title":"Configuraci\u00f3n de escaneado de redes WiFi"},{"location":"RPI-I/P2/#escaneado-de-todos-los-canales-en-primer-plano-ejemplo-de-flujo","text":"El siguiente escenario describe un escaneado b\u00e1sico sobre todos los canales en primer plano (recuerda que \u00fanicamente puede ocurrir en modo station si todav\u00eda no hay conexi\u00f3n a un AP). Fase 1: Configuraci\u00f3n del escaneado Se invoca a la rutina esp_wifi_set_country() para establecer el pa\u00eds donde se est\u00e1 desarrollando el escaneado (opcional). Se invoca a esp_wifi_scan_start() para configurar el escaneado. Para ello, se utilizan los par\u00e1metros por defecto o se configuran tal y como se ha especificado en la secci\u00f3n anterior. En este caso, el tipo de escaneado exige fijar el SSID y canal a 0. Fase 2: Fase de escaneado El driver WiFi cambia al canal 1 y emite (en caso de escaneado activo) en modo broadcast un paquete de tipo probe request . En caso de escaneado pasivo, seguir\u00e1 escuchando en el canal 1 durante un tiempo determinado a la espera de beacons . En cualquier caso, el valor por defecto de espera es de 120 milisengundos. El driver cambia al canal 2 y repite el proceso. El proceso se repite para N canales, donde N viene configurado seg\u00fan el pa\u00eds en el que se lleva a cabo el an\u00e1lisis. Fase 3: Fase de an\u00e1lisis de resultados Cuando todos los canales se han escaneado, se emite un evento de tipo WIFI_EVENT_SCAN_DONE . La aplicaci\u00f3n, a trav\u00e9s del callback correspondiente, recibe y procesa los resultados. Se invoca a esp_wifi_scan_get_ap_num() para obtener el n\u00famero de APs que se han encontrado. A continuaci\u00f3n, aloja suficientes entradas e invoca a esp_wifi_scan_get_ap_records() para obtener la informaci\u00f3n de cada AP.","title":"Escaneado de todos los canales en primer plano. Ejemplo de flujo"},{"location":"RPI-I/P2/#analisis-de-un-ejemplo-wifiscan","text":"Analiza el ejemplo de escaneado, e intenta observar el flujo de trabajo detallado anteriormente. Tarea Compila, flashea y ejecuta el ejemplo de escaneado. Observa si los resultados son los esperados en el laboratorio o en un entorno dom\u00e9stico. Modifica el c\u00f3digo para conseguir distintos tipos de escaneado, asegur\u00e1ndote, por ejemplo, de que si fijas un canal espec\u00edfico en el que tu punto de acceso est\u00e1 trabajando, \u00e9ste es detectado corretamente. Estudia y modifica los tiempos de espera en el escaneado y observa su efecto en el tiempo total de escaneado. Documenta las modificaciones realizadas y las observaciones que consideres de inter\u00e9s.","title":"An\u00e1lisis de un ejemplo (wifi/scan)"},{"location":"RPI-I/P2/#conexion-a-una-red-wpa2-enterprise-eduroam","text":"Las \u00faltimas versiones de ESP-IDF permiten la conexi\u00f3n a redes con autenticaci\u00f3n RADIUS, como por ejemplo eduroam . Aunque los detalles de configuraci\u00f3n y desarrollo de un ejemplo concreto van m\u00e1s all\u00e1 del objetivo de la pr\u00e1ctica, es deseable realizar una prueba de conexi\u00f3n a eduroam en el laboratorio, ya que nos resultar\u00e1 de utilidad de cara a futuras pr\u00e1cticas. Como preparaci\u00f3n, debemos utilizar la \u00faltima versi\u00f3n de ESP-IDF, disponible en Github, en lugar de la versi\u00f3n 4.1 que has utilizado hasta ahora. Para ello, en un directorio independiente del que has utilizado hasta ahora instala la \u00faltima versi\u00f3n de ESP-IDF siguiendo las mismas instrucciones que en la instalaci\u00f3n incial, pero clonando la rama master del repositorio, es decir, ejecutando la siguiente instrucci\u00f3n exclusivamente: git clone --recursive https://github.com/espressif/esp-idf.git En lugar de las cadena de ordenes que usaste en la primera pr\u00e1ctica: ## NO EJECUTAR ESTAS ORDENES EN LA NUEVA INSTALACI\u00d3N git clone --recursive https://github.com/espressif/esp-idf.git cd esp-idf git fetch git checkout release/v4.1 git pull git submodule update --init --recursive En cualquier caso, tras la ejecuci\u00f3n anterior, deber\u00e1s instalar las dependencias de nuevo y a continuaci\u00f3n exportar las variables de entorno correctas: sh install.sh . export.sh","title":"Conexi\u00f3n a una red WPA2 Enterprise (eduroam)"},{"location":"RPI-I/P2/#conexion-a-eduroam-wifiwpa2_enterprise","text":"Para conectar a eduroam nuestro ESP32, necesitaremos seguir los siguientes pasos: Descarga el certificado de la CA de la UCM desde este enlace . Copia el fichero descargado, con nombre eduroam.crt al directorio main , y as\u00edgnale el nombre wpa2_ca.pem . Configura el proyecto a trav\u00e9s de idf.py menuconfig con los siguientes par\u00e1metros: SSID: eduroam Validate server: activo EAP method: TTLS Phase2 method for TTLS: PAP EAP ID: anonymous@ucm.es EAP USERNAME: tuusuario@ucm.es EAP PASSWORD: (tu contrase\u00f1a UCM) Tarea Configura, compila y ejecuta el ejemplo de autenticaci\u00f3n y adjunta una captura de pantalla que demuestre la correcta conexi\u00f3n a eduroam .","title":"Conexi\u00f3n a eduroam (wifi/wpa2_enterprise)"},{"location":"RPI-I/P3/","text":"Pr\u00e1ctica 3. WiFi. Conceptos avanzados (WiFi Mesh, provisionamiento y ahorro de energ\u00eda) Objetivos La presente pr\u00e1ctica se divide en tres partes principales, que abordan tres temas avanzados relacionados con la conectividad WiFi en ESP-IDF y en el ESP32. Los objetivos en cada punto son: WiFi MESH Revisar los conceptos b\u00e1sicos para la construcci\u00f3n de una red MESH WiFi autogestionada. Presentar la API b\u00e1sica para la creaci\u00f3n de aplicaciones basadas en la pila ESP-MESH. Observar en funcionamiento una red ESP-MESH, as\u00ed como sus capacidades de autoconfiguraci\u00f3n. Provisionamiento Entender y experimentar con distintos modos de provisionamiento de credenciales WiFi, v\u00eda BLE y v\u00eda softAP . Comprobar el intercambio de claves en claro realizando provisionamientos desde l\u00ednea de comandos, as\u00ed como observar la utilidad (y necesidad) del env\u00edo cifrado de credenciales. Ahorro de energ\u00eda Entender los tres modos de funcionamiento del ESP32 a nivel de ahorro energ\u00e9tico en conexiones WiFi. Observar la desviaci\u00f3n en latencia de recepci\u00f3n de paquetes en funci\u00f3n del modo aplicado. Parte 1. WiFi Mesh (ESP MESH) El stack ESP-MESH est\u00e1 construido por encima del driver WiFi (es decir, obviamente hace uso de sus servicios), y en algunos casos tambi\u00e9n haciendo uso de servicios de la pila IP ( lwIP ), por ejemplo en el nodo ra\u00edz, que es el \u00fanico con comunicaci\u00f3n IP contra un router de borde. El siguiente diagrama muestra la situaci\u00f3n de la pila Mesh en ESP-IDF: Como cualquier otro componente ESP-IDF, ESP-MESH se comunica con las aplicaciones a trav\u00e9s de eventos propios: El tipo mesh_event_id_t define todos los posibles eventos que pueden surgir en las distintas fases del ciclo de vida de una red (por ejemplo, para un nodo determinado, conexi\u00f3n o desconexi\u00f3n de su nodo padre, o de uno de sus nodos hijo). Antes de utilizar los eventos ESP-MESH para gestionar u observar el funcionamiento de la red, es necesario registrarlos v\u00eda esp_event_handler_register() . Algunos usos t\u00edpicos de los eventos incluyen, por ejemplo, la situaci\u00f3n de conexi\u00f3n de un nodo padre ( MESH_EVENT_PARENT_CONNECTED ) o de un hijo ( MESH_EVENT_CHILD_CONNECTED ), indicando, respectivamente, que un nodo puede comenzar a emitir hacia arriba en el grafo, o hacia abajo. Del mismo modo, en un nodo ra\u00edz, la recepci\u00f3n de los eventos IP_EVENT_STA_GOT_IP y IP_EVENT_STA_LOST_IP se pueden aprovechar para indicar que dicho nodo ra\u00edz puede o no enviar datos a la red IP externa. Eventos MESH_EVENT_STARTED : mesh iniciada. MESH_EVENT_STOPPED : mesh finalizada. MESH_EVENT_CHANNEL_SWITCH : cambio de canal. MESH_EVENT_CHILD_CONNECTED : un hijo ha conectado a la interfaz softAP . MESH_EVENT_CHILD_DISCONNECTED : un hijo ha desconectado de la interfaz softAP . MESH_EVENT_ROUTING_TABLE_ADD : se han a\u00f1adido nuevas entradas a la tabla de enrutamiento a\u00f1adiendo nuevos hijos. MESH_EVENT_ROUTING_TABLE_REMOVE : se ha eliminado entradas de la tabla de enrutamiento eliminado hijos que han abandonado la red. MESH_EVENT_PARENT_CONNECTED : un padre se ha conectado a la interfaz station . MESH_EVENT_PARENT_DISCONNECTED : un padre se ha desconectado de la interfaz station . MESH_EVENT_NO_PARENT_FOUND : no se ha encontrado un padre. MESH_EVENT_LAYER_CHANGE : el nodo ha cambiado de nivel en la red. MESH_EVENT_TODS_STATE : indica que el nodo ra\u00edz es capaz de acceder a la red IP externa. MESH_EVENT_VOTE_STARTED : el proceso de voto de un nuevo nodo ra\u00edz ha comenzado. MESH_EVENT_VOTE_STOPPED : el proceo de voto de un nuevo nodo ra\u00edz ha finalizado. MESH_EVENT_ROOT_ADDRESS : se ha obtenido la direcci\u00f3n del nodo ra\u00edz. MESH_EVENT_ROOT_SWITCH_REQ : un nodo ra\u00edz candidato ya elegido solicita un cambio de nodo ra\u00edz. MESH_EVENT_ROOT_SWITCH_ACK : respuesta a la anterior petici\u00f3n por parte del nodo ra\u00edz actual. MESH_EVENT_NETWORK_STATE : la actual red tiene un nodo ra\u00edz. MESH_EVENT_STOP_RECONNECTION : el nodo ra\u00edz detiene el proceso de reconexi\u00f3n al router y los dem\u00e1s nodos detienen los procesos de conexi\u00f3n a sus nodos padre. MESH_EVENT_FIND_NETWORK : si el canal solicitado es 0, la pila escanear\u00e1 todos los canales para encontrar una red mesh a la que conectar, devolviendo el canal en el que lo ha conseguido. Uso de la pila IP El c\u00f3digo de una aplicaci\u00f3n que haga uso de ESP-MESH puede acceder directamente a la pila MESH sin pasar por la pila IP. De hecho, la pila IP s\u00f3lo es estrictamente necesaria por parte del nodo ra\u00edz, al ser el \u00fanico que puede recibir o transmitir datos desde o hacia la red IP externa. Sin embargo, como cualquier nodo de la topolog\u00eda puede potencialmente convertirse en nodo ra\u00edz (ya que su selecci\u00f3n es autom\u00e1tica), todos los nodos deber\u00e1n inicializar la pila IP. Por tanto, todos los nodos incializan la pila IP v\u00eda tcpip_adapter_init() . Adem\u00e1s, todos los nodos deber\u00e1n detener el servidor DHCP en la interfaz softAP , y el cliente DHCP en la interfaz station : /* tcpip initialization */ tcpip_adapter_init(); /* * for mesh * stop DHCP server on softAP interface by default * stop DHCP client on station interface by default */ ESP_ERROR_CHECK(tcpip_adapter_dhcps_stop(TCPIP_ADAPTER_IF_AP)); ESP_ERROR_CHECK(tcpip_adapter_dhcpc_stop(TCPIP_ADAPTER_IF_STA)); Sin embargo, en el caso de un nodo que se convierte en ra\u00edz, es imprescindible arrancar el cliente DHCP como respuesta al evento corresondiente para as\u00ed obtener direcci\u00f3n IP desde el router que da salida hacia la red externa. Estructura b\u00e1sica de una aplicaci\u00f3n ESP-MESH El siguiente c\u00f3digo muestra la estructura b\u00e1sica de inicializaci\u00f3n de pilas IP y WiFi necesarias para comenzar con la configuraci\u00f3n de la red MESH: tcpip_adapter_init(); /* * for mesh * stop DHCP server on softAP interface by default * stop DHCP client on station interface by default */ ESP_ERROR_CHECK(tcpip_adapter_dhcps_stop(TCPIP_ADAPTER_IF_AP)); ESP_ERROR_CHECK(tcpip_adapter_dhcpc_stop(TCPIP_ADAPTER_IF_STA)); /* event initialization */ ESP_ERROR_CHECK(esp_event_loop_create_default()); /* Wi-Fi initialization */ wifi_init_config_t config = WIFI_INIT_CONFIG_DEFAULT(); ESP_ERROR_CHECK(esp_wifi_init(&config)); /* register IP events handler */ ESP_ERROR_CHECK(esp_event_handler_register(IP_EVENT, IP_EVENT_STA_GOT_IP, &ip_event_handler, NULL)); ESP_ERROR_CHECK(esp_wifi_set_storage(WIFI_STORAGE_FLASH)); ESP_ERROR_CHECK(esp_wifi_start()); Tras esta inicializaci\u00f3n, comienza la fase de configuraci\u00f3n e inicializaci\u00f3n de la malla, que proceder\u00e1 en tres pasos principales: Inicializaci\u00f3n de la malla Configuraci\u00f3n de la red ESP-MESH Arranque de la red Paso 1. Inicializaci\u00f3n de la malla La inicializaci\u00f3n de la malla y registro de eventos propios es sencilla: /* mesh initialization */ ESP_ERROR_CHECK(esp_mesh_init()); /* register mesh events handler */ ESP_ERROR_CHECK(esp_event_handler_register(MESH_EVENT, ESP_EVENT_ANY_ID, &mesh_event_handler, NULL)); Paso 2. Configuraci\u00f3n de la red ESP-MESH La configuraci\u00f3n de ESP-MESH se realiza a trav\u00e9s de la funci\u00f3n esp_mesh_set_config() , que recibe una estructura de tipo mesh_cfg_t con la configuraci\u00f3n de la red: Par\u00e1metro Descripci\u00f3n Channel Canal (entre 1 y 14) Mesh ID Identificaci\u00f3n de la red MESH (6 bytes) Router SSID y contrase\u00f1a de conexi\u00f3n al router de salida Mesh AP Configuraci\u00f3n espec\u00edfica del AP generado por cada nodo Un ejemplo de configuraci\u00f3n podr\u00eda ser: /* Mesh ID */ static const uint8_t MESH_ID = { 0x77, 0x77, 0x77, 0x77, 0x77, 0x77 }; /* Enable the Mesh IE encryption by default */ mesh_cfg_t cfg = MESH_INIT_CONFIG_DEFAULT(); /* mesh ID */ memcpy((uint8_t *) &cfg.mesh_id, MESH_ID, 6); /* channel (must match the router's channel) */ cfg.channel = CONFIG_MESH_CHANNEL; /* router */ cfg.router.ssid_len = strlen(CONFIG_MESH_ROUTER_SSID); memcpy((uint8_t *) &cfg.router.ssid, CONFIG_MESH_ROUTER_SSID, cfg.router.ssid_len); memcpy((uint8_t *) &cfg.router.password, CONFIG_MESH_ROUTER_PASSWD, strlen(CONFIG_MESH_ROUTER_PASSWD)); /* mesh softAP */ cfg.mesh_ap.max_connection = CONFIG_MESH_AP_CONNECTIONS; memcpy((uint8_t *) &cfg.mesh_ap.password, CONFIG_MESH_AP_PASSWD, strlen(CONFIG_MESH_AP_PASSWD)); ESP_ERROR_CHECK(esp_mesh_set_config(&cfg)); Paso 3. Arranque de la red El arranque de la red MESH es sencillo: /* mesh start */ ESP_ERROR_CHECK(esp_mesh_start()); Tras el arranque, la aplicaci\u00f3n deber\u00eda comprobar los eventos para determinar si la conexi\u00f3n a la red ha sido exitosa. En dicho caso, tras la conexi\u00f3n, la aplicaci\u00f3n puede comenzar a transmitir paquetes a trav\u00e9s de la red MESH utilizando las rutinas esp_mesh_send() y esp_mesh_recv() . Ejercicio en clase. Despliegue conjunto de una red WiFi Mesh La forma m\u00e1s conveniente de observar el comportamiento de una red WiFi Mesh es desplegar una infraestructura con suficiente n\u00famero de nodos pertenecientes a una misma red. Desafortunadamente, para ello es necesario disponer de dichos nodos en un espacio cercano. En la presente pr\u00e1ctica, desplegaremos una red WiFi Mesh en el laboratorio, utilizando vuestro o vuestros ESP32 como elementos de la red. Para ello, configuraremos, compilaremos y ejecutaremos el ejemplo examples/mesh/internal_communication . Antes de proceder, configuraremos el proyecto para: Conectar al punto de acceso com\u00fan del laboratorio ( Router SSID y Router password ). Configurar la red ESP-MESH para utilizar WPA2_PSK y seleccionar como contrase\u00f1a password . Aumentar el n\u00famero de conexiones al AP a 10. De momento, no realizaremos ning\u00fan cambio en el c\u00f3digo del ejemplo. Compila y ejecuta tu c\u00f3digo. En la direcci\u00f3n del enlace dispones de una primera pesta\u00f1a en la que deber\u00e1s completar cierta informaci\u00f3n que observar\u00e1s en la salida de monitorizaci\u00f3n una vez arranques el ESP32, en la celda correspondiente a tu puesto. Esta informaci\u00f3n, en principio, incluye: Tu nombre. Direcciones MAC de las interfaces STA y SoftAP (lo observar\u00e1s en los primeros mensajes de salida). Capa de la topolog\u00eda en la que se encuentra tu nodo (lo observar\u00e1s en formato [L:XX] en los env\u00edos y recepciones de datos). En caso de haber sido elegido nodo ra\u00edz, anotar tambi\u00e9n esta circunstancia y la IP asignada por el router (observa la respuesta al evento correspondiente). Adem\u00e1s, anota la ID de la red Mesh que se ha utilizado para conectar. Antes de rellenar la informaci\u00f3n, espera que el profesor te indique que la topolog\u00eda ha convergido, y que por tanto no habr\u00e1 ning\u00fan cambio m\u00e1s en ella (siempre que ningun nodo deje de formar parte de la misma). Ejercicio entregable Captura el estado de la red cuando todos tus compa\u00f1eros hayan llegado al punto de convergencia, e intenta determinar, en forma de grafo, la topolog\u00eda de la misma. A continuaci\u00f3n, apagaremos el nodo ra\u00edz y esperaremos a la vuelta a la convergencia de la red. Ejercicio entregable Captura de nuevo el estado de la red cuando todos tus compa\u00f1eros hayan llegado al punto de convergencia, e intenta determinar, en forma de grafo, la topolog\u00eda de la misma. Como \u00faltimo ejercicio, vamos a crear nuevas redes Mesh en funci\u00f3n del puesto que tengas asignado. Observa los colores asignados a cada grupo de puestos en la siguiente hoja . Ejercicio en clase. Despliegue conjunto de una red WiFi Mesh de menores dimensiones Modifica tu c\u00f3digo para que el canal de escucha y el identificador de red coincidan con el indicado. Puedes configurar el canal a trav\u00e9s del men\u00fa de configuracion del ejemplo ( channel ) y el identificador modificando la variable correspondiente en el fichero mesh_main.c . Una vez hecho esto, reconstruid la informaci\u00f3n de las tablas para reflejar las nuevas topolog\u00edas. Pod\u00e9is hacer pruebas posteriores apagando el nodo ra\u00edz y observando la convergencia de la red. Ejercicio entregable Captura de nuevo el estado de la red cuando todos tus compa\u00f1eros hayan llegado al punto de convergencia, e intenta determinar, en forma de grafo, la topolog\u00eda de la misma. El estudio detallado del c\u00f3digo para el despliegue de la red queda como ejercicio para el alumno. Observa el tratamiento de eventos y la fase de configuraci\u00f3n de la red. Intenta entender el funcionamiento del c\u00f3digo (env\u00edos y recepciones, destinatarios de los mismos, etc.). Parte 2.Provisionamiento WiFi ESP-IDF proporciona un componente espec\u00edfico que ofrece un servicio de provisionamiento WiFi. Entendemos por provisionamiento WiFi el mecanismo o mecanismos mediante los cuales es posible proporcionar, de forma externa y segura, el conjunto de credenciales de conexi\u00f3n a una red WiFi a un dispositivo no conectado. El component de provisionamiento WiFi en ESP-IDF permite proporcionar dichas credenciales a trav\u00e9s de dos v\u00edas: Bluetooth Low Energy (modo BLE ) o a trav\u00e9s de un mecanismo de punto de acceso WiFi temporal (modo SoftAP ). ESP-IDF proporciona una serie de APIs (con prototipos wifi_prov_mgr_* ) para implementar de forma sencilla ambos modos de provisionamiento. Para completar esta parte de la pr\u00e1ctica deber\u00e1s trabajar con los ejemplos examples/provisioning/softap_prov (para la versi\u00f3n de provisionamiento v\u00eda WiFi) y examples/provisioning/ble_prov (para la versi\u00f3n de provisionamiento via Bluetooth Low Energy). Inicializaci\u00f3n del servicio de provisionamiento La rutina wifi_prov_mgr_init() se utiliza para configurar e inicializar el componente de provisionamiento, y debe invocarse antes de cualquier otra invocaci\u00f3n a rutinas de tipo wifi_prov_mgr* . Adem\u00e1s, es necesario destacar que el componente de provisionamiento conf\u00eda en las funcionalidades de otros componentes (b\u00e1sicamente NVS, TCP/IP, Event loop y mDNS), por lo que \u00e9stos deben inicializarse antes del propio componente. Para finalizar el componente de provisionamiento, es suficiente con invocar a la rutina wifi_prov_mgr_deinit() . Un ejemplo de inicializaci\u00f3n resultar\u00eda en: wifi_prov_mgr_config_t config = { .scheme = wifi_prov_scheme_ble, .scheme_event_handler = WIFI_PROV_SCHEME_BLE_EVENT_HANDLER_FREE_BTDM }; ESP_ERR_CHECK( wifi_prov_mgr_init(config) ); La estructura de configuraci\u00f3n de tipo wifi_prov_mgr_config_t dispone de campos que permiten especificar el comportamiento del componente; espec\u00edficamente, el campo scheme especifica el esquema (o tipo) de provisionamiento. Disponemos de tres opciones: wifi_prov_scheme_softap : transporta la informaci\u00f3n de provisionamiento v\u00eda WiFi (creando un punto de acceso temporal) y un servidor HTTP para recibir los comandos e informaci\u00f3n de provisionamiento. wifi_prov_scheme_ble : transporta la informaci\u00f3n de provisionamiento v\u00eda Bluetooth Low Energy (BLE) y un servidor GATT para recibir los comandos e informaci\u00f3n de provisionamiento. wifi_prov_scheme_console : transporta la informaci\u00f3n v\u00eda puerto serie y Comprobaci\u00f3n del estado de provisionamiento Es posible comprobar el estado de provisionamiento de un dispositivo mediante una invocaci\u00f3n a wifi_prov_mgr_is_provisioned() , que chequea si las credenciales de conexi\u00f3n WiFi est\u00e1n almacenadas en la memoria no vol\u00e1til (NVS). Aunque existen distintos m\u00e9todos para eliminar la informaci\u00f3n de provisionamento almacenada en la NVS, utilizaremos el mecanismo proporcionado por idf.py para eliminar su contenido. Para ello, ejecutaremos: idf.py erase_flash Par\u00e1metros de inicializaci\u00f3n del servicio de provisionamiento WiFi Al inicializar el componente de provisionamiento, es necesario especificar un nombre de servicio y una clave. Esto se traduce en: SSID y contrase\u00f1a para el modo SoftAP (es decir, cuando el esquema de provisionamiento se ha configurado como wifi_prov_scheme_softap ). Nombre del dispositivo BLE para el modo BLE (es decir, cuando el esquema de provisionamiento se ha configurado como wifi_prov_scheme_ble ). Adem\u00e1s, internamente el componente utiliza el mecanismo de comunicaci\u00f3n protocomm , que permite dos niveles de seguridad en la comunicaci\u00f3n de credenciales de provisionamiento: Nivel 1 de seguridad, que consiste en un handshake previo entre ambos extremos, con intercambio de claves y utilizaci\u00f3n de una prueba de posesi\u00f3n (PoP, proof of possession ), y utilizando encriptaci\u00f3n AES para el intercambio de mensajes. Nivel 0 de seguridad, que consiste en un intercambio de credenciales utilizando texto plano y sin PoP . As\u00ed, un ejemplo de inicializaci\u00f3n del servicio de provisionamiento podr\u00eda resultar en el siguiente c\u00f3digo: const char *service_name = \"my_device\"; const char *service_key = \"password\"; wifi_prov_security_t security = WIFI_PROV_SECURITY_1; const char *pop = \"abcd1234\"; ESP_ERR_CHECK( wifi_prov_mgr_start_provisioning(security, pop, service_name, service_key) ); El servicio de provisionamiento finalizar\u00e1 autom\u00e1ticamente al conectar a un AP con \u00e9xito (es decir, al obtener IP desde el mismo). En cualquier caso, puede tambi\u00e9n detenerse de forma manual en cualquier momento a trav\u00e9s de la invocaci\u00f3n a wifi_prov_mgr_stop_provisioning() . Espera a la finalizaci\u00f3n del proceso de provisionamiento T\u00edpicamente, las aplicaciones de usuario en el ESP32 deber\u00e1n esperar a que el proceso de provisionamiento finalice antes de proceder. En ese momento, y antes de proceder, liberar\u00e1n los recursos que se alojaron para el proceso de provisionamiento, y comenzar\u00e1n con su l\u00f3gica habitual. Existen dos mecanismos para conseguir este efecto: En primer lugar, la soluci\u00f3n m\u00e1s simple consiste en utilizar una invocaci\u00f3n bloqueante a la rutina wifi_prov_mgr_wait() : // Inicializaci\u00f3n del servicio de provisionamiento ESP_ERR_CHECK( wifi_prov_mgr_start_provisioning(security, pop, service_name, service_key) ); // Espera a la compleci\u00f3n del provisionamiento wifi_prov_mgr_wait(); // Liberaci\u00f3n de recursos wifi_prov_mgr_deinit(); // A partir de aqu\u00ed, comenzar\u00eda la l\u00f3gica habitual de la aplicaci\u00f3n // ... El segundo mecanismo estar\u00eda basado en eventos (es decir, ser\u00eda no bloqueante ), interceptando y trabajando sobre eventos de tipo WIFI_PROV_EVENT e invocando a wifi_prov_mgr_deinit() cuando el identificador de evento sea WIFI_PROV_END : static void event_handler(void* arg, esp_event_base_t event_base, int event_id, void* event_data) { if (event_base == WIFI_PROV_EVENT && event_id == WIFI_PROV_END) { /* Liberar recursos una vez el proceso de provisionamiento ha finalizado */ wifi_prov_mgr_deinit(); } } Herramientas de provisionamiento para dispositivos m\u00f3viles Existen aplicaciones preparadas por Espressif para llevar a cabo el proceso de provisionamiento sobre ESP32. Estas aplicaciones est\u00e1n disponibles tanto para dispositivos Android como IOS, en las versiones con transporte BLE o SoftAP: Android: Provisionamiento BLE . Provisionamiento SoftAP . IOS: Provisionamiento BLE . Provisionamiento SoftAP . Tarea entregable Utilizando las aplicaciones correspondientes a tu dispositivo m\u00f3vil, tanto para el uso de BLE como de SoftAP, provisiona tu ESP32 utilizando las credenciales que correspondan a tu red WiFi. Entrega una breve descripci\u00f3n del proceso desarrollado, as\u00ed como capturas de pantalla correspondientes a la salida del ESP32 que evidencien que el proceso de provisionamiento se ha realizado correctamente. Recuerda, antes de cada repetici\u00f3n del experimento, utilizar la orden idf.py erase_flash para eliminar informaci\u00f3n de provisionamiento de sesiones anteriores. Comprueba el funcionamiento de los distintos niveles de seguridad. Estas aplicaciones funcionan mediante una comunicaci\u00f3n muy sencilla con el ESP32 no provisionado, cuyos mecanismos dependen del transporte utilizado; en el caso de BLE, se crea una tabla GATT con distintas caracter\u00edsticas que ser\u00e1n utilizadas para escribir (enviar) datos en el dispositivo. Veremos qu\u00e9 es una tabla GATT en pr\u00f3ximas pr\u00e1cticas, por lo que retornaremos a este punto. En el caso de softAP , se crean una serie de endpoints (URIs HTTP) que permiten, de forma sencilla, leer y escribir aquellos datos que deseamos comunicar al otro extremo de la comunicaci\u00f3n. La siguiente tabla resume los endpoints creados por las versiones est\u00e1ndar del protocolo de provisionamiento (pueden ser modificados o adaptados en funci\u00f3n de la informaci\u00f3n adicional que deseemos intercambiar): Endpoint (BLE + Servidor GATT) URI (SoftAP + HTTP) Establecimiento de sesi\u00f3n prov-session http://IP:80/prov-session Escaneo de redes disponibles prov-scan http://IP:80/prov-scan Configuraci\u00f3n de provisionamiento prov-config http://IP:80/prov-config Versi\u00f3n del protocolo proto-ver http://IP:80/proto-ver Los detalles de este tipo de protocolo de provisionamiento quedan como ejercicio adicional al alumno, y van m\u00e1s all\u00e1 del objetivo de la pr\u00e1ctica. Sin embargo, s\u00ed es conveniente disponer de alg\u00fan mecanismo que permita observarlos, y determinar, por ejemplo para el caso de SoftAP, si el intercambio de credenciales se realiza como texto plano (en claro) o cifrado, lo cu\u00e1l podr\u00eda suponer serios problemas de seguridad para el usuario de un dispositivo m\u00f3vil, ya que se expondr\u00edan las credenciales de conexi\u00f3n a la red WiFi. Para estudiar este hecho, utilizaremos una herramienta de l\u00ednea de \u00f3rdenes proporcionada junto a ESP-IDF, llamada esp_prov.py , situada en el directorio tools/esp_prov de la instalaci\u00f3n. Nota Antes de utilizar el programa, debes instalar las dependencias respectivas utilizando las \u00f3rdenes (desde el propio directorio tools/esp_prov ): pip install -r requirements.txt pip install -r requirements_linux_extra.txt Su uso es sencillo, y puede consultarse ejecutando python esp_prov.py -h . B\u00e1sicamente, una sesi\u00f3n de provisionamiento utilizando softAP sobre un dispositivo a la espera con IP 192.168.4.1 , sin capa de seguridad (cifrado) y proporcionando la SSID y clave SSID_EJEMPLO/CLAVE_EJEMPLO resultar\u00eda: python esp_prov.py --transport softap --service_name \"192.168.4.1:80\" --sec_ver 0 --ssid SSID_EJEMPLO --passphrase CLAVE_EJEMPLO Ten en cuenta que, para emitir el anterior comando, debes pertenecer a la misma red que el dispositivo a provisionar, es decir, haber conectado al SSID de provisionamiento que se proporciona. Tarea entregable Realiza el proceso de provisionamiento desde l\u00ednea de comandos utilizando las anteriores indicaciones, y muestra capturas de tr\u00e1fico v\u00eda Wireshark donde se evidencie la entrega en claro (en modo texto, sin cifrar) de las credenciales de red entre el provisionador y el dispositivo, y el uso de los endpoints/URIs anteriormente mencionados. A continuaci\u00f3n, pasa a un modo seguro (opci\u00f3n --sec_ver 1 ) y observa c\u00f3mo las claves se intercambian cifradas. Parte 3. Modos de ahorro de consumo WiFi En la versi\u00f3n actual de ESP-IDF, el framework soporta distintos modos de ahorro de energ\u00eda, con soporte tanto a nivel de dispositivo ( station ) como de punto de acceso ( AP ). Todos estos modos se basan en las caracter\u00edsticas de ahorro de consumo contempladas en el est\u00e1ndar 802.11 (concretamente en el modo Modem-sleep ). El modo Modem-sleep trabaja exclusivamente cuando un dispositivo est\u00e1 configurado como station , y se encuentra conectado a un AP. Si el modo Modem-sleep est\u00e1 activo, el dispositivo var\u00eda su estado entre activo y sleep peri\u00f3dicamente. En el modo sleep , tres de los principales componentes del subsistema de comunicacion inal\u00e1mbrica (PHY, BB y RF) se desconectan para reducir el consumo energ\u00e9tico. Pese a permanecer desconectados, la estaci\u00f3n sigue conectada al AP en todo momento. El modo Modem-sleep soporta dos submodos de ahorro de consumo: m\u00ednimo y m\u00e1ximo . En el modo m\u00ednimo , la estaci\u00f3n se despierta cada DTIM para recibir un beacon. Debido a que los mensajes de difusi\u00f3n ( broadcast ) se transmiten tras cada DTIM, en este caso no se perder\u00e1n y ser\u00e1n recibidos por las estaciones. Sin embargo, el ahorro energ\u00e9tico puede ser reducido si el DTIM es breve (adem\u00e1s, DTIM est\u00e1 determinado por el AP, por lo que la estaci\u00f3n no tiene control sobre este par\u00e1metro). En el modo m\u00e1ximo , la estaci\u00f3n se despierta tras cada intervalo de escucha para recibir un beacon. Este intervalo de escucha no tiene que coincidir con el valor de DTIM , y de hecho suele fijarse a un valor mayor para conseguir mayor ahorro de consumo. Los datos de broadcast podr\u00edan perderse usando este modo si la estaci\u00f3n est\u00e1 en estado de reposo mientras expira el temporizador DTIM . El valor del intervalo de escucha puede configurarse mediante una invocaci\u00f3n a esp_wifi_set_config() antes de conectar al AP. Para activar el modo m\u00ednimo , es neceario invocar a la rutina esp_wifi_set_ps(WIFI_PS_MIN_MODEM) ; para activar el modo m\u00e1ximo , es neceario invocar a la rutina esp_wifi_set_ps(WIFI_PS_MAX_MODEM) , ambos tras la infocaci\u00f3n de esp_wifi_init() . Los modos de ahorro se activar\u00e1n al conectar al AP, y se desactivar\u00e1n al desconectar. Es posible desactivar los modos de ahorro mediante una invocaci\u00f3n a esp_wifi_set_ps(WIFI_PS_NONE) . Obviamente, esto aumentar\u00e1 el consumo, pero reducir\u00e1 la latencia en la recepci\u00f3n de mensajes. Con el modo de ahorro activado, la recepci\u00f3n de los mensajes se retrasar\u00e1 tanto como el per\u00edodo DTIM (en modo m\u00ednimo ahorro) o el per\u00edodo de escucha (modo m\u00e1ximo ahorro). El modo por defecto es WIFI_PS_MIN_MODEM . En modo punto de acceso, ESP-IDF no soporta todos los modos de ahorro dictados en la especificaci\u00f3n WiFi. Concretamente, un AP programado v\u00eda ESP-IDF s\u00f3lo cachear\u00e1 (almacenar\u00e1 temporalmente) los paquetes de tipo unicast para las estaciones conectadas a dicho AP, pero no paquetes multicast para dichas estacioens. As\u00ed, con el modo de ahorro activo, las estaciones podr\u00edan perder paquetes multicast . El ejemplo examples/wifi/power_save ilustra mediante un c\u00f3digo sencillo la configuraci\u00f3n de una estaci\u00f3n en los dos modos de ahorro energ\u00e9tico. Estos modos pueden configurarse a trav\u00e9s del men\u00fa de configuraci\u00f3n; adem\u00e1s, se ofrece una opci\u00f3n para modificar el tiempo de escucha en el caso del modo de ahorro m\u00e1ximo . Tarea entregable Compila, flashea y ejecuta el c\u00f3digo de ejemplo utilizando los tres modos disponibles (sin ahorro, con ahorro m\u00ednimo y con ahorro m\u00e1ximo). En el caso del ahorro m\u00e1ximo, var\u00eda el tiempo de escucha para que tome distintos valores. En todos los casos, conecta tu ESP32 a un punto de acceso y, desde un port\u00e1til conectado al mismo AP, ejecuta una serie de pings hacia la estaci\u00f3n. Para cada modo, representa gr\u00e1ficamente el tiempo de respuesta de la estaci\u00f3n en una gr\u00e1fica para cada petici\u00f3n ping , relacionando su comportamiento con los tiempos DTIM y de escucha.","title":"Pr\u00e1ctica 3"},{"location":"RPI-I/P3/#practica-3-wifi-conceptos-avanzados-wifi-mesh-provisionamiento-y-ahorro-de-energia","text":"","title":"Pr\u00e1ctica 3. WiFi. Conceptos avanzados (WiFi Mesh, provisionamiento y ahorro de energ\u00eda)"},{"location":"RPI-I/P3/#objetivos","text":"La presente pr\u00e1ctica se divide en tres partes principales, que abordan tres temas avanzados relacionados con la conectividad WiFi en ESP-IDF y en el ESP32. Los objetivos en cada punto son: WiFi MESH Revisar los conceptos b\u00e1sicos para la construcci\u00f3n de una red MESH WiFi autogestionada. Presentar la API b\u00e1sica para la creaci\u00f3n de aplicaciones basadas en la pila ESP-MESH. Observar en funcionamiento una red ESP-MESH, as\u00ed como sus capacidades de autoconfiguraci\u00f3n. Provisionamiento Entender y experimentar con distintos modos de provisionamiento de credenciales WiFi, v\u00eda BLE y v\u00eda softAP . Comprobar el intercambio de claves en claro realizando provisionamientos desde l\u00ednea de comandos, as\u00ed como observar la utilidad (y necesidad) del env\u00edo cifrado de credenciales. Ahorro de energ\u00eda Entender los tres modos de funcionamiento del ESP32 a nivel de ahorro energ\u00e9tico en conexiones WiFi. Observar la desviaci\u00f3n en latencia de recepci\u00f3n de paquetes en funci\u00f3n del modo aplicado.","title":"Objetivos"},{"location":"RPI-I/P3/#parte-1-wifi-mesh-esp-mesh","text":"El stack ESP-MESH est\u00e1 construido por encima del driver WiFi (es decir, obviamente hace uso de sus servicios), y en algunos casos tambi\u00e9n haciendo uso de servicios de la pila IP ( lwIP ), por ejemplo en el nodo ra\u00edz, que es el \u00fanico con comunicaci\u00f3n IP contra un router de borde. El siguiente diagrama muestra la situaci\u00f3n de la pila Mesh en ESP-IDF: Como cualquier otro componente ESP-IDF, ESP-MESH se comunica con las aplicaciones a trav\u00e9s de eventos propios: El tipo mesh_event_id_t define todos los posibles eventos que pueden surgir en las distintas fases del ciclo de vida de una red (por ejemplo, para un nodo determinado, conexi\u00f3n o desconexi\u00f3n de su nodo padre, o de uno de sus nodos hijo). Antes de utilizar los eventos ESP-MESH para gestionar u observar el funcionamiento de la red, es necesario registrarlos v\u00eda esp_event_handler_register() . Algunos usos t\u00edpicos de los eventos incluyen, por ejemplo, la situaci\u00f3n de conexi\u00f3n de un nodo padre ( MESH_EVENT_PARENT_CONNECTED ) o de un hijo ( MESH_EVENT_CHILD_CONNECTED ), indicando, respectivamente, que un nodo puede comenzar a emitir hacia arriba en el grafo, o hacia abajo. Del mismo modo, en un nodo ra\u00edz, la recepci\u00f3n de los eventos IP_EVENT_STA_GOT_IP y IP_EVENT_STA_LOST_IP se pueden aprovechar para indicar que dicho nodo ra\u00edz puede o no enviar datos a la red IP externa.","title":"Parte 1. WiFi Mesh (ESP MESH)"},{"location":"RPI-I/P3/#eventos","text":"MESH_EVENT_STARTED : mesh iniciada. MESH_EVENT_STOPPED : mesh finalizada. MESH_EVENT_CHANNEL_SWITCH : cambio de canal. MESH_EVENT_CHILD_CONNECTED : un hijo ha conectado a la interfaz softAP . MESH_EVENT_CHILD_DISCONNECTED : un hijo ha desconectado de la interfaz softAP . MESH_EVENT_ROUTING_TABLE_ADD : se han a\u00f1adido nuevas entradas a la tabla de enrutamiento a\u00f1adiendo nuevos hijos. MESH_EVENT_ROUTING_TABLE_REMOVE : se ha eliminado entradas de la tabla de enrutamiento eliminado hijos que han abandonado la red. MESH_EVENT_PARENT_CONNECTED : un padre se ha conectado a la interfaz station . MESH_EVENT_PARENT_DISCONNECTED : un padre se ha desconectado de la interfaz station . MESH_EVENT_NO_PARENT_FOUND : no se ha encontrado un padre. MESH_EVENT_LAYER_CHANGE : el nodo ha cambiado de nivel en la red. MESH_EVENT_TODS_STATE : indica que el nodo ra\u00edz es capaz de acceder a la red IP externa. MESH_EVENT_VOTE_STARTED : el proceso de voto de un nuevo nodo ra\u00edz ha comenzado. MESH_EVENT_VOTE_STOPPED : el proceo de voto de un nuevo nodo ra\u00edz ha finalizado. MESH_EVENT_ROOT_ADDRESS : se ha obtenido la direcci\u00f3n del nodo ra\u00edz. MESH_EVENT_ROOT_SWITCH_REQ : un nodo ra\u00edz candidato ya elegido solicita un cambio de nodo ra\u00edz. MESH_EVENT_ROOT_SWITCH_ACK : respuesta a la anterior petici\u00f3n por parte del nodo ra\u00edz actual. MESH_EVENT_NETWORK_STATE : la actual red tiene un nodo ra\u00edz. MESH_EVENT_STOP_RECONNECTION : el nodo ra\u00edz detiene el proceso de reconexi\u00f3n al router y los dem\u00e1s nodos detienen los procesos de conexi\u00f3n a sus nodos padre. MESH_EVENT_FIND_NETWORK : si el canal solicitado es 0, la pila escanear\u00e1 todos los canales para encontrar una red mesh a la que conectar, devolviendo el canal en el que lo ha conseguido.","title":"Eventos"},{"location":"RPI-I/P3/#uso-de-la-pila-ip","text":"El c\u00f3digo de una aplicaci\u00f3n que haga uso de ESP-MESH puede acceder directamente a la pila MESH sin pasar por la pila IP. De hecho, la pila IP s\u00f3lo es estrictamente necesaria por parte del nodo ra\u00edz, al ser el \u00fanico que puede recibir o transmitir datos desde o hacia la red IP externa. Sin embargo, como cualquier nodo de la topolog\u00eda puede potencialmente convertirse en nodo ra\u00edz (ya que su selecci\u00f3n es autom\u00e1tica), todos los nodos deber\u00e1n inicializar la pila IP. Por tanto, todos los nodos incializan la pila IP v\u00eda tcpip_adapter_init() . Adem\u00e1s, todos los nodos deber\u00e1n detener el servidor DHCP en la interfaz softAP , y el cliente DHCP en la interfaz station : /* tcpip initialization */ tcpip_adapter_init(); /* * for mesh * stop DHCP server on softAP interface by default * stop DHCP client on station interface by default */ ESP_ERROR_CHECK(tcpip_adapter_dhcps_stop(TCPIP_ADAPTER_IF_AP)); ESP_ERROR_CHECK(tcpip_adapter_dhcpc_stop(TCPIP_ADAPTER_IF_STA)); Sin embargo, en el caso de un nodo que se convierte en ra\u00edz, es imprescindible arrancar el cliente DHCP como respuesta al evento corresondiente para as\u00ed obtener direcci\u00f3n IP desde el router que da salida hacia la red externa.","title":"Uso de la pila IP"},{"location":"RPI-I/P3/#estructura-basica-de-una-aplicacion-esp-mesh","text":"El siguiente c\u00f3digo muestra la estructura b\u00e1sica de inicializaci\u00f3n de pilas IP y WiFi necesarias para comenzar con la configuraci\u00f3n de la red MESH: tcpip_adapter_init(); /* * for mesh * stop DHCP server on softAP interface by default * stop DHCP client on station interface by default */ ESP_ERROR_CHECK(tcpip_adapter_dhcps_stop(TCPIP_ADAPTER_IF_AP)); ESP_ERROR_CHECK(tcpip_adapter_dhcpc_stop(TCPIP_ADAPTER_IF_STA)); /* event initialization */ ESP_ERROR_CHECK(esp_event_loop_create_default()); /* Wi-Fi initialization */ wifi_init_config_t config = WIFI_INIT_CONFIG_DEFAULT(); ESP_ERROR_CHECK(esp_wifi_init(&config)); /* register IP events handler */ ESP_ERROR_CHECK(esp_event_handler_register(IP_EVENT, IP_EVENT_STA_GOT_IP, &ip_event_handler, NULL)); ESP_ERROR_CHECK(esp_wifi_set_storage(WIFI_STORAGE_FLASH)); ESP_ERROR_CHECK(esp_wifi_start()); Tras esta inicializaci\u00f3n, comienza la fase de configuraci\u00f3n e inicializaci\u00f3n de la malla, que proceder\u00e1 en tres pasos principales: Inicializaci\u00f3n de la malla Configuraci\u00f3n de la red ESP-MESH Arranque de la red","title":"Estructura b\u00e1sica de una aplicaci\u00f3n ESP-MESH"},{"location":"RPI-I/P3/#paso-1-inicializacion-de-la-malla","text":"La inicializaci\u00f3n de la malla y registro de eventos propios es sencilla: /* mesh initialization */ ESP_ERROR_CHECK(esp_mesh_init()); /* register mesh events handler */ ESP_ERROR_CHECK(esp_event_handler_register(MESH_EVENT, ESP_EVENT_ANY_ID, &mesh_event_handler, NULL));","title":"Paso 1. Inicializaci\u00f3n de la malla"},{"location":"RPI-I/P3/#paso-2-configuracion-de-la-red-esp-mesh","text":"La configuraci\u00f3n de ESP-MESH se realiza a trav\u00e9s de la funci\u00f3n esp_mesh_set_config() , que recibe una estructura de tipo mesh_cfg_t con la configuraci\u00f3n de la red: Par\u00e1metro Descripci\u00f3n Channel Canal (entre 1 y 14) Mesh ID Identificaci\u00f3n de la red MESH (6 bytes) Router SSID y contrase\u00f1a de conexi\u00f3n al router de salida Mesh AP Configuraci\u00f3n espec\u00edfica del AP generado por cada nodo Un ejemplo de configuraci\u00f3n podr\u00eda ser: /* Mesh ID */ static const uint8_t MESH_ID = { 0x77, 0x77, 0x77, 0x77, 0x77, 0x77 }; /* Enable the Mesh IE encryption by default */ mesh_cfg_t cfg = MESH_INIT_CONFIG_DEFAULT(); /* mesh ID */ memcpy((uint8_t *) &cfg.mesh_id, MESH_ID, 6); /* channel (must match the router's channel) */ cfg.channel = CONFIG_MESH_CHANNEL; /* router */ cfg.router.ssid_len = strlen(CONFIG_MESH_ROUTER_SSID); memcpy((uint8_t *) &cfg.router.ssid, CONFIG_MESH_ROUTER_SSID, cfg.router.ssid_len); memcpy((uint8_t *) &cfg.router.password, CONFIG_MESH_ROUTER_PASSWD, strlen(CONFIG_MESH_ROUTER_PASSWD)); /* mesh softAP */ cfg.mesh_ap.max_connection = CONFIG_MESH_AP_CONNECTIONS; memcpy((uint8_t *) &cfg.mesh_ap.password, CONFIG_MESH_AP_PASSWD, strlen(CONFIG_MESH_AP_PASSWD)); ESP_ERROR_CHECK(esp_mesh_set_config(&cfg));","title":"Paso 2. Configuraci\u00f3n de la red ESP-MESH"},{"location":"RPI-I/P3/#paso-3-arranque-de-la-red","text":"El arranque de la red MESH es sencillo: /* mesh start */ ESP_ERROR_CHECK(esp_mesh_start()); Tras el arranque, la aplicaci\u00f3n deber\u00eda comprobar los eventos para determinar si la conexi\u00f3n a la red ha sido exitosa. En dicho caso, tras la conexi\u00f3n, la aplicaci\u00f3n puede comenzar a transmitir paquetes a trav\u00e9s de la red MESH utilizando las rutinas esp_mesh_send() y esp_mesh_recv() .","title":"Paso 3. Arranque de la red"},{"location":"RPI-I/P3/#ejercicio-en-clase-despliegue-conjunto-de-una-red-wifi-mesh","text":"La forma m\u00e1s conveniente de observar el comportamiento de una red WiFi Mesh es desplegar una infraestructura con suficiente n\u00famero de nodos pertenecientes a una misma red. Desafortunadamente, para ello es necesario disponer de dichos nodos en un espacio cercano. En la presente pr\u00e1ctica, desplegaremos una red WiFi Mesh en el laboratorio, utilizando vuestro o vuestros ESP32 como elementos de la red. Para ello, configuraremos, compilaremos y ejecutaremos el ejemplo examples/mesh/internal_communication . Antes de proceder, configuraremos el proyecto para: Conectar al punto de acceso com\u00fan del laboratorio ( Router SSID y Router password ). Configurar la red ESP-MESH para utilizar WPA2_PSK y seleccionar como contrase\u00f1a password . Aumentar el n\u00famero de conexiones al AP a 10. De momento, no realizaremos ning\u00fan cambio en el c\u00f3digo del ejemplo. Compila y ejecuta tu c\u00f3digo. En la direcci\u00f3n del enlace dispones de una primera pesta\u00f1a en la que deber\u00e1s completar cierta informaci\u00f3n que observar\u00e1s en la salida de monitorizaci\u00f3n una vez arranques el ESP32, en la celda correspondiente a tu puesto. Esta informaci\u00f3n, en principio, incluye: Tu nombre. Direcciones MAC de las interfaces STA y SoftAP (lo observar\u00e1s en los primeros mensajes de salida). Capa de la topolog\u00eda en la que se encuentra tu nodo (lo observar\u00e1s en formato [L:XX] en los env\u00edos y recepciones de datos). En caso de haber sido elegido nodo ra\u00edz, anotar tambi\u00e9n esta circunstancia y la IP asignada por el router (observa la respuesta al evento correspondiente). Adem\u00e1s, anota la ID de la red Mesh que se ha utilizado para conectar. Antes de rellenar la informaci\u00f3n, espera que el profesor te indique que la topolog\u00eda ha convergido, y que por tanto no habr\u00e1 ning\u00fan cambio m\u00e1s en ella (siempre que ningun nodo deje de formar parte de la misma). Ejercicio entregable Captura el estado de la red cuando todos tus compa\u00f1eros hayan llegado al punto de convergencia, e intenta determinar, en forma de grafo, la topolog\u00eda de la misma. A continuaci\u00f3n, apagaremos el nodo ra\u00edz y esperaremos a la vuelta a la convergencia de la red. Ejercicio entregable Captura de nuevo el estado de la red cuando todos tus compa\u00f1eros hayan llegado al punto de convergencia, e intenta determinar, en forma de grafo, la topolog\u00eda de la misma. Como \u00faltimo ejercicio, vamos a crear nuevas redes Mesh en funci\u00f3n del puesto que tengas asignado. Observa los colores asignados a cada grupo de puestos en la siguiente hoja .","title":"Ejercicio en clase. Despliegue conjunto de una red WiFi Mesh"},{"location":"RPI-I/P3/#ejercicio-en-clase-despliegue-conjunto-de-una-red-wifi-mesh-de-menores-dimensiones","text":"Modifica tu c\u00f3digo para que el canal de escucha y el identificador de red coincidan con el indicado. Puedes configurar el canal a trav\u00e9s del men\u00fa de configuracion del ejemplo ( channel ) y el identificador modificando la variable correspondiente en el fichero mesh_main.c . Una vez hecho esto, reconstruid la informaci\u00f3n de las tablas para reflejar las nuevas topolog\u00edas. Pod\u00e9is hacer pruebas posteriores apagando el nodo ra\u00edz y observando la convergencia de la red. Ejercicio entregable Captura de nuevo el estado de la red cuando todos tus compa\u00f1eros hayan llegado al punto de convergencia, e intenta determinar, en forma de grafo, la topolog\u00eda de la misma. El estudio detallado del c\u00f3digo para el despliegue de la red queda como ejercicio para el alumno. Observa el tratamiento de eventos y la fase de configuraci\u00f3n de la red. Intenta entender el funcionamiento del c\u00f3digo (env\u00edos y recepciones, destinatarios de los mismos, etc.).","title":"Ejercicio en clase. Despliegue conjunto de una red WiFi Mesh de menores dimensiones"},{"location":"RPI-I/P3/#parte-2provisionamiento-wifi","text":"ESP-IDF proporciona un componente espec\u00edfico que ofrece un servicio de provisionamiento WiFi. Entendemos por provisionamiento WiFi el mecanismo o mecanismos mediante los cuales es posible proporcionar, de forma externa y segura, el conjunto de credenciales de conexi\u00f3n a una red WiFi a un dispositivo no conectado. El component de provisionamiento WiFi en ESP-IDF permite proporcionar dichas credenciales a trav\u00e9s de dos v\u00edas: Bluetooth Low Energy (modo BLE ) o a trav\u00e9s de un mecanismo de punto de acceso WiFi temporal (modo SoftAP ). ESP-IDF proporciona una serie de APIs (con prototipos wifi_prov_mgr_* ) para implementar de forma sencilla ambos modos de provisionamiento. Para completar esta parte de la pr\u00e1ctica deber\u00e1s trabajar con los ejemplos examples/provisioning/softap_prov (para la versi\u00f3n de provisionamiento v\u00eda WiFi) y examples/provisioning/ble_prov (para la versi\u00f3n de provisionamiento via Bluetooth Low Energy).","title":"Parte 2.Provisionamiento WiFi"},{"location":"RPI-I/P3/#inicializacion-del-servicio-de-provisionamiento","text":"La rutina wifi_prov_mgr_init() se utiliza para configurar e inicializar el componente de provisionamiento, y debe invocarse antes de cualquier otra invocaci\u00f3n a rutinas de tipo wifi_prov_mgr* . Adem\u00e1s, es necesario destacar que el componente de provisionamiento conf\u00eda en las funcionalidades de otros componentes (b\u00e1sicamente NVS, TCP/IP, Event loop y mDNS), por lo que \u00e9stos deben inicializarse antes del propio componente. Para finalizar el componente de provisionamiento, es suficiente con invocar a la rutina wifi_prov_mgr_deinit() . Un ejemplo de inicializaci\u00f3n resultar\u00eda en: wifi_prov_mgr_config_t config = { .scheme = wifi_prov_scheme_ble, .scheme_event_handler = WIFI_PROV_SCHEME_BLE_EVENT_HANDLER_FREE_BTDM }; ESP_ERR_CHECK( wifi_prov_mgr_init(config) ); La estructura de configuraci\u00f3n de tipo wifi_prov_mgr_config_t dispone de campos que permiten especificar el comportamiento del componente; espec\u00edficamente, el campo scheme especifica el esquema (o tipo) de provisionamiento. Disponemos de tres opciones: wifi_prov_scheme_softap : transporta la informaci\u00f3n de provisionamiento v\u00eda WiFi (creando un punto de acceso temporal) y un servidor HTTP para recibir los comandos e informaci\u00f3n de provisionamiento. wifi_prov_scheme_ble : transporta la informaci\u00f3n de provisionamiento v\u00eda Bluetooth Low Energy (BLE) y un servidor GATT para recibir los comandos e informaci\u00f3n de provisionamiento. wifi_prov_scheme_console : transporta la informaci\u00f3n v\u00eda puerto serie y","title":"Inicializaci\u00f3n del servicio de provisionamiento"},{"location":"RPI-I/P3/#comprobacion-del-estado-de-provisionamiento","text":"Es posible comprobar el estado de provisionamiento de un dispositivo mediante una invocaci\u00f3n a wifi_prov_mgr_is_provisioned() , que chequea si las credenciales de conexi\u00f3n WiFi est\u00e1n almacenadas en la memoria no vol\u00e1til (NVS). Aunque existen distintos m\u00e9todos para eliminar la informaci\u00f3n de provisionamento almacenada en la NVS, utilizaremos el mecanismo proporcionado por idf.py para eliminar su contenido. Para ello, ejecutaremos: idf.py erase_flash","title":"Comprobaci\u00f3n del estado de provisionamiento"},{"location":"RPI-I/P3/#parametros-de-inicializacion-del-servicio-de-provisionamiento-wifi","text":"Al inicializar el componente de provisionamiento, es necesario especificar un nombre de servicio y una clave. Esto se traduce en: SSID y contrase\u00f1a para el modo SoftAP (es decir, cuando el esquema de provisionamiento se ha configurado como wifi_prov_scheme_softap ). Nombre del dispositivo BLE para el modo BLE (es decir, cuando el esquema de provisionamiento se ha configurado como wifi_prov_scheme_ble ). Adem\u00e1s, internamente el componente utiliza el mecanismo de comunicaci\u00f3n protocomm , que permite dos niveles de seguridad en la comunicaci\u00f3n de credenciales de provisionamiento: Nivel 1 de seguridad, que consiste en un handshake previo entre ambos extremos, con intercambio de claves y utilizaci\u00f3n de una prueba de posesi\u00f3n (PoP, proof of possession ), y utilizando encriptaci\u00f3n AES para el intercambio de mensajes. Nivel 0 de seguridad, que consiste en un intercambio de credenciales utilizando texto plano y sin PoP . As\u00ed, un ejemplo de inicializaci\u00f3n del servicio de provisionamiento podr\u00eda resultar en el siguiente c\u00f3digo: const char *service_name = \"my_device\"; const char *service_key = \"password\"; wifi_prov_security_t security = WIFI_PROV_SECURITY_1; const char *pop = \"abcd1234\"; ESP_ERR_CHECK( wifi_prov_mgr_start_provisioning(security, pop, service_name, service_key) ); El servicio de provisionamiento finalizar\u00e1 autom\u00e1ticamente al conectar a un AP con \u00e9xito (es decir, al obtener IP desde el mismo). En cualquier caso, puede tambi\u00e9n detenerse de forma manual en cualquier momento a trav\u00e9s de la invocaci\u00f3n a wifi_prov_mgr_stop_provisioning() .","title":"Par\u00e1metros de inicializaci\u00f3n del servicio de provisionamiento WiFi"},{"location":"RPI-I/P3/#espera-a-la-finalizacion-del-proceso-de-provisionamiento","text":"T\u00edpicamente, las aplicaciones de usuario en el ESP32 deber\u00e1n esperar a que el proceso de provisionamiento finalice antes de proceder. En ese momento, y antes de proceder, liberar\u00e1n los recursos que se alojaron para el proceso de provisionamiento, y comenzar\u00e1n con su l\u00f3gica habitual. Existen dos mecanismos para conseguir este efecto: En primer lugar, la soluci\u00f3n m\u00e1s simple consiste en utilizar una invocaci\u00f3n bloqueante a la rutina wifi_prov_mgr_wait() : // Inicializaci\u00f3n del servicio de provisionamiento ESP_ERR_CHECK( wifi_prov_mgr_start_provisioning(security, pop, service_name, service_key) ); // Espera a la compleci\u00f3n del provisionamiento wifi_prov_mgr_wait(); // Liberaci\u00f3n de recursos wifi_prov_mgr_deinit(); // A partir de aqu\u00ed, comenzar\u00eda la l\u00f3gica habitual de la aplicaci\u00f3n // ... El segundo mecanismo estar\u00eda basado en eventos (es decir, ser\u00eda no bloqueante ), interceptando y trabajando sobre eventos de tipo WIFI_PROV_EVENT e invocando a wifi_prov_mgr_deinit() cuando el identificador de evento sea WIFI_PROV_END : static void event_handler(void* arg, esp_event_base_t event_base, int event_id, void* event_data) { if (event_base == WIFI_PROV_EVENT && event_id == WIFI_PROV_END) { /* Liberar recursos una vez el proceso de provisionamiento ha finalizado */ wifi_prov_mgr_deinit(); } }","title":"Espera a la finalizaci\u00f3n del proceso de provisionamiento"},{"location":"RPI-I/P3/#herramientas-de-provisionamiento-para-dispositivos-moviles","text":"Existen aplicaciones preparadas por Espressif para llevar a cabo el proceso de provisionamiento sobre ESP32. Estas aplicaciones est\u00e1n disponibles tanto para dispositivos Android como IOS, en las versiones con transporte BLE o SoftAP: Android: Provisionamiento BLE . Provisionamiento SoftAP . IOS: Provisionamiento BLE . Provisionamiento SoftAP . Tarea entregable Utilizando las aplicaciones correspondientes a tu dispositivo m\u00f3vil, tanto para el uso de BLE como de SoftAP, provisiona tu ESP32 utilizando las credenciales que correspondan a tu red WiFi. Entrega una breve descripci\u00f3n del proceso desarrollado, as\u00ed como capturas de pantalla correspondientes a la salida del ESP32 que evidencien que el proceso de provisionamiento se ha realizado correctamente. Recuerda, antes de cada repetici\u00f3n del experimento, utilizar la orden idf.py erase_flash para eliminar informaci\u00f3n de provisionamiento de sesiones anteriores. Comprueba el funcionamiento de los distintos niveles de seguridad. Estas aplicaciones funcionan mediante una comunicaci\u00f3n muy sencilla con el ESP32 no provisionado, cuyos mecanismos dependen del transporte utilizado; en el caso de BLE, se crea una tabla GATT con distintas caracter\u00edsticas que ser\u00e1n utilizadas para escribir (enviar) datos en el dispositivo. Veremos qu\u00e9 es una tabla GATT en pr\u00f3ximas pr\u00e1cticas, por lo que retornaremos a este punto. En el caso de softAP , se crean una serie de endpoints (URIs HTTP) que permiten, de forma sencilla, leer y escribir aquellos datos que deseamos comunicar al otro extremo de la comunicaci\u00f3n. La siguiente tabla resume los endpoints creados por las versiones est\u00e1ndar del protocolo de provisionamiento (pueden ser modificados o adaptados en funci\u00f3n de la informaci\u00f3n adicional que deseemos intercambiar): Endpoint (BLE + Servidor GATT) URI (SoftAP + HTTP) Establecimiento de sesi\u00f3n prov-session http://IP:80/prov-session Escaneo de redes disponibles prov-scan http://IP:80/prov-scan Configuraci\u00f3n de provisionamiento prov-config http://IP:80/prov-config Versi\u00f3n del protocolo proto-ver http://IP:80/proto-ver Los detalles de este tipo de protocolo de provisionamiento quedan como ejercicio adicional al alumno, y van m\u00e1s all\u00e1 del objetivo de la pr\u00e1ctica. Sin embargo, s\u00ed es conveniente disponer de alg\u00fan mecanismo que permita observarlos, y determinar, por ejemplo para el caso de SoftAP, si el intercambio de credenciales se realiza como texto plano (en claro) o cifrado, lo cu\u00e1l podr\u00eda suponer serios problemas de seguridad para el usuario de un dispositivo m\u00f3vil, ya que se expondr\u00edan las credenciales de conexi\u00f3n a la red WiFi. Para estudiar este hecho, utilizaremos una herramienta de l\u00ednea de \u00f3rdenes proporcionada junto a ESP-IDF, llamada esp_prov.py , situada en el directorio tools/esp_prov de la instalaci\u00f3n. Nota Antes de utilizar el programa, debes instalar las dependencias respectivas utilizando las \u00f3rdenes (desde el propio directorio tools/esp_prov ): pip install -r requirements.txt pip install -r requirements_linux_extra.txt Su uso es sencillo, y puede consultarse ejecutando python esp_prov.py -h . B\u00e1sicamente, una sesi\u00f3n de provisionamiento utilizando softAP sobre un dispositivo a la espera con IP 192.168.4.1 , sin capa de seguridad (cifrado) y proporcionando la SSID y clave SSID_EJEMPLO/CLAVE_EJEMPLO resultar\u00eda: python esp_prov.py --transport softap --service_name \"192.168.4.1:80\" --sec_ver 0 --ssid SSID_EJEMPLO --passphrase CLAVE_EJEMPLO Ten en cuenta que, para emitir el anterior comando, debes pertenecer a la misma red que el dispositivo a provisionar, es decir, haber conectado al SSID de provisionamiento que se proporciona. Tarea entregable Realiza el proceso de provisionamiento desde l\u00ednea de comandos utilizando las anteriores indicaciones, y muestra capturas de tr\u00e1fico v\u00eda Wireshark donde se evidencie la entrega en claro (en modo texto, sin cifrar) de las credenciales de red entre el provisionador y el dispositivo, y el uso de los endpoints/URIs anteriormente mencionados. A continuaci\u00f3n, pasa a un modo seguro (opci\u00f3n --sec_ver 1 ) y observa c\u00f3mo las claves se intercambian cifradas.","title":"Herramientas de provisionamiento para dispositivos m\u00f3viles"},{"location":"RPI-I/P3/#parte-3-modos-de-ahorro-de-consumo-wifi","text":"En la versi\u00f3n actual de ESP-IDF, el framework soporta distintos modos de ahorro de energ\u00eda, con soporte tanto a nivel de dispositivo ( station ) como de punto de acceso ( AP ). Todos estos modos se basan en las caracter\u00edsticas de ahorro de consumo contempladas en el est\u00e1ndar 802.11 (concretamente en el modo Modem-sleep ). El modo Modem-sleep trabaja exclusivamente cuando un dispositivo est\u00e1 configurado como station , y se encuentra conectado a un AP. Si el modo Modem-sleep est\u00e1 activo, el dispositivo var\u00eda su estado entre activo y sleep peri\u00f3dicamente. En el modo sleep , tres de los principales componentes del subsistema de comunicacion inal\u00e1mbrica (PHY, BB y RF) se desconectan para reducir el consumo energ\u00e9tico. Pese a permanecer desconectados, la estaci\u00f3n sigue conectada al AP en todo momento. El modo Modem-sleep soporta dos submodos de ahorro de consumo: m\u00ednimo y m\u00e1ximo . En el modo m\u00ednimo , la estaci\u00f3n se despierta cada DTIM para recibir un beacon. Debido a que los mensajes de difusi\u00f3n ( broadcast ) se transmiten tras cada DTIM, en este caso no se perder\u00e1n y ser\u00e1n recibidos por las estaciones. Sin embargo, el ahorro energ\u00e9tico puede ser reducido si el DTIM es breve (adem\u00e1s, DTIM est\u00e1 determinado por el AP, por lo que la estaci\u00f3n no tiene control sobre este par\u00e1metro). En el modo m\u00e1ximo , la estaci\u00f3n se despierta tras cada intervalo de escucha para recibir un beacon. Este intervalo de escucha no tiene que coincidir con el valor de DTIM , y de hecho suele fijarse a un valor mayor para conseguir mayor ahorro de consumo. Los datos de broadcast podr\u00edan perderse usando este modo si la estaci\u00f3n est\u00e1 en estado de reposo mientras expira el temporizador DTIM . El valor del intervalo de escucha puede configurarse mediante una invocaci\u00f3n a esp_wifi_set_config() antes de conectar al AP. Para activar el modo m\u00ednimo , es neceario invocar a la rutina esp_wifi_set_ps(WIFI_PS_MIN_MODEM) ; para activar el modo m\u00e1ximo , es neceario invocar a la rutina esp_wifi_set_ps(WIFI_PS_MAX_MODEM) , ambos tras la infocaci\u00f3n de esp_wifi_init() . Los modos de ahorro se activar\u00e1n al conectar al AP, y se desactivar\u00e1n al desconectar. Es posible desactivar los modos de ahorro mediante una invocaci\u00f3n a esp_wifi_set_ps(WIFI_PS_NONE) . Obviamente, esto aumentar\u00e1 el consumo, pero reducir\u00e1 la latencia en la recepci\u00f3n de mensajes. Con el modo de ahorro activado, la recepci\u00f3n de los mensajes se retrasar\u00e1 tanto como el per\u00edodo DTIM (en modo m\u00ednimo ahorro) o el per\u00edodo de escucha (modo m\u00e1ximo ahorro). El modo por defecto es WIFI_PS_MIN_MODEM . En modo punto de acceso, ESP-IDF no soporta todos los modos de ahorro dictados en la especificaci\u00f3n WiFi. Concretamente, un AP programado v\u00eda ESP-IDF s\u00f3lo cachear\u00e1 (almacenar\u00e1 temporalmente) los paquetes de tipo unicast para las estaciones conectadas a dicho AP, pero no paquetes multicast para dichas estacioens. As\u00ed, con el modo de ahorro activo, las estaciones podr\u00edan perder paquetes multicast . El ejemplo examples/wifi/power_save ilustra mediante un c\u00f3digo sencillo la configuraci\u00f3n de una estaci\u00f3n en los dos modos de ahorro energ\u00e9tico. Estos modos pueden configurarse a trav\u00e9s del men\u00fa de configuraci\u00f3n; adem\u00e1s, se ofrece una opci\u00f3n para modificar el tiempo de escucha en el caso del modo de ahorro m\u00e1ximo . Tarea entregable Compila, flashea y ejecuta el c\u00f3digo de ejemplo utilizando los tres modos disponibles (sin ahorro, con ahorro m\u00ednimo y con ahorro m\u00e1ximo). En el caso del ahorro m\u00e1ximo, var\u00eda el tiempo de escucha para que tome distintos valores. En todos los casos, conecta tu ESP32 a un punto de acceso y, desde un port\u00e1til conectado al mismo AP, ejecuta una serie de pings hacia la estaci\u00f3n. Para cada modo, representa gr\u00e1ficamente el tiempo de respuesta de la estaci\u00f3n en una gr\u00e1fica para cada petici\u00f3n ping , relacionando su comportamiento con los tiempos DTIM y de escucha.","title":"Parte 3. Modos de ahorro de consumo WiFi"},{"location":"RPI-I/P4/","text":"Pr\u00e1ctica 4. Bluetooth Low Energy (BLE) Objetivos Diseccionar en detalle un firmware de construcci\u00f3n de tabla GATT (servidor GATT) utilizando la API de ESP-IDF. Aprender a utilizar la herramienta gatttool para interactuar con el servidor GATT. Modificar el servidor GATT para que acepte peticiones de notificaci\u00f3n por parte del cliente, y para que publique bajo demanda valores actualizados para una determinada caracter\u00edstica. Implementaci\u00f3n de un servidor GATT basado en tablas Introducci\u00f3n En esta pr\u00e1ctica, desplegaremos un servidor GATT utilizando la API de ESP-IDF para tal fin. Dicha API expone las funcionalidades de Bluedroid, la pila Bluetooth (incluyendo BLE) que proporciona ESP-IDF para el desarrollo de aplicaciones Bluetooth. El ejemplo con el que trabajaremos reside en el directorio examples/bluetooth/bluedroid/ble/gatt_server_service_table . Debido a la complejidad del ejemplo (al menos en su parte inicial), la presente pr\u00e1ctica procede, en primer lugar, con un recorrido por la preparaci\u00f3n y construcci\u00f3n del servidor siguiendo una estructura de tabla que define los servicios y caracter\u00edsticas que se implementar\u00e1n en el mismo. El ejemplo implementa el perfile Heart Rate Profile definido en la especificaci\u00f3n Bluetooth , y sigue la siguiente estructura: Desplegaremos, por tanto, tres caracter\u00edsticas. De ellas, la m\u00e1s importante para nosotros ser\u00e1 el valor de medici\u00f3n de ritmo cardiaco, con su valor ( Heart Rate Measurement Value ) y su configuraci\u00f3n de notificaciones ( Heart Rate Measurement Notification Configuration ). Inclusi\u00f3n de encabezados Los siguientes ficheros de cabecera son necesarios para dotar de funcionalidad BLE a nuestro firmware : #include \"freertos/FreeRTOS.h\" #include \"freertos/task.h\" #include \"freertos/event_groups.h\" #include \"esp_system.h\" #include \"esp_log.h\" #include \"nvs_flash.h\" #include \"bt.h\" #include \"bta_api.h\" #include \"esp_gap_ble_api.h\" #include \"esp_gatts_api.h\" #include \"esp_bt_defs.h\" #include \"esp_bt_main.h\" #include \"esp_bt_main.h\" #include \u201cgatts_table_creat_demo.h\" Estos encabezados son necesarios para un correcto funcionamiento de FreeRTOS y de sus componentes, incluyendo funcionalidad relativa a logging y almacenamiento no vol\u00e1til. Son especialmente interesantes los ficheros bt.h , esp_bt_main.h , esp_gap_ble_api.h y esp_gatts_api.h , ya que exponen la API BLE necesaria para la implementaci\u00f3n del firmware : bt.h : implementa el controlador Bluetooth. esp_bt_main.h : implementa las rutinas de inicializaci\u00f3n y activaci\u00f3n de la pila Bluedroid. esp_gap_ble_api.h : implementa la configuraci\u00f3n GAP (par\u00e1metros de anuncios y conexi\u00f3n). esp_gatts_api.h : immplementa la configuraci\u00f3n del servidor GATT (por ejemplo, la creaci\u00f3n de servicios y caracter\u00edsticas). La tabla de servicios El fichero de encabezado gatts_table_creat_demo.h contiene una enumeraci\u00f3n de los servicios y caracter\u00edsticas deseadas: enum { HRS_IDX_SVC, HRS_IDX_HR_MEAS_CHAR, HRS_IDX_HR_MEAS_VAL, HRS_IDX_HR_MEAS_NTF_CFG, HRS_IDX_BOBY_SENSOR_LOC_CHAR, HRS_IDX_BOBY_SENSOR_LOC_VAL, HRS_IDX_HR_CTNL_PT_CHAR, HRS_IDX_HR_CTNL_PT_VAL, HRS_IDX_NB, }; Los elementos de la anterior estructura se han incluido en el mismo orden que los atributos del Heart Rate Profile , comenzando con el servicio, seguido por las caracter\u00edsticas del mismo. Adem\u00e1s, la caracter\u00edstica Heart Rate Measurement dispone de configuraci\u00f3n propia ( Client Characteristic Configuration , o CCC), un descriptor que describe si la caracter\u00edstica tiene las notificaciones activas . Todos estos \u00edndices pueden utilizarse para identificar a cada elemento a la hora de crear la tabla de atributos: HRS_IDX_SVC : \u00edndice del servicio Heart Rate. HRS_IDX_HR_MEAS_CHAR : \u00edndice de la caracter\u00edstica Heart Rate Measurement. HRS_IDX_HR_MEAS_VAL : \u00edndice del valor Heart Rate Measurement. HRS_IDX_HR_MEAS_NTF_CFG : \u00edndice de la configuraci\u00f3n de notificaciones (CCC) Heart Rate Measurement. HRS_IDX_BOBY_SENSOR_LOC_CHAR : \u00edndice de la caracter\u00edstica Heart Rate Body Sensor Location. HRS_IDX_BOBY_SENSOR_LOC_VAL : \u00edndice del valor Heart Rate Body Sensor Location. HRS_IDX_HR_CTNL_PT_CHAR : \u00edndice de la caracter\u00edstica Heart Rate Control Point. HRS_IDX_HR_CTNL_PT_VAL : \u00edndice del valor Heart Rate Control Point. HRS_IDX_NB : n\u00famero de elementos d ela tabla. Punto de entrada El punto de entrada de la aplicaci\u00f3n ( app_main() ) se implementa como sigue: void app_main() { esp_err_t ret; // Initialize NVS. ret = nvs_flash_init(); if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) { ESP_ERROR_CHECK(nvs_flash_erase()); ret = nvs_flash_init(); } ESP_ERROR_CHECK( ret ); esp_bt_controller_config_t bt_cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT(); ret = esp_bt_controller_init(&bt_cfg); if (ret) { ESP_LOGE(GATTS_TABLE_TAG, \"%s enable controller failed\\n\", __func__); return; } ret = esp_bt_controller_enable(ESP_BT_MODE_BLE); if (ret) { ESP_LOGE(GATTS_TABLE_TAG, \"%s enable controller failed\\n\", __func__); return; } ESP_LOGI(GATTS_TABLE_TAG, \"%s init bluetooth\\n\", __func__); ret = esp_bluedroid_init(); if (ret) { ESP_LOGE(GATTS_TABLE_TAG, \"%s init bluetooth failed\\n\", __func__); return; } ret = esp_bluedroid_enable(); if (ret) { ESP_LOGE(GATTS_TABLE_TAG, \"%s enable bluetooth failed\\n\", __func__); return; } esp_ble_gatts_register_callback(gatts_event_handler); esp_ble_gap_register_callback(gap_event_handler); esp_ble_gatts_app_register(ESP_HEART_RATE_APP_ID); return; } La funci\u00f3n principal procede incializando el almacenamiento no vol\u00e1til, para almacenar los par\u00e1metros necesarios en memoria flash : ret = nvs_flash_init(); Inicializaci\u00f3n del controlador y de la pila Bluetooth La funci\u00f3n principal inicializa tambi\u00e9n el controlador Bluetooth, creando en primer lugar una estructura de configuraci\u00f3n para tal fin de tipo esp_bt_controller_config_t con valores por defecto dictados por la macro BT_CONTROLLER_INIT_CONFIG_DEFAULT() . El controlador Bluetooth implementa el Host Controller Interface (HCI), la capa de enlace y la capa f\u00edsica BLE; es, por tanto, transparente para el programador. La configuraci\u00f3n incluye el tama\u00f1o de pila reservado al controlador, prioridad y baudios para la transmisi\u00f3n. Con estas configuraciones, el controlador puede ser inicializado y activado con la funci\u00f3n esp_bt_controller_init() : esp_bt_controller_config_t bt_cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT(); ret = esp_bt_controller_init(&bt_cfg); A continuaci\u00f3n, el controlador activa el modo BLE: ret = esp_bt_controller_enable(ESP_BT_MODE_BLE); Existen cuatro modos de funcioinamiento Bluetooth: ESP_BT_MODE_IDLE : Bluetooth no funcional ESP_BT_MODE_BLE : Modo BLE ESP_BT_MODE_CLASSIC_BT : Modo BT Cl\u00e1sico ESP_BT_MODE_BTDM : Modo Dual (BLE + BT Cl\u00e1sico) Tras la incializaci\u00f3n del controlador Bluetooth, la pila Bluedroid (que incluye APIs tanto para BLE como para Bluetooth Cl\u00e1sico) debe ser inicializada y activada: ret = esp_bluedroid_init(); ret = esp_bluedroid_enable(); La pila Bluetooth est\u00e1, a partir de este punto, lista para funcionar, pero todav\u00eda no se ha implementado ninguna l\u00f3gica de aplicaci\u00f3n. Dicha funcionalidad se define con el cl\u00e1sico mecanismo basado en eventos, que pueden ser emitidos, por ejemplo, cuando otro dispositivo intenta leer o escribir par\u00e1metros, o establecer una conexi\u00f3n. Existen dos gestores de eventos relacionados con BLE: los manejadores ( handlers ) GAP y GATT. La aplicaci\u00f3n necesita registrar una funci\u00f3n de callback para cada manejador, para permitir a la aplicaci\u00f3n conocer qu\u00e9 funciones se invocar\u00e1n eventos de tipo GAP y GATT: esp_ble_gatts_register_callback(gatts_event_handler); esp_ble_gap_register_callback(gap_event_handler); Las funciones gatts_event_handler() y gap_event_handler() manejan todos los eventos emitidos por la pila BLE hacia la plicaci\u00f3n. Perfiles de aplicaci\u00f3n ( Application profiles ) Como se ha dicho, el objetivo es implementar un Perfil de Aplicaci\u00f3n para el servicio Heart Rate . Un Perfil de Aplicaci\u00f3n es un mecanismo que permite agrupar funcionalidad dise\u00f1ada para ser utilizada por un cliente de la aplicaci\u00f3n, por ejemplo, una aplicaci\u00f3n m\u00f3vil. En este sentido, diferentes tipos de perfiles pueden acomodarse en un mismo servidor. El Identifificador de Perfil de Aplicaci\u00f3n ( Application Profile ID ) es un valor seleccionable por el usuario para identificar cada perfil; su uso se recude al registro del perfil en la pila Bluetooth. En el ejemplo, el ID es 0x55 . #define HEART_PROFILE_NUM 1 #define HEART_PROFILE_APP_IDX 0 #define ESP_HEART_RATE_APP_ID 0x55 Los perfiles se almacenan en el array heart_rate_profile_tab . Al haber un \u00fanico perfil en el ejemplo, s\u00f3lo se almacena un elemento en el array, con \u00edndice 0 (tal y como se define en HEART_PROFILE_APP_IDX ). Adem\u00e1s, es necesario inicializar la funci\u00f3n de callback manejadora de los eventos del perfil. Cada aplicaci\u00f3n en el servidor GATT utiliza una interfaz diferenciada, representada por el par\u00e1metro gats_if . Para la incializaci\u00f3n, este par\u00e1metro se iguala a ESP_GATT_IF_NONE ; cuando la aplicaci\u00f3n se registre, m\u00e1s adelante, el par\u00e1metro gatts_if se actualizar\u00e1 con la interfaz generada autom\u00e1ticamente por la pila Bluetooth. /* One gatt-based profile one app_id and one gatts_if, this array will store the gatts_if returned by ESP_GATTS_REG_EVT */ static struct gatts_profile_inst heart_rate_profile_tab[HEART_PROFILE_NUM] = { [HEART_PROFILE_APP_IDX] = { .gatts_cb = gatts_profile_event_handler, .gatts_if = ESP_GATT_IF_NONE, /* Not get the gatt_if, so initial is ESP_GATT_IF_NONE */ }, }; El registro de la aplicaci\u00f3n tiene lugar en la funci\u00f3n app_main() , utilizando la funci\u00f3n esp_ble_gatts_app_register() : esp_ble_gatts_app_register(ESP_HEART_RATE_APP_ID); Par\u00e1metros GAP El evento de registro de aplicaci\u00f3n es el primero que se invoca durante la vida de un programa. Este ejemplo utiliza este evento para configurar par\u00e1metros GAP (de anuncio). Las funciones asociadas son: esp_ble_gap_set_device_name() : utilizada para establecer el nombre del dispositivo anunciado. esp_ble_gap_config_adv_data() : usada para configurar datos est\u00e1ndar de anuncio. La funci\u00f3n utilizada para configurar los par\u00e1metros est\u00e1ndar ( esp_ble_gap_config_adv_data() ) toma un puntero a una estructura de tipo esp_ble_adv_data_t . La estructura esp_ble_adv_data_t dispone de los siguientes campos: typedef struct { bool set_scan_rsp; /*!< Set this advertising data as scan response or not*/ bool include_name; /*!< Advertising data include device name or not */ bool include_txpower; /*!< Advertising data include TX power */ int min_interval; /*!< Advertising data show slave preferred connection min interval */ int max_interval; /*!< Advertising data show slave preferred connection max interval */ int appearance; /*!< External appearance of device */ uint16_t manufacturer_len; /*!< Manufacturer data length */ uint8_t *p_manufacturer_data; /*!< Manufacturer data point */ uint16_t service_data_len; /*!< Service data length */ uint8_t *p_service_data; /*!< Service data point */ uint16_t service_uuid_len; /*!< Service uuid length */ uint8_t *p_service_uuid; /*!< Service uuid array point */ uint8_t flag; /*!< Advertising flag of discovery mode, see BLE_ADV_DATA_FLAG detail */ } esp_ble_adv_data_t; En el ejemplo, la estructura se incializar\u00e1 como sigue: static esp_ble_adv_data_t heart_rate_adv_config = { .set_scan_rsp = false, .include_name = true, .include_txpower = true, .min_interval = 0x0006, .max_interval = 0x0010, .appearance = 0x00, .manufacturer_len = 0, //TEST_MANUFACTURER_DATA_LEN, .p_manufacturer_data = NULL, //&test_manufacturer[0], .service_data_len = 0, .p_service_data = NULL, .service_uuid_len = sizeof(heart_rate_service_uuid), .p_service_uuid = heart_rate_service_uuid, .flag = (ESP_BLE_ADV_FLAG_GEN_DISC | ESP_BLE_ADV_FLAG_BREDR_NOT_SPT), }; Los intervalos m\u00ednimos y m\u00e1ximos de conexi\u00f3n se establecen en unidades de 1.25 ms. En el ejemplo, el intervalo de conexi\u00f3n m\u00ednimo preferido se establece, por tanto, en 7.5 ms y el m\u00e1ximo en 20 ms. El payload del anuncio puede almacenar hasta 31 bytes de datos. Es posible que algunos par\u00e1metros los superen, pero en dicho caso el stack BLE cortar\u00e1 el mensaje y eliminar\u00e1 aquellos que superen el tama\u00f1o m\u00e1ximo. Por \u00faltimo, para establecer el nombre del dispositivo se puede utilizar la funci\u00f3n esp_ble_gap_set_device_name() . Para regitrar el manejador de eventos, procedemos de la siguiente forma: static void gatts_profile_event_handler(esp_gatts_cb_event_t event, esp_gatt_if_t gatts_if, esp_ble_gatts_cb_param_t *param) { ESP_LOGE(GATTS_TABLE_TAG, \"event = %x\\n\",event); switch (event) { case ESP_GATTS_REG_EVT: ESP_LOGI(GATTS_TABLE_TAG, \"%s %d\\n\", __func__, __LINE__); esp_ble_gap_set_device_name(SAMPLE_DEVICE_NAME); ESP_LOGI(GATTS_TABLE_TAG, \"%s %d\\n\", __func__, __LINE__); esp_ble_gap_config_adv_data(&heart_rate_adv_config); ESP_LOGI(GATTS_TABLE_TAG, \"%s %d\\n\", __func__, __LINE__); \u2026 El manejador de eventos GAP Una vez establecidos los datos de anuncio, se emite un evento de tipo ESP_GAP_BLE_ADV_DATA_SET_COMPLETE_EVT , que ser\u00e1 manejado por el manejador GAP configurado. Adem\u00e1s, se emite tambi\u00e9n un evento de tipo ESP_GAP_BLE_SCAN_RSP_DATA_SET_COMPLETE_EVT si se ha configurado una respuesta al escaneado. As\u00ed, el manejador puede utilizar cualquiera de estos dos eventos para comenzar con el proceso de anuncio, utilizando la funci\u00f3n esp_ble_gap_start_advertising() : static void gap_event_handler(esp_gap_ble_cb_event_t event, esp_ble_gap_cb_param_t *param) { ESP_LOGE(GATTS_TABLE_TAG, \"GAP_EVT, event %d\\n\", event); switch (event) { case ESP_GAP_BLE_ADV_DATA_SET_COMPLETE_EVT: esp_ble_gap_start_advertising(&heart_rate_adv_params); break; case ESP_GAP_BLE_ADV_START_COMPLETE_EVT: //advertising start complete event to indicate advertising start successfully or failed if (param->adv_start_cmpl.status != ESP_BT_STATUS_SUCCESS) { ESP_LOGE(GATTS_TABLE_TAG, \"Advertising start failed\\n\"); } break; default: break; } } La funci\u00f3n de inicio de anuncios toma una estructura de tipo esp_ble_adv_params_t con los par\u00e1metros de anuncio requeridos: /// Advertising parameters typedef struct { uint16_t adv_int_min; /*!< Minimum advertising interval for undirected and low duty cycle directed advertising. Range: 0x0020 to 0x4000 Default: N = 0x0800 (1.28 second) Time = N * 0.625 msec Time Range: 20 ms to 10.24 sec */ uint16_t adv_int_max; /*!< Maximum advertising interval for undirected and low duty cycle directed advertising. Range: 0x0020 to 0x4000 Default: N = 0x0800 (1.28 second) Time = N * 0.625 msec Time Range: 20 ms to 10.24 sec */ esp_ble_adv_type_t adv_type; /*!< Advertising type */ esp_ble_addr_type_t own_addr_type; /*!< Owner bluetooth device address type */ esp_bd_addr_t peer_addr; /*!< Peer device bluetooth device address */ esp_ble_addr_type_t peer_addr_type; /*!< Peer device bluetooth device address type */ esp_ble_adv_channel_t channel_map; /*!< Advertising channel map */ esp_ble_adv_filter_t adv_filter_policy; /*!< Advertising filter policy */ } esp_ble_adv_params_t; N\u00f3tese como esp_ble_gap_config_adv_data() configura los datos que son aunciados al cliente y toma una estructura de tipo esp_ble_adv_data_t structure , mientras que esp_ble_gap_start_advertising() hace que el servidor realmente comience a anunciar, tomando una estructura de tipo esp_ble_adv_params_t . Los datos de anuncio son aquellos que realmente se env\u00edan al cliente, mientras que los par\u00e1metros de anuncio son la configuraci\u00f3n requerida por la pila BLE para actuar correctamente. Para este ejemplo, los par\u00e1metros de anuncio se inicializar\u00e1n como sigue: static esp_ble_adv_params_t heart_rate_adv_params = { .adv_int_min = 0x20, .adv_int_max = 0x40, .adv_type = ADV_TYPE_IND, .own_addr_type = BLE_ADDR_TYPE_PUBLIC, //.peer_addr = //.peer_addr_type = .channel_map = ADV_CHNL_ALL, .adv_filter_policy = ADV_FILTER_ALLOW_SCAN_ANY_CON_ANY, }; Estos par\u00e1metros configuran el intervalo de anuncio entre 20 ms y 40 ms. El anuncio es de tipo ADV_TYPE_IND (tipo gen\u00e9rico), destinados a ning\u00fan dispositivo central en particular, y anuncia que el servidor GATT es conectable. El tipo de direcci\u00f3n es p\u00fablico, utiliza todos los canales y permite peticiones de escaneo y conexi\u00f3n por parte de cualquier dispositivo central. Si el proceso de anuncio se inici\u00f3 correctamente, se emitir\u00e1 un evento de tipo ESP_GAP_BLE_ADV_START_COMPLETE_EVT , que en este ejemplo se utiliza para comprobar si el estado de anuncio es realmente anunciando u otro, en cuyo caso se emitir\u00e1 un mensaje de error: ... case ESP_GAP_BLE_ADV_START_COMPLETE_EVT: //advertising start complete event to indicate advertising start successfully or failed if (param->adv_start_cmpl.status != ESP_BT_STATUS_SUCCESS) { ESP_LOGE(GATTS_TABLE_TAG, \"Advertising start failed\\n\"); } break; ... Manejadores de eventos GATT Al registrar un Pefil de Aplicaci\u00f3n, se emite un evento de tipo ESP_GATTS_REG_EVT . Los par\u00e1metros asociados al evento son: esp_gatt_status_t status; /*!< Operation status */ uint16_t app_id; /*!< Application id which input in register API */ Adem\u00e1s de los anteriores par\u00e1metros, el evento tambi\u00e9n contiene la interfaz GATT asignada por la pila BLE, a utilizar a partir de ahora. El evento es capturado por el manejador gatts_event_handler() , que almacena la interfaz generada en la tabla de perfiles, y la reenv\u00eda al manejador de eventos correspondiente al perfil: static void gatts_event_handler(esp_gatts_cb_event_t event, esp_gatt_if_t gatts_if, esp_ble_gatts_cb_param_t *param) { ESP_LOGI(GATTS_TABLE_TAG, \"EVT %d, gatts if %d\\n\", event, gatts_if); /* If event is register event, store the gatts_if for each profile */ if (event == ESP_GATTS_REG_EVT) { if (param->reg.status == ESP_GATT_OK) { heart_rate_profile_tab[HEART_PROFILE_APP_IDX].gatts_if = gatts_if; } else { ESP_LOGI(GATTS_TABLE_TAG, \"Reg app failed, app_id %04x, status %d\\n\", param->reg.app_id, param->reg.status); return; } } do { int idx; for (idx = 0; idx < HEART_PROFILE_NUM; idx++) { if (gatts_if == ESP_GATT_IF_NONE || /* ESP_GATT_IF_NONE, not specify a certain gatt_if, need to call every profile cb function */ gatts_if == heart_rate_profile_tab[idx].gatts_if) { if (heart_rate_profile_tab[idx].gatts_cb) { heart_rate_profile_tab[idx].gatts_cb(event, gatts_if, param); } } } } while (0); } Creaci\u00f3n de Servicios y Caracter\u00edsticas con una Tabla de Atributos Aprovecharemos el evento de tipo Registro para crear una tabla de atributos de perfil utilizando la funci\u00f3n esp_ble_gatts_create_attr_tab() . Esta funci\u00f3n toma como argumento una estructura de tipo esp_gatts_attr_db_t , que corresponde a una tabla de lookup indexada por los valores de la enumeraci\u00f3n definidos en el fichero de cabecera. La estructura esp_gatts_attr_db_t tiene dos miembros: esp_attr_control_t attr_control; /*!< The attribute control type*/ esp_attr_desc_t att_desc; /*!< The attribute type*/ attr_control es el par\u00e1metro de autorespuesta, t\u00edpicamente fijado a ESP_GATT_AUTO_RSP para permitir que la pila BLE reponda autom\u00e1ticamente a los mensajes de lectura o escritura cuando dichos eventos son recibidos. Una opci\u00f3n alternativa es ESP_GATT_RSP_BY_APP que permite respuestas manuales utilizando la funci\u00f3n esp_ble_gatts_send_response() . att_desc es la descripci\u00f3n del atributo, formada por: uint16_t uuid_length; /*!< UUID length */ uint8_t *uuid_p; /*!< UUID value */ uint16_t perm; /*!< Attribute permission */ uint16_t max_length; /*!< Maximum length of the element*/ uint16_t length; /*!< Current length of the element*/ uint8_t *value; /*!< Element value array*/ Por ejemplo, el primer elemento de la tabla en el ejemplo es el atributo de servicio: [HRS_IDX_SVC] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&primary_service_uuid, ESP_GATT_PERM_READ, sizeof(uint16_t), sizeof(heart_rate_svc), (uint8_t *)&heart_rate_svc}}, Los valores de inicializaci\u00f3n son: [HRS_IDX_SVC] : Inicializador en la tabla. ESP_GATT_AUTO_RSP : configuraci\u00f3n de respuesta autom\u00e1tica, fijada en este caso a respuesta autom\u00e1tica por parte de la pila BLE. ESP_UUID_LEN_16 : longitudo del UUID fijada a 16 bits. (uint8_t *)&primary_service_uuid : UUID para identificar al servicio como primario (0x2800). ESP_GATT_PERM_READ : Permisos de lectura para el servicio. sizeof(uint16_t) : Longitud m\u00e1xima del UUID del servicio (16 bits). sizeof(heart_rate_svc) : Longitud del servicio, en este caso 16 bits (fijada por el tama\u00f1o de la variable heart_rate_svc ). (uint8_t *)&heart_rate_svc : Valor del atributo servicio fijada a la variable the variable heart_rate_svc , que contiene el UUID del Heart Rate Service (0x180D). El resto de atributos se inicializan de forma similar. Algunos atributos tambi\u00e9n tienen activa la propiedad NOTIFY , que se establece v\u00eda &char_prop_notify . La tabla completa se inicializa como sigue: /// Full HRS Database Description - Used to add attributes into the database static const esp_gatts_attr_db_t heart_rate_gatt_db[HRS_IDX_NB] = { // Heart Rate Service Declaration [HRS_IDX_SVC] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&primary_service_uuid, ESP_GATT_PERM_READ, sizeof(uint16_t), sizeof(heart_rate_svc), (uint8_t *)&heart_rate_svc}}, // Heart Rate Measurement Characteristic Declaration [HRS_IDX_HR_MEAS_CHAR] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&character_declaration_uuid, ESP_GATT_PERM_READ, CHAR_DECLARATION_SIZE,CHAR_DECLARATION_SIZE, (uint8_t *)&char_prop_notify}}, // Heart Rate Measurement Characteristic Value [HRS_IDX_HR_MEAS_VAL] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&heart_rate_meas_uuid, ESP_GATT_PERM_READ, HRPS_HT_MEAS_MAX_LEN,0, NULL}}, // Heart Rate Measurement Characteristic - Client Characteristic Configuration Descriptor [HRS_IDX_HR_MEAS_NTF_CFG] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&character_client_config_uuid, ESP_GATT_PERM_READ|ESP_GATT_PERM_WRITE, sizeof(uint16_t),sizeof(heart_measurement_ccc), (uint8_t *)heart_measurement_ccc}}, // Body Sensor Location Characteristic Declaration [HRS_IDX_BOBY_SENSOR_LOC_CHAR] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&character_declaration_uuid, ESP_GATT_PERM_READ, CHAR_DECLARATION_SIZE,CHAR_DECLARATION_SIZE, (uint8_t *)&char_prop_read}}, // Body Sensor Location Characteristic Value [HRS_IDX_BOBY_SENSOR_LOC_VAL] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&body_sensor_location_uuid, ESP_GATT_PERM_READ, sizeof(uint8_t), sizeof(body_sensor_loc_val), (uint8_t *)body_sensor_loc_val}}, // Heart Rate Control Point Characteristic Declaration [HRS_IDX_HR_CTNL_PT_CHAR] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&character_declaration_uuid, ESP_GATT_PERM_READ, CHAR_DECLARATION_SIZE,CHAR_DECLARATION_SIZE, (uint8_t *)&char_prop_read_write}}, // Heart Rate Control Point Characteristic Value [HRS_IDX_HR_CTNL_PT_VAL] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&heart_rate_ctrl_point, ESP_GATT_PERM_WRITE|ESP_GATT_PERM_READ, sizeof(uint8_t), sizeof(heart_ctrl_point), (uint8_t *)heart_ctrl_point}}, }; Inicializaci\u00f3n del servicio Cuando la tabla se crea, se emite un evento de tipo ESP_GATTS_CREAT_ATTR_TAB_EVT . Este evento tiene los siguientes par\u00e1metros asociados: esp_gatt_status_t status; /*!< Operation status */ esp_bt_uuid_t svc_uuid; /*!< Service uuid type */ uint16_t num_handle; /*!< The number of the attribute handle to be added to the gatts database */ uint16_t *handles; /*!< The number to the handles */ Este ejemplo utiliza este evento para mostrar informaci\u00f3n y comprobar que el tama\u00f1o de la tabla creada es igual al n\u00famero de elementos en la enumeraci\u00f3n HRS_IDX_NB . Si la tabla se cre\u00f3 correctamente, los manejadores de atributos se copian en la tabla de manejadores heart_rate_handle_table y el servicio se inicicaliza utilizando la funci\u00f3n esp_ble_gatts_start_service() : case ESP_GATTS_CREAT_ATTR_TAB_EVT:{ ESP_LOGI(GATTS_TABLE_TAG, \"The number handle =%x\\n\",param->add_attr_tab.num_handle); if (param->add_attr_tab.status != ESP_GATT_OK){ ESP_LOGE(GATTS_TABLE_TAG, \"Create attribute table failed, error code=0x%x\", param->add_attr_tab.status); } else if (param->add_attr_tab.num_handle != HRS_IDX_NB){ ESP_LOGE(GATTS_TABLE_TAG, \"Create attribute table abnormally, num_handle (%d) \\ doesn't equal to HRS_IDX_NB(%d)\", param->add_attr_tab.num_handle, HRS_IDX_NB); } else { memcpy(heart_rate_handle_table, param->add_attr_tab.handles, sizeof(heart_rate_handle_table)); esp_ble_gatts_start_service(heart_rate_handle_table[HRS_IDX_SVC]); } break; Los manejadores almacenados son n\u00fameros que identifican cada atributo. Estos manejadores pueden usarse para determinar qu\u00e9 caracter\u00edstica est\u00e1 siendo le\u00edda o escrita, y por tanto pueden ser proporcionados a otros puntos de la aplicaci\u00f3n para manejar distintas acciones. Finalmente, la tabla heart_rate_handle_table contiene el Perfil de Aplicaci\u00f3n en forma de estructura con informaci\u00f3n sobre los par\u00e1metros de los atributos y la interfaz GATT, ID de conexi\u00f3n, permisos e ID de aplicaci\u00f3n. La estructura presenta los siguientes campos (no todos se usan en el ejemplo): struct gatts_profile_inst { esp_gatts_cb_t gatts_cb; uint16_t gatts_if; uint16_t app_id; uint16_t conn_id; uint16_t service_handle; esp_gatt_srvc_id_t service_id; uint16_t char_handle; esp_bt_uuid_t char_uuid; esp_gatt_perm_t perm; esp_gatt_char_prop_t property; uint16_t descr_handle; esp_bt_uuid_t descr_uuid; }; Interacci\u00f3n a trav\u00e9s de un cliente GATT Nota Para desarrollar esta parte de la pr\u00e1ctica, deber\u00e1s importar la m\u00e1quina virtual del curso en el PC del laboratorio, y hacer visible a ella el dispositivo Bluetooth del equipo de laboratorio. Nota Existen multitud de herramientas que permiten gestionar la conexi\u00f3n al servidor GATT. En Linux, utilizaremos hcitool y gatttool ; en Windows, puedes utilizar una herramienta llamada Bluetooth LE Explorer , que implementa, aunque de forma gr\u00e1fica, la misma funcionalidad. Uso de hcitool y gatttool en modo cliente Escaneando dispositivos disponibles: hcitool hcitool es una herramienta de l\u00ednea de comandos que permite gestionar la interfaz Bluetooth del equipo en el que se ejecuta. En nuestro caso, necesitaremos determinar la direcci\u00f3n MAC Bluetooth de nuestro servidor. Para ello, en primer lugar, realizaremos un escaneado de los dispsitivos BLE disponibles en el entorno utilizando la orden: sudo hcitool lescan Si todo ha ido bien, se mostrar\u00e1 una l\u00ednea por dispositivo BLE disponible y en fase de anuncio. Entre ellos, deberemos encontrar nuestro dispositivo, para recordar su direcci\u00f3n MAC. Tarea Edita el fichero main/gatts_table_creat_demo.c y modifica el nombre de tu dispositivo, que se anunciar\u00e1 en cada anuncio emitido en la fase de advertising . Para ello, debes modificar el campo correspondiente de la estructura raw_adv_data . A continuaci\u00f3n, compila y flashea el ejemplo, y comienza una sesi\u00f3n de escaneado de dispositivos BLE mediante la orden: sudo hcitool lescan . Deber\u00e1s observar tu dispositivo en una de las l\u00edneas. Anota o recuerda su direcci\u00f3n MAC. Interactuando con el servidor GATT: gatttool Una vez obtenida la direcci\u00f3n MAC Bluetooth del dispositivo, deberemos proceder en dos fases. La primera de ellas es el emparejado al dispostivo desde tu consola. La segunda, la interacci\u00f3n con la tabla GATT. En ambos casos, se utilizar\u00e1 la herramienta gatttool desde l\u00ednea de comandos. Para comenzar una sesi\u00f3n gatttool , invocaremos a la herramienta en modo interactivo, utilizando la orden: gatttool -b MAC -I Esto abrir\u00e1 una consola interactiva, a la espera de las ordenes correspondientes. Para realizar el emparejamiento, y considerando que la MAC Bluetooth es ya conocida, utilizaremos la orden connect . Si todo ha ido bien, deberemos observar un cambio en el color del prompt, y un mensaje Connection successful . En este punto, observa como en la salida de depuraci\u00f3n del ESP32 se muestran los mensajes correspondientes al proceso de emparejamiento. Desde la terminal de gatttool , puedes ejecutar en cualquier momento la orden help para obtener ayuda (en forma de lista de comandos disponibles): gatttool -b 24:6F:28:36:60:B2 -I [24:6F:28:36:60:B2][LE]> connect Attempting to connect to 24:6F:28:36:60:B2 Connection successful [24:6F:28:36:60:B2][LE]> help help Show this help exit Exit interactive mode quit Exit interactive mode connect [address [address type]] Connect to a remote device disconnect Disconnect from a remote device primary [UUID] Primary Service Discovery included [start hnd [end hnd]] Find Included Services characteristics [start hnd [end hnd [UUID]]] Characteristics Discovery char-desc [start hnd] [end hnd] Characteristics Descriptor Discovery char-read-hnd <handle> Characteristics Value/Descriptor Read by handle char-read-uuid <UUID> [start hnd] [end hnd] Characteristics Value/Descriptor Read by UUID char-write-req <handle> <new value> Characteristic Value Write (Write Request) char-write-cmd <handle> <new value> Characteristic Value Write (No response) sec-level [low | medium | high] Set security level. Default: low mtu <value> Exchange MTU for GATT/ATT Comenzaremos consultando la lista de caracter\u00edsticas del servidor GATT. Tarea Mediante el comando correspondiente ( characteristics ), consulta y anota las caracter\u00edsticas disponibles en tu servidor GATT. Una de estas caracter\u00edsticas ser\u00e1 de crucial inter\u00e9s, ya que nos permitir\u00e1 acceder, a trav\u00e9s de su UUID, a la medici\u00f3n instant\u00e1nea de ritmo card\u00edaco, as\u00ed como a la configuraci\u00f3n de notificaciones sobre dicho valor. Para determinar cu\u00e1l de las l\u00edneas es la que nos interesa, observa el valor de UUID devuelta para cada una de ellas, y determina, en funci\u00f3n de la macro GATTS_CHAR_UUID_TEST_A de cu\u00e1l se trata. Para interactuar con dicha caracter\u00edstica, necesitaremos un manejador ( handler ) que permita un uso m\u00e1s sencillo de la misma desde la herramienta gatttool . Dicho manejador se muestra, para cada l\u00ednea, tras la cadena char value handle . Tarea El manejador que permite leer desde la caracter\u00edstica *Heart Rate Value\" tiene un manejador de tipo car\u00e1cter asociado. Anota su valor. Para leer el valor de la caracter\u00edstica, podemos utilizar su manejador asociado. As\u00ed, podemos obtener dicho valor con un comando de lectura, en este caso char-read-hnd manejador . Tarea Obt\u00e9n los datos de lectura de la caracter\u00edstica de medici\u00f3n del valor de monitorizaci\u00f3n de ritmo card\u00edaco. \u00bfCu\u00e1les son? Deber\u00edas observar un valor de retorno de cuatro bytes con valor 0x00. Estos valores corresponden a los de la variable char_value de tu c\u00f3digo. Modif\u00edcalos, recompila y vuelve a flashear el c\u00f3digo. \u00bfHan variado? Tarea Intenta ahora escribir en la anterior caracter\u00edstica. Para ello, utiliza el comando char-write-cmd handler valor , siendo valor, por ejemplo, 11223344 . \u00bfEs posible? \u00bfPor qu\u00e9? Escribiremos a continuaci\u00f3n en la caracter\u00edstica de configuraci\u00f3n del servicio de montorizaci\u00f3n. Para ello, utilizaremos el manejador siguiente al utilizado anteriormente. Esto es, si se nos devolvi\u00f3, por ejemplo, un manejador 0x0001 para el valor de monitorizaci\u00f3n, el valor de configuraci\u00f3n ser\u00e1 0x0002 . Tarea Intenta ahora escribir en la caracter\u00edstica de configuraci\u00f3n. Para ello, utiliza el comando char-write-cmd handler valor , siendo valor, por ejemplo, 0100 . \u00bfEs posible? \u00bfPor qu\u00e9? Como habr\u00e1s observado, es posible leer desde el valor de monitorizaci\u00f3n, y escribir en el valor de configuraci\u00f3n. Utilizaremos esta \u00faltima caracter\u00edstica para configurar las notificaciones sobre el valor de monitorizaci\u00f3n. De este modo, cada vez que se desee enviar dicho valor a los clientes que tengan activada la notificaci\u00f3n, \u00e9stos la recibir\u00e1n sin necesidad de cambio alguno. Para ello, necesitamos modificar algunas partes de nuestro c\u00f3digo. Espec\u00edficamente, necesitaremos: Crear una nueva tarea que, peri\u00f3dicamente, modifique el valor de monitorizaci\u00f3n de ritmo card\u00edaco (ley\u00e9ndolo desde un sensor, si est\u00e1 disponible, o, en nuestro caso generando un valor aleatorio). Dicha tarea consistir\u00e1 en un bucle infinito que, en cualquier caso, s\u00f3lo enviar\u00e1 datos al cliente si la notificaci\u00f3n est\u00e1 activa, con un intervalo de env\u00edo de un segundo: static void publish_data_task(void *pvParameters) { while (1) { ESP_LOGI(\"APP\", \"Sending data...\"); // Paso 1: Actualizo valor... // Paso 2: Si notificaci\u00f3n activa... // Paso 3: Env\u00edo datos... // Paso 4: Duermo un segundo... vTaskDelay( 1000. / portTICK_PERIOD_MS); } } Esta rutina deber\u00e1 crearse en respuesta al evento de conexi\u00f3n por parte de un cliente, utilizando, por ejemplo, la invocaci\u00f3n a: xTaskCreate(&publish_data_task, \"publish_data_task\", 4096, NULL, 5, NULL); La actualizaci\u00f3n del valor, realizada peri\u00f3dicamente y de forma aleatoria, modificar\u00e1 el byte 1 de la variable char_value , tomando un valor aleatorio entre 0 y 255 (como nota adicional, los puls\u00f3metros actuales soportan valores mayores para ritmo cardiaco, aunque la configuraci\u00f3n de esta funcionalidad est\u00e1 fuera del alcance de la pr\u00e1ctica). La comprobaci\u00f3n de la activaci\u00f3n o no de la notificaci\u00f3n se realiza consultando los dos bytes de la variable heart_meaurement_ccc . Si dichos valores son 0x01 y 0x00 (posiciones 0 y 1, respectivamente), las notificaciones est\u00e1n activas, y por tanto, se realizar\u00e1 el env\u00edo de notificaci\u00f3n. Para enviar la notificaci\u00f3n, utilizaremos la siguiente funci\u00f3n: esp_ble_gatts_send_indicate(heart_rate_profile_tab[0].gatts_if, heart_rate_profile_tab[0].conn_id, heart_rate_handle_table[IDX_CHAR_VAL_A], sizeof(char_value), char_value, false); La activaci\u00f3n de notificaciones desde gatttool se realizar\u00e1 mediante la escritura del valor 0x0100 en la caracter\u00edstica de configuraci\u00f3n, esto es: char-write-cmd HANDLER 0100 Nuestro firmware deber\u00e1 modificarse para que, al recibir dicho valor en la caracter\u00edstica, se sobreescriba el contenido de la variable heart_measurement_ccc . Esta escritura debe realizarse en respuesta al evento ESP_GATTS_WRITE_EVT . Tarea entregable Modifica el firmware original para que, peri\u00f3dicamente (cada segundo) notifique el valor de ritmo card\u00edaco a los clientes conectados. Si adem\u00e1s modificas las UUID por las proporcionadas en la especificaci\u00f3n Bluetooth para el Servicio Heart Rate y todo ha sido configurado correctamente, tu ESP32 deber\u00eda poder interactuar con cualquier monitor de ritmo cardiaco para, por ejemplo, Android. Para ello, utiliza las siguientes UUIDs: static const uint16_t GATTS_SERVICE_UUID_TEST = 0x180D; //0x00FF; static const uint16_t GATTS_CHAR_UUID_TEST_A = 0x2A37; //0xFF01; static const uint16_t GATTS_CHAR_UUID_TEST_B = 0x2A38; //0xFF02; static const uint16_t GATTS_CHAR_UUID_TEST_C = 0x2A39; //0xFF03; Entrega el c\u00f3digo modificado, as\u00ed como evidencias (capturas de pantalla) que demuestren que un cliente gatttool suscrito a notificaciones recibe, cada segundo, la actualizaci\u00f3n de ritmo card\u00edaco por parte del sensor.","title":"Pr\u00e1ctica 4"},{"location":"RPI-I/P4/#practica-4-bluetooth-low-energy-ble","text":"","title":"Pr\u00e1ctica 4. Bluetooth Low Energy (BLE)"},{"location":"RPI-I/P4/#objetivos","text":"Diseccionar en detalle un firmware de construcci\u00f3n de tabla GATT (servidor GATT) utilizando la API de ESP-IDF. Aprender a utilizar la herramienta gatttool para interactuar con el servidor GATT. Modificar el servidor GATT para que acepte peticiones de notificaci\u00f3n por parte del cliente, y para que publique bajo demanda valores actualizados para una determinada caracter\u00edstica.","title":"Objetivos"},{"location":"RPI-I/P4/#implementacion-de-un-servidor-gatt-basado-en-tablas","text":"","title":"Implementaci\u00f3n de un servidor GATT basado en tablas"},{"location":"RPI-I/P4/#introduccion","text":"En esta pr\u00e1ctica, desplegaremos un servidor GATT utilizando la API de ESP-IDF para tal fin. Dicha API expone las funcionalidades de Bluedroid, la pila Bluetooth (incluyendo BLE) que proporciona ESP-IDF para el desarrollo de aplicaciones Bluetooth. El ejemplo con el que trabajaremos reside en el directorio examples/bluetooth/bluedroid/ble/gatt_server_service_table . Debido a la complejidad del ejemplo (al menos en su parte inicial), la presente pr\u00e1ctica procede, en primer lugar, con un recorrido por la preparaci\u00f3n y construcci\u00f3n del servidor siguiendo una estructura de tabla que define los servicios y caracter\u00edsticas que se implementar\u00e1n en el mismo. El ejemplo implementa el perfile Heart Rate Profile definido en la especificaci\u00f3n Bluetooth , y sigue la siguiente estructura: Desplegaremos, por tanto, tres caracter\u00edsticas. De ellas, la m\u00e1s importante para nosotros ser\u00e1 el valor de medici\u00f3n de ritmo cardiaco, con su valor ( Heart Rate Measurement Value ) y su configuraci\u00f3n de notificaciones ( Heart Rate Measurement Notification Configuration ).","title":"Introducci\u00f3n"},{"location":"RPI-I/P4/#inclusion-de-encabezados","text":"Los siguientes ficheros de cabecera son necesarios para dotar de funcionalidad BLE a nuestro firmware : #include \"freertos/FreeRTOS.h\" #include \"freertos/task.h\" #include \"freertos/event_groups.h\" #include \"esp_system.h\" #include \"esp_log.h\" #include \"nvs_flash.h\" #include \"bt.h\" #include \"bta_api.h\" #include \"esp_gap_ble_api.h\" #include \"esp_gatts_api.h\" #include \"esp_bt_defs.h\" #include \"esp_bt_main.h\" #include \"esp_bt_main.h\" #include \u201cgatts_table_creat_demo.h\" Estos encabezados son necesarios para un correcto funcionamiento de FreeRTOS y de sus componentes, incluyendo funcionalidad relativa a logging y almacenamiento no vol\u00e1til. Son especialmente interesantes los ficheros bt.h , esp_bt_main.h , esp_gap_ble_api.h y esp_gatts_api.h , ya que exponen la API BLE necesaria para la implementaci\u00f3n del firmware : bt.h : implementa el controlador Bluetooth. esp_bt_main.h : implementa las rutinas de inicializaci\u00f3n y activaci\u00f3n de la pila Bluedroid. esp_gap_ble_api.h : implementa la configuraci\u00f3n GAP (par\u00e1metros de anuncios y conexi\u00f3n). esp_gatts_api.h : immplementa la configuraci\u00f3n del servidor GATT (por ejemplo, la creaci\u00f3n de servicios y caracter\u00edsticas).","title":"Inclusi\u00f3n de encabezados"},{"location":"RPI-I/P4/#la-tabla-de-servicios","text":"El fichero de encabezado gatts_table_creat_demo.h contiene una enumeraci\u00f3n de los servicios y caracter\u00edsticas deseadas: enum { HRS_IDX_SVC, HRS_IDX_HR_MEAS_CHAR, HRS_IDX_HR_MEAS_VAL, HRS_IDX_HR_MEAS_NTF_CFG, HRS_IDX_BOBY_SENSOR_LOC_CHAR, HRS_IDX_BOBY_SENSOR_LOC_VAL, HRS_IDX_HR_CTNL_PT_CHAR, HRS_IDX_HR_CTNL_PT_VAL, HRS_IDX_NB, }; Los elementos de la anterior estructura se han incluido en el mismo orden que los atributos del Heart Rate Profile , comenzando con el servicio, seguido por las caracter\u00edsticas del mismo. Adem\u00e1s, la caracter\u00edstica Heart Rate Measurement dispone de configuraci\u00f3n propia ( Client Characteristic Configuration , o CCC), un descriptor que describe si la caracter\u00edstica tiene las notificaciones activas . Todos estos \u00edndices pueden utilizarse para identificar a cada elemento a la hora de crear la tabla de atributos: HRS_IDX_SVC : \u00edndice del servicio Heart Rate. HRS_IDX_HR_MEAS_CHAR : \u00edndice de la caracter\u00edstica Heart Rate Measurement. HRS_IDX_HR_MEAS_VAL : \u00edndice del valor Heart Rate Measurement. HRS_IDX_HR_MEAS_NTF_CFG : \u00edndice de la configuraci\u00f3n de notificaciones (CCC) Heart Rate Measurement. HRS_IDX_BOBY_SENSOR_LOC_CHAR : \u00edndice de la caracter\u00edstica Heart Rate Body Sensor Location. HRS_IDX_BOBY_SENSOR_LOC_VAL : \u00edndice del valor Heart Rate Body Sensor Location. HRS_IDX_HR_CTNL_PT_CHAR : \u00edndice de la caracter\u00edstica Heart Rate Control Point. HRS_IDX_HR_CTNL_PT_VAL : \u00edndice del valor Heart Rate Control Point. HRS_IDX_NB : n\u00famero de elementos d ela tabla.","title":"La tabla de servicios"},{"location":"RPI-I/P4/#punto-de-entrada","text":"El punto de entrada de la aplicaci\u00f3n ( app_main() ) se implementa como sigue: void app_main() { esp_err_t ret; // Initialize NVS. ret = nvs_flash_init(); if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) { ESP_ERROR_CHECK(nvs_flash_erase()); ret = nvs_flash_init(); } ESP_ERROR_CHECK( ret ); esp_bt_controller_config_t bt_cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT(); ret = esp_bt_controller_init(&bt_cfg); if (ret) { ESP_LOGE(GATTS_TABLE_TAG, \"%s enable controller failed\\n\", __func__); return; } ret = esp_bt_controller_enable(ESP_BT_MODE_BLE); if (ret) { ESP_LOGE(GATTS_TABLE_TAG, \"%s enable controller failed\\n\", __func__); return; } ESP_LOGI(GATTS_TABLE_TAG, \"%s init bluetooth\\n\", __func__); ret = esp_bluedroid_init(); if (ret) { ESP_LOGE(GATTS_TABLE_TAG, \"%s init bluetooth failed\\n\", __func__); return; } ret = esp_bluedroid_enable(); if (ret) { ESP_LOGE(GATTS_TABLE_TAG, \"%s enable bluetooth failed\\n\", __func__); return; } esp_ble_gatts_register_callback(gatts_event_handler); esp_ble_gap_register_callback(gap_event_handler); esp_ble_gatts_app_register(ESP_HEART_RATE_APP_ID); return; } La funci\u00f3n principal procede incializando el almacenamiento no vol\u00e1til, para almacenar los par\u00e1metros necesarios en memoria flash : ret = nvs_flash_init();","title":"Punto de entrada"},{"location":"RPI-I/P4/#inicializacion-del-controlador-y-de-la-pila-bluetooth","text":"La funci\u00f3n principal inicializa tambi\u00e9n el controlador Bluetooth, creando en primer lugar una estructura de configuraci\u00f3n para tal fin de tipo esp_bt_controller_config_t con valores por defecto dictados por la macro BT_CONTROLLER_INIT_CONFIG_DEFAULT() . El controlador Bluetooth implementa el Host Controller Interface (HCI), la capa de enlace y la capa f\u00edsica BLE; es, por tanto, transparente para el programador. La configuraci\u00f3n incluye el tama\u00f1o de pila reservado al controlador, prioridad y baudios para la transmisi\u00f3n. Con estas configuraciones, el controlador puede ser inicializado y activado con la funci\u00f3n esp_bt_controller_init() : esp_bt_controller_config_t bt_cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT(); ret = esp_bt_controller_init(&bt_cfg); A continuaci\u00f3n, el controlador activa el modo BLE: ret = esp_bt_controller_enable(ESP_BT_MODE_BLE); Existen cuatro modos de funcioinamiento Bluetooth: ESP_BT_MODE_IDLE : Bluetooth no funcional ESP_BT_MODE_BLE : Modo BLE ESP_BT_MODE_CLASSIC_BT : Modo BT Cl\u00e1sico ESP_BT_MODE_BTDM : Modo Dual (BLE + BT Cl\u00e1sico) Tras la incializaci\u00f3n del controlador Bluetooth, la pila Bluedroid (que incluye APIs tanto para BLE como para Bluetooth Cl\u00e1sico) debe ser inicializada y activada: ret = esp_bluedroid_init(); ret = esp_bluedroid_enable(); La pila Bluetooth est\u00e1, a partir de este punto, lista para funcionar, pero todav\u00eda no se ha implementado ninguna l\u00f3gica de aplicaci\u00f3n. Dicha funcionalidad se define con el cl\u00e1sico mecanismo basado en eventos, que pueden ser emitidos, por ejemplo, cuando otro dispositivo intenta leer o escribir par\u00e1metros, o establecer una conexi\u00f3n. Existen dos gestores de eventos relacionados con BLE: los manejadores ( handlers ) GAP y GATT. La aplicaci\u00f3n necesita registrar una funci\u00f3n de callback para cada manejador, para permitir a la aplicaci\u00f3n conocer qu\u00e9 funciones se invocar\u00e1n eventos de tipo GAP y GATT: esp_ble_gatts_register_callback(gatts_event_handler); esp_ble_gap_register_callback(gap_event_handler); Las funciones gatts_event_handler() y gap_event_handler() manejan todos los eventos emitidos por la pila BLE hacia la plicaci\u00f3n.","title":"Inicializaci\u00f3n del controlador y de la pila Bluetooth"},{"location":"RPI-I/P4/#perfiles-de-aplicacion-application-profiles","text":"Como se ha dicho, el objetivo es implementar un Perfil de Aplicaci\u00f3n para el servicio Heart Rate . Un Perfil de Aplicaci\u00f3n es un mecanismo que permite agrupar funcionalidad dise\u00f1ada para ser utilizada por un cliente de la aplicaci\u00f3n, por ejemplo, una aplicaci\u00f3n m\u00f3vil. En este sentido, diferentes tipos de perfiles pueden acomodarse en un mismo servidor. El Identifificador de Perfil de Aplicaci\u00f3n ( Application Profile ID ) es un valor seleccionable por el usuario para identificar cada perfil; su uso se recude al registro del perfil en la pila Bluetooth. En el ejemplo, el ID es 0x55 . #define HEART_PROFILE_NUM 1 #define HEART_PROFILE_APP_IDX 0 #define ESP_HEART_RATE_APP_ID 0x55 Los perfiles se almacenan en el array heart_rate_profile_tab . Al haber un \u00fanico perfil en el ejemplo, s\u00f3lo se almacena un elemento en el array, con \u00edndice 0 (tal y como se define en HEART_PROFILE_APP_IDX ). Adem\u00e1s, es necesario inicializar la funci\u00f3n de callback manejadora de los eventos del perfil. Cada aplicaci\u00f3n en el servidor GATT utiliza una interfaz diferenciada, representada por el par\u00e1metro gats_if . Para la incializaci\u00f3n, este par\u00e1metro se iguala a ESP_GATT_IF_NONE ; cuando la aplicaci\u00f3n se registre, m\u00e1s adelante, el par\u00e1metro gatts_if se actualizar\u00e1 con la interfaz generada autom\u00e1ticamente por la pila Bluetooth. /* One gatt-based profile one app_id and one gatts_if, this array will store the gatts_if returned by ESP_GATTS_REG_EVT */ static struct gatts_profile_inst heart_rate_profile_tab[HEART_PROFILE_NUM] = { [HEART_PROFILE_APP_IDX] = { .gatts_cb = gatts_profile_event_handler, .gatts_if = ESP_GATT_IF_NONE, /* Not get the gatt_if, so initial is ESP_GATT_IF_NONE */ }, }; El registro de la aplicaci\u00f3n tiene lugar en la funci\u00f3n app_main() , utilizando la funci\u00f3n esp_ble_gatts_app_register() : esp_ble_gatts_app_register(ESP_HEART_RATE_APP_ID);","title":"Perfiles de aplicaci\u00f3n (Application profiles)"},{"location":"RPI-I/P4/#parametros-gap","text":"El evento de registro de aplicaci\u00f3n es el primero que se invoca durante la vida de un programa. Este ejemplo utiliza este evento para configurar par\u00e1metros GAP (de anuncio). Las funciones asociadas son: esp_ble_gap_set_device_name() : utilizada para establecer el nombre del dispositivo anunciado. esp_ble_gap_config_adv_data() : usada para configurar datos est\u00e1ndar de anuncio. La funci\u00f3n utilizada para configurar los par\u00e1metros est\u00e1ndar ( esp_ble_gap_config_adv_data() ) toma un puntero a una estructura de tipo esp_ble_adv_data_t . La estructura esp_ble_adv_data_t dispone de los siguientes campos: typedef struct { bool set_scan_rsp; /*!< Set this advertising data as scan response or not*/ bool include_name; /*!< Advertising data include device name or not */ bool include_txpower; /*!< Advertising data include TX power */ int min_interval; /*!< Advertising data show slave preferred connection min interval */ int max_interval; /*!< Advertising data show slave preferred connection max interval */ int appearance; /*!< External appearance of device */ uint16_t manufacturer_len; /*!< Manufacturer data length */ uint8_t *p_manufacturer_data; /*!< Manufacturer data point */ uint16_t service_data_len; /*!< Service data length */ uint8_t *p_service_data; /*!< Service data point */ uint16_t service_uuid_len; /*!< Service uuid length */ uint8_t *p_service_uuid; /*!< Service uuid array point */ uint8_t flag; /*!< Advertising flag of discovery mode, see BLE_ADV_DATA_FLAG detail */ } esp_ble_adv_data_t; En el ejemplo, la estructura se incializar\u00e1 como sigue: static esp_ble_adv_data_t heart_rate_adv_config = { .set_scan_rsp = false, .include_name = true, .include_txpower = true, .min_interval = 0x0006, .max_interval = 0x0010, .appearance = 0x00, .manufacturer_len = 0, //TEST_MANUFACTURER_DATA_LEN, .p_manufacturer_data = NULL, //&test_manufacturer[0], .service_data_len = 0, .p_service_data = NULL, .service_uuid_len = sizeof(heart_rate_service_uuid), .p_service_uuid = heart_rate_service_uuid, .flag = (ESP_BLE_ADV_FLAG_GEN_DISC | ESP_BLE_ADV_FLAG_BREDR_NOT_SPT), }; Los intervalos m\u00ednimos y m\u00e1ximos de conexi\u00f3n se establecen en unidades de 1.25 ms. En el ejemplo, el intervalo de conexi\u00f3n m\u00ednimo preferido se establece, por tanto, en 7.5 ms y el m\u00e1ximo en 20 ms. El payload del anuncio puede almacenar hasta 31 bytes de datos. Es posible que algunos par\u00e1metros los superen, pero en dicho caso el stack BLE cortar\u00e1 el mensaje y eliminar\u00e1 aquellos que superen el tama\u00f1o m\u00e1ximo. Por \u00faltimo, para establecer el nombre del dispositivo se puede utilizar la funci\u00f3n esp_ble_gap_set_device_name() . Para regitrar el manejador de eventos, procedemos de la siguiente forma: static void gatts_profile_event_handler(esp_gatts_cb_event_t event, esp_gatt_if_t gatts_if, esp_ble_gatts_cb_param_t *param) { ESP_LOGE(GATTS_TABLE_TAG, \"event = %x\\n\",event); switch (event) { case ESP_GATTS_REG_EVT: ESP_LOGI(GATTS_TABLE_TAG, \"%s %d\\n\", __func__, __LINE__); esp_ble_gap_set_device_name(SAMPLE_DEVICE_NAME); ESP_LOGI(GATTS_TABLE_TAG, \"%s %d\\n\", __func__, __LINE__); esp_ble_gap_config_adv_data(&heart_rate_adv_config); ESP_LOGI(GATTS_TABLE_TAG, \"%s %d\\n\", __func__, __LINE__); \u2026","title":"Par\u00e1metros GAP"},{"location":"RPI-I/P4/#el-manejador-de-eventos-gap","text":"Una vez establecidos los datos de anuncio, se emite un evento de tipo ESP_GAP_BLE_ADV_DATA_SET_COMPLETE_EVT , que ser\u00e1 manejado por el manejador GAP configurado. Adem\u00e1s, se emite tambi\u00e9n un evento de tipo ESP_GAP_BLE_SCAN_RSP_DATA_SET_COMPLETE_EVT si se ha configurado una respuesta al escaneado. As\u00ed, el manejador puede utilizar cualquiera de estos dos eventos para comenzar con el proceso de anuncio, utilizando la funci\u00f3n esp_ble_gap_start_advertising() : static void gap_event_handler(esp_gap_ble_cb_event_t event, esp_ble_gap_cb_param_t *param) { ESP_LOGE(GATTS_TABLE_TAG, \"GAP_EVT, event %d\\n\", event); switch (event) { case ESP_GAP_BLE_ADV_DATA_SET_COMPLETE_EVT: esp_ble_gap_start_advertising(&heart_rate_adv_params); break; case ESP_GAP_BLE_ADV_START_COMPLETE_EVT: //advertising start complete event to indicate advertising start successfully or failed if (param->adv_start_cmpl.status != ESP_BT_STATUS_SUCCESS) { ESP_LOGE(GATTS_TABLE_TAG, \"Advertising start failed\\n\"); } break; default: break; } } La funci\u00f3n de inicio de anuncios toma una estructura de tipo esp_ble_adv_params_t con los par\u00e1metros de anuncio requeridos: /// Advertising parameters typedef struct { uint16_t adv_int_min; /*!< Minimum advertising interval for undirected and low duty cycle directed advertising. Range: 0x0020 to 0x4000 Default: N = 0x0800 (1.28 second) Time = N * 0.625 msec Time Range: 20 ms to 10.24 sec */ uint16_t adv_int_max; /*!< Maximum advertising interval for undirected and low duty cycle directed advertising. Range: 0x0020 to 0x4000 Default: N = 0x0800 (1.28 second) Time = N * 0.625 msec Time Range: 20 ms to 10.24 sec */ esp_ble_adv_type_t adv_type; /*!< Advertising type */ esp_ble_addr_type_t own_addr_type; /*!< Owner bluetooth device address type */ esp_bd_addr_t peer_addr; /*!< Peer device bluetooth device address */ esp_ble_addr_type_t peer_addr_type; /*!< Peer device bluetooth device address type */ esp_ble_adv_channel_t channel_map; /*!< Advertising channel map */ esp_ble_adv_filter_t adv_filter_policy; /*!< Advertising filter policy */ } esp_ble_adv_params_t; N\u00f3tese como esp_ble_gap_config_adv_data() configura los datos que son aunciados al cliente y toma una estructura de tipo esp_ble_adv_data_t structure , mientras que esp_ble_gap_start_advertising() hace que el servidor realmente comience a anunciar, tomando una estructura de tipo esp_ble_adv_params_t . Los datos de anuncio son aquellos que realmente se env\u00edan al cliente, mientras que los par\u00e1metros de anuncio son la configuraci\u00f3n requerida por la pila BLE para actuar correctamente. Para este ejemplo, los par\u00e1metros de anuncio se inicializar\u00e1n como sigue: static esp_ble_adv_params_t heart_rate_adv_params = { .adv_int_min = 0x20, .adv_int_max = 0x40, .adv_type = ADV_TYPE_IND, .own_addr_type = BLE_ADDR_TYPE_PUBLIC, //.peer_addr = //.peer_addr_type = .channel_map = ADV_CHNL_ALL, .adv_filter_policy = ADV_FILTER_ALLOW_SCAN_ANY_CON_ANY, }; Estos par\u00e1metros configuran el intervalo de anuncio entre 20 ms y 40 ms. El anuncio es de tipo ADV_TYPE_IND (tipo gen\u00e9rico), destinados a ning\u00fan dispositivo central en particular, y anuncia que el servidor GATT es conectable. El tipo de direcci\u00f3n es p\u00fablico, utiliza todos los canales y permite peticiones de escaneo y conexi\u00f3n por parte de cualquier dispositivo central. Si el proceso de anuncio se inici\u00f3 correctamente, se emitir\u00e1 un evento de tipo ESP_GAP_BLE_ADV_START_COMPLETE_EVT , que en este ejemplo se utiliza para comprobar si el estado de anuncio es realmente anunciando u otro, en cuyo caso se emitir\u00e1 un mensaje de error: ... case ESP_GAP_BLE_ADV_START_COMPLETE_EVT: //advertising start complete event to indicate advertising start successfully or failed if (param->adv_start_cmpl.status != ESP_BT_STATUS_SUCCESS) { ESP_LOGE(GATTS_TABLE_TAG, \"Advertising start failed\\n\"); } break; ...","title":"El manejador de eventos GAP"},{"location":"RPI-I/P4/#manejadores-de-eventos-gatt","text":"Al registrar un Pefil de Aplicaci\u00f3n, se emite un evento de tipo ESP_GATTS_REG_EVT . Los par\u00e1metros asociados al evento son: esp_gatt_status_t status; /*!< Operation status */ uint16_t app_id; /*!< Application id which input in register API */ Adem\u00e1s de los anteriores par\u00e1metros, el evento tambi\u00e9n contiene la interfaz GATT asignada por la pila BLE, a utilizar a partir de ahora. El evento es capturado por el manejador gatts_event_handler() , que almacena la interfaz generada en la tabla de perfiles, y la reenv\u00eda al manejador de eventos correspondiente al perfil: static void gatts_event_handler(esp_gatts_cb_event_t event, esp_gatt_if_t gatts_if, esp_ble_gatts_cb_param_t *param) { ESP_LOGI(GATTS_TABLE_TAG, \"EVT %d, gatts if %d\\n\", event, gatts_if); /* If event is register event, store the gatts_if for each profile */ if (event == ESP_GATTS_REG_EVT) { if (param->reg.status == ESP_GATT_OK) { heart_rate_profile_tab[HEART_PROFILE_APP_IDX].gatts_if = gatts_if; } else { ESP_LOGI(GATTS_TABLE_TAG, \"Reg app failed, app_id %04x, status %d\\n\", param->reg.app_id, param->reg.status); return; } } do { int idx; for (idx = 0; idx < HEART_PROFILE_NUM; idx++) { if (gatts_if == ESP_GATT_IF_NONE || /* ESP_GATT_IF_NONE, not specify a certain gatt_if, need to call every profile cb function */ gatts_if == heart_rate_profile_tab[idx].gatts_if) { if (heart_rate_profile_tab[idx].gatts_cb) { heart_rate_profile_tab[idx].gatts_cb(event, gatts_if, param); } } } } while (0); }","title":"Manejadores de eventos GATT"},{"location":"RPI-I/P4/#creacion-de-servicios-y-caracteristicas-con-una-tabla-de-atributos","text":"Aprovecharemos el evento de tipo Registro para crear una tabla de atributos de perfil utilizando la funci\u00f3n esp_ble_gatts_create_attr_tab() . Esta funci\u00f3n toma como argumento una estructura de tipo esp_gatts_attr_db_t , que corresponde a una tabla de lookup indexada por los valores de la enumeraci\u00f3n definidos en el fichero de cabecera. La estructura esp_gatts_attr_db_t tiene dos miembros: esp_attr_control_t attr_control; /*!< The attribute control type*/ esp_attr_desc_t att_desc; /*!< The attribute type*/ attr_control es el par\u00e1metro de autorespuesta, t\u00edpicamente fijado a ESP_GATT_AUTO_RSP para permitir que la pila BLE reponda autom\u00e1ticamente a los mensajes de lectura o escritura cuando dichos eventos son recibidos. Una opci\u00f3n alternativa es ESP_GATT_RSP_BY_APP que permite respuestas manuales utilizando la funci\u00f3n esp_ble_gatts_send_response() . att_desc es la descripci\u00f3n del atributo, formada por: uint16_t uuid_length; /*!< UUID length */ uint8_t *uuid_p; /*!< UUID value */ uint16_t perm; /*!< Attribute permission */ uint16_t max_length; /*!< Maximum length of the element*/ uint16_t length; /*!< Current length of the element*/ uint8_t *value; /*!< Element value array*/ Por ejemplo, el primer elemento de la tabla en el ejemplo es el atributo de servicio: [HRS_IDX_SVC] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&primary_service_uuid, ESP_GATT_PERM_READ, sizeof(uint16_t), sizeof(heart_rate_svc), (uint8_t *)&heart_rate_svc}}, Los valores de inicializaci\u00f3n son: [HRS_IDX_SVC] : Inicializador en la tabla. ESP_GATT_AUTO_RSP : configuraci\u00f3n de respuesta autom\u00e1tica, fijada en este caso a respuesta autom\u00e1tica por parte de la pila BLE. ESP_UUID_LEN_16 : longitudo del UUID fijada a 16 bits. (uint8_t *)&primary_service_uuid : UUID para identificar al servicio como primario (0x2800). ESP_GATT_PERM_READ : Permisos de lectura para el servicio. sizeof(uint16_t) : Longitud m\u00e1xima del UUID del servicio (16 bits). sizeof(heart_rate_svc) : Longitud del servicio, en este caso 16 bits (fijada por el tama\u00f1o de la variable heart_rate_svc ). (uint8_t *)&heart_rate_svc : Valor del atributo servicio fijada a la variable the variable heart_rate_svc , que contiene el UUID del Heart Rate Service (0x180D). El resto de atributos se inicializan de forma similar. Algunos atributos tambi\u00e9n tienen activa la propiedad NOTIFY , que se establece v\u00eda &char_prop_notify . La tabla completa se inicializa como sigue: /// Full HRS Database Description - Used to add attributes into the database static const esp_gatts_attr_db_t heart_rate_gatt_db[HRS_IDX_NB] = { // Heart Rate Service Declaration [HRS_IDX_SVC] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&primary_service_uuid, ESP_GATT_PERM_READ, sizeof(uint16_t), sizeof(heart_rate_svc), (uint8_t *)&heart_rate_svc}}, // Heart Rate Measurement Characteristic Declaration [HRS_IDX_HR_MEAS_CHAR] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&character_declaration_uuid, ESP_GATT_PERM_READ, CHAR_DECLARATION_SIZE,CHAR_DECLARATION_SIZE, (uint8_t *)&char_prop_notify}}, // Heart Rate Measurement Characteristic Value [HRS_IDX_HR_MEAS_VAL] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&heart_rate_meas_uuid, ESP_GATT_PERM_READ, HRPS_HT_MEAS_MAX_LEN,0, NULL}}, // Heart Rate Measurement Characteristic - Client Characteristic Configuration Descriptor [HRS_IDX_HR_MEAS_NTF_CFG] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&character_client_config_uuid, ESP_GATT_PERM_READ|ESP_GATT_PERM_WRITE, sizeof(uint16_t),sizeof(heart_measurement_ccc), (uint8_t *)heart_measurement_ccc}}, // Body Sensor Location Characteristic Declaration [HRS_IDX_BOBY_SENSOR_LOC_CHAR] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&character_declaration_uuid, ESP_GATT_PERM_READ, CHAR_DECLARATION_SIZE,CHAR_DECLARATION_SIZE, (uint8_t *)&char_prop_read}}, // Body Sensor Location Characteristic Value [HRS_IDX_BOBY_SENSOR_LOC_VAL] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&body_sensor_location_uuid, ESP_GATT_PERM_READ, sizeof(uint8_t), sizeof(body_sensor_loc_val), (uint8_t *)body_sensor_loc_val}}, // Heart Rate Control Point Characteristic Declaration [HRS_IDX_HR_CTNL_PT_CHAR] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&character_declaration_uuid, ESP_GATT_PERM_READ, CHAR_DECLARATION_SIZE,CHAR_DECLARATION_SIZE, (uint8_t *)&char_prop_read_write}}, // Heart Rate Control Point Characteristic Value [HRS_IDX_HR_CTNL_PT_VAL] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&heart_rate_ctrl_point, ESP_GATT_PERM_WRITE|ESP_GATT_PERM_READ, sizeof(uint8_t), sizeof(heart_ctrl_point), (uint8_t *)heart_ctrl_point}}, };","title":"Creaci\u00f3n de Servicios y Caracter\u00edsticas con una Tabla de Atributos"},{"location":"RPI-I/P4/#inicializacion-del-servicio","text":"Cuando la tabla se crea, se emite un evento de tipo ESP_GATTS_CREAT_ATTR_TAB_EVT . Este evento tiene los siguientes par\u00e1metros asociados: esp_gatt_status_t status; /*!< Operation status */ esp_bt_uuid_t svc_uuid; /*!< Service uuid type */ uint16_t num_handle; /*!< The number of the attribute handle to be added to the gatts database */ uint16_t *handles; /*!< The number to the handles */ Este ejemplo utiliza este evento para mostrar informaci\u00f3n y comprobar que el tama\u00f1o de la tabla creada es igual al n\u00famero de elementos en la enumeraci\u00f3n HRS_IDX_NB . Si la tabla se cre\u00f3 correctamente, los manejadores de atributos se copian en la tabla de manejadores heart_rate_handle_table y el servicio se inicicaliza utilizando la funci\u00f3n esp_ble_gatts_start_service() : case ESP_GATTS_CREAT_ATTR_TAB_EVT:{ ESP_LOGI(GATTS_TABLE_TAG, \"The number handle =%x\\n\",param->add_attr_tab.num_handle); if (param->add_attr_tab.status != ESP_GATT_OK){ ESP_LOGE(GATTS_TABLE_TAG, \"Create attribute table failed, error code=0x%x\", param->add_attr_tab.status); } else if (param->add_attr_tab.num_handle != HRS_IDX_NB){ ESP_LOGE(GATTS_TABLE_TAG, \"Create attribute table abnormally, num_handle (%d) \\ doesn't equal to HRS_IDX_NB(%d)\", param->add_attr_tab.num_handle, HRS_IDX_NB); } else { memcpy(heart_rate_handle_table, param->add_attr_tab.handles, sizeof(heart_rate_handle_table)); esp_ble_gatts_start_service(heart_rate_handle_table[HRS_IDX_SVC]); } break; Los manejadores almacenados son n\u00fameros que identifican cada atributo. Estos manejadores pueden usarse para determinar qu\u00e9 caracter\u00edstica est\u00e1 siendo le\u00edda o escrita, y por tanto pueden ser proporcionados a otros puntos de la aplicaci\u00f3n para manejar distintas acciones. Finalmente, la tabla heart_rate_handle_table contiene el Perfil de Aplicaci\u00f3n en forma de estructura con informaci\u00f3n sobre los par\u00e1metros de los atributos y la interfaz GATT, ID de conexi\u00f3n, permisos e ID de aplicaci\u00f3n. La estructura presenta los siguientes campos (no todos se usan en el ejemplo): struct gatts_profile_inst { esp_gatts_cb_t gatts_cb; uint16_t gatts_if; uint16_t app_id; uint16_t conn_id; uint16_t service_handle; esp_gatt_srvc_id_t service_id; uint16_t char_handle; esp_bt_uuid_t char_uuid; esp_gatt_perm_t perm; esp_gatt_char_prop_t property; uint16_t descr_handle; esp_bt_uuid_t descr_uuid; };","title":"Inicializaci\u00f3n del servicio"},{"location":"RPI-I/P4/#interaccion-a-traves-de-un-cliente-gatt","text":"Nota Para desarrollar esta parte de la pr\u00e1ctica, deber\u00e1s importar la m\u00e1quina virtual del curso en el PC del laboratorio, y hacer visible a ella el dispositivo Bluetooth del equipo de laboratorio. Nota Existen multitud de herramientas que permiten gestionar la conexi\u00f3n al servidor GATT. En Linux, utilizaremos hcitool y gatttool ; en Windows, puedes utilizar una herramienta llamada Bluetooth LE Explorer , que implementa, aunque de forma gr\u00e1fica, la misma funcionalidad.","title":"Interacci\u00f3n a trav\u00e9s de un cliente GATT"},{"location":"RPI-I/P4/#uso-de-hcitool-y-gatttool-en-modo-cliente","text":"","title":"Uso de hcitool y gatttool en modo cliente"},{"location":"RPI-I/P4/#escaneando-dispositivos-disponibles-hcitool","text":"hcitool es una herramienta de l\u00ednea de comandos que permite gestionar la interfaz Bluetooth del equipo en el que se ejecuta. En nuestro caso, necesitaremos determinar la direcci\u00f3n MAC Bluetooth de nuestro servidor. Para ello, en primer lugar, realizaremos un escaneado de los dispsitivos BLE disponibles en el entorno utilizando la orden: sudo hcitool lescan Si todo ha ido bien, se mostrar\u00e1 una l\u00ednea por dispositivo BLE disponible y en fase de anuncio. Entre ellos, deberemos encontrar nuestro dispositivo, para recordar su direcci\u00f3n MAC. Tarea Edita el fichero main/gatts_table_creat_demo.c y modifica el nombre de tu dispositivo, que se anunciar\u00e1 en cada anuncio emitido en la fase de advertising . Para ello, debes modificar el campo correspondiente de la estructura raw_adv_data . A continuaci\u00f3n, compila y flashea el ejemplo, y comienza una sesi\u00f3n de escaneado de dispositivos BLE mediante la orden: sudo hcitool lescan . Deber\u00e1s observar tu dispositivo en una de las l\u00edneas. Anota o recuerda su direcci\u00f3n MAC.","title":"Escaneando dispositivos disponibles: hcitool"},{"location":"RPI-I/P4/#interactuando-con-el-servidor-gatt-gatttool","text":"Una vez obtenida la direcci\u00f3n MAC Bluetooth del dispositivo, deberemos proceder en dos fases. La primera de ellas es el emparejado al dispostivo desde tu consola. La segunda, la interacci\u00f3n con la tabla GATT. En ambos casos, se utilizar\u00e1 la herramienta gatttool desde l\u00ednea de comandos. Para comenzar una sesi\u00f3n gatttool , invocaremos a la herramienta en modo interactivo, utilizando la orden: gatttool -b MAC -I Esto abrir\u00e1 una consola interactiva, a la espera de las ordenes correspondientes. Para realizar el emparejamiento, y considerando que la MAC Bluetooth es ya conocida, utilizaremos la orden connect . Si todo ha ido bien, deberemos observar un cambio en el color del prompt, y un mensaje Connection successful . En este punto, observa como en la salida de depuraci\u00f3n del ESP32 se muestran los mensajes correspondientes al proceso de emparejamiento. Desde la terminal de gatttool , puedes ejecutar en cualquier momento la orden help para obtener ayuda (en forma de lista de comandos disponibles): gatttool -b 24:6F:28:36:60:B2 -I [24:6F:28:36:60:B2][LE]> connect Attempting to connect to 24:6F:28:36:60:B2 Connection successful [24:6F:28:36:60:B2][LE]> help help Show this help exit Exit interactive mode quit Exit interactive mode connect [address [address type]] Connect to a remote device disconnect Disconnect from a remote device primary [UUID] Primary Service Discovery included [start hnd [end hnd]] Find Included Services characteristics [start hnd [end hnd [UUID]]] Characteristics Discovery char-desc [start hnd] [end hnd] Characteristics Descriptor Discovery char-read-hnd <handle> Characteristics Value/Descriptor Read by handle char-read-uuid <UUID> [start hnd] [end hnd] Characteristics Value/Descriptor Read by UUID char-write-req <handle> <new value> Characteristic Value Write (Write Request) char-write-cmd <handle> <new value> Characteristic Value Write (No response) sec-level [low | medium | high] Set security level. Default: low mtu <value> Exchange MTU for GATT/ATT Comenzaremos consultando la lista de caracter\u00edsticas del servidor GATT. Tarea Mediante el comando correspondiente ( characteristics ), consulta y anota las caracter\u00edsticas disponibles en tu servidor GATT. Una de estas caracter\u00edsticas ser\u00e1 de crucial inter\u00e9s, ya que nos permitir\u00e1 acceder, a trav\u00e9s de su UUID, a la medici\u00f3n instant\u00e1nea de ritmo card\u00edaco, as\u00ed como a la configuraci\u00f3n de notificaciones sobre dicho valor. Para determinar cu\u00e1l de las l\u00edneas es la que nos interesa, observa el valor de UUID devuelta para cada una de ellas, y determina, en funci\u00f3n de la macro GATTS_CHAR_UUID_TEST_A de cu\u00e1l se trata. Para interactuar con dicha caracter\u00edstica, necesitaremos un manejador ( handler ) que permita un uso m\u00e1s sencillo de la misma desde la herramienta gatttool . Dicho manejador se muestra, para cada l\u00ednea, tras la cadena char value handle . Tarea El manejador que permite leer desde la caracter\u00edstica *Heart Rate Value\" tiene un manejador de tipo car\u00e1cter asociado. Anota su valor. Para leer el valor de la caracter\u00edstica, podemos utilizar su manejador asociado. As\u00ed, podemos obtener dicho valor con un comando de lectura, en este caso char-read-hnd manejador . Tarea Obt\u00e9n los datos de lectura de la caracter\u00edstica de medici\u00f3n del valor de monitorizaci\u00f3n de ritmo card\u00edaco. \u00bfCu\u00e1les son? Deber\u00edas observar un valor de retorno de cuatro bytes con valor 0x00. Estos valores corresponden a los de la variable char_value de tu c\u00f3digo. Modif\u00edcalos, recompila y vuelve a flashear el c\u00f3digo. \u00bfHan variado? Tarea Intenta ahora escribir en la anterior caracter\u00edstica. Para ello, utiliza el comando char-write-cmd handler valor , siendo valor, por ejemplo, 11223344 . \u00bfEs posible? \u00bfPor qu\u00e9? Escribiremos a continuaci\u00f3n en la caracter\u00edstica de configuraci\u00f3n del servicio de montorizaci\u00f3n. Para ello, utilizaremos el manejador siguiente al utilizado anteriormente. Esto es, si se nos devolvi\u00f3, por ejemplo, un manejador 0x0001 para el valor de monitorizaci\u00f3n, el valor de configuraci\u00f3n ser\u00e1 0x0002 . Tarea Intenta ahora escribir en la caracter\u00edstica de configuraci\u00f3n. Para ello, utiliza el comando char-write-cmd handler valor , siendo valor, por ejemplo, 0100 . \u00bfEs posible? \u00bfPor qu\u00e9? Como habr\u00e1s observado, es posible leer desde el valor de monitorizaci\u00f3n, y escribir en el valor de configuraci\u00f3n. Utilizaremos esta \u00faltima caracter\u00edstica para configurar las notificaciones sobre el valor de monitorizaci\u00f3n. De este modo, cada vez que se desee enviar dicho valor a los clientes que tengan activada la notificaci\u00f3n, \u00e9stos la recibir\u00e1n sin necesidad de cambio alguno. Para ello, necesitamos modificar algunas partes de nuestro c\u00f3digo. Espec\u00edficamente, necesitaremos: Crear una nueva tarea que, peri\u00f3dicamente, modifique el valor de monitorizaci\u00f3n de ritmo card\u00edaco (ley\u00e9ndolo desde un sensor, si est\u00e1 disponible, o, en nuestro caso generando un valor aleatorio). Dicha tarea consistir\u00e1 en un bucle infinito que, en cualquier caso, s\u00f3lo enviar\u00e1 datos al cliente si la notificaci\u00f3n est\u00e1 activa, con un intervalo de env\u00edo de un segundo: static void publish_data_task(void *pvParameters) { while (1) { ESP_LOGI(\"APP\", \"Sending data...\"); // Paso 1: Actualizo valor... // Paso 2: Si notificaci\u00f3n activa... // Paso 3: Env\u00edo datos... // Paso 4: Duermo un segundo... vTaskDelay( 1000. / portTICK_PERIOD_MS); } } Esta rutina deber\u00e1 crearse en respuesta al evento de conexi\u00f3n por parte de un cliente, utilizando, por ejemplo, la invocaci\u00f3n a: xTaskCreate(&publish_data_task, \"publish_data_task\", 4096, NULL, 5, NULL); La actualizaci\u00f3n del valor, realizada peri\u00f3dicamente y de forma aleatoria, modificar\u00e1 el byte 1 de la variable char_value , tomando un valor aleatorio entre 0 y 255 (como nota adicional, los puls\u00f3metros actuales soportan valores mayores para ritmo cardiaco, aunque la configuraci\u00f3n de esta funcionalidad est\u00e1 fuera del alcance de la pr\u00e1ctica). La comprobaci\u00f3n de la activaci\u00f3n o no de la notificaci\u00f3n se realiza consultando los dos bytes de la variable heart_meaurement_ccc . Si dichos valores son 0x01 y 0x00 (posiciones 0 y 1, respectivamente), las notificaciones est\u00e1n activas, y por tanto, se realizar\u00e1 el env\u00edo de notificaci\u00f3n. Para enviar la notificaci\u00f3n, utilizaremos la siguiente funci\u00f3n: esp_ble_gatts_send_indicate(heart_rate_profile_tab[0].gatts_if, heart_rate_profile_tab[0].conn_id, heart_rate_handle_table[IDX_CHAR_VAL_A], sizeof(char_value), char_value, false); La activaci\u00f3n de notificaciones desde gatttool se realizar\u00e1 mediante la escritura del valor 0x0100 en la caracter\u00edstica de configuraci\u00f3n, esto es: char-write-cmd HANDLER 0100 Nuestro firmware deber\u00e1 modificarse para que, al recibir dicho valor en la caracter\u00edstica, se sobreescriba el contenido de la variable heart_measurement_ccc . Esta escritura debe realizarse en respuesta al evento ESP_GATTS_WRITE_EVT . Tarea entregable Modifica el firmware original para que, peri\u00f3dicamente (cada segundo) notifique el valor de ritmo card\u00edaco a los clientes conectados. Si adem\u00e1s modificas las UUID por las proporcionadas en la especificaci\u00f3n Bluetooth para el Servicio Heart Rate y todo ha sido configurado correctamente, tu ESP32 deber\u00eda poder interactuar con cualquier monitor de ritmo cardiaco para, por ejemplo, Android. Para ello, utiliza las siguientes UUIDs: static const uint16_t GATTS_SERVICE_UUID_TEST = 0x180D; //0x00FF; static const uint16_t GATTS_CHAR_UUID_TEST_A = 0x2A37; //0xFF01; static const uint16_t GATTS_CHAR_UUID_TEST_B = 0x2A38; //0xFF02; static const uint16_t GATTS_CHAR_UUID_TEST_C = 0x2A39; //0xFF03; Entrega el c\u00f3digo modificado, as\u00ed como evidencias (capturas de pantalla) que demuestren que un cliente gatttool suscrito a notificaciones recibe, cada segundo, la actualizaci\u00f3n de ritmo card\u00edaco por parte del sensor.","title":"Interactuando con el servidor GATT: gatttool"},{"location":"RPI-I/P5/","text":"Pr\u00e1ctica 4. Bluetooth Mesh (BLE MESH) Objetivos Poner en pr\u00e1ctica los conceptos estudiados en teor\u00eda en relaci\u00f3n a BLE MESH, espec\u00edficamente provisionamiento y modelos cliente/servidor. Desplegar una infraestructura de provisionamiento de un modelo ONOFF GENERIC SERVER con provisionamiento desde aplicaci\u00f3n m\u00f3vil para el control remoto de encendido/apagado LED. Desplegar una infraestructura de provisionamiento de un modelo GENERIC SENSOR con provisionamiento desde ESP32. Requisitos previos En primer lugar, instala la \u00faltima versi\u00f3n de ESP-IDF para el desarrollo de esta pr\u00e1ctica. Aseg\u00farate de que, tras el clonado del repostitorio, realizas la instalaci\u00f3n de requisitos correspondiente, y de que exportas las variables de entorno (v\u00eda export.sh ) correctas. Es importante que te asegures de la correcta configuraci\u00f3n del entorno. En segundo lugar, deber\u00e1s rellenar la hoja Excel correspondiente a tu puesto con la direcci\u00f3n MAC Bluetooth de tu dispositivo, que podr\u00e1s obtener con cualquier mecanismo que hayas utilizado en pr\u00e1cticas anteriores. Los c\u00f3digos que estudiaremos en la pr\u00e1ctica se encuentran en el directorio examples/bluetooth/esp_ble_mesh/ble_mesh_node en el caso del sistema OnOff (primera parte de la pr\u00e1ctica) y ble_mesh_sensor_model en el caso del modelo sensor (segunda parte de la pr\u00e1ctica). Por \u00faltimo, descarga e instala la aplicaci\u00f3n (disponible para Android e IOS) nRF Mesh . Ejemplo para el modelo ON-OFF MODEL El servidor ON-OFF El servidor implementa un \u00fanico elemento, en el cual se integran dos modelos distintos: Modelo Configuration Server , que implementa la configuraci\u00f3n de claves de aplicaci\u00f3n ( AppKey ), as\u00ed como configuraciones gen\u00e9ricas del servidor como suscripciones, tama\u00f1o de TTL o funcionalidad de relay de mensajes. Modelo Generic OnOff Server , que implementa la funcionalidad b\u00e1sica de encendido/apagado de una luz. El c\u00f3digo en el fichero ble_mesh_demo_main.c contiene la funcionalidad b\u00e1sica del servidor, que podemos resumir en: Inicializaci\u00f3n de la pila BLE ( bluedroid ). Inicializaci\u00f3n de la pila BLE Mesh. Registro de las funciones de callback para el proceso de provisionamiento y del modelo o modelos implementados. Implementaci\u00f3n e inicializaci\u00f3n del elemento BLE Mesh. Implementaci\u00f3n e inicializaci\u00f3n del modelo Configuration Server y Generic OnOff Server . Soporte para operaciones Get Opcode y Set Opcode en el modelo de configuraci\u00f3n. An\u00e1lisis b\u00e1sico de c\u00f3digo Inicializaci\u00f3n y activaci\u00f3n de la pila BLE Mesh Tras la inicializaci\u00f3n del sistema, la tarea principal ( app_main ) se encarga de la incializaci\u00f3n de las pilas BLE y BLE Mesh: void app_main(void) { int err; ESP_LOGI(TAG, \"Initializing...\"); board_init(); err = bluetooth_init(); if (err) { ESP_LOGE(TAG, \"esp32_bluetooth_init failed (err %d)\", err); return; } /* Initializes the Bluetooth Mesh Subsystem */ err = ble_mesh_init(); if (err) { ESP_LOGE(TAG, \"Bluetooth mesh init failed (err %d)\", err); } } En particular, el c\u00f3digo incluye invocaciones a bluetooth_init() y ble_mesh_init() , que se encargan de ambas inicializaciones. La inicializaci\u00f3n de la pila BLE Mesh requiere alguna explicaci\u00f3n adicional: static esp_err_t ble_mesh_init(void) { int err = 0; memcpy(dev_uuid + 2, esp_bt_dev_get_address(), BLE_MESH_ADDR_LEN); // See comment 1 esp_ble_mesh_register_prov_callback(esp_ble_mesh_prov_cb); esp_ble_mesh_register_custom_model_callback(esp_ble_mesh_model_cb); err = esp_ble_mesh_init(&provision, &composition); if (err) { ESP_LOGE(TAG, \"Initializing mesh failed (err %d)\", err); return err; } esp_ble_mesh_node_prov_enable(ESP_BLE_MESH_PROV_ADV | ESP_BLE_MESH_PROV_GATT); ESP_LOGI(TAG, \"BLE Mesh Node initialized\"); board_led_operation(LED_G, LED_ON); return err; } Observa que el c\u00f3digo incluye la siguiente funcionalidad: esp_ble_mesh_register_prov_callback(esp_ble_mesh_prov_cb) : registra la funci\u00f3n de callback para la pila BLE Mesh. Esta funci\u00f3n se ejecuta durante el proceso de configuraci\u00f3n, y permite a la pila BLE Mesh generar eventos y notificar a la aplicaci\u00f3n sobre hitos importantes en el proceso de configuraci\u00f3n. Los eventos principales que pueden emitirse son: ESP_BLE_MESH_PROVISION_REG_EVT : generado cuando se completa el proceso de incializaci\u00f3n de BLE Mesh. ESP_BLE_MESH_NODE_PROV_LINK_OPEN_EVT : generado cuando un provisionador y un dispositivo no provisionado establecen un enlace. ESP_BLE_MESH_NODE_PROV_LINK_CLOSE_EVT : generado para notificar a la aplicaci\u00f3n que se ha roto un enlace con un dispositivo asociado. ESP_BLE_MESH_NODE_PROV_COMPLETE_EVT : recibido por la aplicaci\u00f3n cuando el proceso de provisionamiento se completa. esp_ble_mesh_register_custom_model_callback(esp_ble_mesh_model_cb) : registra la funci\u00f3n de callback asociada al modelo. Esta funci\u00f3n se utiliza cuando el otro extremo de la comunicaci\u00f3n solicita operaciones sobre el modelo, y es capaz de emitir los siguientes eventos principales: ESP_BLE_MESH_MODEL_OPERATION_EVT : se puede generar en dos situaciones: El modelo servidor recibe un Get Status o Set Status desde un modelo cliente. El modelo cliente recibe un Status State desde un modelo servidor. ESP_BLE_MESH_MODEL_SEND_COMP_EVT : generado despu\u00e9s de que el modelo servidor env\u00ede un Status State a trav\u00e9s de la funci\u00f3n esp_ble_mesh_server_model_send_msg . ESP_BLE_MESH_MODEL_PUBLISH_COMP_EVT : generado despu\u00e9s de que la aplicaci\u00f3n complete la invocaci\u00f3n a esp_ble_mesh_model_publish_msg para publicar mensajes. ESP_BLE_MESH_CLIENT_MODEL_SEND_TIMEOUT_EVT : generado cuando el modelo cliente invoca a la funci\u00f3n esp_ble_mesh_client_model_send_msg , pero no recibe mensaje de ACK de vuelta. ESP_BLE_MESH_MODEL_PUBLISH_UPDATE_EVT : generado despu\u00e9s de que la aplicaci\u00f3n configure la funci\u00f3n de publicaci\u00f3n para enviar de forma peri\u00f3dica mensajes al otro extremo. esp_ble_mesh_node_prov_enable(ESP_BLE_MESH_PROV_ADV | ESP_BLE_MESH_PROV_GATT) : activa el proceso de Anuncio y Escaneo, haciendo visible al dispositivo para potenciales provisionadores que est\u00e9n a la escucha. board_led_operation(LED_G, LED_ON) : inicializa un hipot\u00e9tico LED RGB, que se controlar\u00e1 remotamente. En este punto, la inicializaci\u00f3n de la pila BLE Mesh deber\u00eda estar completa, por lo que un provisionador podr\u00eda identificar dispositivos para privisonamiento de par\u00e1metros de red y transmisi\u00f3n de datos. Implementaci\u00f3n de la estructura BLE Mesh Element A continuaci\u00f3n, se detallan los pasos necesarios para, en el servidor: Completar la inicializaci\u00f3n del sistema. A\u00f1adir un elemento y un modelo al servidor. Elegir distintas implementaciones de encriptaci\u00f3n. Declarar las caracter\u00edsticas de Proxy , Relay , Low Power y Friend del nodo. En primer lugar, para declarar y definir un elemento y un modelo asociado, utilizaremos las siguientes estructuras: /*!< Abstraction that describes a BLE Mesh Element. This structure is associated with bt_mesh_elem in mesh_access.h */ typedef struct { /* Element Address, it is assigned during provisioning. */ uint16_t element_addr; /* Location Descriptor (GATT Bluetooth Namespace Descriptors) */ const uint16_t location; /* Model count */ const uint8_t sig_model_count; const uint8_t vnd_model_count; /* Models */ esp_ble_mesh_model_t *sig_models; esp_ble_mesh_model_t *vnd_models; } esp_ble_mesh_elem_t; As\u00ed, podemos mantener informaci\u00f3n sobre los elementos disponibles en el vector elements : static esp_ble_mesh_elem_t elements[] = { ESP_BLE_MESH_ELEMENT(0, root_models, ESP_BLE_MESH_MODEL_NONE), }; La implementaci\u00f3n y definici\u00f3n de un modelo se realiza de forma similar: static esp_err_t ble_mesh_init(void) { int err = 0; memcpy(dev_uuid + 2, esp_bt_dev_get_address(), BLE_MESH_ADDR_LEN); // See comment 1 esp_ble_mesh_register_prov_callback(esp_ble_mesh_prov_cb); esp_ble_mesh_register_custom_model_callback(esp_ble_mesh_model_cb); err = esp_ble_mesh_init(&provision, &composition); if (err) { ESP_LOGE(TAG, \"Initializing mesh failed (err %d)\", err); return err; } esp_ble_mesh_node_prov_enable(ESP_BLE_MESH_PROV_ADV | ESP_BLE_MESH_PROV_GATT); ESP_LOGI(TAG, \"BLE Mesh Node initialized\"); board_led_operation(LED_G, LED_ON); return err; } Del mismo modo, podemos usar el array root_models para almacenar los modelos creados: static esp_ble_mesh_model_t root_models[] = { ESP_BLE_MESH_MODEL_CFG_SRV(&config_server), ESP_BLE_MESH_SIG_MODEL(ESP_BLE_MESH_MODEL_ID_GEN_ONOFF_SRV, onoff_op, &onoff_pub, &led_state[0]), }; Distintos modelos requieren diferentes macros (en este caso, ya que vamos a implementar un modelo Generic OnOff Server , hemos utilizado ESP_BLE_MESH_MODEL_ID_GEN_ONOFF_SRV ). Otra estructura importante en un modelo son los punteros esp_ble_mesh_model_op_t *op . Estas estructuras apuntan a la estrcutura de operaci\u00f3n que define el estado del modelo. Generalmente, hay dos tipos de modelos en BLE Mesh: Modelo servidor : Consiste en uno o varios estados que pueden existir y abarcar varios elementos. Define los mensajes enviados/recibidos por el modelo, junto con el comportamiento del elemento. Por ejemplo, un cambio entre On y Off en un interruptor indica el estado de On/Off en el modelo. Modelo cliente : Define los mensajes usados por el cliente para solicitar, modificar o usar el estado del servidor. Por ejemplo, un cambio entre un On y Off en un interruptor (cliente) indica el mensaje de On/Off enviado por el cliente. El siguiente c\u00f3digo muestra la declaraci\u00f3n de la estructura operaci\u00f3n asociada al Modelo del servidor: /*!< Model operation context. This structure is associated with bt_mesh_model_op in mesh_access.h */ typedef struct { const uint32_t opcode; /* Opcode encoded with the ESP_BLE_MESH_MODEL_OP_* macro */ const size_t min_len; /* Minimum required message length */ esp_ble_mesh_cb_t param_cb; /* The callback is only used for the BLE Mesh stack, not for the app layer. */ } esp_ble_mesh_model_op_t; Existe tres variables en la declaraci\u00f3n: opcode : c\u00f3digo de operaci\u00f3n asociado al estado. min_len : tama\u00f1o m\u00ednimo de los mensajes recibidos por el estado. Por ejemplo, para OnOff Get State , el tama\u00f1o es 0 (estamos leyendo), mientras que en el caso de OnOff Set State , el tama\u00f1o es 2 (incluye el valor a escribir). param_cb : par\u00e1metro interno utilizado por la pila BLE Mesh, t\u00edpicamente inicializado a 0. As\u00ed, la definici\u00f3n en el servidor quedar\u00eda: static esp_ble_mesh_model_op_t onoff_op[] = { { ESP_BLE_MESH_MODEL_OP_GEN_ONOFF_GET, 0, 0}, { ESP_BLE_MESH_MODEL_OP_GEN_ONOFF_SET, 2, 0}, { ESP_BLE_MESH_MODEL_OP_GEN_ONOFF_SET_UNACK, 2, 0}, /* Each model operation struct array must use this terminator * as the end tag of the operation uint. */ ESP_BLE_MESH_MODEL_OP_END, }; El cliente ON-OFF El cliente resulta mucho m\u00e1s sencillo en su funcionamiento. De forma gen\u00e9rica, simplemente define un modelo Client ON/OFF y espera a ser provisionado. Una vez completado el proceso de provisionamento, espera a la pulsaci\u00f3n de uno de los botones en la placa (RESET) para el env\u00edo a todos los nodos en la misma red de una solicitud de modificaci\u00f3n en el estado de activaci\u00f3n de las luces. Concretamente, nos interesan las siguientes definiciones. En el fichero board.c , observa la respusta a la pulsaci\u00f3n del bot\u00f3n: static void button_tap_cb(void* arg) { ESP_LOGI(TAG, \"tap cb (%s)\", (char *)arg); example_ble_mesh_send_gen_onoff_set(); } static void board_button_init(void) { button_handle_t btn_handle = iot_button_create(BUTTON_IO_NUM, BUTTON_ACTIVE_LEVEL); if (btn_handle) { iot_button_set_evt_cb(btn_handle, BUTTON_CB_RELEASE, button_tap_cb, \"RELEASE\"); } } void board_init(void) { board_led_init(); board_button_init(); } La funci\u00f3n invocada, example_ble_mesh_send_gen_onoff_set , realiza el env\u00edo de una operaci\u00f3n de tipo SET a todos los miembros de la red : void example_ble_mesh_send_gen_onoff_set(void) { esp_ble_mesh_generic_client_set_state_t set = {0}; esp_ble_mesh_client_common_param_t common = {0}; esp_err_t err = ESP_OK; common.opcode = ESP_BLE_MESH_MODEL_OP_GEN_ONOFF_SET_UNACK; common.model = onoff_client.model; common.ctx.net_idx = store.net_idx; common.ctx.app_idx = store.app_idx; common.ctx.addr = 0xFFFF; /* to all nodes */ common.ctx.send_ttl = 3; common.ctx.send_rel = false; common.msg_timeout = 0; /* 0 indicates that timeout value from menuconfig will be used */ common.msg_role = ROLE_NODE; set.onoff_set.op_en = false; set.onoff_set.onoff = store.onoff; set.onoff_set.tid = store.tid++; err = esp_ble_mesh_generic_client_set_state(&common, &set); if (err) { ESP_LOGE(TAG, \"Send Generic OnOff Set Unack failed\"); return; } store.onoff = !store.onoff; mesh_example_info_store(); /* Store proper mesh example info */ } Observa c\u00f3mo el mensaje se enviar\u00e1 a todos los nodos de la red ( common.ctx.addr = 0xFFFF; ). Provisionamiento y control desde una aplicaci\u00f3n m\u00f3vil En primer lugar, nos dividiremos en grupos de 3-4 personas. Uno de vosotros, utilizando la aplicaci\u00f3n m\u00f3vil nRF Mesh , actuar\u00e1 como provisionador de la red, proporcionando claves de red y aplicaci\u00f3n, as\u00ed como informaci\u00f3n b\u00e1sica de red (por ejemplo, direcciones unicast). Adem\u00e1s, podr\u00e1 crear grupos y suscribir/desuscribir modelos a dichos grupos. Adem\u00e1s, se requiere que uno de vuestros ESP32 act\u00fae como cliente, y el resto como servidores. As\u00ed, emularemos una sala con m\u00faltiples luces, y un s\u00f3lo interruptor que controlar\u00e1 su estado de encendido/apagado. PASO 1 : en la pantalla inicial se nos mostrar\u00e1n los nodos ya provisionados. En nuestro caso, inicialmente ninguno. PASO 2 : pincharemos sobre ADD NODE , y provisionaremos, uno a uno, todos los nodos que deseemos que formen parte de nuestra red (s\u00f3lo aquellos que forman parte de tu grupo de compa\u00f1eros): PASO 3 : antes de provisionar, generamos informaci\u00f3n de red para el nuevo nodo (lo identificamos ), presionando en IDENTIFY : PASO 4 : una vez generada la informaci\u00f3n de red, provisionamos el nodo ( PROVISION ): PASO 5 : si todo ha ido bien, se nos mostrar\u00e1 un mensaje de \u00e9xito como el siguiente: PASO 6 : tras repetir este paso con todos los nodos de nuestro grupo, veremos una pantalla como la siguiente. Observa y anota las direcciones unicast de cada nodo. Los nodos con un elemento son el cliente OnOff; los nodos con tres elementos (s\u00f3lo usaremos el primero) son los servidores OnOff: A continuaci\u00f3n, generar\u00e1s un grupo de nodos. Esto nos permitir\u00e1 suscribir a modelos al mismo, y publicar mensajes que se transmitir\u00e1n a todos los modelos del grupo. PASO 7 : crea un nuevo grupo pulsando el bot\u00f3n + . Dale el nombre y la direcci\u00f3n que desees, por ejemplo, Sala de Estar , 0xC000 . Si todo ha ido bien, se especificar\u00e1 que en el \u00fanico grupo disponible no hay ning\u00fan dispositivo suscrito/asociado. A continuaci\u00f3n, suscribiremos a cada modelo de los servidores y clientes (de tipo Generic On Off Server y Generic On Off Client ) al grupo creado. Esto lo har\u00e1s nodo a nodo, en primer lugar pincando en el modelo concreto: Y a continuaci\u00f3n asociando una clave de aplicaci\u00f3n ( BIND KEY ) y suscribiendo ( SUBSCRIBE ) al grupo deseado: Ahora, si vuelves a la descripci\u00f3n del grupo, ver\u00e1s que, tras pinchar, observas dos luces (o una por servidor) y un interruptor (correspondiente al cliente): En este punto, si est\u00e1s monitorizando la salida de todos los ESP32, ver\u00e1s que el estado del LED cambia a petici\u00f3n de la aplicaci\u00f3n. Adem\u00e1s, ver\u00e1s que tambi\u00e9n cambia si presionas el bot\u00f3n correspondiente del interruptor ( RESET ) en la placa. Tarea entregable El cliente env\u00eda, tras presionar un bot\u00f3n, el mensaje de tipo SET a todos los nodos de la red. Modif\u00edcalo para que \u00fanicamente se env\u00ede a los pertenecientes a tu grupo. Prueba a suscribir/desuscribir un modelo del grupo, y ver\u00e1s como ya no recibe los mensajes de solicitud de modificaci\u00f3n de estado. Ejemplo para el modelo SENSOR MODEL En este ejemplo, se implementa la creaci\u00f3n de un cliente de modelo sensor que, adem\u00e1s, es provisionador, y un servidor de modelo sensor configurable. El modelo Sensor Server es un modelo que permite exponer series de datos de sensorizaci\u00f3n. El modelo Sensor Client se usa para consumir valores de sensorizaci\u00f3n ( Sensor states ) expuestos por el servidor. Estos estados se componen de las siguientes partes: Estado Sensor Descriptor . Describe los datos del sensor, y es inmutable durante su vida. Estado Sensor Setting . Controla los par\u00e1metros del sensor. Por ejemplo, podr\u00eda indicar su sensibilidad, y podr\u00eda ser ajustado remotamente para prevenir que un sensor de movimiento se disparase ante peque\u00f1os movimientos. Estado Sensor Cadence . Controla la cadencia de sensorizaci\u00f3n. Estado Sensor Data . Contiene los valores de sensorizaci\u00f3n. Realmente, representa uno o m\u00e1s pares Property ID - Valor . Estado Sensor Series Column . S\u00f3lo utilizado si se considera cada uno de los valores como perteneciente a una serie de datos. En el ejemplo client , el dispositivo es a la vez un provisionador y un cliente. Una vez el dispositivo servidor es provisionado y configurado, los usuarios pueden presionar el bot\u00f3n de la placa para enviar al servidor peticiones que, sucesivamente, devolver\u00e1n el siguiente estado del sensor en orden ( Descriptor , Setting , Cadence , ...). En el ejemplo server , el dispositivo no provisonado implementa un modelo Sensor Server . El servidor soporta dos instancias de estados: la pimrea ( Property ID 0x0056 ) representar\u00eda la temperatura Indoor ; la segunda ( Property ID 0x005B ) representar\u00eda la temperatura Outdoor*. Todos los datos, en estos ejemplos, est\u00e1n preinicializados. Puesta en marcha En primer lugar, arranca en tu grupo un nodo cliente/provisionador, y monitoriza su salida. Cuando un compa\u00f1ero/a arranque un nodo servidor, ver\u00e1s que es provisionado por tu cliente, otorg\u00e1ndole una direcci\u00f3n unicast. An\u00f3tala. El funcionamiento general del sistema es: El dispositivo A ejecuta el ejemplo client , y el dispositivo B ejecuta el ejemplo server . A act\u00faa como provisionador. Tras recibir una petici\u00f3n por parte de B, lo provisiona y almacena su direcci\u00f3n. Observar\u00e1s la MAC BLE (UUID) de B en el proceso de provisionamiento desde A. En A, cada pulsaci\u00f3n del bot\u00f3n supondr\u00e1 una petici\u00f3n al nodo B. Sucesivamente, estas peticiones ser\u00e1n, en orden y por cada pulsaci\u00f3n: Sensor Descriptor . Sensor Cadence . Sensor Settings . Sensor Data . Sensor Series . Tarea Estudia el c\u00f3digo del cliente y del servidor, y observa a qu\u00e9 nodo se env\u00edan las peticiones desde el cliente, qu\u00e9 operaciones se solicitan en cada pulsaci\u00f3n de bot\u00f3n, y qu\u00e9 datos devuelve el servidor en cada caso. Tarea entregable Modifica el c\u00f3digo de cliente y/o servidor para que los valores de sensorizaci\u00f3n que se consulten en cada pulsaci\u00f3n del bot\u00f3n no sean todos los del modelo del \u00faltimo nodo provisonado, como ahora se hace, sino \u00fanicamente los datos de sensorizaci\u00f3n ( Sensor Data State ) de todos los nodos provisionados. As\u00ed, si hay tres nodos provisionados, cada pulsaci\u00f3n nos devolver\u00e1 el valor de sensorizaci\u00f3n de uno de ellos, por orden de provisionamiento. Como funcionalidad adicional, s\u00f3lo se provisionar\u00e1 autom\u00e1ticamente a aquellos nodos autorizados (los que pertenecen a tu sala, por ejemplo). Por \u00faltimo, opcionalmente, se pide que el valor sensorizado var\u00ede aleatoriamente de forma peri\u00f3dica en el servidor, con una cadencia predeterminada (la modificaci\u00f3n remota de la cadencia queda como ejercicio avanzado).","title":"Pr\u00e1ctica 5"},{"location":"RPI-I/P5/#practica-4-bluetooth-mesh-ble-mesh","text":"","title":"Pr\u00e1ctica 4. Bluetooth Mesh (BLE MESH)"},{"location":"RPI-I/P5/#objetivos","text":"Poner en pr\u00e1ctica los conceptos estudiados en teor\u00eda en relaci\u00f3n a BLE MESH, espec\u00edficamente provisionamiento y modelos cliente/servidor. Desplegar una infraestructura de provisionamiento de un modelo ONOFF GENERIC SERVER con provisionamiento desde aplicaci\u00f3n m\u00f3vil para el control remoto de encendido/apagado LED. Desplegar una infraestructura de provisionamiento de un modelo GENERIC SENSOR con provisionamiento desde ESP32.","title":"Objetivos"},{"location":"RPI-I/P5/#requisitos-previos","text":"En primer lugar, instala la \u00faltima versi\u00f3n de ESP-IDF para el desarrollo de esta pr\u00e1ctica. Aseg\u00farate de que, tras el clonado del repostitorio, realizas la instalaci\u00f3n de requisitos correspondiente, y de que exportas las variables de entorno (v\u00eda export.sh ) correctas. Es importante que te asegures de la correcta configuraci\u00f3n del entorno. En segundo lugar, deber\u00e1s rellenar la hoja Excel correspondiente a tu puesto con la direcci\u00f3n MAC Bluetooth de tu dispositivo, que podr\u00e1s obtener con cualquier mecanismo que hayas utilizado en pr\u00e1cticas anteriores. Los c\u00f3digos que estudiaremos en la pr\u00e1ctica se encuentran en el directorio examples/bluetooth/esp_ble_mesh/ble_mesh_node en el caso del sistema OnOff (primera parte de la pr\u00e1ctica) y ble_mesh_sensor_model en el caso del modelo sensor (segunda parte de la pr\u00e1ctica). Por \u00faltimo, descarga e instala la aplicaci\u00f3n (disponible para Android e IOS) nRF Mesh .","title":"Requisitos previos"},{"location":"RPI-I/P5/#ejemplo-para-el-modelo-on-off-model","text":"","title":"Ejemplo para el modelo ON-OFF MODEL"},{"location":"RPI-I/P5/#el-servidor-on-off","text":"El servidor implementa un \u00fanico elemento, en el cual se integran dos modelos distintos: Modelo Configuration Server , que implementa la configuraci\u00f3n de claves de aplicaci\u00f3n ( AppKey ), as\u00ed como configuraciones gen\u00e9ricas del servidor como suscripciones, tama\u00f1o de TTL o funcionalidad de relay de mensajes. Modelo Generic OnOff Server , que implementa la funcionalidad b\u00e1sica de encendido/apagado de una luz. El c\u00f3digo en el fichero ble_mesh_demo_main.c contiene la funcionalidad b\u00e1sica del servidor, que podemos resumir en: Inicializaci\u00f3n de la pila BLE ( bluedroid ). Inicializaci\u00f3n de la pila BLE Mesh. Registro de las funciones de callback para el proceso de provisionamiento y del modelo o modelos implementados. Implementaci\u00f3n e inicializaci\u00f3n del elemento BLE Mesh. Implementaci\u00f3n e inicializaci\u00f3n del modelo Configuration Server y Generic OnOff Server . Soporte para operaciones Get Opcode y Set Opcode en el modelo de configuraci\u00f3n.","title":"El servidor ON-OFF"},{"location":"RPI-I/P5/#analisis-basico-de-codigo","text":"Inicializaci\u00f3n y activaci\u00f3n de la pila BLE Mesh Tras la inicializaci\u00f3n del sistema, la tarea principal ( app_main ) se encarga de la incializaci\u00f3n de las pilas BLE y BLE Mesh: void app_main(void) { int err; ESP_LOGI(TAG, \"Initializing...\"); board_init(); err = bluetooth_init(); if (err) { ESP_LOGE(TAG, \"esp32_bluetooth_init failed (err %d)\", err); return; } /* Initializes the Bluetooth Mesh Subsystem */ err = ble_mesh_init(); if (err) { ESP_LOGE(TAG, \"Bluetooth mesh init failed (err %d)\", err); } } En particular, el c\u00f3digo incluye invocaciones a bluetooth_init() y ble_mesh_init() , que se encargan de ambas inicializaciones. La inicializaci\u00f3n de la pila BLE Mesh requiere alguna explicaci\u00f3n adicional: static esp_err_t ble_mesh_init(void) { int err = 0; memcpy(dev_uuid + 2, esp_bt_dev_get_address(), BLE_MESH_ADDR_LEN); // See comment 1 esp_ble_mesh_register_prov_callback(esp_ble_mesh_prov_cb); esp_ble_mesh_register_custom_model_callback(esp_ble_mesh_model_cb); err = esp_ble_mesh_init(&provision, &composition); if (err) { ESP_LOGE(TAG, \"Initializing mesh failed (err %d)\", err); return err; } esp_ble_mesh_node_prov_enable(ESP_BLE_MESH_PROV_ADV | ESP_BLE_MESH_PROV_GATT); ESP_LOGI(TAG, \"BLE Mesh Node initialized\"); board_led_operation(LED_G, LED_ON); return err; } Observa que el c\u00f3digo incluye la siguiente funcionalidad: esp_ble_mesh_register_prov_callback(esp_ble_mesh_prov_cb) : registra la funci\u00f3n de callback para la pila BLE Mesh. Esta funci\u00f3n se ejecuta durante el proceso de configuraci\u00f3n, y permite a la pila BLE Mesh generar eventos y notificar a la aplicaci\u00f3n sobre hitos importantes en el proceso de configuraci\u00f3n. Los eventos principales que pueden emitirse son: ESP_BLE_MESH_PROVISION_REG_EVT : generado cuando se completa el proceso de incializaci\u00f3n de BLE Mesh. ESP_BLE_MESH_NODE_PROV_LINK_OPEN_EVT : generado cuando un provisionador y un dispositivo no provisionado establecen un enlace. ESP_BLE_MESH_NODE_PROV_LINK_CLOSE_EVT : generado para notificar a la aplicaci\u00f3n que se ha roto un enlace con un dispositivo asociado. ESP_BLE_MESH_NODE_PROV_COMPLETE_EVT : recibido por la aplicaci\u00f3n cuando el proceso de provisionamiento se completa. esp_ble_mesh_register_custom_model_callback(esp_ble_mesh_model_cb) : registra la funci\u00f3n de callback asociada al modelo. Esta funci\u00f3n se utiliza cuando el otro extremo de la comunicaci\u00f3n solicita operaciones sobre el modelo, y es capaz de emitir los siguientes eventos principales: ESP_BLE_MESH_MODEL_OPERATION_EVT : se puede generar en dos situaciones: El modelo servidor recibe un Get Status o Set Status desde un modelo cliente. El modelo cliente recibe un Status State desde un modelo servidor. ESP_BLE_MESH_MODEL_SEND_COMP_EVT : generado despu\u00e9s de que el modelo servidor env\u00ede un Status State a trav\u00e9s de la funci\u00f3n esp_ble_mesh_server_model_send_msg . ESP_BLE_MESH_MODEL_PUBLISH_COMP_EVT : generado despu\u00e9s de que la aplicaci\u00f3n complete la invocaci\u00f3n a esp_ble_mesh_model_publish_msg para publicar mensajes. ESP_BLE_MESH_CLIENT_MODEL_SEND_TIMEOUT_EVT : generado cuando el modelo cliente invoca a la funci\u00f3n esp_ble_mesh_client_model_send_msg , pero no recibe mensaje de ACK de vuelta. ESP_BLE_MESH_MODEL_PUBLISH_UPDATE_EVT : generado despu\u00e9s de que la aplicaci\u00f3n configure la funci\u00f3n de publicaci\u00f3n para enviar de forma peri\u00f3dica mensajes al otro extremo. esp_ble_mesh_node_prov_enable(ESP_BLE_MESH_PROV_ADV | ESP_BLE_MESH_PROV_GATT) : activa el proceso de Anuncio y Escaneo, haciendo visible al dispositivo para potenciales provisionadores que est\u00e9n a la escucha. board_led_operation(LED_G, LED_ON) : inicializa un hipot\u00e9tico LED RGB, que se controlar\u00e1 remotamente. En este punto, la inicializaci\u00f3n de la pila BLE Mesh deber\u00eda estar completa, por lo que un provisionador podr\u00eda identificar dispositivos para privisonamiento de par\u00e1metros de red y transmisi\u00f3n de datos.","title":"An\u00e1lisis b\u00e1sico de c\u00f3digo"},{"location":"RPI-I/P5/#implementacion-de-la-estructura-ble-mesh-element","text":"A continuaci\u00f3n, se detallan los pasos necesarios para, en el servidor: Completar la inicializaci\u00f3n del sistema. A\u00f1adir un elemento y un modelo al servidor. Elegir distintas implementaciones de encriptaci\u00f3n. Declarar las caracter\u00edsticas de Proxy , Relay , Low Power y Friend del nodo. En primer lugar, para declarar y definir un elemento y un modelo asociado, utilizaremos las siguientes estructuras: /*!< Abstraction that describes a BLE Mesh Element. This structure is associated with bt_mesh_elem in mesh_access.h */ typedef struct { /* Element Address, it is assigned during provisioning. */ uint16_t element_addr; /* Location Descriptor (GATT Bluetooth Namespace Descriptors) */ const uint16_t location; /* Model count */ const uint8_t sig_model_count; const uint8_t vnd_model_count; /* Models */ esp_ble_mesh_model_t *sig_models; esp_ble_mesh_model_t *vnd_models; } esp_ble_mesh_elem_t; As\u00ed, podemos mantener informaci\u00f3n sobre los elementos disponibles en el vector elements : static esp_ble_mesh_elem_t elements[] = { ESP_BLE_MESH_ELEMENT(0, root_models, ESP_BLE_MESH_MODEL_NONE), }; La implementaci\u00f3n y definici\u00f3n de un modelo se realiza de forma similar: static esp_err_t ble_mesh_init(void) { int err = 0; memcpy(dev_uuid + 2, esp_bt_dev_get_address(), BLE_MESH_ADDR_LEN); // See comment 1 esp_ble_mesh_register_prov_callback(esp_ble_mesh_prov_cb); esp_ble_mesh_register_custom_model_callback(esp_ble_mesh_model_cb); err = esp_ble_mesh_init(&provision, &composition); if (err) { ESP_LOGE(TAG, \"Initializing mesh failed (err %d)\", err); return err; } esp_ble_mesh_node_prov_enable(ESP_BLE_MESH_PROV_ADV | ESP_BLE_MESH_PROV_GATT); ESP_LOGI(TAG, \"BLE Mesh Node initialized\"); board_led_operation(LED_G, LED_ON); return err; } Del mismo modo, podemos usar el array root_models para almacenar los modelos creados: static esp_ble_mesh_model_t root_models[] = { ESP_BLE_MESH_MODEL_CFG_SRV(&config_server), ESP_BLE_MESH_SIG_MODEL(ESP_BLE_MESH_MODEL_ID_GEN_ONOFF_SRV, onoff_op, &onoff_pub, &led_state[0]), }; Distintos modelos requieren diferentes macros (en este caso, ya que vamos a implementar un modelo Generic OnOff Server , hemos utilizado ESP_BLE_MESH_MODEL_ID_GEN_ONOFF_SRV ). Otra estructura importante en un modelo son los punteros esp_ble_mesh_model_op_t *op . Estas estructuras apuntan a la estrcutura de operaci\u00f3n que define el estado del modelo. Generalmente, hay dos tipos de modelos en BLE Mesh: Modelo servidor : Consiste en uno o varios estados que pueden existir y abarcar varios elementos. Define los mensajes enviados/recibidos por el modelo, junto con el comportamiento del elemento. Por ejemplo, un cambio entre On y Off en un interruptor indica el estado de On/Off en el modelo. Modelo cliente : Define los mensajes usados por el cliente para solicitar, modificar o usar el estado del servidor. Por ejemplo, un cambio entre un On y Off en un interruptor (cliente) indica el mensaje de On/Off enviado por el cliente. El siguiente c\u00f3digo muestra la declaraci\u00f3n de la estructura operaci\u00f3n asociada al Modelo del servidor: /*!< Model operation context. This structure is associated with bt_mesh_model_op in mesh_access.h */ typedef struct { const uint32_t opcode; /* Opcode encoded with the ESP_BLE_MESH_MODEL_OP_* macro */ const size_t min_len; /* Minimum required message length */ esp_ble_mesh_cb_t param_cb; /* The callback is only used for the BLE Mesh stack, not for the app layer. */ } esp_ble_mesh_model_op_t; Existe tres variables en la declaraci\u00f3n: opcode : c\u00f3digo de operaci\u00f3n asociado al estado. min_len : tama\u00f1o m\u00ednimo de los mensajes recibidos por el estado. Por ejemplo, para OnOff Get State , el tama\u00f1o es 0 (estamos leyendo), mientras que en el caso de OnOff Set State , el tama\u00f1o es 2 (incluye el valor a escribir). param_cb : par\u00e1metro interno utilizado por la pila BLE Mesh, t\u00edpicamente inicializado a 0. As\u00ed, la definici\u00f3n en el servidor quedar\u00eda: static esp_ble_mesh_model_op_t onoff_op[] = { { ESP_BLE_MESH_MODEL_OP_GEN_ONOFF_GET, 0, 0}, { ESP_BLE_MESH_MODEL_OP_GEN_ONOFF_SET, 2, 0}, { ESP_BLE_MESH_MODEL_OP_GEN_ONOFF_SET_UNACK, 2, 0}, /* Each model operation struct array must use this terminator * as the end tag of the operation uint. */ ESP_BLE_MESH_MODEL_OP_END, };","title":"Implementaci\u00f3n de la estructura BLE Mesh Element"},{"location":"RPI-I/P5/#el-cliente-on-off","text":"El cliente resulta mucho m\u00e1s sencillo en su funcionamiento. De forma gen\u00e9rica, simplemente define un modelo Client ON/OFF y espera a ser provisionado. Una vez completado el proceso de provisionamento, espera a la pulsaci\u00f3n de uno de los botones en la placa (RESET) para el env\u00edo a todos los nodos en la misma red de una solicitud de modificaci\u00f3n en el estado de activaci\u00f3n de las luces. Concretamente, nos interesan las siguientes definiciones. En el fichero board.c , observa la respusta a la pulsaci\u00f3n del bot\u00f3n: static void button_tap_cb(void* arg) { ESP_LOGI(TAG, \"tap cb (%s)\", (char *)arg); example_ble_mesh_send_gen_onoff_set(); } static void board_button_init(void) { button_handle_t btn_handle = iot_button_create(BUTTON_IO_NUM, BUTTON_ACTIVE_LEVEL); if (btn_handle) { iot_button_set_evt_cb(btn_handle, BUTTON_CB_RELEASE, button_tap_cb, \"RELEASE\"); } } void board_init(void) { board_led_init(); board_button_init(); } La funci\u00f3n invocada, example_ble_mesh_send_gen_onoff_set , realiza el env\u00edo de una operaci\u00f3n de tipo SET a todos los miembros de la red : void example_ble_mesh_send_gen_onoff_set(void) { esp_ble_mesh_generic_client_set_state_t set = {0}; esp_ble_mesh_client_common_param_t common = {0}; esp_err_t err = ESP_OK; common.opcode = ESP_BLE_MESH_MODEL_OP_GEN_ONOFF_SET_UNACK; common.model = onoff_client.model; common.ctx.net_idx = store.net_idx; common.ctx.app_idx = store.app_idx; common.ctx.addr = 0xFFFF; /* to all nodes */ common.ctx.send_ttl = 3; common.ctx.send_rel = false; common.msg_timeout = 0; /* 0 indicates that timeout value from menuconfig will be used */ common.msg_role = ROLE_NODE; set.onoff_set.op_en = false; set.onoff_set.onoff = store.onoff; set.onoff_set.tid = store.tid++; err = esp_ble_mesh_generic_client_set_state(&common, &set); if (err) { ESP_LOGE(TAG, \"Send Generic OnOff Set Unack failed\"); return; } store.onoff = !store.onoff; mesh_example_info_store(); /* Store proper mesh example info */ } Observa c\u00f3mo el mensaje se enviar\u00e1 a todos los nodos de la red ( common.ctx.addr = 0xFFFF; ).","title":"El cliente ON-OFF"},{"location":"RPI-I/P5/#provisionamiento-y-control-desde-una-aplicacion-movil","text":"En primer lugar, nos dividiremos en grupos de 3-4 personas. Uno de vosotros, utilizando la aplicaci\u00f3n m\u00f3vil nRF Mesh , actuar\u00e1 como provisionador de la red, proporcionando claves de red y aplicaci\u00f3n, as\u00ed como informaci\u00f3n b\u00e1sica de red (por ejemplo, direcciones unicast). Adem\u00e1s, podr\u00e1 crear grupos y suscribir/desuscribir modelos a dichos grupos. Adem\u00e1s, se requiere que uno de vuestros ESP32 act\u00fae como cliente, y el resto como servidores. As\u00ed, emularemos una sala con m\u00faltiples luces, y un s\u00f3lo interruptor que controlar\u00e1 su estado de encendido/apagado. PASO 1 : en la pantalla inicial se nos mostrar\u00e1n los nodos ya provisionados. En nuestro caso, inicialmente ninguno. PASO 2 : pincharemos sobre ADD NODE , y provisionaremos, uno a uno, todos los nodos que deseemos que formen parte de nuestra red (s\u00f3lo aquellos que forman parte de tu grupo de compa\u00f1eros): PASO 3 : antes de provisionar, generamos informaci\u00f3n de red para el nuevo nodo (lo identificamos ), presionando en IDENTIFY : PASO 4 : una vez generada la informaci\u00f3n de red, provisionamos el nodo ( PROVISION ): PASO 5 : si todo ha ido bien, se nos mostrar\u00e1 un mensaje de \u00e9xito como el siguiente: PASO 6 : tras repetir este paso con todos los nodos de nuestro grupo, veremos una pantalla como la siguiente. Observa y anota las direcciones unicast de cada nodo. Los nodos con un elemento son el cliente OnOff; los nodos con tres elementos (s\u00f3lo usaremos el primero) son los servidores OnOff: A continuaci\u00f3n, generar\u00e1s un grupo de nodos. Esto nos permitir\u00e1 suscribir a modelos al mismo, y publicar mensajes que se transmitir\u00e1n a todos los modelos del grupo. PASO 7 : crea un nuevo grupo pulsando el bot\u00f3n + . Dale el nombre y la direcci\u00f3n que desees, por ejemplo, Sala de Estar , 0xC000 . Si todo ha ido bien, se especificar\u00e1 que en el \u00fanico grupo disponible no hay ning\u00fan dispositivo suscrito/asociado. A continuaci\u00f3n, suscribiremos a cada modelo de los servidores y clientes (de tipo Generic On Off Server y Generic On Off Client ) al grupo creado. Esto lo har\u00e1s nodo a nodo, en primer lugar pincando en el modelo concreto: Y a continuaci\u00f3n asociando una clave de aplicaci\u00f3n ( BIND KEY ) y suscribiendo ( SUBSCRIBE ) al grupo deseado: Ahora, si vuelves a la descripci\u00f3n del grupo, ver\u00e1s que, tras pinchar, observas dos luces (o una por servidor) y un interruptor (correspondiente al cliente): En este punto, si est\u00e1s monitorizando la salida de todos los ESP32, ver\u00e1s que el estado del LED cambia a petici\u00f3n de la aplicaci\u00f3n. Adem\u00e1s, ver\u00e1s que tambi\u00e9n cambia si presionas el bot\u00f3n correspondiente del interruptor ( RESET ) en la placa. Tarea entregable El cliente env\u00eda, tras presionar un bot\u00f3n, el mensaje de tipo SET a todos los nodos de la red. Modif\u00edcalo para que \u00fanicamente se env\u00ede a los pertenecientes a tu grupo. Prueba a suscribir/desuscribir un modelo del grupo, y ver\u00e1s como ya no recibe los mensajes de solicitud de modificaci\u00f3n de estado.","title":"Provisionamiento y control desde una aplicaci\u00f3n m\u00f3vil"},{"location":"RPI-I/P5/#ejemplo-para-el-modelo-sensor-model","text":"En este ejemplo, se implementa la creaci\u00f3n de un cliente de modelo sensor que, adem\u00e1s, es provisionador, y un servidor de modelo sensor configurable. El modelo Sensor Server es un modelo que permite exponer series de datos de sensorizaci\u00f3n. El modelo Sensor Client se usa para consumir valores de sensorizaci\u00f3n ( Sensor states ) expuestos por el servidor. Estos estados se componen de las siguientes partes: Estado Sensor Descriptor . Describe los datos del sensor, y es inmutable durante su vida. Estado Sensor Setting . Controla los par\u00e1metros del sensor. Por ejemplo, podr\u00eda indicar su sensibilidad, y podr\u00eda ser ajustado remotamente para prevenir que un sensor de movimiento se disparase ante peque\u00f1os movimientos. Estado Sensor Cadence . Controla la cadencia de sensorizaci\u00f3n. Estado Sensor Data . Contiene los valores de sensorizaci\u00f3n. Realmente, representa uno o m\u00e1s pares Property ID - Valor . Estado Sensor Series Column . S\u00f3lo utilizado si se considera cada uno de los valores como perteneciente a una serie de datos. En el ejemplo client , el dispositivo es a la vez un provisionador y un cliente. Una vez el dispositivo servidor es provisionado y configurado, los usuarios pueden presionar el bot\u00f3n de la placa para enviar al servidor peticiones que, sucesivamente, devolver\u00e1n el siguiente estado del sensor en orden ( Descriptor , Setting , Cadence , ...). En el ejemplo server , el dispositivo no provisonado implementa un modelo Sensor Server . El servidor soporta dos instancias de estados: la pimrea ( Property ID 0x0056 ) representar\u00eda la temperatura Indoor ; la segunda ( Property ID 0x005B ) representar\u00eda la temperatura Outdoor*. Todos los datos, en estos ejemplos, est\u00e1n preinicializados.","title":"Ejemplo para el modelo SENSOR MODEL"},{"location":"RPI-I/P5/#puesta-en-marcha","text":"En primer lugar, arranca en tu grupo un nodo cliente/provisionador, y monitoriza su salida. Cuando un compa\u00f1ero/a arranque un nodo servidor, ver\u00e1s que es provisionado por tu cliente, otorg\u00e1ndole una direcci\u00f3n unicast. An\u00f3tala. El funcionamiento general del sistema es: El dispositivo A ejecuta el ejemplo client , y el dispositivo B ejecuta el ejemplo server . A act\u00faa como provisionador. Tras recibir una petici\u00f3n por parte de B, lo provisiona y almacena su direcci\u00f3n. Observar\u00e1s la MAC BLE (UUID) de B en el proceso de provisionamiento desde A. En A, cada pulsaci\u00f3n del bot\u00f3n supondr\u00e1 una petici\u00f3n al nodo B. Sucesivamente, estas peticiones ser\u00e1n, en orden y por cada pulsaci\u00f3n: Sensor Descriptor . Sensor Cadence . Sensor Settings . Sensor Data . Sensor Series . Tarea Estudia el c\u00f3digo del cliente y del servidor, y observa a qu\u00e9 nodo se env\u00edan las peticiones desde el cliente, qu\u00e9 operaciones se solicitan en cada pulsaci\u00f3n de bot\u00f3n, y qu\u00e9 datos devuelve el servidor en cada caso. Tarea entregable Modifica el c\u00f3digo de cliente y/o servidor para que los valores de sensorizaci\u00f3n que se consulten en cada pulsaci\u00f3n del bot\u00f3n no sean todos los del modelo del \u00faltimo nodo provisonado, como ahora se hace, sino \u00fanicamente los datos de sensorizaci\u00f3n ( Sensor Data State ) de todos los nodos provisionados. As\u00ed, si hay tres nodos provisionados, cada pulsaci\u00f3n nos devolver\u00e1 el valor de sensorizaci\u00f3n de uno de ellos, por orden de provisionamiento. Como funcionalidad adicional, s\u00f3lo se provisionar\u00e1 autom\u00e1ticamente a aquellos nodos autorizados (los que pertenecen a tu sala, por ejemplo). Por \u00faltimo, opcionalmente, se pide que el valor sensorizado var\u00ede aleatoriamente de forma peri\u00f3dica en el servidor, con una cadencia predeterminada (la modificaci\u00f3n remota de la cadencia queda como ejercicio avanzado).","title":"Puesta en marcha"},{"location":"RPI-I/P6/","text":"Pr\u00e1ctica 6. 6LowPAN (simulaci\u00f3n en Cooja) Introducci\u00f3n y objetivos Los routers de borde son enrutadores que pueden encontrarse en el borde de una red, encaminando el tr\u00e1fico de dicha red hacia una segunda red externa. Su funci\u00f3n, en definitiva, es conectar una red con otra. En esta pr\u00e1ctica, veremos c\u00f3mo construir una simulaci\u00f3n utilizando un router de borde en Contiki. M\u00e1s concretamente, veremos c\u00f3mo un router de borde Contiki puede utilizarse para enrutar tr\u00e1fico entre una red RPL (una red de sensores Contiki con protocolo de enrutamiento RPL sobre IPv6) y una red IPv4 externa, siguiendo el siguiente diagrama: El objetivo de la pr\u00e1ctica es ofrecer una visi\u00f3n general sobre c\u00f3mo desplegar tanto una red RPL con Contiki en el simulador Cooja, as\u00ed como conseguir hacerla interactuar con una segunda red externa real utilizando la herramienta tunslip . Instalaci\u00f3n de requisitos software La instalaci\u00f3n b\u00e1sica de Contiki (en su versi\u00f3n 2.7) se encuentra en el directorio /home/ubuntu/contiki de tu m\u00e1quina virtual. Antes de comenzar, necesitar\u00e1s instalar una serie de software de soporte para el correcto desarrollo de la pr\u00e1ctica: sudo apt install -y openjdk-8-jdk openjdk-8-jre A continuaci\u00f3n, aseg\u00farate de seleccionar la versi\u00f3n 8 de Java para un correcto funcionamiento del proceso de compilaci\u00f3n de Cooja: ubuntu@ubuntu2004:~/contiki/tools/cooja$ sudo update-alternatives --config java Existen 3 opciones para la alternativa java (que provee /usr/bin/java). Selecci\u00f3n Ruta Prioridad Estado ------------------------------------------------------------ 0 /usr/lib/jvm/java-14-openjdk-amd64/bin/java 1411 modo autom\u00e1tico 1 /usr/lib/jvm/java-11-openjdk-amd64/bin/java 1111 modo manual 2 /usr/lib/jvm/java-14-openjdk-amd64/bin/java 1411 modo manual * 3 /usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java 1081 modo manual Pulse <Intro> para mantener el valor por omisi\u00f3n [*] o pulse un n\u00famero de selecci\u00f3n: 3 Por \u00faltimo, necesitar\u00e1s instalar el compilador que nos permitir\u00e1 generar las im\u00e1genes para los nodos en la simulaci\u00f3n: sudo apt-get install gcc-msp430 gdb-msp430 C\u00f3digo Contiki En el desarrollo de la pr\u00e1ctica, utilizaremos los siguientes ficheros, todos situados en el directorio examples/ipv6/rpl-border-router de la instalaci\u00f3n de Contiki: border_router.c : que contendr\u00e1 la l\u00f3gica de enrutamiento del router de borde. udp-client.c o udp_server.c (en el directorio examples/ipv6/rpl-udp ): que actuar\u00e1n como nodos en la red RPL (de momento, no es importante su funcionalidad, aunque como en la siguiente pr\u00e1ctica utilizar\u00e1s el cliente UDP, se aconseja utilizar \u00e9ste). slip-bridge.c : que contiene las funciones de callback para procesar una petici\u00f3n de conexi\u00f3n SLIP. httpd-simple.c : que contiene un servidor web sencillo que nos permitir\u00e1 consultar las tablas de enrutamiento del router de borde. Los nodos que implementen el c\u00f3digo udp-client.c o udp-server.c formar\u00e1n un DAG con el router de borde configurado como ra\u00edz. El router de borde recibir\u00e1 el prefijo de red v\u00eda una conexi\u00f3n SLIP ( Serial Line Interface Protocol ) y lo comunicar\u00e1 al resto de nodos de la red RPL para que conformen sus respectivas direcciones IPv6 globales. Aunque no es de mayor inter\u00e9s de cara a la pr\u00e1ctica, los siguientes fragmentos de c\u00f3digo en el router de borde establecen los puntos en los que espera a la configuraci\u00f3n del prefijo de red. Una vez recibido, el router de borde se configura como la ra\u00edz del DAG y env\u00eda el prefijo al resto de nodos de la red: /* Request prefix until it has been received */ while(!prefix_set) { etimer_set(&et, CLOCK_SECOND); request_prefix(); PROCESS_WAIT_EVENT_UNTIL(etimer_expired(&et)); } dag = rpl_set_root(RPL_DEFAULT_INSTANCE,(uip_ip6addr_t *)dag_id); if(dag != NULL) { rpl_set_prefix(dag, &prefix, 64); PRINTF(\"created a new RPL dag\\n\"); } Por defecto, el router de borde aloja una p\u00e1gina web sencilla que nos servir\u00e1 para consultar el estado de sus tablas de enrutamiento. Esta p\u00e1gina se mostrar\u00e1 cuando introduzcamos la direcci\u00f3n IPv6 del router de borde en cualquier navegador. El uso de esta p\u00e1gina puede desactivarse a trav\u00e9s del valor de la macro WEBSERVER , y su activaci\u00f3n en Contiki en base a su valor es sencilla (fichero http-simple.c ): PROCESS(border_router_process, \"Border router process\"); #if WEBSERVER==0 /* No webserver */ AUTOSTART_PROCESSES(&border_router_process); #elif WEBSERVER>1 /* Use an external webserver application */ #include \"webserver-nogui.h\" AUTOSTART_PROCESSES(&border_router_process,&webserver_nogui_process); Compilaci\u00f3n del c\u00f3digo El c\u00f3digo para router de borde puede encontrarse en la ruta examples/ipv6/rpl-border-router . Utiliza la siguiente orden para realizar la compilaci\u00f3n: cd examples/ipv6/rpl-border-router make TARGET=z1 Una vez ejecutado, se crear\u00e1 un fichero llamado border-router.z1 , que se utilizar\u00e1 para programar las motas (dispositivos simulados) router de borde en el simulador Cooja. Para demostrar la funcionalidad del router de borde, crearemos una red de nodos con el router de borde como ra\u00edz. Para ello, utilizaremos nodos cliente UDP, implementados en el fichero udp-client.c . Para ello, prepara im\u00e1genes para las motas de la siguiente manera: cd examples/ipv6/rpl-udp make TARGET=z1 Del mismo modo que anteriormente, dispondr\u00e1s de un fihcero udp-client.z1 , que conformar\u00e1n un DAG con el router de borde como ra\u00edz y que utilizaremos en el resto de motas de la simulaci\u00f3n. Simulaci\u00f3n en Cooja Tras la compilaci\u00f3n de las im\u00e1genes, llega el momento de crear la simulaci\u00f3n completa en Cooja. Arranca el simulador usando la siguiente orden: cd tools/cooja ant run Tras la ejecuci\u00f3n, sigue los siguientes pasos para crear una nueva simulaci\u00f3n: Selecciona la opci\u00f3n File->New Simulation . Selecciona UDGM e introduce el nombre de la simulaci\u00f3n. Presiona Create . En el men\u00fa Motes , selecciona Add New Motes->Create new motes y seleccona el timp de mota Z1 . Busca la localizaci\u00f3n de la imagen de router de borde ( examples/ipv6/rpl-border-router ) y selecciona el fichero rpl-border-router.z1 . Clica en Create y a\u00f1ade una mota de este tipo. Repite los pasos 2 y 3 pero esta vez con la imagen del cliente o servidor UDP que creaste anteriormente. A\u00f1ade cuatro o cinco motas de este tipo y distribuyelas por la simulaci\u00f3n. Selecciona las opciones del men\u00fa View como se muestra en la figura, ya que esto te permitir\u00e1 crear de forma m\u00e1s clara tu topolog\u00eda (puedes temporalmente a\u00f1adir tambi\u00e9n la direcci\u00f3n IP, aunque puede resultar demasiada informaci\u00f3n): A continuaci\u00f3n, crearemos un puente entre la red RPL simulada en Cooja y la m\u00e1quina local. Esto puede realizarse en la mota programada como router de borde. Selecciona Tools y Serial Socket (SERVER) sobre la mota router de borde (ident\u00edficala con su valor num\u00e9rico). Obtendr\u00e1s un mensaje como el de la siguiente figura (observa que el mensaje indica Listening on port 60001 ): A continuaci\u00f3n, arranca la simulaci\u00f3n (bot\u00f3n Start ). La utilidad tunslip Como hemos dicho, un router de borde act\u00faa como enlace para conectar una red a otra. En este ejemplo, el router de borde se usa para establecer ruta de datos entre la red RPL y una red externa. Hasta ahora, s\u00f3lo hemos creado la red RPL, por lo que necesitamos simular un escenario en el que esta red RPL se conecte a una red externa. Para ello, utilizaremos la utilidad tunslip proporcionada con Contiki. En este ejemplo, tunslip crea un puente entre la red RPL y la m\u00e1quina local. El c\u00f3digo tunslip6.c se encuentra en el directorio tools de la instalaci\u00f3n, y se puede compilar con la orden: make tunslip6 A continuaci\u00f3n, podemos establecer una conexi\u00f3n entre la red RPL y la m\u00e1quina local: sudo ./tunslip6 -a 127.0.0.1 aaaa::1/64 Si la ejecuci\u00f3n ha sido correcta, veremos una salida similar a la siguiente en la terminal: ubuntu@ubuntu2004:~/contiki/tools$ sudo ./tunslip6 -a 127.0.0.1 aaaa::1/64 slip connected to ``127.0.0.1:60001'' opened tun device ``/dev/tun0'' ifconfig tun0 inet `hostname` mtu 1500 up ifconfig tun0 add aaaa::1/64 ifconfig tun0 add fe80::0:0:0:1/64 ifconfig tun0 tun0: flags=4305<UP,POINTOPOINT,RUNNING,NOARP,MULTICAST> mtu 1500 inet 127.0.1.1 netmask 255.255.255.255 destination 127.0.1.1 inet6 aaaa::1 prefixlen 64 scopeid 0x0<global> inet6 fe80::1 prefixlen 64 scopeid 0x20<link> inet6 fe80::ace4:dadf:8e12:be05 prefixlen 64 scopeid 0x20<link> unspec 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00 txqueuelen 500 (UNSPEC) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 *** Address:aaaa::1 => aaaa:0000:0000:0000 Got configuration message of type P Setting prefix aaaa:: Server IPv6 addresses: aaaa::c30c:0:0:1 fe80::c30c:0:0:1 El programa ha creado una interfaz puente tun0 con IPv4 127.0.1.1, y ha enviado, v\u00eda serie, un mensaje de configuraci\u00f3n al router de borde indicando el prefijo deseado para los nodos de la red RPL ( aaaa ). La salida de las \u00faltimas dos l\u00edneas pertenece al router de borde, e indica cu\u00e1les son sus direcciones IPv6 tras la recepci\u00f3n del prefijo. Vuelve al simulador Cooja y observa que ha aparecido un mensaje en el que se observa la cadena Client connected: /127.0.0.1 . Verificaci\u00f3n de resultados Es posible verificar la direcci\u00f3n del router de borde a trav\u00e9s de una orden ping desde tu m\u00e1quina virtual: ubuntu@ubuntu2004:~/contiki/tools$ ping aaaa::c30c:0:0:1 PING aaaa::c30c:0:0:1(aaaa::c30c:0:0:1) 56 data bytes 64 bytes from aaaa::c30c:0:0:1: icmp_seq=1 ttl=64 time=21.5 ms 64 bytes from aaaa::c30c:0:0:1: icmp_seq=2 ttl=64 time=7.44 ms 64 bytes from aaaa::c30c:0:0:1: icmp_seq=3 ttl=64 time=8.57 ms 64 bytes from aaaa::c30c:0:0:1: icmp_seq=4 ttl=64 time=62.7 ms 64 bytes from aaaa::c30c:0:0:1: icmp_seq=5 ttl=64 time=15.2 ms --- aaaa::c30c:0:0:1 ping statistics --- 5 packets transmitted, 5 received, 0% packet loss, time 4015ms rtt min/avg/max/mdev = 7.442/23.066/62.661/20.427 ms As\u00ed como la de cualquier nodo de la red, por ejemplo el nodo 4: ubuntu@ubuntu2004:~/contiki/tools$ ping aaaa::c30c:0:0:4 PING aaaa::c30c:0:0:4(aaaa::c30c:0:0:4) 56 data bytes 64 bytes from aaaa::c30c:0:0:4: icmp_seq=1 ttl=62 time=116 ms 64 bytes from aaaa::c30c:0:0:4: icmp_seq=2 ttl=62 time=106 ms 64 bytes from aaaa::c30c:0:0:4: icmp_seq=3 ttl=62 time=108 ms 64 bytes from aaaa::c30c:0:0:4: icmp_seq=4 ttl=62 time=111 ms 64 bytes from aaaa::c30c:0:0:4: icmp_seq=5 ttl=62 time=79.0 ms ^C --- aaaa::c30c:0:0:4 ping statistics --- 5 packets transmitted, 5 received, 0% packet loss, time 4016ms rtt min/avg/max/mdev = 79.002/104.028/115.794/12.937 ms La direcci\u00f3n de cada nodo puede obtenerse filtrando el la pantalla de log en funci\u00f3n del ID del nodo (mota) destino. Desde cualquier navegador (en la red de la m\u00e1quina virtual), puedes navegar a la direcci\u00f3n IP del router de borde para observar su estado: Tarea entregable Sigue los pasos del bolet\u00edn para crear una red RPL con un n\u00famero reducido de nodos (entre 5 y 10), conect\u00e1ndola a tu red local. Haz que no todos los nodos est\u00e9n al alcance del router de borde, y comienza tu simulaci\u00f3n. Estudia y reporta el tr\u00e1fico RPL generado en el proceso de generaci\u00f3n del DAG, y comprueba la conectividad con todos ellos v\u00eda ping6 . Realiza y reporta una serie de movimientos sobre una mota que est\u00e9 al alcance del router de borde, para que deje de estarlo. Con una ejecuci\u00f3n de ping6 activa sobre dicha mota, reporta el tiempo que tarda RPL en hacer converger de nuevo el DODAG. Por \u00faltimo, realiza movimientos sobre los nodos, o crea nuevas motas en la simulaci\u00f3n, y estudia, a trav\u00e9s de la interfaz web del router de borde, el tiempo de establecimiento de nuevas rutas.","title":"Pr\u00e1ctica 6"},{"location":"RPI-I/P6/#practica-6-6lowpan-simulacion-en-cooja","text":"","title":"Pr\u00e1ctica 6. 6LowPAN (simulaci\u00f3n en Cooja)"},{"location":"RPI-I/P6/#introduccion-y-objetivos","text":"Los routers de borde son enrutadores que pueden encontrarse en el borde de una red, encaminando el tr\u00e1fico de dicha red hacia una segunda red externa. Su funci\u00f3n, en definitiva, es conectar una red con otra. En esta pr\u00e1ctica, veremos c\u00f3mo construir una simulaci\u00f3n utilizando un router de borde en Contiki. M\u00e1s concretamente, veremos c\u00f3mo un router de borde Contiki puede utilizarse para enrutar tr\u00e1fico entre una red RPL (una red de sensores Contiki con protocolo de enrutamiento RPL sobre IPv6) y una red IPv4 externa, siguiendo el siguiente diagrama: El objetivo de la pr\u00e1ctica es ofrecer una visi\u00f3n general sobre c\u00f3mo desplegar tanto una red RPL con Contiki en el simulador Cooja, as\u00ed como conseguir hacerla interactuar con una segunda red externa real utilizando la herramienta tunslip .","title":"Introducci\u00f3n y objetivos"},{"location":"RPI-I/P6/#instalacion-de-requisitos-software","text":"La instalaci\u00f3n b\u00e1sica de Contiki (en su versi\u00f3n 2.7) se encuentra en el directorio /home/ubuntu/contiki de tu m\u00e1quina virtual. Antes de comenzar, necesitar\u00e1s instalar una serie de software de soporte para el correcto desarrollo de la pr\u00e1ctica: sudo apt install -y openjdk-8-jdk openjdk-8-jre A continuaci\u00f3n, aseg\u00farate de seleccionar la versi\u00f3n 8 de Java para un correcto funcionamiento del proceso de compilaci\u00f3n de Cooja: ubuntu@ubuntu2004:~/contiki/tools/cooja$ sudo update-alternatives --config java Existen 3 opciones para la alternativa java (que provee /usr/bin/java). Selecci\u00f3n Ruta Prioridad Estado ------------------------------------------------------------ 0 /usr/lib/jvm/java-14-openjdk-amd64/bin/java 1411 modo autom\u00e1tico 1 /usr/lib/jvm/java-11-openjdk-amd64/bin/java 1111 modo manual 2 /usr/lib/jvm/java-14-openjdk-amd64/bin/java 1411 modo manual * 3 /usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java 1081 modo manual Pulse <Intro> para mantener el valor por omisi\u00f3n [*] o pulse un n\u00famero de selecci\u00f3n: 3 Por \u00faltimo, necesitar\u00e1s instalar el compilador que nos permitir\u00e1 generar las im\u00e1genes para los nodos en la simulaci\u00f3n: sudo apt-get install gcc-msp430 gdb-msp430","title":"Instalaci\u00f3n de requisitos software"},{"location":"RPI-I/P6/#codigo-contiki","text":"En el desarrollo de la pr\u00e1ctica, utilizaremos los siguientes ficheros, todos situados en el directorio examples/ipv6/rpl-border-router de la instalaci\u00f3n de Contiki: border_router.c : que contendr\u00e1 la l\u00f3gica de enrutamiento del router de borde. udp-client.c o udp_server.c (en el directorio examples/ipv6/rpl-udp ): que actuar\u00e1n como nodos en la red RPL (de momento, no es importante su funcionalidad, aunque como en la siguiente pr\u00e1ctica utilizar\u00e1s el cliente UDP, se aconseja utilizar \u00e9ste). slip-bridge.c : que contiene las funciones de callback para procesar una petici\u00f3n de conexi\u00f3n SLIP. httpd-simple.c : que contiene un servidor web sencillo que nos permitir\u00e1 consultar las tablas de enrutamiento del router de borde. Los nodos que implementen el c\u00f3digo udp-client.c o udp-server.c formar\u00e1n un DAG con el router de borde configurado como ra\u00edz. El router de borde recibir\u00e1 el prefijo de red v\u00eda una conexi\u00f3n SLIP ( Serial Line Interface Protocol ) y lo comunicar\u00e1 al resto de nodos de la red RPL para que conformen sus respectivas direcciones IPv6 globales. Aunque no es de mayor inter\u00e9s de cara a la pr\u00e1ctica, los siguientes fragmentos de c\u00f3digo en el router de borde establecen los puntos en los que espera a la configuraci\u00f3n del prefijo de red. Una vez recibido, el router de borde se configura como la ra\u00edz del DAG y env\u00eda el prefijo al resto de nodos de la red: /* Request prefix until it has been received */ while(!prefix_set) { etimer_set(&et, CLOCK_SECOND); request_prefix(); PROCESS_WAIT_EVENT_UNTIL(etimer_expired(&et)); } dag = rpl_set_root(RPL_DEFAULT_INSTANCE,(uip_ip6addr_t *)dag_id); if(dag != NULL) { rpl_set_prefix(dag, &prefix, 64); PRINTF(\"created a new RPL dag\\n\"); } Por defecto, el router de borde aloja una p\u00e1gina web sencilla que nos servir\u00e1 para consultar el estado de sus tablas de enrutamiento. Esta p\u00e1gina se mostrar\u00e1 cuando introduzcamos la direcci\u00f3n IPv6 del router de borde en cualquier navegador. El uso de esta p\u00e1gina puede desactivarse a trav\u00e9s del valor de la macro WEBSERVER , y su activaci\u00f3n en Contiki en base a su valor es sencilla (fichero http-simple.c ): PROCESS(border_router_process, \"Border router process\"); #if WEBSERVER==0 /* No webserver */ AUTOSTART_PROCESSES(&border_router_process); #elif WEBSERVER>1 /* Use an external webserver application */ #include \"webserver-nogui.h\" AUTOSTART_PROCESSES(&border_router_process,&webserver_nogui_process);","title":"C\u00f3digo Contiki"},{"location":"RPI-I/P6/#compilacion-del-codigo","text":"El c\u00f3digo para router de borde puede encontrarse en la ruta examples/ipv6/rpl-border-router . Utiliza la siguiente orden para realizar la compilaci\u00f3n: cd examples/ipv6/rpl-border-router make TARGET=z1 Una vez ejecutado, se crear\u00e1 un fichero llamado border-router.z1 , que se utilizar\u00e1 para programar las motas (dispositivos simulados) router de borde en el simulador Cooja. Para demostrar la funcionalidad del router de borde, crearemos una red de nodos con el router de borde como ra\u00edz. Para ello, utilizaremos nodos cliente UDP, implementados en el fichero udp-client.c . Para ello, prepara im\u00e1genes para las motas de la siguiente manera: cd examples/ipv6/rpl-udp make TARGET=z1 Del mismo modo que anteriormente, dispondr\u00e1s de un fihcero udp-client.z1 , que conformar\u00e1n un DAG con el router de borde como ra\u00edz y que utilizaremos en el resto de motas de la simulaci\u00f3n.","title":"Compilaci\u00f3n del c\u00f3digo"},{"location":"RPI-I/P6/#simulacion-en-cooja","text":"Tras la compilaci\u00f3n de las im\u00e1genes, llega el momento de crear la simulaci\u00f3n completa en Cooja. Arranca el simulador usando la siguiente orden: cd tools/cooja ant run Tras la ejecuci\u00f3n, sigue los siguientes pasos para crear una nueva simulaci\u00f3n: Selecciona la opci\u00f3n File->New Simulation . Selecciona UDGM e introduce el nombre de la simulaci\u00f3n. Presiona Create . En el men\u00fa Motes , selecciona Add New Motes->Create new motes y seleccona el timp de mota Z1 . Busca la localizaci\u00f3n de la imagen de router de borde ( examples/ipv6/rpl-border-router ) y selecciona el fichero rpl-border-router.z1 . Clica en Create y a\u00f1ade una mota de este tipo. Repite los pasos 2 y 3 pero esta vez con la imagen del cliente o servidor UDP que creaste anteriormente. A\u00f1ade cuatro o cinco motas de este tipo y distribuyelas por la simulaci\u00f3n. Selecciona las opciones del men\u00fa View como se muestra en la figura, ya que esto te permitir\u00e1 crear de forma m\u00e1s clara tu topolog\u00eda (puedes temporalmente a\u00f1adir tambi\u00e9n la direcci\u00f3n IP, aunque puede resultar demasiada informaci\u00f3n): A continuaci\u00f3n, crearemos un puente entre la red RPL simulada en Cooja y la m\u00e1quina local. Esto puede realizarse en la mota programada como router de borde. Selecciona Tools y Serial Socket (SERVER) sobre la mota router de borde (ident\u00edficala con su valor num\u00e9rico). Obtendr\u00e1s un mensaje como el de la siguiente figura (observa que el mensaje indica Listening on port 60001 ): A continuaci\u00f3n, arranca la simulaci\u00f3n (bot\u00f3n Start ).","title":"Simulaci\u00f3n en Cooja"},{"location":"RPI-I/P6/#la-utilidad-tunslip","text":"Como hemos dicho, un router de borde act\u00faa como enlace para conectar una red a otra. En este ejemplo, el router de borde se usa para establecer ruta de datos entre la red RPL y una red externa. Hasta ahora, s\u00f3lo hemos creado la red RPL, por lo que necesitamos simular un escenario en el que esta red RPL se conecte a una red externa. Para ello, utilizaremos la utilidad tunslip proporcionada con Contiki. En este ejemplo, tunslip crea un puente entre la red RPL y la m\u00e1quina local. El c\u00f3digo tunslip6.c se encuentra en el directorio tools de la instalaci\u00f3n, y se puede compilar con la orden: make tunslip6 A continuaci\u00f3n, podemos establecer una conexi\u00f3n entre la red RPL y la m\u00e1quina local: sudo ./tunslip6 -a 127.0.0.1 aaaa::1/64 Si la ejecuci\u00f3n ha sido correcta, veremos una salida similar a la siguiente en la terminal: ubuntu@ubuntu2004:~/contiki/tools$ sudo ./tunslip6 -a 127.0.0.1 aaaa::1/64 slip connected to ``127.0.0.1:60001'' opened tun device ``/dev/tun0'' ifconfig tun0 inet `hostname` mtu 1500 up ifconfig tun0 add aaaa::1/64 ifconfig tun0 add fe80::0:0:0:1/64 ifconfig tun0 tun0: flags=4305<UP,POINTOPOINT,RUNNING,NOARP,MULTICAST> mtu 1500 inet 127.0.1.1 netmask 255.255.255.255 destination 127.0.1.1 inet6 aaaa::1 prefixlen 64 scopeid 0x0<global> inet6 fe80::1 prefixlen 64 scopeid 0x20<link> inet6 fe80::ace4:dadf:8e12:be05 prefixlen 64 scopeid 0x20<link> unspec 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00 txqueuelen 500 (UNSPEC) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 *** Address:aaaa::1 => aaaa:0000:0000:0000 Got configuration message of type P Setting prefix aaaa:: Server IPv6 addresses: aaaa::c30c:0:0:1 fe80::c30c:0:0:1 El programa ha creado una interfaz puente tun0 con IPv4 127.0.1.1, y ha enviado, v\u00eda serie, un mensaje de configuraci\u00f3n al router de borde indicando el prefijo deseado para los nodos de la red RPL ( aaaa ). La salida de las \u00faltimas dos l\u00edneas pertenece al router de borde, e indica cu\u00e1les son sus direcciones IPv6 tras la recepci\u00f3n del prefijo. Vuelve al simulador Cooja y observa que ha aparecido un mensaje en el que se observa la cadena Client connected: /127.0.0.1 .","title":"La utilidad tunslip"},{"location":"RPI-I/P6/#verificacion-de-resultados","text":"Es posible verificar la direcci\u00f3n del router de borde a trav\u00e9s de una orden ping desde tu m\u00e1quina virtual: ubuntu@ubuntu2004:~/contiki/tools$ ping aaaa::c30c:0:0:1 PING aaaa::c30c:0:0:1(aaaa::c30c:0:0:1) 56 data bytes 64 bytes from aaaa::c30c:0:0:1: icmp_seq=1 ttl=64 time=21.5 ms 64 bytes from aaaa::c30c:0:0:1: icmp_seq=2 ttl=64 time=7.44 ms 64 bytes from aaaa::c30c:0:0:1: icmp_seq=3 ttl=64 time=8.57 ms 64 bytes from aaaa::c30c:0:0:1: icmp_seq=4 ttl=64 time=62.7 ms 64 bytes from aaaa::c30c:0:0:1: icmp_seq=5 ttl=64 time=15.2 ms --- aaaa::c30c:0:0:1 ping statistics --- 5 packets transmitted, 5 received, 0% packet loss, time 4015ms rtt min/avg/max/mdev = 7.442/23.066/62.661/20.427 ms As\u00ed como la de cualquier nodo de la red, por ejemplo el nodo 4: ubuntu@ubuntu2004:~/contiki/tools$ ping aaaa::c30c:0:0:4 PING aaaa::c30c:0:0:4(aaaa::c30c:0:0:4) 56 data bytes 64 bytes from aaaa::c30c:0:0:4: icmp_seq=1 ttl=62 time=116 ms 64 bytes from aaaa::c30c:0:0:4: icmp_seq=2 ttl=62 time=106 ms 64 bytes from aaaa::c30c:0:0:4: icmp_seq=3 ttl=62 time=108 ms 64 bytes from aaaa::c30c:0:0:4: icmp_seq=4 ttl=62 time=111 ms 64 bytes from aaaa::c30c:0:0:4: icmp_seq=5 ttl=62 time=79.0 ms ^C --- aaaa::c30c:0:0:4 ping statistics --- 5 packets transmitted, 5 received, 0% packet loss, time 4016ms rtt min/avg/max/mdev = 79.002/104.028/115.794/12.937 ms La direcci\u00f3n de cada nodo puede obtenerse filtrando el la pantalla de log en funci\u00f3n del ID del nodo (mota) destino. Desde cualquier navegador (en la red de la m\u00e1quina virtual), puedes navegar a la direcci\u00f3n IP del router de borde para observar su estado: Tarea entregable Sigue los pasos del bolet\u00edn para crear una red RPL con un n\u00famero reducido de nodos (entre 5 y 10), conect\u00e1ndola a tu red local. Haz que no todos los nodos est\u00e9n al alcance del router de borde, y comienza tu simulaci\u00f3n. Estudia y reporta el tr\u00e1fico RPL generado en el proceso de generaci\u00f3n del DAG, y comprueba la conectividad con todos ellos v\u00eda ping6 . Realiza y reporta una serie de movimientos sobre una mota que est\u00e9 al alcance del router de borde, para que deje de estarlo. Con una ejecuci\u00f3n de ping6 activa sobre dicha mota, reporta el tiempo que tarda RPL en hacer converger de nuevo el DODAG. Por \u00faltimo, realiza movimientos sobre los nodos, o crea nuevas motas en la simulaci\u00f3n, y estudia, a trav\u00e9s de la interfaz web del router de borde, el tiempo de establecimiento de nuevas rutas.","title":"Verificaci\u00f3n de resultados"},{"location":"RPI-I/P7/","text":"Pr\u00e1ctica 6. 6LowPAN (SensorTag) Objetivos El objetivo principal de la presente pr\u00e1ctica es reproducir (y ampliar) el entorno simulado visto en la pr\u00e1ctica anterior, pero en este caso utilizando hardware real. Para ello, ampliaremos el entorno para desplegar un router de borde f\u00edsico en el laboratorio, que enrutar\u00e1 los mensajes con origen la red RPL hacia un servidor UDP f\u00edsico situado en la red externa. Tras el despliegue, cada Sensortag que forme parte de la red RPL enviar\u00e1, peri\u00f3dicamente, mensajes UDP con un formato preestablecido, que ser\u00e1n mostrados por pantalla en el servidor UDP desplegado en el PC del profesor. Despliegue y modificaci\u00f3n de un cliente UDP en el SensorTag Para la realizaci\u00f3n de la pr\u00e1ctica, partiremos del ejemplo de cliente UDP situado en el directorio examples/ipv6/rpl-udp/udp-client.c . Este sencillo c\u00f3digo realiza un env\u00edo peri\u00f3dico de un paquete UDP (en su versi\u00f3n original, una cadena de caracteres conteniendo el mensaje Hello XX from the client (siendo XX un n\u00famero de secuencia ascendente), a un servidor a la escucha en el puerto 5678 de una direcci\u00f3n IP determinada. Estudia el c\u00f3digo del cliente UDP, concretamente centr\u00e1ndote en las siguientes partes: Temporizaci\u00f3n del env\u00edo (l\u00ednea 252) . El c\u00f3digo establece un temporizador con un retardo determinado ( SEND_TIME ) y un callback asociado ( send_packet ). Env\u00edo del mensaje v\u00eda UDP (l\u00ednea 111) . La funci\u00f3n uip_udp_packet_sendto realiza el env\u00edo del mensaje al extremo remoto del socket UDP. En este caso, utiliza la direcci\u00f3n de inicio del buffer ( buf ) y su tama\u00f1o para controlar el inicio del mensaje y su tama\u00f1o en bytes. Reporte del estado de las tablas de enrutamiento y rutas por defecto . La funci\u00f3n send_packet incluye, en su parte inicial, un reporte del estado de las tablas de enrutamiento (rutas por defecto) precediendo a cada env\u00edo del mensaje. Establecimiento de direcci\u00f3n IP y puerto del servidor UDP . La variable server_ipaddr contiene la direcci\u00f3n IP del destino de la comunicaci\u00f3n. El puerto destino viene fijado por la macro UDP_SERVER_PORT . Las modificaciones que deber\u00e1s realizar para conseguir interactuar con el servidor UDP remoto son sencillas, pero requieren ser correctas para una correcta comunicaci\u00f3n: Modifica el valor de la direcci\u00f3n IP destino para que coincida con la indicada por el profesor. Para ello, deber\u00e1s modificar el valor de la variable server_address , que codifica una direcci\u00f3n IPv6, para embeber en ella una direcci\u00f3n IPv4. Para ello, los 80 primero bits de la direcci\u00f3n deber\u00e1n ser 0s, seguidos de 16 bits fijados con valor 1, y seguidos por \u00faltimo de los 32 bits de la direcci\u00f3n IPv4 que se te indicar\u00e1. Modifica el valor del puerto destino para que coincida con el indicado por el profesor. Modifica la l\u00f3gica de env\u00edo para que el mensaje a enviar contenta, en este orden, los siguientes datos: struct mensaje{ unsigned short id; // Identificador unico del mensaje. unsigned short ip; // Ultimos dos bytes de la direcci\u00f3n IPv6 del emisor (tu Sensortag). unsigned short nsensors; // N\u00famero de valores sensorizados que se env\u00edan. float sensors[6]; // Valores sensorizados. }; Los valores sensorizados pueden generarse aleatoriamente o asign\u00e1rseles valores fijos. Compilaci\u00f3n de la imagen Antes de comenzar a trabajar, crea una nueva carpeta al mismo nivel que la del ejemplo original, sobre la que realizar\u00e1s las compilaciones del firmware . Una vez creada, realiza una primera compilaci\u00f3n de prueba, utilizando la orden: make TARGET=srf06-cc26xx BOARD=sensortag/cc2650 CPU_FAMILY=cc26xx udp-client Si todo ha ido bien, esta orden crear\u00e1 un fichero binario con nombre udp-client.hex , que utilizar\u00e1s en los siguientes pasos para flashear tu SensorTag. Flasheado de imagen El proceso de flasheado de la anterior imagen requiere el uso de la herramienta Uniflash , que encontrar\u00e1s en tu escritorio. En todo momento, tu SensorTag debe estar conectado al depurador ( Devpack ), y \u00e9ste a tu m\u00e1quina virtual. Arranca Uniflash y selecciona tu dispositivo de entre los que se muestran en la parte superior de la pantalla. A continuaci\u00f3n, en la pantalla Flash images , selecciona tu fichero .hex y elige la orden Load image . Es importante que no selecciones la opci\u00f3n Binary . Cuando el proceso haya finalizado, puedes reiniciar tu SensorTag y comenzar una sesi\u00f3n de monitorizaci\u00f3n, como se muestar a continuaci\u00f3n. Monitorizaci\u00f3n v\u00eda minicom Instala el programa minicom ( sudo apt-get install minicom ) y arr\u00e1ncalo con la orden minicom . Configura una nueva conexi\u00f3n usando los siguientes par\u00e1metros (accede a la pantalla correspondiente usando la combinaci\u00f3n de teclas Ctrl+a+z ): Puerto: /dev/ttyACM0 (aseg\u00farate de que tu SensorTag es reconocido en dicho puerto usando la orden dmesg ). BPS: 9600 . Si todo ha ido bien, deber\u00e1s observar por pantalla la salida de depuraci\u00f3n de Contiki. Actualizaci\u00f3n del firmware del Devpack El proceso de flasheado requiere, en algunos casos, un proceso de actualizaci\u00f3n del firmware del Devpack . Sigue las instrucciones proporcionadas en Campus Virtual para llevar a cabo dicho proceso de actualizaci\u00f3n. Tarea entregable Realiza las modificaciones indicadas hasta que consigas observar, en la salida del servidor UDP mostrada por el profesor, los datos enviados por tu SensorTag. Entrega el c\u00f3digo modificado y una evicencia (captura de pantalla) de la correcci\u00f3n del mismo.","title":"Pr\u00e1ctica 7"},{"location":"RPI-I/P7/#practica-6-6lowpan-sensortag","text":"","title":"Pr\u00e1ctica 6. 6LowPAN (SensorTag)"},{"location":"RPI-I/P7/#objetivos","text":"El objetivo principal de la presente pr\u00e1ctica es reproducir (y ampliar) el entorno simulado visto en la pr\u00e1ctica anterior, pero en este caso utilizando hardware real. Para ello, ampliaremos el entorno para desplegar un router de borde f\u00edsico en el laboratorio, que enrutar\u00e1 los mensajes con origen la red RPL hacia un servidor UDP f\u00edsico situado en la red externa. Tras el despliegue, cada Sensortag que forme parte de la red RPL enviar\u00e1, peri\u00f3dicamente, mensajes UDP con un formato preestablecido, que ser\u00e1n mostrados por pantalla en el servidor UDP desplegado en el PC del profesor.","title":"Objetivos"},{"location":"RPI-I/P7/#despliegue-y-modificacion-de-un-cliente-udp-en-el-sensortag","text":"Para la realizaci\u00f3n de la pr\u00e1ctica, partiremos del ejemplo de cliente UDP situado en el directorio examples/ipv6/rpl-udp/udp-client.c . Este sencillo c\u00f3digo realiza un env\u00edo peri\u00f3dico de un paquete UDP (en su versi\u00f3n original, una cadena de caracteres conteniendo el mensaje Hello XX from the client (siendo XX un n\u00famero de secuencia ascendente), a un servidor a la escucha en el puerto 5678 de una direcci\u00f3n IP determinada. Estudia el c\u00f3digo del cliente UDP, concretamente centr\u00e1ndote en las siguientes partes: Temporizaci\u00f3n del env\u00edo (l\u00ednea 252) . El c\u00f3digo establece un temporizador con un retardo determinado ( SEND_TIME ) y un callback asociado ( send_packet ). Env\u00edo del mensaje v\u00eda UDP (l\u00ednea 111) . La funci\u00f3n uip_udp_packet_sendto realiza el env\u00edo del mensaje al extremo remoto del socket UDP. En este caso, utiliza la direcci\u00f3n de inicio del buffer ( buf ) y su tama\u00f1o para controlar el inicio del mensaje y su tama\u00f1o en bytes. Reporte del estado de las tablas de enrutamiento y rutas por defecto . La funci\u00f3n send_packet incluye, en su parte inicial, un reporte del estado de las tablas de enrutamiento (rutas por defecto) precediendo a cada env\u00edo del mensaje. Establecimiento de direcci\u00f3n IP y puerto del servidor UDP . La variable server_ipaddr contiene la direcci\u00f3n IP del destino de la comunicaci\u00f3n. El puerto destino viene fijado por la macro UDP_SERVER_PORT . Las modificaciones que deber\u00e1s realizar para conseguir interactuar con el servidor UDP remoto son sencillas, pero requieren ser correctas para una correcta comunicaci\u00f3n: Modifica el valor de la direcci\u00f3n IP destino para que coincida con la indicada por el profesor. Para ello, deber\u00e1s modificar el valor de la variable server_address , que codifica una direcci\u00f3n IPv6, para embeber en ella una direcci\u00f3n IPv4. Para ello, los 80 primero bits de la direcci\u00f3n deber\u00e1n ser 0s, seguidos de 16 bits fijados con valor 1, y seguidos por \u00faltimo de los 32 bits de la direcci\u00f3n IPv4 que se te indicar\u00e1. Modifica el valor del puerto destino para que coincida con el indicado por el profesor. Modifica la l\u00f3gica de env\u00edo para que el mensaje a enviar contenta, en este orden, los siguientes datos: struct mensaje{ unsigned short id; // Identificador unico del mensaje. unsigned short ip; // Ultimos dos bytes de la direcci\u00f3n IPv6 del emisor (tu Sensortag). unsigned short nsensors; // N\u00famero de valores sensorizados que se env\u00edan. float sensors[6]; // Valores sensorizados. }; Los valores sensorizados pueden generarse aleatoriamente o asign\u00e1rseles valores fijos.","title":"Despliegue y modificaci\u00f3n de un cliente UDP en el SensorTag"},{"location":"RPI-I/P7/#compilacion-de-la-imagen","text":"Antes de comenzar a trabajar, crea una nueva carpeta al mismo nivel que la del ejemplo original, sobre la que realizar\u00e1s las compilaciones del firmware . Una vez creada, realiza una primera compilaci\u00f3n de prueba, utilizando la orden: make TARGET=srf06-cc26xx BOARD=sensortag/cc2650 CPU_FAMILY=cc26xx udp-client Si todo ha ido bien, esta orden crear\u00e1 un fichero binario con nombre udp-client.hex , que utilizar\u00e1s en los siguientes pasos para flashear tu SensorTag.","title":"Compilaci\u00f3n de la imagen"},{"location":"RPI-I/P7/#flasheado-de-imagen","text":"El proceso de flasheado de la anterior imagen requiere el uso de la herramienta Uniflash , que encontrar\u00e1s en tu escritorio. En todo momento, tu SensorTag debe estar conectado al depurador ( Devpack ), y \u00e9ste a tu m\u00e1quina virtual. Arranca Uniflash y selecciona tu dispositivo de entre los que se muestran en la parte superior de la pantalla. A continuaci\u00f3n, en la pantalla Flash images , selecciona tu fichero .hex y elige la orden Load image . Es importante que no selecciones la opci\u00f3n Binary . Cuando el proceso haya finalizado, puedes reiniciar tu SensorTag y comenzar una sesi\u00f3n de monitorizaci\u00f3n, como se muestar a continuaci\u00f3n.","title":"Flasheado de imagen"},{"location":"RPI-I/P7/#monitorizacion-via-minicom","text":"Instala el programa minicom ( sudo apt-get install minicom ) y arr\u00e1ncalo con la orden minicom . Configura una nueva conexi\u00f3n usando los siguientes par\u00e1metros (accede a la pantalla correspondiente usando la combinaci\u00f3n de teclas Ctrl+a+z ): Puerto: /dev/ttyACM0 (aseg\u00farate de que tu SensorTag es reconocido en dicho puerto usando la orden dmesg ). BPS: 9600 . Si todo ha ido bien, deber\u00e1s observar por pantalla la salida de depuraci\u00f3n de Contiki.","title":"Monitorizaci\u00f3n v\u00eda minicom"},{"location":"RPI-I/P7/#actualizacion-del-firmware-del-devpack","text":"El proceso de flasheado requiere, en algunos casos, un proceso de actualizaci\u00f3n del firmware del Devpack . Sigue las instrucciones proporcionadas en Campus Virtual para llevar a cabo dicho proceso de actualizaci\u00f3n. Tarea entregable Realiza las modificaciones indicadas hasta que consigas observar, en la salida del servidor UDP mostrada por el profesor, los datos enviados por tu SensorTag. Entrega el c\u00f3digo modificado y una evicencia (captura de pantalla) de la correcci\u00f3n del mismo.","title":"Actualizaci\u00f3n del firmware del Devpack"},{"location":"RPI-I/P8/","text":"Pr\u00e1ctica 8. LoRA","title":"Pr\u00e1ctica 8"},{"location":"RPI-I/P8/#practica-8-lora","text":"","title":"Pr\u00e1ctica 8. LoRA"},{"location":"RPI-II/P1/","text":"Pr\u00e1ctica 1. Programaci\u00f3n con sockets en Python Objetivos Familiarizarse con la API de sockets en Python. Desarrollar esquemas b\u00e1sicos de sistemas cliente/servidor TCP y UDP utilizando Python. Ser capaces de analizar el tr\u00e1fico generado en una conexi\u00f3n TCP y UDP a trav\u00e9s de Wireshark. Dise\u00f1ar un protocolo de capa de aplicaci\u00f3n para simular una aplicaci\u00f3n cliente/servidor utilizando TCP y UDP. Observar la diferencia en tr\u00e1fico generado para una misma aplicaci\u00f3n utilizando TCP y UDP. Implementar servidores multi-hilo en Python. Introducci\u00f3n La historia de los sockets se remonta al origen de ARPANET, en 1971, y su posterior estandarizaci\u00f3n en forma de API dentro del sistema operativo Berkeley Software Distribution (BSD) , liberado en 1983, bajo el nombre de sockets de Berkeley . Con la popularizaci\u00f3n de Internet en los a\u00f1os 90, y de la mano de la World Wide Web , la programaci\u00f3n de red sufri\u00f3 tambi\u00e9n una notable evoluci\u00f3n. Los servidores web y los navegadores no fueron (ni son) las \u00fanicas aplicaciones basadas en sockets . De hecho, los sistemas cliente/servidor son a d\u00eda de hoy ubicuos e incluyen, por supuesto, a todos los protocolos de alto nivel que dan soporte a Internet de las Cosas. De hecho, a d\u00eda de hoy, aunque los potocolos de alto nivel (capa de aplicaci\u00f3n) han evolucionado hasta niveles de sofisticaci\u00f3n no considerados en sus inicios, la API de bajo nivel sobre la que se basan se mantiene inalterada. El tipo m\u00e1s com\u00fan de aplicaciones basadas en sockets se basa en el paradigma cliente/servidor, donde una de las partes act\u00faa como servidor , esperando pasivamente conexiones desde un conjunto de uno o m\u00e1s clientes . A continuaci\u00f3n, veremos c\u00f3mo desarrollar este tipo de paradigma desde Python, utilizando sockets Berkeley . Existen tambi\u00e9n los llamados Unix domain sockets , que permiten la comunicaci\u00f3n directa entre procesos en el mismo host , aunque quedan fuera de nuestro inter\u00e9s en el \u00e1mbito de IoT. La API de sockets en Python El m\u00f3dulo socket de Python proporciona una interfaz completa para trabajar con la API de sockets de Berkeley . En la presente pr\u00e1ctica, trabajaremos exclusivamente con esta API para desarrollar aplicaciones cliente/servidor utilizando los protocolos TCP y UDP. Las funciones y m\u00e9todos principales de la API de sockets son: socket() - bind() - listen() - accept() - connect() - connect_ex() - send() - recv() - close() - Python prorpociona una API consistente y completa mapeada directamente a las anteriores llamadas al sistema, t\u00edpicamente escritas en lenguaje C. Como parte de su biblioteca est\u00e1ndar, Python tambi\u00e9n proporciona clases que facilitan el trabajo con las funciones de bajo nivel. Aunque no lo cubriremos, el m\u00f3dulo socketserver proporciona una forma sencilla de crear servidores de red. Existen tambi\u00e9n numerosos m\u00f3dulos disponibles para implementar protocolos de alto nivel (por ejemplo HTTP o SMTP), v\u00e9ase . Sockets TCP En Python, los sockets TCP se crean en Python utilizando socket.socket() , especificando el tipo de socket como socket.SOCK_STREAM . El protocolo de control de transmisi\u00f3n (TCP) se caracteriza por dos rasgos principales: Es confiable : se implementan mecanismos de detecci\u00f3n de p\u00e9rdidas en la red y reenv\u00edo de paquetes perdidos. Garantiza una entrega de paquetes en orden : los datos se entregan a las capas superiores (aplicaciones) en el mismo orden en el que fueron enviados. En contra, los sockets UDP se crean a trav\u00e9s de socket.SOCK_DGRAM , y no son confiables ni garantizan la entrega de paquetes en orden. Por tanto, es el desarrollador de aplicaciones quien, en caso de as\u00ed desearlo en el dise\u00f1o de la aplicaci\u00f3n, debe implementar estos mecanismos de forma espec\u00edfica. En el siguiente diagrama se muestra la secuencia t\u00edpica de invocaciones a la API de sockets para TCP: En la figura, la columna de la izquierda representa al servidor, mientras que la columna de la derecha representa al cliente en la conexi\u00f3n TCP. Observa las invocaciones necesarias para configurar un socket a la escucha de conexiones entrantes: socket() bind() listen() accept() En este extremo, un socket escucha ( listen ) potenciales conexiones entrantes desde clientes. Cuando un cliente solicita conectar, el servidor acepta ( accept ) la conexi\u00f3n, complet\u00e1ndola. El cliente invoca a connect() para establecer una conexi\u00f3n con el servidor e inicia el proceso de conexi\u00f3n a tres v\u00edas ( three-way connection ). Una vez establecida la conexi\u00f3n, los datos se intercambian entre cliente y servidor a trav\u00e9s de invocaciones a send() y recv() . Finalmente, el socket se destruye (esto es, la conexi\u00f3n entre ambos extremos se cierra) a trav\u00e9s de una invocaci\u00f3n a close() en cada extremo. Cliente/servidor echo TCP Veamos un ejemplo sencillo para crear un par cliente-servidor. En este caso, el servidor simplemente responder\u00e1 con la misma cadena que reciba desde el cliente. Servidor echo #!/usr/bin/env python3 #### servidor_echo.py import socket HOST = '127.0.0.1' # Interfaz est\u00e1ndar de loopback (localhost) PORT = 65432 # Puerto de escucha (los puertos mayores a 1023 son no privilegiados) with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: s.bind((HOST, PORT)) s.listen() conn, addr = s.accept() with conn: print('Conectado ', addr) while True: data = conn.recv(1024) if not data: break conn.sendall(data) Nota De momento, no importa si no entiendes todas las l\u00edneas en el anterior c\u00f3digo. Simplemente se trata de un punto de partida para desarrollar un servidor sencillo. Sin embargo, es conveniente que copies el c\u00f3digo en un fichero de texto (por ejemplo, llamado servidor_echo.py ) para que podeamos probarlo. Veamos l\u00ednea a l\u00ednea las partes m\u00e1s importantes del anterior c\u00f3digo. socket.socket() crea un objeto socket . Observa que, al crearse a trav\u00e9s de una construcci\u00f3n with , no es necesario invocar expl\u00edcitamente a s.close() , aunque debes tener en cuenta que el objeto es destruido al finalizar la construcci\u00f3n: with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: pass # Es posible usar el socket win invocar a s.close(). Los argumentos que se proporcionan a socket() especifican la familia de direcciones ( AF_INET ) y tipo de socket ( SOCK_STREAM ). AF_INET es la familia de direcciones de Internet para IPv4. SOCK_STREAM es el tipo de socket que permite la creaci\u00f3n de conexiones TCP. bind() se utiliza para asociar el socket a una interfaz de red y n\u00famero de puerto espec\u00edficos: HOST = '127.0.0.1' # Interfaz est\u00e1ndar de loopback (localhost) PORT = 65432 # Puerto de escucha (los puertos mayores a 1023 son no privilegiados) # ... s.bind((HOST, PORT)) Los valores proporcionados a bind() dependen de la familia de direcciones seleccionada para el socket . En este ejemplo, al utilizar AF_INET , espera una tupla con \u00fanicamente dos valores (host, puerto) . Para determinar el host , es posible utilizar un nombre de host , una direcci\u00f3n IP o una cadena vac\u00eda. Si utilizamos una direcci\u00f3n IP, \u00e9sta debe ser especificarse mediante una cadena que contenga una direcci\u00f3n IPv4 bien formada. La direcci\u00f3n 127.0.0.1 es la direcci\u00f3n IPv4 est\u00e1ndar para la interfaz de loopback , por lo que \u00fanicamente procesos que est\u00e9n ejecut\u00e1ndose en el propio host podr\u00e1n comunicar con el servidor. Si proporcionamos una cadena vac\u00eda, el servidro aceptar\u00e1 conexiones entrantes a trav\u00e9s de todas las interfaces IPv4 disponibles en el sistema. El n\u00famero de puerto ( port ) se especifica con un valor entero entre 1 y 65535, y espcifica el puerto (en este caso, TCP) a trav\u00e9s del cual el servidor aceptar\u00e1 conexiones desde los clientes. La mayor\u00eda de sistemas requieren permisos de superusuario para escuchar a trav\u00e9s de los puertos ( well-known ), es decir, con valor inferior a 1024. Continuando con el ejemplo, listen() posibilita que un servidor pueda, en el futuro, aceptar ( accept() ) conexiones entrantes. En otras palabras, pone a la escucha al socket : s.listen() conn, addr = s.accept() La invocaci\u00f3n a accept() bloquea el proceso y espera a una conexi\u00f3n entrante. Cuando un cliente conecta, devuelve un objeto socket que representa la conexi\u00f3n, as\u00ed como una tupla ( addr ) que contiene la direcci\u00f3n del cliente. Concretamente, esta tupla contiene los valores (host, port) que almacenan la direcci\u00f3n IPv4 y puerto del cliente que solicita la conexi\u00f3n. Observa que, en el ejemplo, conn es el objeto socket que usaremos para comunicar con el cliente: conn, addr = s.accept() with conn: print('Conectado ', addr) while True: data = conn.recv(1024) if not data: break conn.sendall(data) Tras obtener el objeto devuelto por accept() , dise\u00f1amos el servidor como un bucle infinito que invoca repetidamente a llamadas bloqueantes a conn.recv() . As\u00ed, leemos los datos enviados por el cliente y los reenviamos sin modificaci\u00f3n utilizando conn.sendall() . Si conn.recv() devuelve un objeto de tipo bytes vac\u00edo ( b'' ) significa que el cliente cerr\u00f3 la conexi\u00f3n, en cuyo caso el bucle termina, destruy\u00e9ndose el socket al salir de la sentencia with . Cliente echo Veamos a continuaci\u00f3n la estructura general del cliente (puedes usar, por ejemplo, cliente_echo.py como nombre para el fichero): #!/usr/bin/env python3 ### cliente_echo.py import socket HOST = '127.0.0.1' # IP del servidor PORT = 65432 # Puerto de escucha del servidor with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: s.connect((HOST, PORT)) s.sendall(b'Hola, mundo') data = s.recv(1024) print('Recibido ', repr(data)) En comparaci\u00f3n con el servidor, la estructura del cliente es m\u00e1s simple; simplemente crea un nuevo objeto socket , conecta con el servidor e invoca a s.sendall() para enviar el mensaje. Finalmente, espera la recepci\u00f3n de la respuesta utilizando s.recv() y la imprime por pantalla. Ejecuci\u00f3n del cliente y servidor echo A continuaci\u00f3n, ejecutaremos cliente y servidor para observar el estado de las conexiones durante su ciclo de vida. Ejecuta en una terminal el servidor: $ python3 ./servidor-echo.py Como ves, la terminal se bloquea (de hecho, el servidor permanece en estado bloqueado) en la invocaci\u00f3n: conn, addr = s.accept() Realmente, el servidor est\u00e1 esperando a que haya conexiones entrantes por parte de un cliente. Abre otra terminal y ejecuta el cliente: $ python3 cliente-echo.py Recibido 'Hola, mundo' En la ventana del servidor, deber\u00edas ver algo similar a: $ python3 ./servidor-echo.py Conectado ('127.0.0.1, 61234') En esta salida, el servidor ha mostrado por pantalla la tupla devuelta por s.accept() , que incluye la direcci\u00f3n IP y el n\u00famero de puerto TCP. Dicho n\u00famero de puerto (en el ejemplo anterior, 61234) es seleccionado aleatoriamente por el sistema operativo y puede variar en tu ejecuci\u00f3n. Herramientas para observar el estado del socket Podemos utilizar la herramienta netstat para observar el estado actual de los sockets en cualquier sistema operativo (macOS, Linux e incluso Windows). Por ejemplo, esta ser\u00eda la salida de netstat en Linux tras ejecutar el servidor: netstat -an | grep 65432 Conexiones activas de Internet (servidores y establecidos) Proto Recib Enviad Direcci\u00f3n local Direcci\u00f3n remota Estado tcp 0 0 127.0.0.1:65432 0.0.0.0:* ESCUCHAR Observa que hemos filtrado la salida de la orden netcat seg\u00fan el n\u00famero de puerto utilizado. Observa el valor de las columnas Proto, Direcci\u00f3n local y Estado . Nota Otra forma de observar el estado de las conexiones es a trav\u00e9s de la orden lsof -i -n . Ejec\u00fatala y observa su salida. Capturas de tr\u00e1fico v\u00eda Wireshark Wireshark es una herramienta de c\u00f3digo abierto ampliamente utilizada para analizar protocolos de comunicaci\u00f3n de red en cualquiera de las capas de la pila TCP/IP (como tambi\u00e9n en otros protocolos). Wireshark implementa un amplio abanico de filtros para definir criterios de b\u00fasqueda en las capturas de tr\u00e1fico, aunque de momento, en nuestro caso, no ser\u00e1 necesario utilizar filtros espec\u00edficos. Para arrancar Wireshark en la m\u00e1quina virtual proporcionada (o en cualquier instalaci\u00f3n b\u00e1sica Linux), teclea en tu terminal: $ sudo wireshark Tras el arranque, podemos comenzar una nueva captura de tr\u00e1fico a trav\u00e9s del men\u00fa Capture , opci\u00f3n Start . La pantalla de selecci\u00f3n de interfaz nos permitir\u00e1 definir en qu\u00e9 interfaz de red se realizar\u00e1 la captura. En nuestro caso, ya que vamos a comunicar dos procesos en la misma m\u00e1quina, elegiremos la interfaz de Loopback (lo) y comenzaremos la captura. Tarea Arranca Wireshark y prepara una captura sobre la interfaz de loopback . Ejecuta el servidor echo TCP y el cliente correspondiente, y analiza el tr\u00e1fico generado. Especialmente, f\u00edjate en el proceso de establecimiento de conexi\u00f3n en tres v\u00edas, paquetes de Acknowledge tras el env\u00edo de cada mensaje y, en general, en cualquier otro aspecto que consideres de inter\u00e9s. Sockets UDP La creaci\u00f3n y gesti\u00f3n de sockets UDP en Python resulta todav\u00eda m\u00e1s sencilla. Observa el siguiente c\u00f3digo, que crea un servidor UDP utilizando la API de sockets Python: import socket udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) udp_socket.bind((\"localhost\", 5005)) data = udp_socket.recv(512) print(data) Primero, importamos la biblioteca socket de recepci\u00f3n, igual que en el caso de TCP. Obviamente, en este caso el tipo de socket pasa a ser socket.DOCK_DGRAM , para indicar que deseamos utilizar UDP en la comunicaci\u00f3n. El programa espera a la recepci\u00f3n de un paquete utilizando el m\u00e9todo bloqueante recv , cuyo \u00fanico par\u00e1metro indica el n\u00famero m\u00e1ximo de bytes que deseamos recibir. Cuando un paquete llega al socket, el metodo recv devolver\u00e1 un array de bytes, que ser\u00e1 almacenado en la variable que deseemos. El env\u00edo de datos a trav\u00e9s de un socket UDP es tambi\u00e9n sencillo: import socket udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) udp_socket.bind((\"localhost\", 0)) data = b\"Hola, mundo!\" udp_socket.sendto(data,(\"localhost\", 5005)) Observa que, en este caso, asociamos ( bind ) el socket a un puerto especificado como 0. Este valor especial indica al sistema operativo que elija para la transimisi\u00f3n un puerto origen aleatorio de entre los disponibles en el sistema. A continuaci\u00f3n, creamos los datos a enviar y los enviamos utilizando el m\u00e9todo sendto() . Este m\u00e9todo tomados argumentos: datos a enviar, y precisamente la direcci\u00f3n de env\u00edo. Los datos enviados a trav\u00e9s del socket deben formar parte de un array de bytes (por ello, la cadena a enviar viene precedida por el car\u00e1cter b ). Tarea Comprueba que, efectivamente, los c\u00f3digos de env\u00edo y recepci\u00f3n a trav\u00e9s de UDP funcionan como se espera. Nota Desde la versi\u00f3n 3 de Python, las cadenas se codifican utilizando Unicode. Al contrario que ASCII, conde cada caracter tiene una representaci\u00f3n en byte directa, Unicode utiliza enteros par representar cada caracter, que deben ser codificados para obtener una representaci\u00f3n en forma de byte. Uno de esos esquemas de codificaci\u00f3n es UTF-8. Por ejemplo, el siguiente c\u00f3digo muestra c\u00f3mo codificar una cadena Unicode en una representaci\u00f3n de bytes: cadena= \"Hola\" data = cadena.encode(\"UTF-8\") print(data, type(data)) lo cual genera b\"Hola\" <class 'bytes'> que puede ya ser enviado directamente por red. Hasta este punto, los programas UDP han sido totalmente unidireccionales en el env\u00edo/recepci\u00f3n de datos, pero obviamente, un socket UDP es un canal de comunicaci\u00f3n bidireccional. Tarea Implementa una funcionalidad similar al servidor echo que vimos para TCP, pero utilizando en este caso UDP. Realiza una captura de tr\u00e1fico en Wireshark similar a la realizada en el caso de TCP, y observa las principales diferencias entre ellas a nivel de tr\u00e1fico generado. Env\u00edo de datos binarios a trav\u00e9s de sockets Hasta este punto, hemos visto \u00fanicamente c\u00f3mo enviar cadenas de texto a trav\u00e9s de sockets TCP o UDP, pero es muy probable que sea necesario (o conveniente), en ocasiones, enviar datos directamente en formato binario (por ejemplo, valores num\u00e9ricos en punto flotante o enteros). Utilizando el m\u00f3dulo struct de Python podemos especificar qu\u00e9 tipo o tipos de datos se almacenan en una secuencia de bytes y c\u00f3mo decodificarlos. Tambi\u00e9n es posible especificar en qu\u00e9 lugar de la secuencia se alojan dichos datos, permitiendo el empaquetado de m\u00faltiples datos de distintos tipos de forma sencilla, y su posterior decodificaci\u00f3n en el otro extremo de la comunicaci\u00f3n. Nota Para todos los detalles del m\u00f3dulo struct , consulta la p\u00e1gina oficial de documentaci\u00f3n . El m\u00f3dulo struct proporciona dos m\u00e9todos de inter\u00e9s: pack y unpack . La siguiente sentencia: struct.pack(\">iii\", 1, 2, 3) utiliza el m\u00e9todo pack para realizar un empaquetado de datos. Concretamente, observa como el m\u00e9todo recibe dos par\u00e1metros: En primer lugar, el par\u00e1metro de formato \">iii\" . Define como debe codificarse cada valor en la secuencia de bytes. El primer car\u00e1cter indica el endianness utilizado, en este caso big endian (utilizar\u00edamos \">\" para big endian , \"<\" para little endian y \"=\" para network (big) endian). En segundo lugar, los valores a empaquetar. Observa que el formato, adem\u00e1s, incluye el n\u00famero y tipo de los datos a empaquetar (en este caso, tres valores detipo entero). Para otros tipos de datos, consulta la documentaci\u00f3n del m\u00f3dulo. Desempaquetar los datos enviados en el extremo opuesto es intuitivo: a, b, c = struct.unpack( \">iii\" ) A continuaci\u00f3n, mostramos un ejemplo de sistema cliente/servidor TCP que hace uso del m\u00f3dulo struct para realizar el env\u00edo de dos datos enteros y uno flotante entre un cliente y un servidor. # Cliente import binascii import socket import struct import sys # Socket TCP sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_address = ('localhost', 10001) sock.connect(server_address) packed_data = struct.pack(\"=iif\", 1, 4, 2.7) try: # Envio de datos print('Enviando \"%s\"' % binascii.hexlify(packed_data)) sock.sendall(packed_data) finally: print('Cerrando socket') sock.close() # Servidor import binascii import socket import struct import sys # Socket TCP sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_address = ('localhost', 10001) sock.bind(server_address) sock.listen(1) while True: print('Esperando conexiones entrantes') connection, client_address = sock.accept() try: data = connection.recv(1024) print('Recibido \"%s\"' % binascii.hexlify(data)) unpacked_data = struct.unpack(\"=iif\", data) print('Desempaquetado:', unpacked_data) finally: connection.close() Tarea Ejecuta el anterior sistema cliente servidor y analiza el tr\u00e1fico generado, en busca de los datos binarios empaquetados. Experimenta con otros tipos de datos y endianess y observa las diferencias. Tarea entregable Tarea entregable Se pide dise\u00f1ar un sistema cliente/servidor programado en Python, que simule el env\u00edo de un conjunto de datos sensorizados desde un cliente hacia un servidor. El protocolo a utilizar (formato de datos enviado por la red a nivel de aplicaci\u00f3n) debe ser propuesto por el propio alumno y descrito previamente al desarrollo. Se valorar\u00e1 el uso de m\u00faltiples tipos de datos tanto en el env\u00edo de datos sensorizados como de posibles respuestas por parte del servidor. Se desarrollar\u00e1 una versi\u00f3n utilizando TCP y otra equivalente usando UDP. El cliente enviar\u00e1 los datos de forma peri\u00f3dica y se \u00e9stos generar\u00e1n de modo aleatorio. A modo de entrega, se solicitan los c\u00f3digos desarrollados, as\u00ed como un an\u00e1lisis del tr\u00e1fico generado, considerando la sobrecarga (en bytes reales enviados) introducida por cada protocolo de capa de transporte. Ejemplo de sistema cliente/servidor multi-hilo Los ejemplos anteriormente descritos, aunque funcionales, adolecen en su dise\u00f1o de una caracter\u00edstica esencial: el servidor deja de atender peticiones entrantes mientras trata cada nuevo env\u00edo por parte del cliente. Los siguientes ejemplos muestran implementaciones sencillas con soporte multi-hilo para un sistema cliente/servidor escrito en Python. # Servidor TCP concurrente import socket, threading class ClientThread(threading.Thread): def __init__(self,clientAddress,clientsocket): threading.Thread.__init__(self) self.csocket = clientsocket print (\"Nueva conexion anyadida: \", clientAddress) def run(self): print (\"Conexion desde: \", clientAddress) #self.csocket.send(bytes(\"Hi, This is from Server..\",'utf-8')) msg = '' while True: data = self.csocket.recv(2048) msg = data.decode() if msg=='bye': break print (\"Desde el cliente\", msg) self.csocket.send(bytes(msg,'UTF-8')) print (\"Cliente \", clientAddress , \" desconectado...\") LOCALHOST = \"127.0.0.1\" PORT = 8080 server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) server.bind((LOCALHOST, PORT)) print(\"Servidor arrancado...\") print(\"Esperando petici\u00f3n de clientes...\") server.listen(1) while True: clientsock, clientAddress = server.accept() newthread = ClientThread(clientAddress, clientsock) newthread.start() # Cliente TCP. El env\u00edo de la cadena bye indica petici\u00f3n de desconexi\u00f3n. import socket SERVER = \"127.0.0.1\" PORT = 8080 client = socket.socket(socket.AF_INET, socket.SOCK_STREAM) client.connect((SERVER, PORT)) client.sendall(bytes(\"Hola, soy un cliente!!\",'UTF-8')) while True: in_data = client.recv(1024) print(\"Desde el servidor :\" ,in_data.decode()) out_data = input() client.sendall(bytes(out_data,'UTF-8')) if out_data=='end': break client.close() Tarea Estudia el c\u00f3digo del servidor concurrente y observa c\u00f3mo gestiona la creaci\u00f3n de hilos para atender cada petici\u00f3n entrante. Conecta simult\u00e1neamente m\u00faltiples clientes y observa el estado de los sockets mediante las herramientas correspondientes. Tarea entregable opcional Tarea entregable opcional Modifica tu primer entregable para considerar una implementaci\u00f3n multihilo del servidor TCP, siguiendo las directrices de los c\u00f3digos de ejemplo anteriormente proporcionados. Tarea entregable opcional Tarea entregable opcional Modifica el protocolo de env\u00edo para que tu aplicaci\u00f3n cliente/servidor UDP garantice en la medida de lo posible la recepci\u00f3n de los paquetes enviados desde el cliente, as\u00ed como su recepci\u00f3n en orden. Vuelve a analizar el tr\u00e1fico necesario en este caso comparado con una comunicaci\u00f3n b\u00e1sica basada en TCP (donde s\u00ed se garantizan, a nivel de transporte, dichas caracter\u00edsticas).","title":"Pr\u00e1ctica 1"},{"location":"RPI-II/P1/#practica-1-programacion-con-sockets-en-python","text":"","title":"Pr\u00e1ctica 1. Programaci\u00f3n con sockets en Python"},{"location":"RPI-II/P1/#objetivos","text":"Familiarizarse con la API de sockets en Python. Desarrollar esquemas b\u00e1sicos de sistemas cliente/servidor TCP y UDP utilizando Python. Ser capaces de analizar el tr\u00e1fico generado en una conexi\u00f3n TCP y UDP a trav\u00e9s de Wireshark. Dise\u00f1ar un protocolo de capa de aplicaci\u00f3n para simular una aplicaci\u00f3n cliente/servidor utilizando TCP y UDP. Observar la diferencia en tr\u00e1fico generado para una misma aplicaci\u00f3n utilizando TCP y UDP. Implementar servidores multi-hilo en Python.","title":"Objetivos"},{"location":"RPI-II/P1/#introduccion","text":"La historia de los sockets se remonta al origen de ARPANET, en 1971, y su posterior estandarizaci\u00f3n en forma de API dentro del sistema operativo Berkeley Software Distribution (BSD) , liberado en 1983, bajo el nombre de sockets de Berkeley . Con la popularizaci\u00f3n de Internet en los a\u00f1os 90, y de la mano de la World Wide Web , la programaci\u00f3n de red sufri\u00f3 tambi\u00e9n una notable evoluci\u00f3n. Los servidores web y los navegadores no fueron (ni son) las \u00fanicas aplicaciones basadas en sockets . De hecho, los sistemas cliente/servidor son a d\u00eda de hoy ubicuos e incluyen, por supuesto, a todos los protocolos de alto nivel que dan soporte a Internet de las Cosas. De hecho, a d\u00eda de hoy, aunque los potocolos de alto nivel (capa de aplicaci\u00f3n) han evolucionado hasta niveles de sofisticaci\u00f3n no considerados en sus inicios, la API de bajo nivel sobre la que se basan se mantiene inalterada. El tipo m\u00e1s com\u00fan de aplicaciones basadas en sockets se basa en el paradigma cliente/servidor, donde una de las partes act\u00faa como servidor , esperando pasivamente conexiones desde un conjunto de uno o m\u00e1s clientes . A continuaci\u00f3n, veremos c\u00f3mo desarrollar este tipo de paradigma desde Python, utilizando sockets Berkeley . Existen tambi\u00e9n los llamados Unix domain sockets , que permiten la comunicaci\u00f3n directa entre procesos en el mismo host , aunque quedan fuera de nuestro inter\u00e9s en el \u00e1mbito de IoT.","title":"Introducci\u00f3n"},{"location":"RPI-II/P1/#la-api-de-sockets-en-python","text":"El m\u00f3dulo socket de Python proporciona una interfaz completa para trabajar con la API de sockets de Berkeley . En la presente pr\u00e1ctica, trabajaremos exclusivamente con esta API para desarrollar aplicaciones cliente/servidor utilizando los protocolos TCP y UDP. Las funciones y m\u00e9todos principales de la API de sockets son: socket() - bind() - listen() - accept() - connect() - connect_ex() - send() - recv() - close() - Python prorpociona una API consistente y completa mapeada directamente a las anteriores llamadas al sistema, t\u00edpicamente escritas en lenguaje C. Como parte de su biblioteca est\u00e1ndar, Python tambi\u00e9n proporciona clases que facilitan el trabajo con las funciones de bajo nivel. Aunque no lo cubriremos, el m\u00f3dulo socketserver proporciona una forma sencilla de crear servidores de red. Existen tambi\u00e9n numerosos m\u00f3dulos disponibles para implementar protocolos de alto nivel (por ejemplo HTTP o SMTP), v\u00e9ase .","title":"La API de sockets en Python"},{"location":"RPI-II/P1/#sockets-tcp","text":"En Python, los sockets TCP se crean en Python utilizando socket.socket() , especificando el tipo de socket como socket.SOCK_STREAM . El protocolo de control de transmisi\u00f3n (TCP) se caracteriza por dos rasgos principales: Es confiable : se implementan mecanismos de detecci\u00f3n de p\u00e9rdidas en la red y reenv\u00edo de paquetes perdidos. Garantiza una entrega de paquetes en orden : los datos se entregan a las capas superiores (aplicaciones) en el mismo orden en el que fueron enviados. En contra, los sockets UDP se crean a trav\u00e9s de socket.SOCK_DGRAM , y no son confiables ni garantizan la entrega de paquetes en orden. Por tanto, es el desarrollador de aplicaciones quien, en caso de as\u00ed desearlo en el dise\u00f1o de la aplicaci\u00f3n, debe implementar estos mecanismos de forma espec\u00edfica. En el siguiente diagrama se muestra la secuencia t\u00edpica de invocaciones a la API de sockets para TCP: En la figura, la columna de la izquierda representa al servidor, mientras que la columna de la derecha representa al cliente en la conexi\u00f3n TCP. Observa las invocaciones necesarias para configurar un socket a la escucha de conexiones entrantes: socket() bind() listen() accept() En este extremo, un socket escucha ( listen ) potenciales conexiones entrantes desde clientes. Cuando un cliente solicita conectar, el servidor acepta ( accept ) la conexi\u00f3n, complet\u00e1ndola. El cliente invoca a connect() para establecer una conexi\u00f3n con el servidor e inicia el proceso de conexi\u00f3n a tres v\u00edas ( three-way connection ). Una vez establecida la conexi\u00f3n, los datos se intercambian entre cliente y servidor a trav\u00e9s de invocaciones a send() y recv() . Finalmente, el socket se destruye (esto es, la conexi\u00f3n entre ambos extremos se cierra) a trav\u00e9s de una invocaci\u00f3n a close() en cada extremo.","title":"Sockets TCP"},{"location":"RPI-II/P1/#clienteservidor-echo-tcp","text":"Veamos un ejemplo sencillo para crear un par cliente-servidor. En este caso, el servidor simplemente responder\u00e1 con la misma cadena que reciba desde el cliente.","title":"Cliente/servidor echo TCP"},{"location":"RPI-II/P1/#servidor-echo","text":"#!/usr/bin/env python3 #### servidor_echo.py import socket HOST = '127.0.0.1' # Interfaz est\u00e1ndar de loopback (localhost) PORT = 65432 # Puerto de escucha (los puertos mayores a 1023 son no privilegiados) with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: s.bind((HOST, PORT)) s.listen() conn, addr = s.accept() with conn: print('Conectado ', addr) while True: data = conn.recv(1024) if not data: break conn.sendall(data) Nota De momento, no importa si no entiendes todas las l\u00edneas en el anterior c\u00f3digo. Simplemente se trata de un punto de partida para desarrollar un servidor sencillo. Sin embargo, es conveniente que copies el c\u00f3digo en un fichero de texto (por ejemplo, llamado servidor_echo.py ) para que podeamos probarlo. Veamos l\u00ednea a l\u00ednea las partes m\u00e1s importantes del anterior c\u00f3digo. socket.socket() crea un objeto socket . Observa que, al crearse a trav\u00e9s de una construcci\u00f3n with , no es necesario invocar expl\u00edcitamente a s.close() , aunque debes tener en cuenta que el objeto es destruido al finalizar la construcci\u00f3n: with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: pass # Es posible usar el socket win invocar a s.close(). Los argumentos que se proporcionan a socket() especifican la familia de direcciones ( AF_INET ) y tipo de socket ( SOCK_STREAM ). AF_INET es la familia de direcciones de Internet para IPv4. SOCK_STREAM es el tipo de socket que permite la creaci\u00f3n de conexiones TCP. bind() se utiliza para asociar el socket a una interfaz de red y n\u00famero de puerto espec\u00edficos: HOST = '127.0.0.1' # Interfaz est\u00e1ndar de loopback (localhost) PORT = 65432 # Puerto de escucha (los puertos mayores a 1023 son no privilegiados) # ... s.bind((HOST, PORT)) Los valores proporcionados a bind() dependen de la familia de direcciones seleccionada para el socket . En este ejemplo, al utilizar AF_INET , espera una tupla con \u00fanicamente dos valores (host, puerto) . Para determinar el host , es posible utilizar un nombre de host , una direcci\u00f3n IP o una cadena vac\u00eda. Si utilizamos una direcci\u00f3n IP, \u00e9sta debe ser especificarse mediante una cadena que contenga una direcci\u00f3n IPv4 bien formada. La direcci\u00f3n 127.0.0.1 es la direcci\u00f3n IPv4 est\u00e1ndar para la interfaz de loopback , por lo que \u00fanicamente procesos que est\u00e9n ejecut\u00e1ndose en el propio host podr\u00e1n comunicar con el servidor. Si proporcionamos una cadena vac\u00eda, el servidro aceptar\u00e1 conexiones entrantes a trav\u00e9s de todas las interfaces IPv4 disponibles en el sistema. El n\u00famero de puerto ( port ) se especifica con un valor entero entre 1 y 65535, y espcifica el puerto (en este caso, TCP) a trav\u00e9s del cual el servidor aceptar\u00e1 conexiones desde los clientes. La mayor\u00eda de sistemas requieren permisos de superusuario para escuchar a trav\u00e9s de los puertos ( well-known ), es decir, con valor inferior a 1024. Continuando con el ejemplo, listen() posibilita que un servidor pueda, en el futuro, aceptar ( accept() ) conexiones entrantes. En otras palabras, pone a la escucha al socket : s.listen() conn, addr = s.accept() La invocaci\u00f3n a accept() bloquea el proceso y espera a una conexi\u00f3n entrante. Cuando un cliente conecta, devuelve un objeto socket que representa la conexi\u00f3n, as\u00ed como una tupla ( addr ) que contiene la direcci\u00f3n del cliente. Concretamente, esta tupla contiene los valores (host, port) que almacenan la direcci\u00f3n IPv4 y puerto del cliente que solicita la conexi\u00f3n. Observa que, en el ejemplo, conn es el objeto socket que usaremos para comunicar con el cliente: conn, addr = s.accept() with conn: print('Conectado ', addr) while True: data = conn.recv(1024) if not data: break conn.sendall(data) Tras obtener el objeto devuelto por accept() , dise\u00f1amos el servidor como un bucle infinito que invoca repetidamente a llamadas bloqueantes a conn.recv() . As\u00ed, leemos los datos enviados por el cliente y los reenviamos sin modificaci\u00f3n utilizando conn.sendall() . Si conn.recv() devuelve un objeto de tipo bytes vac\u00edo ( b'' ) significa que el cliente cerr\u00f3 la conexi\u00f3n, en cuyo caso el bucle termina, destruy\u00e9ndose el socket al salir de la sentencia with .","title":"Servidor echo"},{"location":"RPI-II/P1/#cliente-echo","text":"Veamos a continuaci\u00f3n la estructura general del cliente (puedes usar, por ejemplo, cliente_echo.py como nombre para el fichero): #!/usr/bin/env python3 ### cliente_echo.py import socket HOST = '127.0.0.1' # IP del servidor PORT = 65432 # Puerto de escucha del servidor with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: s.connect((HOST, PORT)) s.sendall(b'Hola, mundo') data = s.recv(1024) print('Recibido ', repr(data)) En comparaci\u00f3n con el servidor, la estructura del cliente es m\u00e1s simple; simplemente crea un nuevo objeto socket , conecta con el servidor e invoca a s.sendall() para enviar el mensaje. Finalmente, espera la recepci\u00f3n de la respuesta utilizando s.recv() y la imprime por pantalla.","title":"Cliente echo"},{"location":"RPI-II/P1/#ejecucion-del-cliente-y-servidor-echo","text":"A continuaci\u00f3n, ejecutaremos cliente y servidor para observar el estado de las conexiones durante su ciclo de vida. Ejecuta en una terminal el servidor: $ python3 ./servidor-echo.py Como ves, la terminal se bloquea (de hecho, el servidor permanece en estado bloqueado) en la invocaci\u00f3n: conn, addr = s.accept() Realmente, el servidor est\u00e1 esperando a que haya conexiones entrantes por parte de un cliente. Abre otra terminal y ejecuta el cliente: $ python3 cliente-echo.py Recibido 'Hola, mundo' En la ventana del servidor, deber\u00edas ver algo similar a: $ python3 ./servidor-echo.py Conectado ('127.0.0.1, 61234') En esta salida, el servidor ha mostrado por pantalla la tupla devuelta por s.accept() , que incluye la direcci\u00f3n IP y el n\u00famero de puerto TCP. Dicho n\u00famero de puerto (en el ejemplo anterior, 61234) es seleccionado aleatoriamente por el sistema operativo y puede variar en tu ejecuci\u00f3n.","title":"Ejecuci\u00f3n del cliente y servidor echo"},{"location":"RPI-II/P1/#herramientas-para-observar-el-estado-del-socket","text":"Podemos utilizar la herramienta netstat para observar el estado actual de los sockets en cualquier sistema operativo (macOS, Linux e incluso Windows). Por ejemplo, esta ser\u00eda la salida de netstat en Linux tras ejecutar el servidor: netstat -an | grep 65432 Conexiones activas de Internet (servidores y establecidos) Proto Recib Enviad Direcci\u00f3n local Direcci\u00f3n remota Estado tcp 0 0 127.0.0.1:65432 0.0.0.0:* ESCUCHAR Observa que hemos filtrado la salida de la orden netcat seg\u00fan el n\u00famero de puerto utilizado. Observa el valor de las columnas Proto, Direcci\u00f3n local y Estado . Nota Otra forma de observar el estado de las conexiones es a trav\u00e9s de la orden lsof -i -n . Ejec\u00fatala y observa su salida.","title":"Herramientas para observar el estado del socket"},{"location":"RPI-II/P1/#capturas-de-trafico-via-wireshark","text":"Wireshark es una herramienta de c\u00f3digo abierto ampliamente utilizada para analizar protocolos de comunicaci\u00f3n de red en cualquiera de las capas de la pila TCP/IP (como tambi\u00e9n en otros protocolos). Wireshark implementa un amplio abanico de filtros para definir criterios de b\u00fasqueda en las capturas de tr\u00e1fico, aunque de momento, en nuestro caso, no ser\u00e1 necesario utilizar filtros espec\u00edficos. Para arrancar Wireshark en la m\u00e1quina virtual proporcionada (o en cualquier instalaci\u00f3n b\u00e1sica Linux), teclea en tu terminal: $ sudo wireshark Tras el arranque, podemos comenzar una nueva captura de tr\u00e1fico a trav\u00e9s del men\u00fa Capture , opci\u00f3n Start . La pantalla de selecci\u00f3n de interfaz nos permitir\u00e1 definir en qu\u00e9 interfaz de red se realizar\u00e1 la captura. En nuestro caso, ya que vamos a comunicar dos procesos en la misma m\u00e1quina, elegiremos la interfaz de Loopback (lo) y comenzaremos la captura. Tarea Arranca Wireshark y prepara una captura sobre la interfaz de loopback . Ejecuta el servidor echo TCP y el cliente correspondiente, y analiza el tr\u00e1fico generado. Especialmente, f\u00edjate en el proceso de establecimiento de conexi\u00f3n en tres v\u00edas, paquetes de Acknowledge tras el env\u00edo de cada mensaje y, en general, en cualquier otro aspecto que consideres de inter\u00e9s.","title":"Capturas de tr\u00e1fico v\u00eda Wireshark"},{"location":"RPI-II/P1/#sockets-udp","text":"La creaci\u00f3n y gesti\u00f3n de sockets UDP en Python resulta todav\u00eda m\u00e1s sencilla. Observa el siguiente c\u00f3digo, que crea un servidor UDP utilizando la API de sockets Python: import socket udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) udp_socket.bind((\"localhost\", 5005)) data = udp_socket.recv(512) print(data) Primero, importamos la biblioteca socket de recepci\u00f3n, igual que en el caso de TCP. Obviamente, en este caso el tipo de socket pasa a ser socket.DOCK_DGRAM , para indicar que deseamos utilizar UDP en la comunicaci\u00f3n. El programa espera a la recepci\u00f3n de un paquete utilizando el m\u00e9todo bloqueante recv , cuyo \u00fanico par\u00e1metro indica el n\u00famero m\u00e1ximo de bytes que deseamos recibir. Cuando un paquete llega al socket, el metodo recv devolver\u00e1 un array de bytes, que ser\u00e1 almacenado en la variable que deseemos. El env\u00edo de datos a trav\u00e9s de un socket UDP es tambi\u00e9n sencillo: import socket udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) udp_socket.bind((\"localhost\", 0)) data = b\"Hola, mundo!\" udp_socket.sendto(data,(\"localhost\", 5005)) Observa que, en este caso, asociamos ( bind ) el socket a un puerto especificado como 0. Este valor especial indica al sistema operativo que elija para la transimisi\u00f3n un puerto origen aleatorio de entre los disponibles en el sistema. A continuaci\u00f3n, creamos los datos a enviar y los enviamos utilizando el m\u00e9todo sendto() . Este m\u00e9todo tomados argumentos: datos a enviar, y precisamente la direcci\u00f3n de env\u00edo. Los datos enviados a trav\u00e9s del socket deben formar parte de un array de bytes (por ello, la cadena a enviar viene precedida por el car\u00e1cter b ). Tarea Comprueba que, efectivamente, los c\u00f3digos de env\u00edo y recepci\u00f3n a trav\u00e9s de UDP funcionan como se espera. Nota Desde la versi\u00f3n 3 de Python, las cadenas se codifican utilizando Unicode. Al contrario que ASCII, conde cada caracter tiene una representaci\u00f3n en byte directa, Unicode utiliza enteros par representar cada caracter, que deben ser codificados para obtener una representaci\u00f3n en forma de byte. Uno de esos esquemas de codificaci\u00f3n es UTF-8. Por ejemplo, el siguiente c\u00f3digo muestra c\u00f3mo codificar una cadena Unicode en una representaci\u00f3n de bytes: cadena= \"Hola\" data = cadena.encode(\"UTF-8\") print(data, type(data)) lo cual genera b\"Hola\" <class 'bytes'> que puede ya ser enviado directamente por red. Hasta este punto, los programas UDP han sido totalmente unidireccionales en el env\u00edo/recepci\u00f3n de datos, pero obviamente, un socket UDP es un canal de comunicaci\u00f3n bidireccional. Tarea Implementa una funcionalidad similar al servidor echo que vimos para TCP, pero utilizando en este caso UDP. Realiza una captura de tr\u00e1fico en Wireshark similar a la realizada en el caso de TCP, y observa las principales diferencias entre ellas a nivel de tr\u00e1fico generado.","title":"Sockets UDP"},{"location":"RPI-II/P1/#envio-de-datos-binarios-a-traves-de-sockets","text":"Hasta este punto, hemos visto \u00fanicamente c\u00f3mo enviar cadenas de texto a trav\u00e9s de sockets TCP o UDP, pero es muy probable que sea necesario (o conveniente), en ocasiones, enviar datos directamente en formato binario (por ejemplo, valores num\u00e9ricos en punto flotante o enteros). Utilizando el m\u00f3dulo struct de Python podemos especificar qu\u00e9 tipo o tipos de datos se almacenan en una secuencia de bytes y c\u00f3mo decodificarlos. Tambi\u00e9n es posible especificar en qu\u00e9 lugar de la secuencia se alojan dichos datos, permitiendo el empaquetado de m\u00faltiples datos de distintos tipos de forma sencilla, y su posterior decodificaci\u00f3n en el otro extremo de la comunicaci\u00f3n. Nota Para todos los detalles del m\u00f3dulo struct , consulta la p\u00e1gina oficial de documentaci\u00f3n . El m\u00f3dulo struct proporciona dos m\u00e9todos de inter\u00e9s: pack y unpack . La siguiente sentencia: struct.pack(\">iii\", 1, 2, 3) utiliza el m\u00e9todo pack para realizar un empaquetado de datos. Concretamente, observa como el m\u00e9todo recibe dos par\u00e1metros: En primer lugar, el par\u00e1metro de formato \">iii\" . Define como debe codificarse cada valor en la secuencia de bytes. El primer car\u00e1cter indica el endianness utilizado, en este caso big endian (utilizar\u00edamos \">\" para big endian , \"<\" para little endian y \"=\" para network (big) endian). En segundo lugar, los valores a empaquetar. Observa que el formato, adem\u00e1s, incluye el n\u00famero y tipo de los datos a empaquetar (en este caso, tres valores detipo entero). Para otros tipos de datos, consulta la documentaci\u00f3n del m\u00f3dulo. Desempaquetar los datos enviados en el extremo opuesto es intuitivo: a, b, c = struct.unpack( \">iii\" ) A continuaci\u00f3n, mostramos un ejemplo de sistema cliente/servidor TCP que hace uso del m\u00f3dulo struct para realizar el env\u00edo de dos datos enteros y uno flotante entre un cliente y un servidor. # Cliente import binascii import socket import struct import sys # Socket TCP sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_address = ('localhost', 10001) sock.connect(server_address) packed_data = struct.pack(\"=iif\", 1, 4, 2.7) try: # Envio de datos print('Enviando \"%s\"' % binascii.hexlify(packed_data)) sock.sendall(packed_data) finally: print('Cerrando socket') sock.close() # Servidor import binascii import socket import struct import sys # Socket TCP sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_address = ('localhost', 10001) sock.bind(server_address) sock.listen(1) while True: print('Esperando conexiones entrantes') connection, client_address = sock.accept() try: data = connection.recv(1024) print('Recibido \"%s\"' % binascii.hexlify(data)) unpacked_data = struct.unpack(\"=iif\", data) print('Desempaquetado:', unpacked_data) finally: connection.close() Tarea Ejecuta el anterior sistema cliente servidor y analiza el tr\u00e1fico generado, en busca de los datos binarios empaquetados. Experimenta con otros tipos de datos y endianess y observa las diferencias.","title":"Env\u00edo de datos binarios a trav\u00e9s de sockets"},{"location":"RPI-II/P1/#tarea-entregable","text":"Tarea entregable Se pide dise\u00f1ar un sistema cliente/servidor programado en Python, que simule el env\u00edo de un conjunto de datos sensorizados desde un cliente hacia un servidor. El protocolo a utilizar (formato de datos enviado por la red a nivel de aplicaci\u00f3n) debe ser propuesto por el propio alumno y descrito previamente al desarrollo. Se valorar\u00e1 el uso de m\u00faltiples tipos de datos tanto en el env\u00edo de datos sensorizados como de posibles respuestas por parte del servidor. Se desarrollar\u00e1 una versi\u00f3n utilizando TCP y otra equivalente usando UDP. El cliente enviar\u00e1 los datos de forma peri\u00f3dica y se \u00e9stos generar\u00e1n de modo aleatorio. A modo de entrega, se solicitan los c\u00f3digos desarrollados, as\u00ed como un an\u00e1lisis del tr\u00e1fico generado, considerando la sobrecarga (en bytes reales enviados) introducida por cada protocolo de capa de transporte.","title":"Tarea entregable"},{"location":"RPI-II/P1/#ejemplo-de-sistema-clienteservidor-multi-hilo","text":"Los ejemplos anteriormente descritos, aunque funcionales, adolecen en su dise\u00f1o de una caracter\u00edstica esencial: el servidor deja de atender peticiones entrantes mientras trata cada nuevo env\u00edo por parte del cliente. Los siguientes ejemplos muestran implementaciones sencillas con soporte multi-hilo para un sistema cliente/servidor escrito en Python. # Servidor TCP concurrente import socket, threading class ClientThread(threading.Thread): def __init__(self,clientAddress,clientsocket): threading.Thread.__init__(self) self.csocket = clientsocket print (\"Nueva conexion anyadida: \", clientAddress) def run(self): print (\"Conexion desde: \", clientAddress) #self.csocket.send(bytes(\"Hi, This is from Server..\",'utf-8')) msg = '' while True: data = self.csocket.recv(2048) msg = data.decode() if msg=='bye': break print (\"Desde el cliente\", msg) self.csocket.send(bytes(msg,'UTF-8')) print (\"Cliente \", clientAddress , \" desconectado...\") LOCALHOST = \"127.0.0.1\" PORT = 8080 server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) server.bind((LOCALHOST, PORT)) print(\"Servidor arrancado...\") print(\"Esperando petici\u00f3n de clientes...\") server.listen(1) while True: clientsock, clientAddress = server.accept() newthread = ClientThread(clientAddress, clientsock) newthread.start() # Cliente TCP. El env\u00edo de la cadena bye indica petici\u00f3n de desconexi\u00f3n. import socket SERVER = \"127.0.0.1\" PORT = 8080 client = socket.socket(socket.AF_INET, socket.SOCK_STREAM) client.connect((SERVER, PORT)) client.sendall(bytes(\"Hola, soy un cliente!!\",'UTF-8')) while True: in_data = client.recv(1024) print(\"Desde el servidor :\" ,in_data.decode()) out_data = input() client.sendall(bytes(out_data,'UTF-8')) if out_data=='end': break client.close() Tarea Estudia el c\u00f3digo del servidor concurrente y observa c\u00f3mo gestiona la creaci\u00f3n de hilos para atender cada petici\u00f3n entrante. Conecta simult\u00e1neamente m\u00faltiples clientes y observa el estado de los sockets mediante las herramientas correspondientes.","title":"Ejemplo de sistema cliente/servidor multi-hilo"},{"location":"RPI-II/P1/#tarea-entregable-opcional","text":"Tarea entregable opcional Modifica tu primer entregable para considerar una implementaci\u00f3n multihilo del servidor TCP, siguiendo las directrices de los c\u00f3digos de ejemplo anteriormente proporcionados.","title":"Tarea entregable opcional"},{"location":"RPI-II/P1/#tarea-entregable-opcional_1","text":"Tarea entregable opcional Modifica el protocolo de env\u00edo para que tu aplicaci\u00f3n cliente/servidor UDP garantice en la medida de lo posible la recepci\u00f3n de los paquetes enviados desde el cliente, as\u00ed como su recepci\u00f3n en orden. Vuelve a analizar el tr\u00e1fico necesario en este caso comparado con una comunicaci\u00f3n b\u00e1sica basada en TCP (donde s\u00ed se garantizan, a nivel de transporte, dichas caracter\u00edsticas).","title":"Tarea entregable opcional"},{"location":"RPI-II/P10/","text":"Pr\u00e1ctica 10. Frameworks IoT y Cloud Objetivos La pr\u00e1ctica presenta los pasos esenciales que permiten hacer interactuar un dispositivo (ESP32) con una infraestructura IoT en la nube. Aunque en este caso utilizaremos Microsoft Azure, los pasos tanto en configuraci\u00f3n remota como a nivel de nodo son muy similares a los que deber\u00edas seguir para otras infraestructuras (Amazon AWS, Google IoT Core, Aliyun IoT, Tencent Iot o cualquier otro). La documentaci\u00f3n de IDF proporciona ejemplos detallados para cada uno. El objetivo de la pr\u00e1ctica es desplegar un sistema de monitorizaci\u00f3n remota en Microsoft Power BI, que permita visualizar datos de telemetr\u00eda emitidos v\u00eda MQTT por el dispositivo a trav\u00e9s de un gateway en la nube (llamado en el caso de Azure IoT Hub ). Introducci\u00f3n El SDK ESP Azure IoT es una infraestructura basada en el SDK de Azure par IoT con soporte para C ( azure-iot-sdk-c ) portado sobre ESP-IDF para dar soporte al ESP32. Adem\u00e1s, proporciona un conjunto de ejemplos que permiten observar y simplificar el proceso de configuraci\u00f3n y conexi\u00f3n al framework Azure IoT Hub. Preparaci\u00f3n del firmware en el ESP32 En la presente pr\u00e1ctica utilizar\u00e1s una placa ESP32 que actuar\u00e1 como cliente ESP32, con un firmware personalizado que implementa la l\u00f3gica de conexi\u00f3n e interacci\u00f3n con Azure. En primer lugar: Configura una instalaci\u00f3n de ESP IDF tal y como has hecho en pr\u00e1cticas anteriores. Si ya la has configurado y es funcional, no es necesario ninguna reinstalaci\u00f3n ni reconfiguraci\u00f3n. En un directorio independiente, clona el repositorio de ESP Azure (f\u00edjate en la opci\u00f3n --recursive , que es imprescindible): git clone --recursive https://github.com/espressif/esp-azure.git Configuraci\u00f3n de Microsoft Azure Los siguientes pasos requieren el uso de una cuenta creada con Microsoft Azure. Los estudiantes UCM pueden adherirse al programa acad\u00e9mico, que otorga suficiente cr\u00e9dito para realizar este tipo de pr\u00e1cticas. Aseg\u00farate de acceder al portal de MS Azure y utilizar tu usuario y credenciales UCM para ello. Creaci\u00f3n de un Centro de IoT ( IoT Hub ) En la p\u00e1gina principal de Azure, selecciona la opci\u00f3n \"Crear un Recurso\" (en el men\u00fa de la parte superior izquierda de la pantalla) y a continuaici\u00f3n selecciona IoT Hub en cuadro \"Buscar en Marketplace\". Selecciona Iot Hub en los resultados de la b\u00fasqueda, y a continuaci\u00f3n \"Crear\". En la pesta\u00f1a Aspectos B\u00e1sicos , completa los campos de la siguiente forma: Suscripci\u00f3n : selecciona la suscripci\u00f3n que desees usar (por defecto, deber\u00eda aparecer Azure para estudiantes ). Grupo de recursos : crea un nuevo grupo de recursos seleccionando la opci\u00f3n Crear nuevo , y ot\u00f3rgale el nombre que desees, por ejemplo MIOTGROUP . Regi\u00f3n : selecciona la regi\u00f3n m\u00e1s cercana a ti (por ejemplo, Oeste de Europa ). Nombre : por \u00faltimo, da un nombre al hub , por ejemplo MIOTHUB . Deja los par\u00e1metros por defecto en la pesta\u00f1a Redes , y elige como Nivel de precios F1 en la pesta\u00f1a Administraci\u00f3n . Asigna las etiquetas que desees y finalmente confirma la creaci\u00f3n del Centro de IoT . Si todo ha ido bien, ver\u00e1s un resumen del recurso creado y podr\u00e1s acceder a \u00e9l pinchando en \"Ir al recurso\" . Ver\u00e1s una pantalla similar a la siguiente: En la secci\u00f3n de Configuraci\u00f3n , elige Directivas de acceso compartido y crea una nueva directiva llamada, por ejemplo MIOTPOLICY , con permisos de lectura y escritura en Registro, y conexi\u00f3n de servicios y dispositivos. Las pol\u00edticas de lectura y escritura en registro otorgan derechos de acceso al registro de indentidades de Azure. Estos permisos ser\u00e1n utilizados por servicios de back-end para gestionar las identidades de dispositivos, por ejemplo. La pol\u00edtica de conexi\u00f3n de servicio otorga permisos para acceder a endpoints de servicio. Los servicios de back-end podr\u00e1n enviar y recibir mensajes de dispositivos. La pol\u00edtica de conexi\u00f3n de dispositivo otorga permisos para enviar y recibir mensajes usando el IoT Hub . Una vez creada, selecci\u00f3nala y copia la Cadena de conexi\u00f3n principal (clave principal) que aparece en pantalla. No es necesario que la muestres, puedes usar el bot\u00f3n de copia directamente. Apunta esta cadena en un fichero de texto. Esta es la clave de acceso para el Hub . Registro de un nuevo dispositivo A continuaci\u00f3n, crearemos una nueva identidad de dispositivo en el Registro de Identidades del hub IoT que acabas de crear. Para ello: En el men\u00fa de navegaci\u00f3n, abre la opci\u00f3n \"Dispositivos de IoT\" y selecciona Nuevo para crear un nuevo dispositivo. Dale el nombre que quieras (por ejemplo MIOTDEVICE), pero recu\u00e9rdalo, y selecciona Guardar . Una vez creado, selecci\u00f3nalo y copia la Cadena de conexi\u00f3n principal que aparece en pantalla. No es necesario que la muestres, puedes usar el bot\u00f3n de copia directamente. Apunta esta cadena en un fichero de texto. Esta es la clave de acceso para el dispositivo . Instalaci\u00f3n de el cliente Azure Para instalar el cliente Azure en Linux, usa la orden: curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash Tienes m\u00e1s opciones de instalaci\u00f3n en la p\u00e1gina . Una vez instalado, desde tu terminal, ejecuta el comando az para comprobar que la instalaci\u00f3n fue correcta. Deber\u00edas ver una salida similar a esta: az Welcome to Azure CLI! --------------------- Use `az -h` to see available commands or go to https://aka.ms/cli. ... Instala la extensi\u00f3n del cliente para Azure IoT: az extension add --name azure-cli-iot-ext Ingresa en el sistema ejecutando (se te pedir\u00e1 autenticaci\u00f3n en navegador, introduce tus credenciales): az login Para usar el cliente como m\u00e9todo de creaci\u00f3n de un dispositivo, puedes utilizar la siguiente orden: az iot hub device-identity create -n [IoTHub Name] -d [Device ID] Tarea Crea un nuevo dispositivo, distinto al que creaste anteriormente, en tu hub. Despu\u00e9s, obt\u00e9n su cadena de conexi\u00f3n usando la orden az iot hub device-identity show-connection-string -n [IoTHub Name] -d [Device ID] . Comprueba que, efectivamente, la creaci\u00f3n del dispositivo es visible en la plataforma web. Monitorizaci\u00f3n de valores de telemetr\u00eda del dispositivo y eventos Para observar los datos intercambiados entre el dispositivo y el hub IoT desde l\u00ednea de ocmandos, puedes usar la orden: az iot hub monitor-events -n [IoTHub Name] --login 'cadena de conexion' (Ten en cuenta que las comillas simples deben estar presentes). Despliegue de un cliente MQTT en el ESP32 Dir\u00edgete al ejemplo situado en el directorio examples/iothub_client_sample_mqtt . En \u00e9l, vamos a trabajar con cualquiera de los dos dispositivos que has creado en tu Hub . En cualquier caso, muestra su cadena de conexi\u00f3n principal . Deber\u00e1s ver un valor de devoluci\u00f3n de tipo: { \"connectionString\": \"HostName=<azure-iot-hub-name>.azure-devices.net;DeviceId=<azure-iot-device-id>;SharedAccessKey=<base64-encoded-shared-access-key>\" } Deber\u00e1s apuntar (copiar) \u00fanicamente la parte que comienza por HostName=... , hasta el final de la cadena. No incluyas las comillas dobles. Ejecuta make menuconfig . En el men\u00fa Example Configuration , configura las credenciales de acceso a tu red WiFi, as\u00ed como la cadena de conexi\u00f3n que copiaste en la opci\u00f3n IOT Hub Device Connection String . A continuaci\u00f3n, ejecuta la orden de compilaci\u00f3n, flasheado y monitorizaci\u00f3n: make flash monitor En una ventana separada, puedes monitorizar los eventos IoT en tu hub usando su cadena de conexi\u00f3n: az iot hub monitor-events -n [IoTHub Name] --login 'Cadena de conexi\u00f3n primaria' Una vez arrancado y conectado a Internet el dispositivo comenzar\u00e1 a publicar mensajes MQTT. El monitor que has lanzado los mostrar\u00e1 como: { \"event\": { \"origin\": \"<azure-iot-device-id>\", \"payload\": \"{\\\"deviceId\\\":\\\"MIOTDEVICE\\\",\\\"windSpeed\\\":13.00,\\\"temperature\\\":22.00,\\\"humidity\\\":67.00}\" } } Observa que incluye tres valores: velocidad del viento, temperatura y humedad. Tarea Analiza el c\u00f3digo y observa, en la tarea principal, el uso que hace de la API de Azure SDK C, as\u00ed como el punto en el que genera el mensaje MQTT (y sus valores). Tambi\u00e9n es posible enviar mensajes al dispositivo directamente desde l\u00ednea de comandos (observa que estos mensajes se env\u00edan v\u00eda red, no v\u00eda puerto serie, a trav\u00e9s del Hub ). Por tanto, puedes hacerlo desde cualquier punto, no obligatoriamente desde tu PC: az iot device c2d-message send -d [Device Id] -n [IoTHub Name] --data [Data_to_Send] Nota Si todo ha ido bien, en este punto deber\u00edas estar observando cada uno de los mensajes enviados por tu ESP32 al hub desde el monitor. Visualizaci\u00f3n de datos en Microsoft PowerBI En esta parte, el objetivo es visualizar los datos enviados por tu sensor (temperatura, humedad y velocidad del viento, en la herramienta de visualizaci\u00f3n PowerBI de Microsoft. Aunque PowerBI suele utilizarse en entornos de inteligencia de negocio, resulta tambi\u00e9n \u00fatil para reportar datos de cualquier elemento de Azure, incluido el IoT Hub . Nota Necesitar\u00e1s una cuenta de acceso gratuita a PowerBI, que puedes crear con tus credenciales de usuario UCM directamente en la p\u00e1gina del producto . Adici\u00f3n de un grupo de consumidores Los grupos de consumidores proporcionan vistas independientes en la secuencia de eventos que permiten a las aplicaciones y a los servicios de Azure consumir datos de forma independiente desde el mismo punto de conexi\u00f3n del centro de eventos. Vamos a agregar un grupo de consumidores al punto de conexi\u00f3n integrado de tu instancia de IoT Hub que se usar\u00e1 posteriormente para extraer datos del punto de conexi\u00f3n. Para agregar un grupo de consumidores a su centro de IoT, sigue estos pasos: En el portal de Azure, abre tu IoT Hub . En el panel izquierdo, selecciona Puntos de Conexi\u00f3n Integrados , luego Eventos en el panel superior derecho, y escribe un nombre en Grupos de consumidores (por ejemplo, MIOTGROUP ). A continuaci\u00f3n, selecciona Guardar . Creaci\u00f3n, configuraci\u00f3n y ejecuci\u00f3n de un trabajo de Stream Analytics Comencemos creando un trabajo de Stream Analytics . Despu\u00e9s de crear el trabajo, definiremos las entradas, las salidas y la consulta que se usar\u00e1 para recuperar los datos. Creaci\u00f3n de un trabajo de Stream Analytics En el portal de Azure, selecciona Crear un recurso -> Internet de las Cosas -> Stream Analytics Job . Escribe la siguiente informaci\u00f3n para el trabajo: Nombre del trabajo : Nombre que se asigna al trabajo; debe ser \u00fanico (por ejemplo, MIOTJOB ). Grupo de recursos : Usa el mismo grupo de recursos que definiste para el centro de IoT (por ejemplo, MIOTGROUP ). Ubicaci\u00f3n : Usa la misma que para el grupo de recursos. Selecciona Crear . Adici\u00f3n de una entrada al trabajo de Stream Analytics Abre el trabajo de Stream Analytics . En Topolog\u00eda de trabajo , selecciona Entradas . En el panel Entradas , selecciona Agregar entrada de flujo , y a continuaci\u00f3n, selecciona IoT Hub en la lista desplegable. En el panel de la nueva entrada, escribe la siguiente informaci\u00f3n: Alias de entrada : Un alias \u00fanico para la entrada (por ejemplo, MIOTINPUT ). Seleccionar centro de IoT de entre las suscripciones : Selecciona esta opci\u00f3n. Suscripci\u00f3n : Usa la suscripci\u00f3n que has utilizado en el resto de la pr\u00e1ctica. IoT Hub : Selecciona la instancia de tu Hub IoT tal y como has hecho en el resto de la pr\u00e1ctica. Punto de Conexi\u00f3n : Selecciona Mensajer\u00eda . Nombre de la directiva de acceso compartido : Selecciona el nombre de la directiva de acceso compartido que quieras que utilice el trabajo de Stream Analytics para tu centro de IoT. Para esta pr\u00e1ctica, puedes seleccionar service . La directiva service se crea de forma predeterminada en los centros de IoT nuevos y concede permiso de env\u00edo y recepci\u00f3n para los puntos de conexi\u00f3n de la nube que expone el centro de IoT. Clave de directiva de acceso compartido : Se rellena autom\u00e1ticamente en funci\u00f3n del nombre de directiva de acceso compartido. Grupo de consumidores : Selecciona el gruop de consumidores que se cre\u00f3 anteriormente. El resto de campos pueden dejarse en sus valores predeterminados. Finalmente, selecciona Guardar . Adici\u00f3n de una salida al trabajo de Stream Analytics En Topolog\u00eda de trabajo, selecciona Salidas . En el panel Salidas , selecciona Agregar y Power BI . En el panel Power BI: Nueva salida panel , selecciona Autorizar y sigue las indicaciones para iniciar sesi\u00f3n en tu cuenta de Power BI. Una vez que hayas iniciado sesi\u00f3n en Power BI, escribe la siguiente informaci\u00f3n: Alias de salida : alias \u00fanico para la salida, por ejemplo MIOTOUTPUT . \u00c1rea de trabajo de grupo : selecciona el \u00e1rea de trabajo de grupo de destino. Nombre del conjunto de datos : escribe un nombre para el conjunto de datos, por ejemplo MIOTDATASET . Nombre de la tabla : Escribe un nombre de tabla, por ejemplo MIOTTABLE . Modo de autenticaci\u00f3n : Deja la opci\u00f3n predeterminada. Configuraci\u00f3n de la consulta del trabajo de Stream Analytics En Topolog\u00eda de trabajo , selecciona Consulta . Reemplaza [YourInputAlias] por el alias de entrada del trabajo. Reemplaza [YourOutputAlias] por el alias de salida del trabajo. Selecciona Guardar consulta . Ejecuci\u00f3n del trabajo de Stream Analytics En el trabajo de Stream Analytics , selecciona Informaci\u00f3n general y, a continuaci\u00f3n, elige Iniciar->Ahora->Iniciar . Una vez que el trabajo se inicia correctamente, su estado cambia de Detenido a En ejecuci\u00f3n . Creaci\u00f3n y publicaci\u00f3n de un informe de Power BI para visualizar los datos En los pasos siguientes se muestra c\u00f3mo crear y publicar un informe mediante el servicio Power BI: Aseg\u00farate de que la aplicaci\u00f3n (tu ESP32) est\u00e1 ejecut\u00e1ndose. Inicia sesi\u00f3n en Power BI. Selecciona tu \u00e1rea de trabajo ( workspace ). Selecciona Conjunto de datos usando el conjunto de datos que creaste en pasos anteriores (corresponde al que creaste en el momento de crear la salida para el trabajo de Stream Analytics . Para dicho conjunto de datos, selecciona Agregar Informe (el primer icono a la derecha del nombre del conjunto de datos. Crea un gr\u00e1fico de l\u00edneas para mostrar la temperatura en tiempo real en un per\u00edodo determinado. Para ello: En el panel Visualizaciones de la p\u00e1gina de creaci\u00f3n de informes, selecciona el icono de gr\u00e1fico de l\u00edneas para agregar un gr\u00e1fico de l\u00edneas. En el panel Campos , expande la tabla que especific\u00f3 en el momento de crear la salida para el trabajo de Stream Analytics . Arrastra EventEnqueuedUtcTime (Hora UTC de evento en cola) al Eje en el panel Visualizaciones. Arrastra temperature (temperatura) a Valores . Se ha creado un gr\u00e1fico de l\u00edneas. El eje X muestra la fecha y hora en la zona horaria UTC. El eje Y muestra la temperatura del sensor: Tarea A\u00f1ade ahora informaci\u00f3n sobre humedad y velocidad del viento y refresca (actualiza) la visualizaci\u00f3n. Tarea entregable En esta pr\u00e1ctica, simplemente se pide que entregues alguna evidencia (por ejemplo, una captura de pantalla con tu ESP32 femitiendo eventos y una captura simult\u00e1nea de PowerBI mostr\u00e1ndolos) del correcto funcionamiento de los pasos listados. Opcionalmente, se puede a\u00f1adir, como informaci\u00f3n emitida desde el ESP32, valores reales de temperatura obtenidos desde un sensor en el ESP32.","title":"Pr\u00e1ctica 10"},{"location":"RPI-II/P10/#practica-10-frameworks-iot-y-cloud","text":"","title":"Pr\u00e1ctica 10. Frameworks IoT y Cloud"},{"location":"RPI-II/P10/#objetivos","text":"La pr\u00e1ctica presenta los pasos esenciales que permiten hacer interactuar un dispositivo (ESP32) con una infraestructura IoT en la nube. Aunque en este caso utilizaremos Microsoft Azure, los pasos tanto en configuraci\u00f3n remota como a nivel de nodo son muy similares a los que deber\u00edas seguir para otras infraestructuras (Amazon AWS, Google IoT Core, Aliyun IoT, Tencent Iot o cualquier otro). La documentaci\u00f3n de IDF proporciona ejemplos detallados para cada uno. El objetivo de la pr\u00e1ctica es desplegar un sistema de monitorizaci\u00f3n remota en Microsoft Power BI, que permita visualizar datos de telemetr\u00eda emitidos v\u00eda MQTT por el dispositivo a trav\u00e9s de un gateway en la nube (llamado en el caso de Azure IoT Hub ).","title":"Objetivos"},{"location":"RPI-II/P10/#introduccion","text":"El SDK ESP Azure IoT es una infraestructura basada en el SDK de Azure par IoT con soporte para C ( azure-iot-sdk-c ) portado sobre ESP-IDF para dar soporte al ESP32. Adem\u00e1s, proporciona un conjunto de ejemplos que permiten observar y simplificar el proceso de configuraci\u00f3n y conexi\u00f3n al framework Azure IoT Hub.","title":"Introducci\u00f3n"},{"location":"RPI-II/P10/#preparacion-del-firmware-en-el-esp32","text":"En la presente pr\u00e1ctica utilizar\u00e1s una placa ESP32 que actuar\u00e1 como cliente ESP32, con un firmware personalizado que implementa la l\u00f3gica de conexi\u00f3n e interacci\u00f3n con Azure. En primer lugar: Configura una instalaci\u00f3n de ESP IDF tal y como has hecho en pr\u00e1cticas anteriores. Si ya la has configurado y es funcional, no es necesario ninguna reinstalaci\u00f3n ni reconfiguraci\u00f3n. En un directorio independiente, clona el repositorio de ESP Azure (f\u00edjate en la opci\u00f3n --recursive , que es imprescindible): git clone --recursive https://github.com/espressif/esp-azure.git","title":"Preparaci\u00f3n del firmware en el ESP32"},{"location":"RPI-II/P10/#configuracion-de-microsoft-azure","text":"Los siguientes pasos requieren el uso de una cuenta creada con Microsoft Azure. Los estudiantes UCM pueden adherirse al programa acad\u00e9mico, que otorga suficiente cr\u00e9dito para realizar este tipo de pr\u00e1cticas. Aseg\u00farate de acceder al portal de MS Azure y utilizar tu usuario y credenciales UCM para ello.","title":"Configuraci\u00f3n de Microsoft Azure"},{"location":"RPI-II/P10/#creacion-de-un-centro-de-iot-iot-hub","text":"En la p\u00e1gina principal de Azure, selecciona la opci\u00f3n \"Crear un Recurso\" (en el men\u00fa de la parte superior izquierda de la pantalla) y a continuaici\u00f3n selecciona IoT Hub en cuadro \"Buscar en Marketplace\". Selecciona Iot Hub en los resultados de la b\u00fasqueda, y a continuaci\u00f3n \"Crear\". En la pesta\u00f1a Aspectos B\u00e1sicos , completa los campos de la siguiente forma: Suscripci\u00f3n : selecciona la suscripci\u00f3n que desees usar (por defecto, deber\u00eda aparecer Azure para estudiantes ). Grupo de recursos : crea un nuevo grupo de recursos seleccionando la opci\u00f3n Crear nuevo , y ot\u00f3rgale el nombre que desees, por ejemplo MIOTGROUP . Regi\u00f3n : selecciona la regi\u00f3n m\u00e1s cercana a ti (por ejemplo, Oeste de Europa ). Nombre : por \u00faltimo, da un nombre al hub , por ejemplo MIOTHUB . Deja los par\u00e1metros por defecto en la pesta\u00f1a Redes , y elige como Nivel de precios F1 en la pesta\u00f1a Administraci\u00f3n . Asigna las etiquetas que desees y finalmente confirma la creaci\u00f3n del Centro de IoT . Si todo ha ido bien, ver\u00e1s un resumen del recurso creado y podr\u00e1s acceder a \u00e9l pinchando en \"Ir al recurso\" . Ver\u00e1s una pantalla similar a la siguiente: En la secci\u00f3n de Configuraci\u00f3n , elige Directivas de acceso compartido y crea una nueva directiva llamada, por ejemplo MIOTPOLICY , con permisos de lectura y escritura en Registro, y conexi\u00f3n de servicios y dispositivos. Las pol\u00edticas de lectura y escritura en registro otorgan derechos de acceso al registro de indentidades de Azure. Estos permisos ser\u00e1n utilizados por servicios de back-end para gestionar las identidades de dispositivos, por ejemplo. La pol\u00edtica de conexi\u00f3n de servicio otorga permisos para acceder a endpoints de servicio. Los servicios de back-end podr\u00e1n enviar y recibir mensajes de dispositivos. La pol\u00edtica de conexi\u00f3n de dispositivo otorga permisos para enviar y recibir mensajes usando el IoT Hub . Una vez creada, selecci\u00f3nala y copia la Cadena de conexi\u00f3n principal (clave principal) que aparece en pantalla. No es necesario que la muestres, puedes usar el bot\u00f3n de copia directamente. Apunta esta cadena en un fichero de texto. Esta es la clave de acceso para el Hub .","title":"Creaci\u00f3n de un Centro de IoT (IoT Hub)"},{"location":"RPI-II/P10/#registro-de-un-nuevo-dispositivo","text":"A continuaci\u00f3n, crearemos una nueva identidad de dispositivo en el Registro de Identidades del hub IoT que acabas de crear. Para ello: En el men\u00fa de navegaci\u00f3n, abre la opci\u00f3n \"Dispositivos de IoT\" y selecciona Nuevo para crear un nuevo dispositivo. Dale el nombre que quieras (por ejemplo MIOTDEVICE), pero recu\u00e9rdalo, y selecciona Guardar . Una vez creado, selecci\u00f3nalo y copia la Cadena de conexi\u00f3n principal que aparece en pantalla. No es necesario que la muestres, puedes usar el bot\u00f3n de copia directamente. Apunta esta cadena en un fichero de texto. Esta es la clave de acceso para el dispositivo .","title":"Registro de un nuevo dispositivo"},{"location":"RPI-II/P10/#instalacion-de-el-cliente-azure","text":"Para instalar el cliente Azure en Linux, usa la orden: curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash Tienes m\u00e1s opciones de instalaci\u00f3n en la p\u00e1gina . Una vez instalado, desde tu terminal, ejecuta el comando az para comprobar que la instalaci\u00f3n fue correcta. Deber\u00edas ver una salida similar a esta: az Welcome to Azure CLI! --------------------- Use `az -h` to see available commands or go to https://aka.ms/cli. ... Instala la extensi\u00f3n del cliente para Azure IoT: az extension add --name azure-cli-iot-ext Ingresa en el sistema ejecutando (se te pedir\u00e1 autenticaci\u00f3n en navegador, introduce tus credenciales): az login Para usar el cliente como m\u00e9todo de creaci\u00f3n de un dispositivo, puedes utilizar la siguiente orden: az iot hub device-identity create -n [IoTHub Name] -d [Device ID] Tarea Crea un nuevo dispositivo, distinto al que creaste anteriormente, en tu hub. Despu\u00e9s, obt\u00e9n su cadena de conexi\u00f3n usando la orden az iot hub device-identity show-connection-string -n [IoTHub Name] -d [Device ID] . Comprueba que, efectivamente, la creaci\u00f3n del dispositivo es visible en la plataforma web.","title":"Instalaci\u00f3n de el cliente Azure"},{"location":"RPI-II/P10/#monitorizacion-de-valores-de-telemetria-del-dispositivo-y-eventos","text":"Para observar los datos intercambiados entre el dispositivo y el hub IoT desde l\u00ednea de ocmandos, puedes usar la orden: az iot hub monitor-events -n [IoTHub Name] --login 'cadena de conexion' (Ten en cuenta que las comillas simples deben estar presentes).","title":"Monitorizaci\u00f3n de valores de telemetr\u00eda del dispositivo y eventos"},{"location":"RPI-II/P10/#despliegue-de-un-cliente-mqtt-en-el-esp32","text":"Dir\u00edgete al ejemplo situado en el directorio examples/iothub_client_sample_mqtt . En \u00e9l, vamos a trabajar con cualquiera de los dos dispositivos que has creado en tu Hub . En cualquier caso, muestra su cadena de conexi\u00f3n principal . Deber\u00e1s ver un valor de devoluci\u00f3n de tipo: { \"connectionString\": \"HostName=<azure-iot-hub-name>.azure-devices.net;DeviceId=<azure-iot-device-id>;SharedAccessKey=<base64-encoded-shared-access-key>\" } Deber\u00e1s apuntar (copiar) \u00fanicamente la parte que comienza por HostName=... , hasta el final de la cadena. No incluyas las comillas dobles. Ejecuta make menuconfig . En el men\u00fa Example Configuration , configura las credenciales de acceso a tu red WiFi, as\u00ed como la cadena de conexi\u00f3n que copiaste en la opci\u00f3n IOT Hub Device Connection String . A continuaci\u00f3n, ejecuta la orden de compilaci\u00f3n, flasheado y monitorizaci\u00f3n: make flash monitor En una ventana separada, puedes monitorizar los eventos IoT en tu hub usando su cadena de conexi\u00f3n: az iot hub monitor-events -n [IoTHub Name] --login 'Cadena de conexi\u00f3n primaria' Una vez arrancado y conectado a Internet el dispositivo comenzar\u00e1 a publicar mensajes MQTT. El monitor que has lanzado los mostrar\u00e1 como: { \"event\": { \"origin\": \"<azure-iot-device-id>\", \"payload\": \"{\\\"deviceId\\\":\\\"MIOTDEVICE\\\",\\\"windSpeed\\\":13.00,\\\"temperature\\\":22.00,\\\"humidity\\\":67.00}\" } } Observa que incluye tres valores: velocidad del viento, temperatura y humedad. Tarea Analiza el c\u00f3digo y observa, en la tarea principal, el uso que hace de la API de Azure SDK C, as\u00ed como el punto en el que genera el mensaje MQTT (y sus valores). Tambi\u00e9n es posible enviar mensajes al dispositivo directamente desde l\u00ednea de comandos (observa que estos mensajes se env\u00edan v\u00eda red, no v\u00eda puerto serie, a trav\u00e9s del Hub ). Por tanto, puedes hacerlo desde cualquier punto, no obligatoriamente desde tu PC: az iot device c2d-message send -d [Device Id] -n [IoTHub Name] --data [Data_to_Send] Nota Si todo ha ido bien, en este punto deber\u00edas estar observando cada uno de los mensajes enviados por tu ESP32 al hub desde el monitor.","title":"Despliegue de un cliente MQTT en el ESP32"},{"location":"RPI-II/P10/#visualizacion-de-datos-en-microsoft-powerbi","text":"En esta parte, el objetivo es visualizar los datos enviados por tu sensor (temperatura, humedad y velocidad del viento, en la herramienta de visualizaci\u00f3n PowerBI de Microsoft. Aunque PowerBI suele utilizarse en entornos de inteligencia de negocio, resulta tambi\u00e9n \u00fatil para reportar datos de cualquier elemento de Azure, incluido el IoT Hub . Nota Necesitar\u00e1s una cuenta de acceso gratuita a PowerBI, que puedes crear con tus credenciales de usuario UCM directamente en la p\u00e1gina del producto .","title":"Visualizaci\u00f3n de datos en Microsoft PowerBI"},{"location":"RPI-II/P10/#adicion-de-un-grupo-de-consumidores","text":"Los grupos de consumidores proporcionan vistas independientes en la secuencia de eventos que permiten a las aplicaciones y a los servicios de Azure consumir datos de forma independiente desde el mismo punto de conexi\u00f3n del centro de eventos. Vamos a agregar un grupo de consumidores al punto de conexi\u00f3n integrado de tu instancia de IoT Hub que se usar\u00e1 posteriormente para extraer datos del punto de conexi\u00f3n. Para agregar un grupo de consumidores a su centro de IoT, sigue estos pasos: En el portal de Azure, abre tu IoT Hub . En el panel izquierdo, selecciona Puntos de Conexi\u00f3n Integrados , luego Eventos en el panel superior derecho, y escribe un nombre en Grupos de consumidores (por ejemplo, MIOTGROUP ). A continuaci\u00f3n, selecciona Guardar .","title":"Adici\u00f3n de un grupo de consumidores"},{"location":"RPI-II/P10/#creacion-configuracion-y-ejecucion-de-un-trabajo-de-stream-analytics","text":"Comencemos creando un trabajo de Stream Analytics . Despu\u00e9s de crear el trabajo, definiremos las entradas, las salidas y la consulta que se usar\u00e1 para recuperar los datos.","title":"Creaci\u00f3n, configuraci\u00f3n y ejecuci\u00f3n de un trabajo de Stream Analytics"},{"location":"RPI-II/P10/#creacion-de-un-trabajo-de-stream-analytics","text":"En el portal de Azure, selecciona Crear un recurso -> Internet de las Cosas -> Stream Analytics Job . Escribe la siguiente informaci\u00f3n para el trabajo: Nombre del trabajo : Nombre que se asigna al trabajo; debe ser \u00fanico (por ejemplo, MIOTJOB ). Grupo de recursos : Usa el mismo grupo de recursos que definiste para el centro de IoT (por ejemplo, MIOTGROUP ). Ubicaci\u00f3n : Usa la misma que para el grupo de recursos. Selecciona Crear .","title":"Creaci\u00f3n de un trabajo de Stream Analytics"},{"location":"RPI-II/P10/#adicion-de-una-entrada-al-trabajo-de-stream-analytics","text":"Abre el trabajo de Stream Analytics . En Topolog\u00eda de trabajo , selecciona Entradas . En el panel Entradas , selecciona Agregar entrada de flujo , y a continuaci\u00f3n, selecciona IoT Hub en la lista desplegable. En el panel de la nueva entrada, escribe la siguiente informaci\u00f3n: Alias de entrada : Un alias \u00fanico para la entrada (por ejemplo, MIOTINPUT ). Seleccionar centro de IoT de entre las suscripciones : Selecciona esta opci\u00f3n. Suscripci\u00f3n : Usa la suscripci\u00f3n que has utilizado en el resto de la pr\u00e1ctica. IoT Hub : Selecciona la instancia de tu Hub IoT tal y como has hecho en el resto de la pr\u00e1ctica. Punto de Conexi\u00f3n : Selecciona Mensajer\u00eda . Nombre de la directiva de acceso compartido : Selecciona el nombre de la directiva de acceso compartido que quieras que utilice el trabajo de Stream Analytics para tu centro de IoT. Para esta pr\u00e1ctica, puedes seleccionar service . La directiva service se crea de forma predeterminada en los centros de IoT nuevos y concede permiso de env\u00edo y recepci\u00f3n para los puntos de conexi\u00f3n de la nube que expone el centro de IoT. Clave de directiva de acceso compartido : Se rellena autom\u00e1ticamente en funci\u00f3n del nombre de directiva de acceso compartido. Grupo de consumidores : Selecciona el gruop de consumidores que se cre\u00f3 anteriormente. El resto de campos pueden dejarse en sus valores predeterminados. Finalmente, selecciona Guardar .","title":"Adici\u00f3n de una entrada al trabajo de Stream Analytics"},{"location":"RPI-II/P10/#adicion-de-una-salida-al-trabajo-de-stream-analytics","text":"En Topolog\u00eda de trabajo, selecciona Salidas . En el panel Salidas , selecciona Agregar y Power BI . En el panel Power BI: Nueva salida panel , selecciona Autorizar y sigue las indicaciones para iniciar sesi\u00f3n en tu cuenta de Power BI. Una vez que hayas iniciado sesi\u00f3n en Power BI, escribe la siguiente informaci\u00f3n: Alias de salida : alias \u00fanico para la salida, por ejemplo MIOTOUTPUT . \u00c1rea de trabajo de grupo : selecciona el \u00e1rea de trabajo de grupo de destino. Nombre del conjunto de datos : escribe un nombre para el conjunto de datos, por ejemplo MIOTDATASET . Nombre de la tabla : Escribe un nombre de tabla, por ejemplo MIOTTABLE . Modo de autenticaci\u00f3n : Deja la opci\u00f3n predeterminada.","title":"Adici\u00f3n de una salida al trabajo de Stream Analytics"},{"location":"RPI-II/P10/#configuracion-de-la-consulta-del-trabajo-de-stream-analytics","text":"En Topolog\u00eda de trabajo , selecciona Consulta . Reemplaza [YourInputAlias] por el alias de entrada del trabajo. Reemplaza [YourOutputAlias] por el alias de salida del trabajo. Selecciona Guardar consulta .","title":"Configuraci\u00f3n de la consulta del trabajo de Stream Analytics"},{"location":"RPI-II/P10/#ejecucion-del-trabajo-de-stream-analytics","text":"En el trabajo de Stream Analytics , selecciona Informaci\u00f3n general y, a continuaci\u00f3n, elige Iniciar->Ahora->Iniciar . Una vez que el trabajo se inicia correctamente, su estado cambia de Detenido a En ejecuci\u00f3n .","title":"Ejecuci\u00f3n del trabajo de Stream Analytics"},{"location":"RPI-II/P10/#creacion-y-publicacion-de-un-informe-de-power-bi-para-visualizar-los-datos","text":"En los pasos siguientes se muestra c\u00f3mo crear y publicar un informe mediante el servicio Power BI: Aseg\u00farate de que la aplicaci\u00f3n (tu ESP32) est\u00e1 ejecut\u00e1ndose. Inicia sesi\u00f3n en Power BI. Selecciona tu \u00e1rea de trabajo ( workspace ). Selecciona Conjunto de datos usando el conjunto de datos que creaste en pasos anteriores (corresponde al que creaste en el momento de crear la salida para el trabajo de Stream Analytics . Para dicho conjunto de datos, selecciona Agregar Informe (el primer icono a la derecha del nombre del conjunto de datos. Crea un gr\u00e1fico de l\u00edneas para mostrar la temperatura en tiempo real en un per\u00edodo determinado. Para ello: En el panel Visualizaciones de la p\u00e1gina de creaci\u00f3n de informes, selecciona el icono de gr\u00e1fico de l\u00edneas para agregar un gr\u00e1fico de l\u00edneas. En el panel Campos , expande la tabla que especific\u00f3 en el momento de crear la salida para el trabajo de Stream Analytics . Arrastra EventEnqueuedUtcTime (Hora UTC de evento en cola) al Eje en el panel Visualizaciones. Arrastra temperature (temperatura) a Valores . Se ha creado un gr\u00e1fico de l\u00edneas. El eje X muestra la fecha y hora en la zona horaria UTC. El eje Y muestra la temperatura del sensor: Tarea A\u00f1ade ahora informaci\u00f3n sobre humedad y velocidad del viento y refresca (actualiza) la visualizaci\u00f3n. Tarea entregable En esta pr\u00e1ctica, simplemente se pide que entregues alguna evidencia (por ejemplo, una captura de pantalla con tu ESP32 femitiendo eventos y una captura simult\u00e1nea de PowerBI mostr\u00e1ndolos) del correcto funcionamiento de los pasos listados. Opcionalmente, se puede a\u00f1adir, como informaci\u00f3n emitida desde el ESP32, valores reales de temperatura obtenidos desde un sensor en el ESP32.","title":"Creaci\u00f3n y publicaci\u00f3n de un informe de Power BI para visualizar los datos"},{"location":"RPI-II/P2/","text":"Pr\u00e1ctica 2. Sockets TCP y UDP en ESP-IDF Objetivos Familiarizarse con la API de sockets en C. Desarrollar esquemas b\u00e1sicos de sistemas cliente/servidor TCP y UDP utilizando C. Ser capaces de analizar el tr\u00e1fico generado en una conexi\u00f3n TCP y UDP a trav\u00e9s de Wireshark. Dise\u00f1ar un protocolo de capa de aplicaci\u00f3n para simular una aplicaci\u00f3n cliente/servidor utilizando TCP y UDP para interactuar entre un host y la placa ESP32 Introducci\u00f3n En la pr\u00e1ctica anterior, vimos c\u00f3mo desarrollar sistemas cliente/servidor sencillos utilizando Python, tanto en sus variantes TCP como UDP. El objetivo de la presente pr\u00e1ctica es estudiar y desarrollar componentes de red (clientes y servidores TCP y UDP) que puedan ejecutarse sobre el ESP32 haciendo uso de las facilidades propuestas por ESP-IDF. Adem\u00e1s, demostraremos que es posible hacer interactuar clientes y servidores ejecut\u00e1ndose indistintamente en la m\u00e1quina virtual (programados v\u00eda Python) y en la propia placa (utilizando la API de sockets de C). La API de sockets en C Funciones para ordenacion de bytes Como TCP/IP es un est\u00e1ndar universal, y permite comunicaciones entre cualquier plataforma y arquitectura, es necesario disponer de un m\u00e9todo de ordenaci\u00f3n de los bytes para que m\u00e1quinas big-endian y little-endian puedan comunicarse de forma transparente y correcta. Para ello, se suelen proporcionar rutinas de reordenaci\u00f3n de bytes. En plataformas donde los datos ya est\u00e1n correctamente ordenados, estas funciones no tienen ninguna funcionalidad especial, pero en cualquier caso, es necesario utilizarlas siempre para que la comunicaci\u00f3n entre pares sea correcta. Las funciones t\u00edpicas de reordenaci\u00f3n de datos son cuatro: htons , htonl , ntohs y ntohl . Su nombre explica correctamente su sem\u00e1ntica: host to network (short) host to network (long) , network to host (short) y network to host (long) , convirtiendo tipos de datos short y long desde el formato utilizado en transmisiones de red ( network ) a representaci\u00f3n en el host . As\u00ed, siempre que enviemos un dato binario por la red, deber\u00e1 ser transformado utilizando hton* y cuando lo recibamos y debamos procesarlo, utilizando ntoh* . Estructuras de datos Antes de estudiar la API de sockets b\u00e1sica, es necesario mostrar el cometido de un conjunto de estructuras de datos utilizadas comunmente en todas ellas. La m\u00e1s importante es sockaddr_in , que se define como sigue: struct sockaddr_in { short sin_family; u_short sin_port; struct in_addr sin_addr; char sin_zero[8]; }; La estructura in_addr utilizada en sockaddr_in se define como: struct in_addr { u_long s_addr; }; \u00c9sta consiste en un campo de tipo unsigned long int que contiene la direcci\u00f3n IP que se asociar\u00e1 con el socket. La estructura sockaddr_in contiene dos campos importantes: sin_family : que indica al socket qu\u00e9 familia de protocolos se utiliar\u00e1n (usaremos la constante AF_INET para IPv4). sin_port : que indica el puerto asociado al socket. API b\u00e1sica socket() Prototipo: int socket(int family, int type, int protocol); Descripci\u00f3n: Crea un endpoint de comunicaci\u00f3n y devuelve un descriptor de fichero para manejarlo. Par\u00e1metros: family : AF_INET (IPv4), AF_INET6 (IPv6). type : SOCK_DGRAM (UDP), SOCK_STREAM (TCP), SOCK_RAW . protocol : T\u00edpicamente 0 (no usado en sockets de Internet). Valor de retorno: Si tiene \u00e9xito, devuelve el descriptor de socket . Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de socket ( man socket ). bind() Prototipo: int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); Descripci\u00f3n: Asocia un socket a una direcci\u00f3n especificada por addr . Normalmente, es necesario asignar una direcci\u00f3n local v\u00eda esta funci\u00f3n antes de que un socket TCP pueda recibir conexiones. Par\u00e1metros: sockfd : descriptor de socket (devuelto por socket ). addr : direcci\u00f3n a asociar (v\u00e9ase estructura en secci\u00f3n anterior). addrlen : longitud (en bytes) de la anterior estructura. Valor de retorno: Si tiene \u00e9xito, devuelve 0. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de bind ( man bind ). listen() Prototipo: int listen(int sockfd, int backlog); Descripci\u00f3n: Marca el socket proporcionado como pasivo , esto es, un socket que podr\u00e1 ser utilizado para aceptar conexiones entrantes usando la llamada accept . Par\u00e1metros: sockfd : descriptor de socket (devuelto por socket ). backlog : longitud m\u00e1xima que podr\u00e1 tener la cola de conexiones pendientes para el socket . Si se sobrepasa, el cliente recibir\u00e1 un error en su intento de conexi\u00f3n. Valor de retorno: Si tiene \u00e9xito, devuelve 0. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de listen ( man listen ). accept() Prototipo: int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); Descripci\u00f3n: En sockets orientados a conexi\u00f3n, extrae la primera solicitud de conexi\u00f3n de la cola de conexiones pendientes para el socket proporcionado, crea un nuevo socket conectado y devuelve su descriptor. Par\u00e1metros: sockfd : descriptor de socket (devuelto por socket ). addr : es un puntero a una estructura de tipo sockaddr , cuyos campos ser\u00e1n rellenados con los datos de direcci\u00f3n del socket remoto. addrlen : tama\u00f1o de la estructura addr . Valor de retorno: Si tiene \u00e9xito, devuelve el descriptor de socket. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de accept ( man accept ). connect() Prototipo: int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); Descripci\u00f3n: Conecta el socket proporcionada a la direcci\u00f3n espec\u00edficada por addr . Si el socket es UDP, addr ser\u00e1 la direcci\u00f3n a la que se enviar\u00e1n los datagramas por defecto, y la \u00fanica desde la que se recibir\u00e1n datagramas. En caso de TCP, esta llamada inicia el proceso de conexi\u00f3n a la direcci\u00f3n especificada. Par\u00e1metros: sockfd : descriptor de socket (devuelto por socket ). addr : es un puntero a una estructura de tipo sockaddr , cuyos campos indican la direcci\u00f3n de conexi\u00f3n destino. addrlen : tama\u00f1o de la estructura addr . Valor de retorno: Si tiene \u00e9xito, devuelve el descriptor de socket. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de connect ( man connect ). send() Prototipo: ssize_t send(int sockfd, const void *buf, size_t len, int flags); Descripci\u00f3n: En un socket en estado conectado (con receptor conocido) transmite mensajes a un socket remoto. Par\u00e1metros: sockfd : descriptor de socket de env\u00edo. buf : buffer de env\u00edo donde se almacena el mensaje a enviar. len : n\u00famero de bytes a enviar. Valor de retorno: Si tiene \u00e9xito, devuelve el n\u00famero de bytes enviados. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de send ( man send ). recv() / recvfrom() Prototipos: ssize_t recv(int sockfd, void *buf, size_t len, int flags); ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen); Descripci\u00f3n: Reciben mensajes desde un socket , tanto en sockets orientados como no orientados a conexi\u00f3n. recvfrom , a diferencia de recv , recibe par\u00e1metrosd de salida adicionales que almacenan informaci\u00f3n sobre la direcci\u00f3n origen del mensaje. Par\u00e1metros: sockfd : descriptor de socket de recepci\u00f3n. buf : buffer de recepci\u00f3n donde se almacena el mensaje a recibir. len : n\u00famero de bytes a recibir. src_addr : direcci\u00f3n del extremo remoto del socket (origen de la comunicaci\u00f3n). addrlen : tama\u00f1o de la estructura src_addr . Valor de retorno: Si tiene \u00e9xito, devuelve el n\u00famero de bytes recibidos. Devuelve -1 si se produce un error. Detalles: consultad las p\u00e1ginas de manual de recv y recv_from ( man recv y man recv_from ). close() Prototipo: int close(int fd); Descripci\u00f3n: Cierra un socket. Par\u00e1metros: fd : descriptor de socket . Detalles: consultad la p\u00e1gina de manual de close ( man close ). Ejemplos Se proporcionan a continuaci\u00f3n ejemplos completos de uso de la API de sockets en C para el desarrollo de sistemas cliente/servidor sencillos. Para cada uno de ellos, comprueba que, efectivamente, el uso y secuencia de aplicaci\u00f3n de cada llamada sigue las directivas de la figura: Tarea Compila ( gcc ejemplo.c -o ejemplo.x ) y ejecuta ( ./ejemplo.x ) cada par de c\u00f3digos y comprueba su funcionamiento. Estudia con detenimiento el uso de cada rutina y como efectivamente siguen las directivas marcadas anteriormente. Ejemplo: un cliente TCP #include <arpa/inet.h> #include <stdio.h> #include <string.h> #include <sys/socket.h> #include <unistd.h> #include <netinet/in.h> int main() { const int server_port = 9000; struct sockaddr_in server_address; memset(&server_address, 0, sizeof(server_address)); server_address.sin_family = AF_INET; server_address.sin_addr.s_addr = inet_addr(\"127.0.0.1\"); server_address.sin_port = htons(server_port); int sock; if ((sock = socket(PF_INET, SOCK_STREAM, 0)) < 0) { printf(\"Error en socket\\n\"); return 1; } if (connect(sock, (struct sockaddr*)&server_address, sizeof(server_address)) < 0) { printf(\"Error en connect\\n\"); return 1; } const char* data_to_send = \"Hola, RPI!!\"; send(sock, data_to_send, strlen(data_to_send), 0); int n = 0; int len = 0, maxlen = 100; char buffer[maxlen]; char* pbuffer = buffer; while ((n = recv(sock, pbuffer, maxlen, 0)) > 0) { pbuffer += n; maxlen -= n; len += n; buffer[len] = '\\0'; printf(\"Recibido: '%s'\\n\", buffer); } close(sock); return 0; } Ejemplo: un servidor TCP #include <arpa/inet.h> #include <netinet/in.h> #include <stdbool.h> #include <stdio.h> #include <string.h> #include <unistd.h> int main(int argc, char *argv[]) { int SERVER_PORT = 9000; struct sockaddr_in server_address; memset(&server_address, 0, sizeof(server_address)); server_address.sin_family = AF_INET; server_address.sin_port = htons(SERVER_PORT); server_address.sin_addr.s_addr = htonl(INADDR_ANY); int listen_sock; if ((listen_sock = socket(PF_INET, SOCK_STREAM, 0)) < 0) { printf(\"Error en socket\\n\"); return 1; } if ((bind(listen_sock, (struct sockaddr *)&server_address, sizeof(server_address))) < 0) { printf(\"Error en bind\\n\"); return 1; } int wait_size = 16; if (listen(listen_sock, wait_size) < 0) { printf(\"Error en listen\\n\"); return 1; } struct sockaddr_in client_address; int client_address_len = 0; while (true) { int sock; if ((sock = accept(listen_sock, (struct sockaddr *)&client_address, &client_address_len)) < 0) { printf(\"Error en accept\\n\"); return 1; } int n = 0; int len = 0, maxlen = 100; char buffer[maxlen]; char *pbuffer = buffer; printf(\"Cliente conectado con IP: %s\\n\", inet_ntoa(client_address.sin_addr)); while ((n = recv(sock, pbuffer, maxlen, 0)) > 0) { pbuffer += n; maxlen -= n; len += n; printf(\"Recibido: '%s'\\n\", buffer); send(sock, buffer, len, 0); } close(sock); } close(listen_sock); return 0; } Tarea Reproduce el funcionamiento del anterior sistema cliente/servidor echo utilizando UDP. Construcci\u00f3n de mensajes Para enviar mensajes que encapsulen distintos tipos de datos en una sola invocaci\u00f3n, puedes definir un mensaje como el siguiente: typedef struct { int x; int y; } mensaje; Dando valor a cada campo y a continuaci\u00f3n envi\u00e1ndolo proporcionando la direcci\u00f3n de inicio de la estructura, del siguiente modo: mensaje.x = x; mensaje.y = y; send( socketfd, &mensaje, sizeof( mensaje ), 0 ); Tarea Modifica el cliente UDP para que encapsule y env\u00ede una estructura con distintos campos (por ejemplo, dos enteros), que sea recibida por un servidor Python siguiendo las directivas de la anterior pr\u00e1ctica. En este caso, no utilices campos de tipo flotante (veremos c\u00f3mo hacerlo m\u00e1s adelante). El objetivo del ejercicio es simplemente comprobar que la comunicaci\u00f3n entre un cliente programado en C y un servidor programado en Python es posible. No se pretende que desarrolles un sistema complejo. Sistemas cliente/servidor en el ESP32 La raz\u00f3n por la que hemos ejercitado el uso de la API de sockets desde C en Linux es que la implementaci\u00f3n de la pila TCP/IP en ESP-IDF (llamada Lightweight TCP/IP (lwIP) ) implementa al 100% dicha API. Por tanto, tanto la estructura b\u00e1sica de un firmware que implemente un cliente o servidor como la API utilizada permanece inalterada. En esta \u00faltima secci\u00f3n, se pide trabajar con dos ejemplos b\u00e1sicos de implementaci\u00f3n de sistemas cliente/servidor UDP y TCP sobre el ESP32, con el objetivo de estudiar su funcionalidad, comprobar su interoperabilidad y realizar modificaciones para adaptarlas a una hipot\u00e9tica aplicaci\u00f3n IoT. Cliente/servidor UDP en el ESP32 En esta parte, trabajar\u00e1s con dos ejemplos proporcionados dentro de la colecci\u00f3n de ejemplos de ESP-IDF. Por tanto, copia en tu espacio de trabajo (fuera del \u00e1rbol principal de ESP-IDF) los ejemplos: Servidor UDP : examples/protocols/sockets/udp_server/ Cliente UDP : examples/protocols/sockets/udp_client/ Estructura general Observa sus c\u00f3digos ( udp_server.c para el servidor, y udp_client.c para el cliente). Comprueba que, tanto la estructura b\u00e1sica de ambos componentes como las invocaciones a la API de sockets concuerdan con las que vimos para el sistema echo programado en C. Acerca de la tarea principal (funcion app_main ) observa que realiza una serie de llamadas a APIs de configuraci\u00f3n de algunos subsistemas de FreeRTOS, principalmente: // Inicializa la partici\u00f3n NVS (Non-volatile storage) por defecto. ESP_ERROR_CHECK(nvs_flash_init()); // Inicializa la infraestructura ESP-NETIF. ESP_ERROR_CHECK(esp_netif_init()); // Crea un bucle de eventos por defecto. ESP_ERROR_CHECK(esp_event_loop_create_default()); /* Esta funci\u00f3n configura WiFi o Ethernet, tal y como seleccionemos via menuconfig. */ ESP_ERROR_CHECK(example_connect()); xTaskCreate(udp_server_task, \"udp_server\", 4096, NULL, 5, NULL); example_connect() , funci\u00f3n que no forma parte de ESP-IDF, establece una conexi\u00f3n WiFi o Ethernet. La funci\u00f3n es bloqueante, y retorna cuando se ha conseguido establecer una conexi\u00f3n. Las caracter\u00edsticas de la conexi\u00f3n WiFi (SSID y contrase\u00f1a) se deben proporcionar a trav\u00e9s de menuconfig . El objetivo de ESP-NETIF es proporcionar una capa de abstracci\u00f3n por encima de la pila TCP/IP, de modo que pueda migrarse la pila sin que los c\u00f3digos del usuario cambien. Puedes consultar su documentaci\u00f3n en la p\u00e1gina oficial . Por \u00faltimo, se cerea una tarea que ejecutar\u00e1 la l\u00f3gica del servidor (lo mismo ocurre en el cliente). Observa que, en todo el c\u00f3digo, los mensajes de error se anotan utilizando la macro ESP_LOGE y los informativos con ESP_LOGI ; intenta seguir este convenio en tus c\u00f3digos. Despliegue. Opci\u00f3n 1 En este caso, desplegar\u00e1s el cliente en un ESP32 y el servidor en otro. Si no dispones de dos ESP32, puedes trabajar con un compa\u00f1ero. En cualquier caso, ambos ESP32 deben pertenecer a la misma red inal\u00e1mbrica, por lo que deber\u00e1n conectarse a un mismo punto de acceso (el profesor te proporcionar\u00e1 los datos, o simplemente puedes utilizar tu punto de acceso dom\u00e9stico). Configura los siguientes puntos de la infraestructura: Configura el SSID y contrase\u00f1a del punto de acceso v\u00eda menuconfig antes de compilar y flashear el c\u00f3digo tanto en el cliente como en el servidor. En el servidor, configura v\u00eda menuconfig el puerto sobre el que escuchar\u00e1. Arranca primero el nodo servidor y apunta la IP proporcionada por el punto de acceso; util\u00edzala en el cliente para configurar la IP destino de la comunicaci\u00f3n. No olvides configurar tambi\u00e9n el puerto destino de acuerdo al configurado en el servidor v\u00eda menuconfig . \u00can este punto, podr\u00e1s arrancar el cliente y deber\u00edas estar comunicando dos nodos ESP32 v\u00eda UDP. Despliegue. Opci\u00f3n 2 Si s\u00f3lo dispones de un nodo, o si simplemente quieres probar otra forma de comunicaci\u00f3n en la que uno de los equipos es un PC, puedes utilizar alguna de las herramientas del sistema: Nota Ten en cuenta que port\u00e1til (es decir, m\u00e1quina virtual) y ESP32 deben pertenecera la misma red. Para conseguirlo, para tu m\u00e1quina virtual y a\u00f1ade una nueva interfaz de red de tipo bridge conectada a la interfaz Wifi f\u00edsica de tu PC. As\u00ed, tendr\u00e1s una interfaz con IP en la misma red, otorgada directamente por tu punto de acceso. Para recibir un paquete UDP a trav\u00e9s de un puerto (es decir, emular un servidor UDP): nc -ul -p 3333 Para enviar un paquete UDP a una IP/puerto remotos (es decir, emular un cliente): nc -u IP_REMOTA 3333 En el directorio scripts dispones tambi\u00e9n de peque\u00f1os ejemplos de clientes y servidores UDP Python que puedes tambi\u00e9n utilizar. Cliente/servidor TCP en el ESP32 El despliegue de cliente y servidor TCP es equivalente al UDP. Para recibir un paquete TCP a trav\u00e9s de un puerto (es decir, emular un servidor TCP): nc -l IP -p 3333 Para enviar un paquete TCP a una IP/puerto remotos (es decir, emular un cliente): nc IP 3333 En el directorio scripts dispones tambi\u00e9n de peque\u00f1os ejemplos de clientes y servidores TCP Python que puedes tambi\u00e9n utilizar. Tarea Experimenta con los ejemplos proporcionados en ESP-IDF (cliente/servidor TCP y UDP) y consigue ejecutar todos los elementos en la placa. Si s\u00f3lo dispones de una placa, utiliza la m\u00e1quina virtual como cliente/servidor para comprobar el correcto funcionamiento de cada c\u00f3digo. Tarea entregable En este punto, deber\u00edas disponer de un conjunto de c\u00f3digos que implementan sistemas cliente/servidor tanto en un host (utilizando Python y/o C) como en la placa ESP32 (utilizando C y ESP-IDF), y deber\u00edas haber comprobado su correcto funcionamiento. Espec\u00edficamente, dispondr\u00e1s de: Sistema cliente/servidor desarrollado en la Pr\u00e1ctica 1, escrito en Python e implementando un protocolo b\u00e1sico de aplicacion (tipo de mensaje) propuesto por ti. C\u00f3digo b\u00e1sico en C para implementaci\u00f3n de un servidor/cliente echo programado en C, cuyos c\u00f3digos se proporcionan en este bolet\u00edn. C\u00f3digos b\u00e1sicos en C/ESP-IDF para implementar servidores/clientes echo sobre el ESP32. Como tarea entregable, se pide que adaptes tu entrega de la Pr\u00e1ctica 1 para que tanto cliente como servidor puedan funcionar en el host (bien usando tu implementaci\u00f3n Python, o bien utilizando una nueva implementaci\u00f3n en C) o en el ESP32. Se entregar\u00e1n los c\u00f3digos y una breve memoria con capturas de tr\u00e1fico que demuestren el correcto funcionamiento del sistema.","title":"Pr\u00e1ctica 2"},{"location":"RPI-II/P2/#practica-2-sockets-tcp-y-udp-en-esp-idf","text":"","title":"Pr\u00e1ctica 2. Sockets TCP y UDP en ESP-IDF"},{"location":"RPI-II/P2/#objetivos","text":"Familiarizarse con la API de sockets en C. Desarrollar esquemas b\u00e1sicos de sistemas cliente/servidor TCP y UDP utilizando C. Ser capaces de analizar el tr\u00e1fico generado en una conexi\u00f3n TCP y UDP a trav\u00e9s de Wireshark. Dise\u00f1ar un protocolo de capa de aplicaci\u00f3n para simular una aplicaci\u00f3n cliente/servidor utilizando TCP y UDP para interactuar entre un host y la placa ESP32","title":"Objetivos"},{"location":"RPI-II/P2/#introduccion","text":"En la pr\u00e1ctica anterior, vimos c\u00f3mo desarrollar sistemas cliente/servidor sencillos utilizando Python, tanto en sus variantes TCP como UDP. El objetivo de la presente pr\u00e1ctica es estudiar y desarrollar componentes de red (clientes y servidores TCP y UDP) que puedan ejecutarse sobre el ESP32 haciendo uso de las facilidades propuestas por ESP-IDF. Adem\u00e1s, demostraremos que es posible hacer interactuar clientes y servidores ejecut\u00e1ndose indistintamente en la m\u00e1quina virtual (programados v\u00eda Python) y en la propia placa (utilizando la API de sockets de C).","title":"Introducci\u00f3n"},{"location":"RPI-II/P2/#la-api-de-sockets-en-c","text":"","title":"La API de sockets en C"},{"location":"RPI-II/P2/#funciones-para-ordenacion-de-bytes","text":"Como TCP/IP es un est\u00e1ndar universal, y permite comunicaciones entre cualquier plataforma y arquitectura, es necesario disponer de un m\u00e9todo de ordenaci\u00f3n de los bytes para que m\u00e1quinas big-endian y little-endian puedan comunicarse de forma transparente y correcta. Para ello, se suelen proporcionar rutinas de reordenaci\u00f3n de bytes. En plataformas donde los datos ya est\u00e1n correctamente ordenados, estas funciones no tienen ninguna funcionalidad especial, pero en cualquier caso, es necesario utilizarlas siempre para que la comunicaci\u00f3n entre pares sea correcta. Las funciones t\u00edpicas de reordenaci\u00f3n de datos son cuatro: htons , htonl , ntohs y ntohl . Su nombre explica correctamente su sem\u00e1ntica: host to network (short) host to network (long) , network to host (short) y network to host (long) , convirtiendo tipos de datos short y long desde el formato utilizado en transmisiones de red ( network ) a representaci\u00f3n en el host . As\u00ed, siempre que enviemos un dato binario por la red, deber\u00e1 ser transformado utilizando hton* y cuando lo recibamos y debamos procesarlo, utilizando ntoh* .","title":"Funciones para ordenacion de bytes"},{"location":"RPI-II/P2/#estructuras-de-datos","text":"Antes de estudiar la API de sockets b\u00e1sica, es necesario mostrar el cometido de un conjunto de estructuras de datos utilizadas comunmente en todas ellas. La m\u00e1s importante es sockaddr_in , que se define como sigue: struct sockaddr_in { short sin_family; u_short sin_port; struct in_addr sin_addr; char sin_zero[8]; }; La estructura in_addr utilizada en sockaddr_in se define como: struct in_addr { u_long s_addr; }; \u00c9sta consiste en un campo de tipo unsigned long int que contiene la direcci\u00f3n IP que se asociar\u00e1 con el socket. La estructura sockaddr_in contiene dos campos importantes: sin_family : que indica al socket qu\u00e9 familia de protocolos se utiliar\u00e1n (usaremos la constante AF_INET para IPv4). sin_port : que indica el puerto asociado al socket.","title":"Estructuras de datos"},{"location":"RPI-II/P2/#api-basica","text":"","title":"API b\u00e1sica"},{"location":"RPI-II/P2/#socket","text":"Prototipo: int socket(int family, int type, int protocol); Descripci\u00f3n: Crea un endpoint de comunicaci\u00f3n y devuelve un descriptor de fichero para manejarlo. Par\u00e1metros: family : AF_INET (IPv4), AF_INET6 (IPv6). type : SOCK_DGRAM (UDP), SOCK_STREAM (TCP), SOCK_RAW . protocol : T\u00edpicamente 0 (no usado en sockets de Internet). Valor de retorno: Si tiene \u00e9xito, devuelve el descriptor de socket . Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de socket ( man socket ).","title":"socket()"},{"location":"RPI-II/P2/#bind","text":"Prototipo: int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); Descripci\u00f3n: Asocia un socket a una direcci\u00f3n especificada por addr . Normalmente, es necesario asignar una direcci\u00f3n local v\u00eda esta funci\u00f3n antes de que un socket TCP pueda recibir conexiones. Par\u00e1metros: sockfd : descriptor de socket (devuelto por socket ). addr : direcci\u00f3n a asociar (v\u00e9ase estructura en secci\u00f3n anterior). addrlen : longitud (en bytes) de la anterior estructura. Valor de retorno: Si tiene \u00e9xito, devuelve 0. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de bind ( man bind ).","title":"bind()"},{"location":"RPI-II/P2/#listen","text":"Prototipo: int listen(int sockfd, int backlog); Descripci\u00f3n: Marca el socket proporcionado como pasivo , esto es, un socket que podr\u00e1 ser utilizado para aceptar conexiones entrantes usando la llamada accept . Par\u00e1metros: sockfd : descriptor de socket (devuelto por socket ). backlog : longitud m\u00e1xima que podr\u00e1 tener la cola de conexiones pendientes para el socket . Si se sobrepasa, el cliente recibir\u00e1 un error en su intento de conexi\u00f3n. Valor de retorno: Si tiene \u00e9xito, devuelve 0. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de listen ( man listen ).","title":"listen()"},{"location":"RPI-II/P2/#accept","text":"Prototipo: int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); Descripci\u00f3n: En sockets orientados a conexi\u00f3n, extrae la primera solicitud de conexi\u00f3n de la cola de conexiones pendientes para el socket proporcionado, crea un nuevo socket conectado y devuelve su descriptor. Par\u00e1metros: sockfd : descriptor de socket (devuelto por socket ). addr : es un puntero a una estructura de tipo sockaddr , cuyos campos ser\u00e1n rellenados con los datos de direcci\u00f3n del socket remoto. addrlen : tama\u00f1o de la estructura addr . Valor de retorno: Si tiene \u00e9xito, devuelve el descriptor de socket. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de accept ( man accept ).","title":"accept()"},{"location":"RPI-II/P2/#connect","text":"Prototipo: int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); Descripci\u00f3n: Conecta el socket proporcionada a la direcci\u00f3n espec\u00edficada por addr . Si el socket es UDP, addr ser\u00e1 la direcci\u00f3n a la que se enviar\u00e1n los datagramas por defecto, y la \u00fanica desde la que se recibir\u00e1n datagramas. En caso de TCP, esta llamada inicia el proceso de conexi\u00f3n a la direcci\u00f3n especificada. Par\u00e1metros: sockfd : descriptor de socket (devuelto por socket ). addr : es un puntero a una estructura de tipo sockaddr , cuyos campos indican la direcci\u00f3n de conexi\u00f3n destino. addrlen : tama\u00f1o de la estructura addr . Valor de retorno: Si tiene \u00e9xito, devuelve el descriptor de socket. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de connect ( man connect ).","title":"connect()"},{"location":"RPI-II/P2/#send","text":"Prototipo: ssize_t send(int sockfd, const void *buf, size_t len, int flags); Descripci\u00f3n: En un socket en estado conectado (con receptor conocido) transmite mensajes a un socket remoto. Par\u00e1metros: sockfd : descriptor de socket de env\u00edo. buf : buffer de env\u00edo donde se almacena el mensaje a enviar. len : n\u00famero de bytes a enviar. Valor de retorno: Si tiene \u00e9xito, devuelve el n\u00famero de bytes enviados. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de send ( man send ).","title":"send()"},{"location":"RPI-II/P2/#recvrecvfrom","text":"Prototipos: ssize_t recv(int sockfd, void *buf, size_t len, int flags); ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen); Descripci\u00f3n: Reciben mensajes desde un socket , tanto en sockets orientados como no orientados a conexi\u00f3n. recvfrom , a diferencia de recv , recibe par\u00e1metrosd de salida adicionales que almacenan informaci\u00f3n sobre la direcci\u00f3n origen del mensaje. Par\u00e1metros: sockfd : descriptor de socket de recepci\u00f3n. buf : buffer de recepci\u00f3n donde se almacena el mensaje a recibir. len : n\u00famero de bytes a recibir. src_addr : direcci\u00f3n del extremo remoto del socket (origen de la comunicaci\u00f3n). addrlen : tama\u00f1o de la estructura src_addr . Valor de retorno: Si tiene \u00e9xito, devuelve el n\u00famero de bytes recibidos. Devuelve -1 si se produce un error. Detalles: consultad las p\u00e1ginas de manual de recv y recv_from ( man recv y man recv_from ).","title":"recv()/recvfrom()"},{"location":"RPI-II/P2/#close","text":"Prototipo: int close(int fd); Descripci\u00f3n: Cierra un socket. Par\u00e1metros: fd : descriptor de socket . Detalles: consultad la p\u00e1gina de manual de close ( man close ).","title":"close()"},{"location":"RPI-II/P2/#ejemplos","text":"Se proporcionan a continuaci\u00f3n ejemplos completos de uso de la API de sockets en C para el desarrollo de sistemas cliente/servidor sencillos. Para cada uno de ellos, comprueba que, efectivamente, el uso y secuencia de aplicaci\u00f3n de cada llamada sigue las directivas de la figura: Tarea Compila ( gcc ejemplo.c -o ejemplo.x ) y ejecuta ( ./ejemplo.x ) cada par de c\u00f3digos y comprueba su funcionamiento. Estudia con detenimiento el uso de cada rutina y como efectivamente siguen las directivas marcadas anteriormente.","title":"Ejemplos"},{"location":"RPI-II/P2/#ejemplo-un-cliente-tcp","text":"#include <arpa/inet.h> #include <stdio.h> #include <string.h> #include <sys/socket.h> #include <unistd.h> #include <netinet/in.h> int main() { const int server_port = 9000; struct sockaddr_in server_address; memset(&server_address, 0, sizeof(server_address)); server_address.sin_family = AF_INET; server_address.sin_addr.s_addr = inet_addr(\"127.0.0.1\"); server_address.sin_port = htons(server_port); int sock; if ((sock = socket(PF_INET, SOCK_STREAM, 0)) < 0) { printf(\"Error en socket\\n\"); return 1; } if (connect(sock, (struct sockaddr*)&server_address, sizeof(server_address)) < 0) { printf(\"Error en connect\\n\"); return 1; } const char* data_to_send = \"Hola, RPI!!\"; send(sock, data_to_send, strlen(data_to_send), 0); int n = 0; int len = 0, maxlen = 100; char buffer[maxlen]; char* pbuffer = buffer; while ((n = recv(sock, pbuffer, maxlen, 0)) > 0) { pbuffer += n; maxlen -= n; len += n; buffer[len] = '\\0'; printf(\"Recibido: '%s'\\n\", buffer); } close(sock); return 0; }","title":"Ejemplo: un cliente TCP"},{"location":"RPI-II/P2/#ejemplo-un-servidor-tcp","text":"#include <arpa/inet.h> #include <netinet/in.h> #include <stdbool.h> #include <stdio.h> #include <string.h> #include <unistd.h> int main(int argc, char *argv[]) { int SERVER_PORT = 9000; struct sockaddr_in server_address; memset(&server_address, 0, sizeof(server_address)); server_address.sin_family = AF_INET; server_address.sin_port = htons(SERVER_PORT); server_address.sin_addr.s_addr = htonl(INADDR_ANY); int listen_sock; if ((listen_sock = socket(PF_INET, SOCK_STREAM, 0)) < 0) { printf(\"Error en socket\\n\"); return 1; } if ((bind(listen_sock, (struct sockaddr *)&server_address, sizeof(server_address))) < 0) { printf(\"Error en bind\\n\"); return 1; } int wait_size = 16; if (listen(listen_sock, wait_size) < 0) { printf(\"Error en listen\\n\"); return 1; } struct sockaddr_in client_address; int client_address_len = 0; while (true) { int sock; if ((sock = accept(listen_sock, (struct sockaddr *)&client_address, &client_address_len)) < 0) { printf(\"Error en accept\\n\"); return 1; } int n = 0; int len = 0, maxlen = 100; char buffer[maxlen]; char *pbuffer = buffer; printf(\"Cliente conectado con IP: %s\\n\", inet_ntoa(client_address.sin_addr)); while ((n = recv(sock, pbuffer, maxlen, 0)) > 0) { pbuffer += n; maxlen -= n; len += n; printf(\"Recibido: '%s'\\n\", buffer); send(sock, buffer, len, 0); } close(sock); } close(listen_sock); return 0; } Tarea Reproduce el funcionamiento del anterior sistema cliente/servidor echo utilizando UDP.","title":"Ejemplo: un servidor TCP"},{"location":"RPI-II/P2/#construccion-de-mensajes","text":"Para enviar mensajes que encapsulen distintos tipos de datos en una sola invocaci\u00f3n, puedes definir un mensaje como el siguiente: typedef struct { int x; int y; } mensaje; Dando valor a cada campo y a continuaci\u00f3n envi\u00e1ndolo proporcionando la direcci\u00f3n de inicio de la estructura, del siguiente modo: mensaje.x = x; mensaje.y = y; send( socketfd, &mensaje, sizeof( mensaje ), 0 ); Tarea Modifica el cliente UDP para que encapsule y env\u00ede una estructura con distintos campos (por ejemplo, dos enteros), que sea recibida por un servidor Python siguiendo las directivas de la anterior pr\u00e1ctica. En este caso, no utilices campos de tipo flotante (veremos c\u00f3mo hacerlo m\u00e1s adelante). El objetivo del ejercicio es simplemente comprobar que la comunicaci\u00f3n entre un cliente programado en C y un servidor programado en Python es posible. No se pretende que desarrolles un sistema complejo.","title":"Construcci\u00f3n de mensajes"},{"location":"RPI-II/P2/#sistemas-clienteservidor-en-el-esp32","text":"La raz\u00f3n por la que hemos ejercitado el uso de la API de sockets desde C en Linux es que la implementaci\u00f3n de la pila TCP/IP en ESP-IDF (llamada Lightweight TCP/IP (lwIP) ) implementa al 100% dicha API. Por tanto, tanto la estructura b\u00e1sica de un firmware que implemente un cliente o servidor como la API utilizada permanece inalterada. En esta \u00faltima secci\u00f3n, se pide trabajar con dos ejemplos b\u00e1sicos de implementaci\u00f3n de sistemas cliente/servidor UDP y TCP sobre el ESP32, con el objetivo de estudiar su funcionalidad, comprobar su interoperabilidad y realizar modificaciones para adaptarlas a una hipot\u00e9tica aplicaci\u00f3n IoT.","title":"Sistemas cliente/servidor en el ESP32"},{"location":"RPI-II/P2/#clienteservidor-udp-en-el-esp32","text":"En esta parte, trabajar\u00e1s con dos ejemplos proporcionados dentro de la colecci\u00f3n de ejemplos de ESP-IDF. Por tanto, copia en tu espacio de trabajo (fuera del \u00e1rbol principal de ESP-IDF) los ejemplos: Servidor UDP : examples/protocols/sockets/udp_server/ Cliente UDP : examples/protocols/sockets/udp_client/","title":"Cliente/servidor UDP en el ESP32"},{"location":"RPI-II/P2/#estructura-general","text":"Observa sus c\u00f3digos ( udp_server.c para el servidor, y udp_client.c para el cliente). Comprueba que, tanto la estructura b\u00e1sica de ambos componentes como las invocaciones a la API de sockets concuerdan con las que vimos para el sistema echo programado en C. Acerca de la tarea principal (funcion app_main ) observa que realiza una serie de llamadas a APIs de configuraci\u00f3n de algunos subsistemas de FreeRTOS, principalmente: // Inicializa la partici\u00f3n NVS (Non-volatile storage) por defecto. ESP_ERROR_CHECK(nvs_flash_init()); // Inicializa la infraestructura ESP-NETIF. ESP_ERROR_CHECK(esp_netif_init()); // Crea un bucle de eventos por defecto. ESP_ERROR_CHECK(esp_event_loop_create_default()); /* Esta funci\u00f3n configura WiFi o Ethernet, tal y como seleccionemos via menuconfig. */ ESP_ERROR_CHECK(example_connect()); xTaskCreate(udp_server_task, \"udp_server\", 4096, NULL, 5, NULL); example_connect() , funci\u00f3n que no forma parte de ESP-IDF, establece una conexi\u00f3n WiFi o Ethernet. La funci\u00f3n es bloqueante, y retorna cuando se ha conseguido establecer una conexi\u00f3n. Las caracter\u00edsticas de la conexi\u00f3n WiFi (SSID y contrase\u00f1a) se deben proporcionar a trav\u00e9s de menuconfig . El objetivo de ESP-NETIF es proporcionar una capa de abstracci\u00f3n por encima de la pila TCP/IP, de modo que pueda migrarse la pila sin que los c\u00f3digos del usuario cambien. Puedes consultar su documentaci\u00f3n en la p\u00e1gina oficial . Por \u00faltimo, se cerea una tarea que ejecutar\u00e1 la l\u00f3gica del servidor (lo mismo ocurre en el cliente). Observa que, en todo el c\u00f3digo, los mensajes de error se anotan utilizando la macro ESP_LOGE y los informativos con ESP_LOGI ; intenta seguir este convenio en tus c\u00f3digos.","title":"Estructura general"},{"location":"RPI-II/P2/#despliegue-opcion-1","text":"En este caso, desplegar\u00e1s el cliente en un ESP32 y el servidor en otro. Si no dispones de dos ESP32, puedes trabajar con un compa\u00f1ero. En cualquier caso, ambos ESP32 deben pertenecer a la misma red inal\u00e1mbrica, por lo que deber\u00e1n conectarse a un mismo punto de acceso (el profesor te proporcionar\u00e1 los datos, o simplemente puedes utilizar tu punto de acceso dom\u00e9stico). Configura los siguientes puntos de la infraestructura: Configura el SSID y contrase\u00f1a del punto de acceso v\u00eda menuconfig antes de compilar y flashear el c\u00f3digo tanto en el cliente como en el servidor. En el servidor, configura v\u00eda menuconfig el puerto sobre el que escuchar\u00e1. Arranca primero el nodo servidor y apunta la IP proporcionada por el punto de acceso; util\u00edzala en el cliente para configurar la IP destino de la comunicaci\u00f3n. No olvides configurar tambi\u00e9n el puerto destino de acuerdo al configurado en el servidor v\u00eda menuconfig . \u00can este punto, podr\u00e1s arrancar el cliente y deber\u00edas estar comunicando dos nodos ESP32 v\u00eda UDP.","title":"Despliegue. Opci\u00f3n 1"},{"location":"RPI-II/P2/#despliegue-opcion-2","text":"Si s\u00f3lo dispones de un nodo, o si simplemente quieres probar otra forma de comunicaci\u00f3n en la que uno de los equipos es un PC, puedes utilizar alguna de las herramientas del sistema: Nota Ten en cuenta que port\u00e1til (es decir, m\u00e1quina virtual) y ESP32 deben pertenecera la misma red. Para conseguirlo, para tu m\u00e1quina virtual y a\u00f1ade una nueva interfaz de red de tipo bridge conectada a la interfaz Wifi f\u00edsica de tu PC. As\u00ed, tendr\u00e1s una interfaz con IP en la misma red, otorgada directamente por tu punto de acceso. Para recibir un paquete UDP a trav\u00e9s de un puerto (es decir, emular un servidor UDP): nc -ul -p 3333 Para enviar un paquete UDP a una IP/puerto remotos (es decir, emular un cliente): nc -u IP_REMOTA 3333 En el directorio scripts dispones tambi\u00e9n de peque\u00f1os ejemplos de clientes y servidores UDP Python que puedes tambi\u00e9n utilizar.","title":"Despliegue. Opci\u00f3n 2"},{"location":"RPI-II/P2/#clienteservidor-tcp-en-el-esp32","text":"El despliegue de cliente y servidor TCP es equivalente al UDP. Para recibir un paquete TCP a trav\u00e9s de un puerto (es decir, emular un servidor TCP): nc -l IP -p 3333 Para enviar un paquete TCP a una IP/puerto remotos (es decir, emular un cliente): nc IP 3333 En el directorio scripts dispones tambi\u00e9n de peque\u00f1os ejemplos de clientes y servidores TCP Python que puedes tambi\u00e9n utilizar. Tarea Experimenta con los ejemplos proporcionados en ESP-IDF (cliente/servidor TCP y UDP) y consigue ejecutar todos los elementos en la placa. Si s\u00f3lo dispones de una placa, utiliza la m\u00e1quina virtual como cliente/servidor para comprobar el correcto funcionamiento de cada c\u00f3digo. Tarea entregable En este punto, deber\u00edas disponer de un conjunto de c\u00f3digos que implementan sistemas cliente/servidor tanto en un host (utilizando Python y/o C) como en la placa ESP32 (utilizando C y ESP-IDF), y deber\u00edas haber comprobado su correcto funcionamiento. Espec\u00edficamente, dispondr\u00e1s de: Sistema cliente/servidor desarrollado en la Pr\u00e1ctica 1, escrito en Python e implementando un protocolo b\u00e1sico de aplicacion (tipo de mensaje) propuesto por ti. C\u00f3digo b\u00e1sico en C para implementaci\u00f3n de un servidor/cliente echo programado en C, cuyos c\u00f3digos se proporcionan en este bolet\u00edn. C\u00f3digos b\u00e1sicos en C/ESP-IDF para implementar servidores/clientes echo sobre el ESP32. Como tarea entregable, se pide que adaptes tu entrega de la Pr\u00e1ctica 1 para que tanto cliente como servidor puedan funcionar en el host (bien usando tu implementaci\u00f3n Python, o bien utilizando una nueva implementaci\u00f3n en C) o en el ESP32. Se entregar\u00e1n los c\u00f3digos y una breve memoria con capturas de tr\u00e1fico que demuestren el correcto funcionamiento del sistema.","title":"Cliente/servidor TCP en el ESP32"},{"location":"RPI-II/P3/","text":"Pr\u00e1ctica 3. Seguridad (TLS y DTLS) Objetivos Observar el comportamiento de TLS y DTLS para el intercambio cifrado de mensajes. Conocer las diferencias b\u00e1sicas entre TLS y DTLS. Conocer una API b\u00e1sica de programaci\u00f3n de sistemas cliente/servidor usando TLS y DTLS (WolfSSL). Conocer una API b\u00e1sica de programaci\u00f3n de sistemas cliente/servidor en ESP-IDF (ESP-TLS). Contenido del paquete proporcionado y setup b\u00e1sico El paquete proporcionado (puedes descargarlo aqu\u00ed ) incluye ejemplos de sistemas cliente/servidor programados utilizando TLS y DTLS mediante el uso de la biblioteca WolfSSL. Estos c\u00f3digos est\u00e1n dise\u00f1ados para ejecutarse exclusivamente en un sistema Linux, y requieren la instalaci\u00f3n de los paquetes de desarrollo WolfSSL. Para realizar la instalaci\u00f3n, ejecuta en tu m\u00e1quina virtual (esta l\u00ednea podr\u00eda cambiar si usas otra distribuci\u00f3n de Linux, en cuyo caso deber\u00e1s buscar los paquetes equivalentes): sudo apt-get install libwolfssl-dev libwolfssl24 Una vez hecho esto, prueba a realizar la compilaci\u00f3n tanto del ejemplo TLS como DTLS utilizando la orden make en el directorio correspondiente. Si todo ha ido bien, puedes continuar con el an\u00e1lisis de los c\u00f3digos en la siguiente secci\u00f3n. Cliente/servidor TLS. Ejemplo b\u00e1sico en host Servidor TLS Analizaremos en primer lugar el c\u00f3digo b\u00e1sico del servidor TLS. Para ello, observa el contenido del fchero tls/server-tls.c . Cabeceras y constantes El uso de WolfSSL requiere la inclusi\u00f3n de dos cabeceras b\u00e1sicas: #include <wolfssl/options.h> #include <wolfssl/ssl.h> Adem\u00e1s, ya que ser\u00e1n necesarios en el desarrollo, definiremos las rutas al certificado (clave p\u00fablica) del servidor y su clave privada: #define CERT_FILE \"../certs/server-cert.pem\" #define KEY_FILE \"../certs/server-key.pem\" Observa adem\u00e1s que el puerto de escucha del servidor ser\u00e1 el 11111 . Objetos b\u00e1sicos WolfSSL. Contexto y objeto SSL Definiremos dos objetos b\u00e1sicos que se utilizar\u00e1n de forma recurrente en el c\u00f3digo: WOLFSSL_CTX* ctx; WOLFSSL* ssl; El contexto ( ctx ) incluye valores globales para cada conexi\u00f3n SSL, incluyendo informaci\u00f3n sobre certificados. Es posible utilizar un mismo contexto para m\u00faltiples conexiones, siempre que compartan caracter\u00edsticas. Para crear un nuevo contexto, utilizaremos la funci\u00f3n wolfSSL_CTX_new como sigue: /* Create and initialize WOLFSSL_CTX */ if ((ctx = wolfSSL_CTX_new(wolfTLSv1_2_server_method())) == NULL) { fprintf(stderr, \"ERROR: failed to create WOLFSSL_CTX\\n\"); return -1; } El argumento proporcionado incluye informaci\u00f3n sobre la versi\u00f3n de protocolo a utilizar. Actualmente, WolfSSL soporta SSL 3.0, TLS 1.1, TLS 1.2, DTLS 1.0 y DTLS 1.2. En este caso, para la parte cliente, las funciones a utilizar como argumento ser\u00edan: wolfSSLv3_server_method(); // SSLv3 wolfTLSv1_server_method(); // TLSv1 wolfTLSv1_1_server_method(); // TLSv1.1 wolfTLSv1_2_server_method(); // TLSv1.2 wolfDTLSv1_server_method(); // DTLS wolfDTLSv1_2_server_method(); // DTLS 1.2 En segundo lugar, es necesario cargar nuestra CA (Autoridad Certificadora) en el contexto, para que cualquier cliente pueda verificar, en el momento de su conexi\u00f3n, la identidad del sevidor. Para ello, usamos la funci\u00f3n wolfSSL_CTX_use_certificate_file de la siguiente manera: /* Load server certificates into WOLFSSL_CTX */ if (wolfSSL_CTX_use_certificate_file(ctx, CERT_FILE, SSL_FILETYPE_PEM) != SSL_SUCCESS) { fprintf(stderr, \"ERROR: failed to load %s, please check the file.\\n\", CERT_FILE); return -1; } Del mismo modo, el servidor deber\u00e1 incluir su clave privada en formato PEM: /* Load server key into WOLFSSL_CTX */ if (wolfSSL_CTX_use_PrivateKey_file(ctx, KEY_FILE, SSL_FILETYPE_PEM) != SSL_SUCCESS) { fprintf(stderr, \"ERROR: failed to load %s, please check the file.\\n\", KEY_FILE); return -1; } A continuaci\u00f3n, observa como el c\u00f3digo de escucha y aceptaci\u00f3n de conexiones entrantes no difier de cualquier c\u00f3digo que hayas desarrollado previamente para aceptar conexiones entrantes TCP ( bind , + listen + accept ). Justo tras la conexi\u00f3n ( accept ), resulta necesario crear un nuevo objeto SSL, as\u00ed como asociar el descriptor de socket con la nueva sesi\u00f3n (conexi\u00f3n) TLS: /* Create a WOLFSSL object */ if ((ssl = wolfSSL_new(ctx)) == NULL) { fprintf(stderr, \"ERROR: failed to create WOLFSSL object\\n\"); return -1; } /* Attach wolfSSL to the socket */ wolfSSL_set_fd(ssl, connd); /* Establish TLS connection */ ret = wolfSSL_accept(ssl); if (ret != SSL_SUCCESS) { fprintf(stderr, \"wolfSSL_accept error = %d\\n\", wolfSSL_get_error(ssl, ret)); return -1; } A partir de este punto, podemos enviar y recibir datos a trav\u00e9s del socket (y por tanto de la conexi\u00f3n TLS) de forma muy similar a como lo hacemos con el enfoque cl\u00e1sico. As\u00ed, para recibir datos: if (wolfSSL_read(ssl, buff, sizeof(buff)-1) == -1) { fprintf(stderr, \"ERROR: failed to read\\n\"); return -1; } Y para enviar datos de vuelta: /* Reply back to the client */ if (wolfSSL_write(ssl, buff, len) != len) { fprintf(stderr, \"ERROR: failed to write\\n\"); return -1; } Por \u00faltimo, finalizaremos la conexi\u00f3n con la invocaci\u00f3n de la funci\u00f3n wolfSSL_free(ssl) . Note El cliente proporcionado sigue una estrategia de implementaci\u00f3n similar. Compara ambos c\u00f3digos (cliente y servidor) y aseg\u00farate de entender las diferencias entre ellos. Tarea entregable Compila y ejecuta el sistema cliente/servidor TLS y obt\u00e9n capturas de tr\u00e1fico tanto de las fases de establecimiento de conexi\u00f3n como de las fases de transferencia de datos. En base a lo aprendido en las clases de teor\u00eda y la documentaci\u00f3n adicional sobre TLS y wolfSSL, redacta un breve informe que resuma el proceso de handshake y transferencia de datos en TLS tomando como base los paquetes reales observados para esta conexi\u00f3n. Cliente/servidor DTLS. Ejemplo b\u00e1sico en host El desarrollo de un sistema b\u00e1sico cliente/servidor con soporte DTLS utilizando WolfSSL es muy similar al visto anteriormente para TLS. Como detalle adicional, la inicializaci\u00f3n de la infraestructura debe realizarse indicando el soporte para DTLS en sus versiones 1.0 o 1.2: wolfDTLSv1_client_method(); // DTLS 1.0 wolfDTLSv1_2_client_method(); // DTLS 1.2 El resto del c\u00f3digo sigue una filosof\u00eda similar a TLS, adaptado, obviamente, a las caracter\u00edsticas de UDP (tipo de socket, ausencia de conexi\u00f3n, etc.), por lo que se deja como ejercicio su an\u00e1lisis y ejecuci\u00f3n. Tarea entregable Analiza, compila y ejecuta los c\u00f3digos correspondientes al sistema cliente/servidor DTLS. Realiza capturas de tr\u00e1fico y comp\u00e1ralas, paquete a paquete, con las generadas para un patr\u00f3n de tr\u00e1fico similar en el caso de TLS. Incide en sus similitudes y diferencias, tanto a nivel de handshake como de transferencia de datos. Observa, en este \u00faltimo caso, la aparici\u00f3n de nuevos campos de encabezado en los env\u00edos de datos DTLS. \u00bfCu\u00e1l/cu\u00e1les son esos campos y por qu\u00e9 aparecen? Realiza una comparativa del tr\u00e1fico total generado en ambos casos para exactamente la misma cantidad de datos transferidos. TLS en el ESP32. El componente ESP-TLS ESP-IDF proporciona un componente (ESP-TLS) que ofrece una interfaz (API) simplificada para acceder a funcionalidad b\u00e1sica TLS. A\u00fan as\u00ed, ofrece una funcionalidad suficientemente amplia como para implementar casos de uso comunes en entornos IoT. La API de ESP-TLS es sencilla,y se basa en el uso de cuatro funciones b\u00e1sicas: Establecimiento de conexi\u00f3n TLS ( esp_tls_conn_new() ) Prototipo: esp_tls_t *esp_tls_conn_new(const char *hostname, int hostlen, int port, constesp_tls_cfg_t *cfg) Descripci\u00f3n: Crea una nueva conexi\u00f3n TLS/SSL bloqueante, estableciendo dicha conexi\u00f3n contra un servidor establecido. Par\u00e1metros: hostname : Identificaci\u00f3n del host. hostlen : Longitud del par\u00e1metro hostname . port : Puerto de conexi\u00f3n con el host. cfg : Configuraci\u00f3n de la conexi\u00f3n TLS. Valor de retorno: Puntero a esp_tls_t (manejador de la conexi\u00f3n). Devuelve NULL si se produce un error en la conexi\u00f3n. Destrucci\u00f3n de conexi\u00f3n TLS ( esp_tls_conn_delete() ) void esp_tls_conn_delete(esp_tls_t *tls) Descripci\u00f3n: Cierra la conexi\u00f3n TLS/SSL. Par\u00e1metros: tls : Manejador de la conexi\u00f3n. Escritura de datos ( esp_tls_conn_read() ) static ssize_t esp_tls_conn_write(esp_tls_t *tls, const void *data, size_t datalen) Descripci\u00f3n: Escribe en la conexi\u00f3n TLS/SSL indicada el contenido del buffer data . Par\u00e1metros: tls : Manejador de la conexi\u00f3n. data : Buffer de env\u00edo. datalen : Longitud del buffer de env\u00edo (o n\u00famero m\u00e1ximo de bytes a escribir). Valor de retorno: >=0 : \u00e9xito en el env\u00edo. N\u00famero de bytes efectivamente enviados. <0 : error en el env\u00edo. Lectura de datos ( esp_tls_conn_read() ) static ssize_t esp_tls_conn_read(esp_tls_t *tls, void *data, size_t datalen) Descripci\u00f3n: Lee desde la conexi\u00f3n TLS/SSL indicada hacia el buffer data . Par\u00e1metros: tls : Manejador de la conexi\u00f3n. data : Buffer de recepci\u00f3n. datalen : Longitud del buffer de recepci\u00f3n (o n\u00famero m\u00e1ximo de bytes a leer). Valor de retorno: >0 : \u00e9xito en la recepci\u00f3n. N\u00famero de bytes efectivamente le\u00eddos. =0 : error en la recepci\u00f3n. La conexi\u00f3n se cerr\u00f3. <0 : error en la recepci\u00f3n. Estructura b\u00e1sica de un cliente TCP usando ESP-IDF Un cliente TCP implementado sobre ESP-IDF para dar soporte TLS, requiere ciertas modificaciones con respecto a la versi\u00f3n sin TLS. De hecho, el uso de ESP-IDF simplifica el c\u00f3digo del cliente (puedes compararlo con tus clientes TCP desarrollados en sesiones anteriores). La estructura b\u00e1sica resultar\u00eda: /// Includes anteriores. #include \"esp_tls.h\" // Puede tomarse desde menuconfig. #define HOST_IP_ADDR DIRECCION_DE_HOST #define PORT PUERTO static const char *payload = \"Hola, mundo via TLS\"; // ... static void tls_client_task( void *pvParameters ) { // ... // Configuraci\u00f3n de ESP-TLS (vac\u00edo para opciones defecto). esp_tls_cfg_t cfg = { }; // Creaci\u00f3n de conexi\u00f3n. struct esp_tls *tls = esp_tls_conn_new( HOST_IP_ADDR, longitud, PORT, &cfg); // Chequeo de errores. // ... // Env\u00edo de datos. ret = esp_tls_conn_write(tls, payload, strlen(payload)); // Chequeo de errores. // ... // Lectura de datos ret = esp_tls_conn_read(tls, (char *)rx_buffer, 128); // Chequeo de errores. // ... // Destrucci\u00f3n de la conexi\u00f3n esp_tls_conn_delete( tls ); vTaskDelete( NULL ); } void app_main( void ) { // ... } Observa como, efectivamente, el c\u00f3digo del cliente se simplifica en gran medida con respecto a tu cliente TCP original. Toma el c\u00f3digo del proyecto que utilizaste para desarrollar tu cliente TCP original y, siguiendo las anteriores directivas, adapta la \u00fanica tarea a crear (por ejemplo, puede recibir el nombre tls_client_task ) para que realice un env\u00edo y recepci\u00f3n de datos (una cadena) al servidor TLS que probaste en el host . Puedes valerte para ello de la base del ejemplo examples/protocols/https_request , obviamente adaptando la totalidad de su c\u00f3digo para que se comporte como un simple cliente echo . Note Compila y ejecuta el cliente TLS en el ESP32, y consigue que interact\u00fae con el servidor TLS que probaste anteriormente en el host . Comprueba que, efectivamente, los datos se transfieren cifrados entre ambos extremos, y que el intercambio de paquetes es similar al que observaste entre cliente y servidor en el host . Tarea entregable Adapta tu sistema cliente/servidor TCP desarrollado en la anterior pr\u00e1ctica para que se ejecute sobre el binomio host /ESP32 utlizando TLS. Entrega el c\u00f3digo generado junto con una captura de tr\u00e1fico que demuestre su correcto funcionamiento.","title":"Pr\u00e1ctica 3"},{"location":"RPI-II/P3/#practica-3-seguridad-tls-y-dtls","text":"","title":"Pr\u00e1ctica 3. Seguridad (TLS y DTLS)"},{"location":"RPI-II/P3/#objetivos","text":"Observar el comportamiento de TLS y DTLS para el intercambio cifrado de mensajes. Conocer las diferencias b\u00e1sicas entre TLS y DTLS. Conocer una API b\u00e1sica de programaci\u00f3n de sistemas cliente/servidor usando TLS y DTLS (WolfSSL). Conocer una API b\u00e1sica de programaci\u00f3n de sistemas cliente/servidor en ESP-IDF (ESP-TLS).","title":"Objetivos"},{"location":"RPI-II/P3/#contenido-del-paquete-proporcionado-y-setup-basico","text":"El paquete proporcionado (puedes descargarlo aqu\u00ed ) incluye ejemplos de sistemas cliente/servidor programados utilizando TLS y DTLS mediante el uso de la biblioteca WolfSSL. Estos c\u00f3digos est\u00e1n dise\u00f1ados para ejecutarse exclusivamente en un sistema Linux, y requieren la instalaci\u00f3n de los paquetes de desarrollo WolfSSL. Para realizar la instalaci\u00f3n, ejecuta en tu m\u00e1quina virtual (esta l\u00ednea podr\u00eda cambiar si usas otra distribuci\u00f3n de Linux, en cuyo caso deber\u00e1s buscar los paquetes equivalentes): sudo apt-get install libwolfssl-dev libwolfssl24 Una vez hecho esto, prueba a realizar la compilaci\u00f3n tanto del ejemplo TLS como DTLS utilizando la orden make en el directorio correspondiente. Si todo ha ido bien, puedes continuar con el an\u00e1lisis de los c\u00f3digos en la siguiente secci\u00f3n.","title":"Contenido del paquete proporcionado y setup b\u00e1sico"},{"location":"RPI-II/P3/#clienteservidor-tls-ejemplo-basico-en-host","text":"","title":"Cliente/servidor TLS. Ejemplo b\u00e1sico en host"},{"location":"RPI-II/P3/#servidor-tls","text":"Analizaremos en primer lugar el c\u00f3digo b\u00e1sico del servidor TLS. Para ello, observa el contenido del fchero tls/server-tls.c .","title":"Servidor TLS"},{"location":"RPI-II/P3/#cabeceras-y-constantes","text":"El uso de WolfSSL requiere la inclusi\u00f3n de dos cabeceras b\u00e1sicas: #include <wolfssl/options.h> #include <wolfssl/ssl.h> Adem\u00e1s, ya que ser\u00e1n necesarios en el desarrollo, definiremos las rutas al certificado (clave p\u00fablica) del servidor y su clave privada: #define CERT_FILE \"../certs/server-cert.pem\" #define KEY_FILE \"../certs/server-key.pem\" Observa adem\u00e1s que el puerto de escucha del servidor ser\u00e1 el 11111 .","title":"Cabeceras y constantes"},{"location":"RPI-II/P3/#objetos-basicos-wolfssl-contexto-y-objeto-ssl","text":"Definiremos dos objetos b\u00e1sicos que se utilizar\u00e1n de forma recurrente en el c\u00f3digo: WOLFSSL_CTX* ctx; WOLFSSL* ssl; El contexto ( ctx ) incluye valores globales para cada conexi\u00f3n SSL, incluyendo informaci\u00f3n sobre certificados. Es posible utilizar un mismo contexto para m\u00faltiples conexiones, siempre que compartan caracter\u00edsticas. Para crear un nuevo contexto, utilizaremos la funci\u00f3n wolfSSL_CTX_new como sigue: /* Create and initialize WOLFSSL_CTX */ if ((ctx = wolfSSL_CTX_new(wolfTLSv1_2_server_method())) == NULL) { fprintf(stderr, \"ERROR: failed to create WOLFSSL_CTX\\n\"); return -1; } El argumento proporcionado incluye informaci\u00f3n sobre la versi\u00f3n de protocolo a utilizar. Actualmente, WolfSSL soporta SSL 3.0, TLS 1.1, TLS 1.2, DTLS 1.0 y DTLS 1.2. En este caso, para la parte cliente, las funciones a utilizar como argumento ser\u00edan: wolfSSLv3_server_method(); // SSLv3 wolfTLSv1_server_method(); // TLSv1 wolfTLSv1_1_server_method(); // TLSv1.1 wolfTLSv1_2_server_method(); // TLSv1.2 wolfDTLSv1_server_method(); // DTLS wolfDTLSv1_2_server_method(); // DTLS 1.2 En segundo lugar, es necesario cargar nuestra CA (Autoridad Certificadora) en el contexto, para que cualquier cliente pueda verificar, en el momento de su conexi\u00f3n, la identidad del sevidor. Para ello, usamos la funci\u00f3n wolfSSL_CTX_use_certificate_file de la siguiente manera: /* Load server certificates into WOLFSSL_CTX */ if (wolfSSL_CTX_use_certificate_file(ctx, CERT_FILE, SSL_FILETYPE_PEM) != SSL_SUCCESS) { fprintf(stderr, \"ERROR: failed to load %s, please check the file.\\n\", CERT_FILE); return -1; } Del mismo modo, el servidor deber\u00e1 incluir su clave privada en formato PEM: /* Load server key into WOLFSSL_CTX */ if (wolfSSL_CTX_use_PrivateKey_file(ctx, KEY_FILE, SSL_FILETYPE_PEM) != SSL_SUCCESS) { fprintf(stderr, \"ERROR: failed to load %s, please check the file.\\n\", KEY_FILE); return -1; } A continuaci\u00f3n, observa como el c\u00f3digo de escucha y aceptaci\u00f3n de conexiones entrantes no difier de cualquier c\u00f3digo que hayas desarrollado previamente para aceptar conexiones entrantes TCP ( bind , + listen + accept ). Justo tras la conexi\u00f3n ( accept ), resulta necesario crear un nuevo objeto SSL, as\u00ed como asociar el descriptor de socket con la nueva sesi\u00f3n (conexi\u00f3n) TLS: /* Create a WOLFSSL object */ if ((ssl = wolfSSL_new(ctx)) == NULL) { fprintf(stderr, \"ERROR: failed to create WOLFSSL object\\n\"); return -1; } /* Attach wolfSSL to the socket */ wolfSSL_set_fd(ssl, connd); /* Establish TLS connection */ ret = wolfSSL_accept(ssl); if (ret != SSL_SUCCESS) { fprintf(stderr, \"wolfSSL_accept error = %d\\n\", wolfSSL_get_error(ssl, ret)); return -1; } A partir de este punto, podemos enviar y recibir datos a trav\u00e9s del socket (y por tanto de la conexi\u00f3n TLS) de forma muy similar a como lo hacemos con el enfoque cl\u00e1sico. As\u00ed, para recibir datos: if (wolfSSL_read(ssl, buff, sizeof(buff)-1) == -1) { fprintf(stderr, \"ERROR: failed to read\\n\"); return -1; } Y para enviar datos de vuelta: /* Reply back to the client */ if (wolfSSL_write(ssl, buff, len) != len) { fprintf(stderr, \"ERROR: failed to write\\n\"); return -1; } Por \u00faltimo, finalizaremos la conexi\u00f3n con la invocaci\u00f3n de la funci\u00f3n wolfSSL_free(ssl) . Note El cliente proporcionado sigue una estrategia de implementaci\u00f3n similar. Compara ambos c\u00f3digos (cliente y servidor) y aseg\u00farate de entender las diferencias entre ellos. Tarea entregable Compila y ejecuta el sistema cliente/servidor TLS y obt\u00e9n capturas de tr\u00e1fico tanto de las fases de establecimiento de conexi\u00f3n como de las fases de transferencia de datos. En base a lo aprendido en las clases de teor\u00eda y la documentaci\u00f3n adicional sobre TLS y wolfSSL, redacta un breve informe que resuma el proceso de handshake y transferencia de datos en TLS tomando como base los paquetes reales observados para esta conexi\u00f3n.","title":"Objetos b\u00e1sicos WolfSSL. Contexto y objeto SSL"},{"location":"RPI-II/P3/#clienteservidor-dtls-ejemplo-basico-en-host","text":"El desarrollo de un sistema b\u00e1sico cliente/servidor con soporte DTLS utilizando WolfSSL es muy similar al visto anteriormente para TLS. Como detalle adicional, la inicializaci\u00f3n de la infraestructura debe realizarse indicando el soporte para DTLS en sus versiones 1.0 o 1.2: wolfDTLSv1_client_method(); // DTLS 1.0 wolfDTLSv1_2_client_method(); // DTLS 1.2 El resto del c\u00f3digo sigue una filosof\u00eda similar a TLS, adaptado, obviamente, a las caracter\u00edsticas de UDP (tipo de socket, ausencia de conexi\u00f3n, etc.), por lo que se deja como ejercicio su an\u00e1lisis y ejecuci\u00f3n. Tarea entregable Analiza, compila y ejecuta los c\u00f3digos correspondientes al sistema cliente/servidor DTLS. Realiza capturas de tr\u00e1fico y comp\u00e1ralas, paquete a paquete, con las generadas para un patr\u00f3n de tr\u00e1fico similar en el caso de TLS. Incide en sus similitudes y diferencias, tanto a nivel de handshake como de transferencia de datos. Observa, en este \u00faltimo caso, la aparici\u00f3n de nuevos campos de encabezado en los env\u00edos de datos DTLS. \u00bfCu\u00e1l/cu\u00e1les son esos campos y por qu\u00e9 aparecen? Realiza una comparativa del tr\u00e1fico total generado en ambos casos para exactamente la misma cantidad de datos transferidos.","title":"Cliente/servidor DTLS. Ejemplo b\u00e1sico en host"},{"location":"RPI-II/P3/#tls-en-el-esp32-el-componente-esp-tls","text":"ESP-IDF proporciona un componente (ESP-TLS) que ofrece una interfaz (API) simplificada para acceder a funcionalidad b\u00e1sica TLS. A\u00fan as\u00ed, ofrece una funcionalidad suficientemente amplia como para implementar casos de uso comunes en entornos IoT. La API de ESP-TLS es sencilla,y se basa en el uso de cuatro funciones b\u00e1sicas:","title":"TLS en el ESP32. El componente ESP-TLS"},{"location":"RPI-II/P3/#establecimiento-de-conexion-tls-esp_tls_conn_new","text":"Prototipo: esp_tls_t *esp_tls_conn_new(const char *hostname, int hostlen, int port, constesp_tls_cfg_t *cfg) Descripci\u00f3n: Crea una nueva conexi\u00f3n TLS/SSL bloqueante, estableciendo dicha conexi\u00f3n contra un servidor establecido. Par\u00e1metros: hostname : Identificaci\u00f3n del host. hostlen : Longitud del par\u00e1metro hostname . port : Puerto de conexi\u00f3n con el host. cfg : Configuraci\u00f3n de la conexi\u00f3n TLS. Valor de retorno: Puntero a esp_tls_t (manejador de la conexi\u00f3n). Devuelve NULL si se produce un error en la conexi\u00f3n.","title":"Establecimiento de conexi\u00f3n TLS (esp_tls_conn_new())"},{"location":"RPI-II/P3/#destruccion-de-conexion-tls-esp_tls_conn_delete","text":"void esp_tls_conn_delete(esp_tls_t *tls) Descripci\u00f3n: Cierra la conexi\u00f3n TLS/SSL. Par\u00e1metros: tls : Manejador de la conexi\u00f3n.","title":"Destrucci\u00f3n de conexi\u00f3n TLS (esp_tls_conn_delete())"},{"location":"RPI-II/P3/#escritura-de-datos-esp_tls_conn_read","text":"static ssize_t esp_tls_conn_write(esp_tls_t *tls, const void *data, size_t datalen) Descripci\u00f3n: Escribe en la conexi\u00f3n TLS/SSL indicada el contenido del buffer data . Par\u00e1metros: tls : Manejador de la conexi\u00f3n. data : Buffer de env\u00edo. datalen : Longitud del buffer de env\u00edo (o n\u00famero m\u00e1ximo de bytes a escribir). Valor de retorno: >=0 : \u00e9xito en el env\u00edo. N\u00famero de bytes efectivamente enviados. <0 : error en el env\u00edo.","title":"Escritura de datos (esp_tls_conn_read())"},{"location":"RPI-II/P3/#lectura-de-datos-esp_tls_conn_read","text":"static ssize_t esp_tls_conn_read(esp_tls_t *tls, void *data, size_t datalen) Descripci\u00f3n: Lee desde la conexi\u00f3n TLS/SSL indicada hacia el buffer data . Par\u00e1metros: tls : Manejador de la conexi\u00f3n. data : Buffer de recepci\u00f3n. datalen : Longitud del buffer de recepci\u00f3n (o n\u00famero m\u00e1ximo de bytes a leer). Valor de retorno: >0 : \u00e9xito en la recepci\u00f3n. N\u00famero de bytes efectivamente le\u00eddos. =0 : error en la recepci\u00f3n. La conexi\u00f3n se cerr\u00f3. <0 : error en la recepci\u00f3n.","title":"Lectura de datos (esp_tls_conn_read())"},{"location":"RPI-II/P3/#estructura-basica-de-un-cliente-tcp-usando-esp-idf","text":"Un cliente TCP implementado sobre ESP-IDF para dar soporte TLS, requiere ciertas modificaciones con respecto a la versi\u00f3n sin TLS. De hecho, el uso de ESP-IDF simplifica el c\u00f3digo del cliente (puedes compararlo con tus clientes TCP desarrollados en sesiones anteriores). La estructura b\u00e1sica resultar\u00eda: /// Includes anteriores. #include \"esp_tls.h\" // Puede tomarse desde menuconfig. #define HOST_IP_ADDR DIRECCION_DE_HOST #define PORT PUERTO static const char *payload = \"Hola, mundo via TLS\"; // ... static void tls_client_task( void *pvParameters ) { // ... // Configuraci\u00f3n de ESP-TLS (vac\u00edo para opciones defecto). esp_tls_cfg_t cfg = { }; // Creaci\u00f3n de conexi\u00f3n. struct esp_tls *tls = esp_tls_conn_new( HOST_IP_ADDR, longitud, PORT, &cfg); // Chequeo de errores. // ... // Env\u00edo de datos. ret = esp_tls_conn_write(tls, payload, strlen(payload)); // Chequeo de errores. // ... // Lectura de datos ret = esp_tls_conn_read(tls, (char *)rx_buffer, 128); // Chequeo de errores. // ... // Destrucci\u00f3n de la conexi\u00f3n esp_tls_conn_delete( tls ); vTaskDelete( NULL ); } void app_main( void ) { // ... } Observa como, efectivamente, el c\u00f3digo del cliente se simplifica en gran medida con respecto a tu cliente TCP original. Toma el c\u00f3digo del proyecto que utilizaste para desarrollar tu cliente TCP original y, siguiendo las anteriores directivas, adapta la \u00fanica tarea a crear (por ejemplo, puede recibir el nombre tls_client_task ) para que realice un env\u00edo y recepci\u00f3n de datos (una cadena) al servidor TLS que probaste en el host . Puedes valerte para ello de la base del ejemplo examples/protocols/https_request , obviamente adaptando la totalidad de su c\u00f3digo para que se comporte como un simple cliente echo . Note Compila y ejecuta el cliente TLS en el ESP32, y consigue que interact\u00fae con el servidor TLS que probaste anteriormente en el host . Comprueba que, efectivamente, los datos se transfieren cifrados entre ambos extremos, y que el intercambio de paquetes es similar al que observaste entre cliente y servidor en el host . Tarea entregable Adapta tu sistema cliente/servidor TCP desarrollado en la anterior pr\u00e1ctica para que se ejecute sobre el binomio host /ESP32 utlizando TLS. Entrega el c\u00f3digo generado junto con una captura de tr\u00e1fico que demuestre su correcto funcionamiento.","title":"Estructura b\u00e1sica de un cliente TCP usando ESP-IDF"},{"location":"RPI-II/P4/","text":"Pr\u00e1ctica 4. Protocolos b\u00e1sicos de capa de aplicaci\u00f3n. Websockets Objetivos Conocer el m\u00f3dulo Python websockets para desarrollar sistemas b\u00e1sicos cliente/servidor utilizando websockets . Estudar el intercambio de mensajes entre un cliente y un servidor websockets , tanto en la fase de handshake como de intercambio de datos. Conseguir interactuar con un servidor websockets utilizando un navegador web como cliente. Estudiar mecanismos de mantenimiento y publicaci\u00f3n de estado a clientes conectados, t\u00edpicos en un entorno IoT. Estudiar el componente websockets client en ESP-IDF, y desarrollar un firmware b\u00e1sico que interact\u00fae con un servidor Python. Introducir la gesti\u00f3n de objetos JSON en ESP-IDF. Los ficheros necesarios para completar la pr\u00e1ctica pueden descargarse aqu\u00ed . Ejemplo b\u00e1sico: sistema cliente/servidor usando Websockets en Python (\u00b4client1.py, server1.py`) En primer lugar, introducimos el uso del m\u00f3dulo Python websockets , que proporciona toda la funcionalidad necesaria para desarrollar sistemas cliente/servidor utilizando websockets . El m\u00f3dulo websockets proporciona la funcionalidad necesaria tanto a nivel de cliente como de servidor para implementar sistemas basados en dicho protocolo. Concretamente, las funciones de alto nivel que proporciona est\u00e1n basadas en una API de bajo nivel que implementa las dos fases principales del protocolo websockets : Handshake de apertura de comunicaci\u00f3n, en forma de peticiones HTTP upgrade . Transferencia de datos, y finalizaci\u00f3n de la comunicaci\u00f3n con un handshake de cierre de conexi\u00f3n. La primera fase est\u00e1 dise\u00f1ada para integrarse con software HTTP (cliente y servidor) existente, y proporciona una implementaci\u00f3n m\u00ednima para construir, parsear y validar peticiones y respuestas HTTP. La segunda fase implementa el n\u00facleo del protocolo websockets , y proporciona una implementaci\u00f3n completa basada en el m\u00f3dulo asyncio ) de Python. Para utilizar el m\u00f3dulo websockets de Python, primero lo instalaremos v\u00eda pip : pip install websockets Un ejemplo b\u00e1sico se puede basar en un cliente que env\u00eda una cadena a un servidor, y queda a la espera de recibir un mensaje de respuesta por parte de \u00e9ste, tal y como hemos visto en otras pr\u00e1cticas. Desarrollar la parte servidora para dicha aplicaci\u00f3n resulta sencillo. Observa el siguiente c\u00f3digo: #!/usr/bin/env python import asyncio import websockets async def hello(websocket, path): name = await websocket.recv() print(f\"< {name}\") greeting = f\"Hello {name}!\" await websocket.send(greeting) print(f\"> {greeting}\") start_server = websockets.serve(hello, \"localhost\", 8765) asyncio.get_event_loop().run_until_complete(start_server) asyncio.get_event_loop().run_forever() El paradigma de programaci\u00f3n utilizado en este ejemplo (basado en el m\u00f3dulo asyncio ) queda fuera del prop\u00f3sito de la pr\u00e1ctica (aunque se invita al alumno a estudiarlo, ya que aporta importantes ventajas a nivel de sencillez de desarrollo en aplicaciones de red). En cualquier caso, el anterior servidor ejecuta una (co)rutina manejadora hello para cada conexi\u00f3n websocket establecida; adem\u00e1s, se cierra dicha conexi\u00f3n cuando dicha (co)rutina finaliza. Concretamente, las funciones de inter\u00e9s en este caso son: await websockets.server.serve(ws_handler, host=None, port=None, # ... Crea, incializa y devuelve un objeto servidor Websocket asociado al host y puerto seleccionados. En un contexto de programaci\u00f3n as\u00edncrona (como el del ejemplo, el servidor finaliza autom\u00e1ticamente al salir de dicho contexto). Cuando un cliente conecta al host y puerto espec\u00edficados, se acepta la conexi\u00f3n, que es tratada por la (co)rutina ws_handler (en el ejemplo, hello ). Antes de delegar la conexi\u00f3n a la (co)rutina, se lleva a cabo el handshake de apertura websocket . await recv() Recibe el siguiente mensaje, devolviendo una cadena si el frame recibido es de texto, o un array de bytes si es binario. await send(message) Env\u00eda un mensaje. message puede er una cadena, o un array de bytes. En el primer caso, se env\u00eda un frame de texto; en el segundo caso, un frame binario. A continuaci\u00f3n se muestra un ejemplo de cliente websocket para interactuar con el anterior servidor: #!/usr/bin/env python import asyncio import websockets async def hello(): uri = \"ws://localhost:8765\" async with websockets.connect(uri) as websocket: name = input(\"What's your name? \") await websocket.send(name) print(f\"> {name}\") greeting = await websocket.recv() print(f\"< {greeting}\") asyncio.get_event_loop().run_until_complete(hello()) El c\u00f3digo en este caso es sencillo, ya que \u00fanicamente se basa en la planificaci\u00f3n (ejecuci\u00f3n) de una (co)rutina llamada hello , que establece una conexi\u00f3n con un servidor websocket v\u00eda connect , enviando y recibiendo un par de mensajes. await websockets.client.connect(uri, # ... Conecta con un servidor websocket en la URI determinada. La conexi\u00f3n se cierra al abandonar el contexto as\u00edncrono (es decir, la (co)rutina hello ). Tarea entregable Ejecuta el servidor en una terminal de tu m\u00e1quina virtual, y a continuaci\u00f3n el cliente en otra. Analiza el tr\u00e1fico intercambiado y responde a las siguientes preguntas: \u00bfEn qu\u00e9 protocolo de capa de transporte se basa la comunicaci\u00f3n v\u00eda Websockets? En la fase de handshake , \u00bfqu\u00e9 peticiones HTTP se intercambian? Analiza sus emisores y destinatarios, e investiga el cometido principal de cada uno de los campos de sus encabezados (f\u00edjate principalmente en el campo Upgrade y los campos espec\u00edficos para Websockets). En la fase de intercambio de datos, \u00bfqu\u00e9 opcode se especifica en el encabezado de cada paquete? \u00bfPor qu\u00e9? \u00bfSe env\u00edan los datos en claro o cifrados? \u00bfQu\u00e9 opcode se a\u00f1ade en los mensajes de cierre de conexi\u00f3n? Interactuando con un navegador web ( client_for_web.html , server_for_web.py ) Aunque fuera del inter\u00e9s de esta pr\u00e1ctica, es conveniente observar una de las ventajas de websockets : el env\u00edo as\u00edncrono bidireccional de informaci\u00f3n, y observarlo a trav\u00e9s de un navegador web convencional (la mayor\u00eda de navegadores modernos soportan websockets a trav\u00e9s de scripts Javascript ). En este caso, simplemente observa la interacci\u00f3n de un servidor websocket que env\u00eda mensajes que incluyen la hora actual separados un n\u00famero aleatorio de tiempo entre ellos: #!/usr/bin/env python # WS server that sends messages at random intervals import asyncio import datetime import random import websockets async def time(websocket, path): while True: now = datetime.datetime.utcnow().isoformat() + \"Z\" await websocket.send(now) await asyncio.sleep(random.random() * 3) start_server = websockets.serve(time, \"127.0.0.1\", 5678) asyncio.get_event_loop().run_until_complete(start_server) asyncio.get_event_loop().run_forever() Con un cliente (una p\u00e1gina HTML) que establece la conexi\u00f3n v\u00eda websockets , y muestra en la misma un elemento de texto con la marca de tiempo recibida tras la recepci\u00f3n de cada mensaje: <!DOCTYPE html> <html> <head> <title>WebSocket demo</title> </head> <body> <script> var ws = new WebSocket(\"ws://127.0.0.1:5678/\"), messages = document.createElement('ul'); ws.onmessage = function (event) { var messages = document.getElementsByTagName('ul')[0], message = document.createElement('li'), content = document.createTextNode(event.data); message.appendChild(content); messages.appendChild(message); }; document.body.appendChild(messages); </script> </body> </html> Tarea Ejecuta el servidor en tu m\u00e1quina virtual y, tras guardar el c\u00f3digo fuente del cliente en un fichero cliente.html , \u00e1brelo con un navegador. Observa como la p\u00e1gina se actualiza a medida que recibe mensajes a trav\u00e9s del socket. Si quieres, puedes observar el intercambio de mensajes. \u00bfQu\u00e9 ocurre si, en otra pesta\u00f1a, vuelves a abrir la p\u00e1gina cliente? Un ejemplo m\u00e1s complejo: sincronizaci\u00f3n entre m\u00faltiples clientes ( server2.py , client.html ) Un servidor websocket puede recibir eventos desde distintos clientes, procesarlos para, por ejemplo, mantener actualizado un estado a nivel de aplicaci\u00f3n, y sincronizar dicho estado entre todos los clientes conectados, envi\u00e1ndoles mensajes de forma as\u00edncrona a trav\u00e9s del socket bidireccional, a modo de \"notificaciones push \". A continuaci\u00f3n, se muestra el c\u00f3digo de un servidor que mantiene dos tipos de informaci\u00f3n de estado siempre actualizada: el valor de un contador ( STATE ), que puede ser modificado por los clientes conectados sumando o restando uno a su valor a trav\u00e9s de mensajes enviados por el socket ; y el n\u00famero de clientes conectados ( USERS ). #!/usr/bin/env python import asyncio import json import logging import websockets logging.basicConfig() STATE = {\"value\": 0} USERS = set() def state_event(): return json.dumps({\"type\": \"state\", **STATE}) def users_event(): return json.dumps({\"type\": \"users\", \"count\": len(USERS)}) async def notify_state(): if USERS: # asyncio.wait doesn't accept an empty list message = state_event() await asyncio.wait([user.send(message) for user in USERS]) async def notify_users(): if USERS: # asyncio.wait doesn't accept an empty list message = users_event() await asyncio.wait([user.send(message) for user in USERS]) async def register(websocket): USERS.add(websocket) await notify_users() async def unregister(websocket): USERS.remove(websocket) await notify_users() async def counter(websocket, path): # register(websocket) sends user_event() to websocket await register(websocket) try: await websocket.send(state_event()) async for message in websocket: data = json.loads(message) if data[\"action\"] == \"minus\": STATE[\"value\"] -= 1 await notify_state() elif data[\"action\"] == \"plus\": STATE[\"value\"] += 1 await notify_state() else: logging.error(\"unsupported event: {}\", data) finally: await unregister(websocket) start_server = websockets.serve(counter, \"localhost\", 6789) asyncio.get_event_loop().run_until_complete(start_server) asyncio.get_event_loop().run_forever() Observa el c\u00f3digo del servidor. El manejador counter procesa cada conexi\u00f3n entrante, registrando a su entrada a un nuevo cliente en el sistema ( register ) y desregistr\u00e1ndolo antes de finalizar ( unregister ). Ante cada registro o desregistro, se notifica a los usuarios este hecho, enviando a cada cliente un peque\u00f1o texto en formato JSON cuyo contenido es: {\"type\": \"users\", \"count\": usuarios} Es decir, un mensaje con dos campos (veremos JSON en la pr\u00f3xima pr\u00e1ctica): campo type , con valor fijo users , y campo count , con un valor entero que indica el n\u00famero de clientes conectados. A continuaci\u00f3n, para cada mensaje recibido a trav\u00e9s del socket, \u00e9ste se procesa, esperando tambi\u00e9n un fichero JSON con la acci\u00f3n que el cliente solicita (sumar o restar 1 al contador), por ejemplo: {\"action\": \"minus\"} o {\"action\": \"plus\"} En funci\u00f3n de la acci\u00f3n solicitada, el servidor actualiza el valor de STATE , y env\u00eda (rutina notify_state ) dicho valor actualizado a TODOS los clientes conectados mediante un peque\u00f1o mensaje de texto en formato JSON: {\"type\": \"state\", \"value\": VALOR} La parte cliente sigue la misma filosof\u00eda, utilizando de nuevo el navegador como plataforma para visualizar la interacci\u00f3n con el cliente. El c\u00f3digo HTML que puedes abrir en tu navegador es el siguiente: <!DOCTYPE html> <html> <head> <title>WebSocket demo</title> <style type=\"text/css\"> body { font-family: \"Courier New\", sans-serif; text-align: center; } .buttons { font-size: 4em; display: flex; justify-content: center; } .button, .value { line-height: 1; padding: 2rem; margin: 2rem; border: medium solid; min-height: 1em; min-width: 1em; } .button { cursor: pointer; user-select: none; } .minus { color: red; } .plus { color: green; } .value { min-width: 2em; } .state { font-size: 2em; } </style> </head> <body> <div class=\"buttons\"> <div class=\"minus button\">-</div> <div class=\"value\">?</div> <div class=\"plus button\">+</div> </div> <div class=\"state\"> <span class=\"users\">?</span> online </div> <script> var minus = document.querySelector('.minus'), plus = document.querySelector('.plus'), value = document.querySelector('.value'), users = document.querySelector('.users'), websocket = new WebSocket(\"ws://127.0.0.1:6789/\"); minus.onclick = function (event) { websocket.send(JSON.stringify({action: 'minus'})); } plus.onclick = function (event) { websocket.send(JSON.stringify({action: 'plus'})); } websocket.onmessage = function (event) { data = JSON.parse(event.data); switch (data.type) { case 'state': value.textContent = data.value; break; case 'users': users.textContent = ( data.count.toString() + \" user\" + (data.count == 1 ? \"\" : \"s\")); break; default: console.error( \"unsupported event\", data); } }; </script> </body> </html> Observa c\u00f3mo el script env\u00eda mensajes de suma o resta en formato JSON acorde al esperado por el servidor, y procesa los mensajes de entrada actualizando la informaci\u00f3n mostrada en pantalla recibida acerca del valor del contador actualizado y n\u00famero de usuarios. Tarea Ejecuta el servidor en tu m\u00e1quina virtual, y m\u00faltiples clientes en distintas ventanas/pesta\u00f1as del navegador (con ventanas lo ver\u00e1s mejor). Interact\u00faa desde un cliente aumentando o reduciendo el valor del contador, y observa c\u00f3mo dicho valor es actualizado (a trav\u00e9s del servidor) en el resto de clientes abiertos. Conecta y desconecta nuevos clientes y observa tambi\u00e9n como el campo correspondiente en la p\u00e1gina web se actualiza correctamente. Si quieres, puedes analizar el tr\u00e1fico Websockets generado v\u00eda Wireshark. Websockets en el ESP32 El soporte a nivel de cliente para el protocolo websockets est\u00e1 integrado en ESP-IDF a trav\u00e9sd el componente websocket client , cuya documentaci\u00f3n puede consultarse a trav\u00e9s de este enlace . El componente websocket client ofrece soporte para el protocolo websocket sobre TCP y tambi\u00e9n, opcionalmente, sobre TLS. Como todos los componentes en ESP-IDF, el componente websocket emite eventos que pueden ser tratados por parte de la aplicaci\u00f3n, entre los cuales destacan: WEBSOCKET_EVENT_CONNECTED : se emite una vez el cliente se ha conectado al servidor, sin intercambio de datos. WEBSOCKET_EVENT_DISCONNECTED : se emite en el instante de la desconexi\u00f3n entre cliente y servidor. WEBSOCKET_EVENT_DATA : se emite al recibir datos desde el servidor. Este \u00faltimo evento es de especial inter\u00e9s para nosotros, ya que accarrea la construcci\u00f3n de una estructura de tipo esp_websocket_event_data_t en la que se almacena el mensaje recibido desde el servidor (tanto en sus campos de control como de datos). Algunos campos de inter\u00e9s dentro de la estructura son: const char * data_ptr : puntero a los datos recibidos ( payload ). data_len : tama\u00f1o (en bytes) de los datos recibidos. op_code : c\u00f3digo de operaci\u00f3n asociado al mensaje recibido. La documentaci\u00f3n del componente ofrece informaci\u00f3n sobre campos adicionales, de menor inter\u00e9s para nosotros. Observemos el c\u00f3digo de una posible funci\u00f3n manejadora de eventos del componente websocket : static void websocket_event_handler(void *handler_args, esp_event_base_t base, int32_t event_id, void *event_data) { esp_websocket_event_data_t *data = (esp_websocket_event_data_t *)event_data; switch (event_id) { case WEBSOCKET_EVENT_CONNECTED: ESP_LOGI(TAG, \"WEBSOCKET_EVENT_CONNECTED\"); break; case WEBSOCKET_EVENT_DISCONNECTED: ESP_LOGI(TAG, \"WEBSOCKET_EVENT_DISCONNECTED\"); break; case WEBSOCKET_EVENT_DATA: ESP_LOGI(TAG, \"WEBSOCKET_EVENT_DATA\"); ESP_LOGI(TAG, \"Received opcode=%d\", data->op_code); if (data->op_code == 0x08 && data->data_len == 2) { ESP_LOGW(TAG, \"Received closed message with code=%d\", 256*data->data_ptr[0] + data->data_ptr[1]); } else { ESP_LOGW(TAG, \"Received=%.*s\", data->data_len, (char *)data->data_ptr); } ESP_LOGW(TAG, \"Total payload length=%d, data_len=%d, current payload offset=%d\\r\\n\", data->payload_len, data->data_len, data->payload_offset); xTimerReset(shutdown_signal_timer, portMAX_DELAY); break; case WEBSOCKET_EVENT_ERROR: ESP_LOGI(TAG, \"WEBSOCKET_EVENT_ERROR\"); break; } } Observa el c\u00f3digo. En funci\u00f3n del par\u00e1metro event_id , el manejador toma un camino de ejecuci\u00f3n u otro. Centr\u00e9monos en la recepci\u00f3n de un evento de tipo \u1e80EBSOCKET_EVENT_DATA ; a trav\u00e9s de los distintos campos de la estructura de informaci\u00f3n recibida ( event_data ), es posible: Obtener y mostrar el c\u00f3digo de la operaci\u00f3n ( op_code ). Mostrar el contenido del mensaje recibido ( data_ptr ). Mostrar el tama\u00f1o del mensaje recibido ( data_len y payload_len ). Preguntas \u00bfCu\u00e1l es la diferencia entre los campos data_len y payload_len ? \u00bfPor qu\u00e9 el programa realiza un tratamiento especial cuando op_code == 8 ? Dada la anterior funci\u00f3n manejadora, la inicializaci\u00f3n de un cliente websockets en el ESP32 es sencilla, y se resume en los siguientes pasos: Configuraci\u00f3n de URI (host + puerto) esp_websocket_client_config_t websocket_cfg = {}; websocket_cfg.uri = \"ws://localhost:123\"; esp_websocket_client_handle_t client = esp_websocket_client_init(&websocket_cfg); Asociaci\u00f3n de manejador a eventos Websocket esp_websocket_register_events(client, WEBSOCKET_EVENT_ANY, websocket_event_handler, (void *)client); Inicializaci\u00f3n del cliente esp_websocket_client_start(client); A partir de este punto, la interacci\u00f3n con el servidor se puede realizar en base a funciones de env\u00edo de texto o binario: int esp_websocket_client_send(esp_websocket_client_handle_tclient, const char *data, int len, TickType_t timeout) esp_websocket_client_send_bin(esp_websocket_client_handle_tclient, const char *data, int len, TickType_t timeout) No existen funciones de recepci\u00f3n, ya que \u00e9sta es impl\u00edcita y se notifica v\u00eda eventos. Ejemplo b\u00e1sico: cliente echo Veremos en primer lugar un ejemplo completo de cliente ejecutado sobre el ESP32. En este punto, configura, compila, flashea y monitoriza el ejemplo examples/protocols/websockets . El ejemplo simplemente conecta con un servidor echo Websockets en la nube (disponible en ws://websockets.org ). Dicho servidor simplemente espera, por parte de cada cliente, el env\u00edo a trav\u00e9s de la conexi\u00f3n de una cadena, respondiendo con la misma cadena en sentido contrario, siempre usando el mismo socket . Tarea Observa el c\u00f3digo del ejemplo y su ejecuci\u00f3n. Determina cu\u00e1l es el funcionamiento del ejemplo, y comprueba que los fragmentos de c\u00f3digo anteriores tienen su funci\u00f3n dentro del c\u00f3digo completo. \u00bfC\u00f3mo implementa el programa la espera limitada en tiempo si no se recibe ning\u00fan paquete tras cierto per\u00edodo? Ejercicio entregable: Comunicaci\u00f3n as\u00edncrona El objetivo del ejercicio entregable es conseguir que el ESP32 se comunique con el servidor Python que se prob\u00f3 en la secci\u00f3n anterior, y que implementaba comunicaci\u00f3n bidireccional para mantener y difundir el estado interno (contador y n\u00famero de clientes conectados) entre todos los clientes conectados. Para ello, se pide modificar el ejemplo de cliente echo para que: El cliente conecte con el servidor Python especificando su IP y puerto. El cliente sea cien por cien pasivo, es decir, no env\u00ede nunca mensajes al servidor. La funci\u00f3n de manejo de paquetes recibidos trate de forma especial el tipo de mensajes esperado por parte del servidor. Recuerda que se pueden recibir dos tipos de mensajes de texto: Mensajes de estado: {\"type\": \"users\", \"count\": usuarios} Mensajes de usuarios: {\"type\": \"state\", \"value\": VALOR} Observa que ambos mensajes, pese a ser recibidos como texto, corresponden con una representaci\u00f3n JSON de la informaci\u00f3n. Para tratarla desde ESP-IDF, puedes hacer uso del componente cJSON del framework . Por ejemplo, para tratar un mensaje de entrada de tipo \"state\", podr\u00edamos a\u00f1adir la siguiente secuencia de c\u00f3digo en nuestro manejador: #include \"cJSON.h\" // ... if( data->op_code == 1 ) { // Text frame only. cJSON *root = cJSON_Parse((char*)data->data_ptr); char *type = cJSON_GetObjectItem(root,\"type\")->valuestring; ESP_LOGI(TAG, \"type=%s\",type); int field = 0; if( strcmp( type, \"state\" ) == 0) { field = cJSON_GetObjectItem(root,\"value\")->valueint; ESP_LOGI(TAG, \"value=%d\",field); } } Tarea entregable Modifica el firmware de ejemplo websockets para que pueda comunicarse en modo lectura con el servidor Python que mantiene y publicita estado, cuyo c\u00f3digo se te proporciona. El programa ESP-IDF, al menos, mostar\u00e1 por pantalla un mensaje con los datos asociados cada vez que se reciban paquetes de tipo texto ( state o users ). Tambi\u00e9n mostrar\u00e1 un mensaje cada vez que el servidor env\u00ede un mensaje de tipo ping o pong (para ello, consulta el RFC que describe el protocolo para determinar el opcode asociado). Para comprobar el funcionamiento de la soluci\u00f3n, arranca el servidor y al menos dos clientes web. Cuando arranques el ESP32, ambos deber\u00e1n incrementar el n\u00famero de clientes reportado, en respuesta al mensaje enviado por el servidor. Cuando cualquiera de los clientes web incremente el valor del contador, el ESP32 recibir\u00e1 un mensaje con el valor actualizado, del mismo modo que cuando cierres uno de los navegadores web. Tarea opcional Modifica el c\u00f3digo para que el cliente, peri\u00f3dicamente, env\u00ede un mensaje de petici\u00f3n de suma o resta siguiendo las especificaciones y tipos de mensaje que se explicaron anteriormente.","title":"Pr\u00e1ctica 4"},{"location":"RPI-II/P4/#practica-4-protocolos-basicos-de-capa-de-aplicacion-websockets","text":"","title":"Pr\u00e1ctica 4. Protocolos b\u00e1sicos de capa de aplicaci\u00f3n. Websockets"},{"location":"RPI-II/P4/#objetivos","text":"Conocer el m\u00f3dulo Python websockets para desarrollar sistemas b\u00e1sicos cliente/servidor utilizando websockets . Estudar el intercambio de mensajes entre un cliente y un servidor websockets , tanto en la fase de handshake como de intercambio de datos. Conseguir interactuar con un servidor websockets utilizando un navegador web como cliente. Estudiar mecanismos de mantenimiento y publicaci\u00f3n de estado a clientes conectados, t\u00edpicos en un entorno IoT. Estudiar el componente websockets client en ESP-IDF, y desarrollar un firmware b\u00e1sico que interact\u00fae con un servidor Python. Introducir la gesti\u00f3n de objetos JSON en ESP-IDF. Los ficheros necesarios para completar la pr\u00e1ctica pueden descargarse aqu\u00ed .","title":"Objetivos"},{"location":"RPI-II/P4/#ejemplo-basico-sistema-clienteservidor-usando-websockets-en-python-client1py-server1py","text":"En primer lugar, introducimos el uso del m\u00f3dulo Python websockets , que proporciona toda la funcionalidad necesaria para desarrollar sistemas cliente/servidor utilizando websockets . El m\u00f3dulo websockets proporciona la funcionalidad necesaria tanto a nivel de cliente como de servidor para implementar sistemas basados en dicho protocolo. Concretamente, las funciones de alto nivel que proporciona est\u00e1n basadas en una API de bajo nivel que implementa las dos fases principales del protocolo websockets : Handshake de apertura de comunicaci\u00f3n, en forma de peticiones HTTP upgrade . Transferencia de datos, y finalizaci\u00f3n de la comunicaci\u00f3n con un handshake de cierre de conexi\u00f3n. La primera fase est\u00e1 dise\u00f1ada para integrarse con software HTTP (cliente y servidor) existente, y proporciona una implementaci\u00f3n m\u00ednima para construir, parsear y validar peticiones y respuestas HTTP. La segunda fase implementa el n\u00facleo del protocolo websockets , y proporciona una implementaci\u00f3n completa basada en el m\u00f3dulo asyncio ) de Python. Para utilizar el m\u00f3dulo websockets de Python, primero lo instalaremos v\u00eda pip : pip install websockets Un ejemplo b\u00e1sico se puede basar en un cliente que env\u00eda una cadena a un servidor, y queda a la espera de recibir un mensaje de respuesta por parte de \u00e9ste, tal y como hemos visto en otras pr\u00e1cticas. Desarrollar la parte servidora para dicha aplicaci\u00f3n resulta sencillo. Observa el siguiente c\u00f3digo: #!/usr/bin/env python import asyncio import websockets async def hello(websocket, path): name = await websocket.recv() print(f\"< {name}\") greeting = f\"Hello {name}!\" await websocket.send(greeting) print(f\"> {greeting}\") start_server = websockets.serve(hello, \"localhost\", 8765) asyncio.get_event_loop().run_until_complete(start_server) asyncio.get_event_loop().run_forever() El paradigma de programaci\u00f3n utilizado en este ejemplo (basado en el m\u00f3dulo asyncio ) queda fuera del prop\u00f3sito de la pr\u00e1ctica (aunque se invita al alumno a estudiarlo, ya que aporta importantes ventajas a nivel de sencillez de desarrollo en aplicaciones de red). En cualquier caso, el anterior servidor ejecuta una (co)rutina manejadora hello para cada conexi\u00f3n websocket establecida; adem\u00e1s, se cierra dicha conexi\u00f3n cuando dicha (co)rutina finaliza. Concretamente, las funciones de inter\u00e9s en este caso son: await websockets.server.serve(ws_handler, host=None, port=None, # ... Crea, incializa y devuelve un objeto servidor Websocket asociado al host y puerto seleccionados. En un contexto de programaci\u00f3n as\u00edncrona (como el del ejemplo, el servidor finaliza autom\u00e1ticamente al salir de dicho contexto). Cuando un cliente conecta al host y puerto espec\u00edficados, se acepta la conexi\u00f3n, que es tratada por la (co)rutina ws_handler (en el ejemplo, hello ). Antes de delegar la conexi\u00f3n a la (co)rutina, se lleva a cabo el handshake de apertura websocket . await recv() Recibe el siguiente mensaje, devolviendo una cadena si el frame recibido es de texto, o un array de bytes si es binario. await send(message) Env\u00eda un mensaje. message puede er una cadena, o un array de bytes. En el primer caso, se env\u00eda un frame de texto; en el segundo caso, un frame binario. A continuaci\u00f3n se muestra un ejemplo de cliente websocket para interactuar con el anterior servidor: #!/usr/bin/env python import asyncio import websockets async def hello(): uri = \"ws://localhost:8765\" async with websockets.connect(uri) as websocket: name = input(\"What's your name? \") await websocket.send(name) print(f\"> {name}\") greeting = await websocket.recv() print(f\"< {greeting}\") asyncio.get_event_loop().run_until_complete(hello()) El c\u00f3digo en este caso es sencillo, ya que \u00fanicamente se basa en la planificaci\u00f3n (ejecuci\u00f3n) de una (co)rutina llamada hello , que establece una conexi\u00f3n con un servidor websocket v\u00eda connect , enviando y recibiendo un par de mensajes. await websockets.client.connect(uri, # ... Conecta con un servidor websocket en la URI determinada. La conexi\u00f3n se cierra al abandonar el contexto as\u00edncrono (es decir, la (co)rutina hello ). Tarea entregable Ejecuta el servidor en una terminal de tu m\u00e1quina virtual, y a continuaci\u00f3n el cliente en otra. Analiza el tr\u00e1fico intercambiado y responde a las siguientes preguntas: \u00bfEn qu\u00e9 protocolo de capa de transporte se basa la comunicaci\u00f3n v\u00eda Websockets? En la fase de handshake , \u00bfqu\u00e9 peticiones HTTP se intercambian? Analiza sus emisores y destinatarios, e investiga el cometido principal de cada uno de los campos de sus encabezados (f\u00edjate principalmente en el campo Upgrade y los campos espec\u00edficos para Websockets). En la fase de intercambio de datos, \u00bfqu\u00e9 opcode se especifica en el encabezado de cada paquete? \u00bfPor qu\u00e9? \u00bfSe env\u00edan los datos en claro o cifrados? \u00bfQu\u00e9 opcode se a\u00f1ade en los mensajes de cierre de conexi\u00f3n?","title":"Ejemplo b\u00e1sico: sistema cliente/servidor usando Websockets en Python (\u00b4client1.py, server1.py`)"},{"location":"RPI-II/P4/#interactuando-con-un-navegador-web-client_for_webhtml-server_for_webpy","text":"Aunque fuera del inter\u00e9s de esta pr\u00e1ctica, es conveniente observar una de las ventajas de websockets : el env\u00edo as\u00edncrono bidireccional de informaci\u00f3n, y observarlo a trav\u00e9s de un navegador web convencional (la mayor\u00eda de navegadores modernos soportan websockets a trav\u00e9s de scripts Javascript ). En este caso, simplemente observa la interacci\u00f3n de un servidor websocket que env\u00eda mensajes que incluyen la hora actual separados un n\u00famero aleatorio de tiempo entre ellos: #!/usr/bin/env python # WS server that sends messages at random intervals import asyncio import datetime import random import websockets async def time(websocket, path): while True: now = datetime.datetime.utcnow().isoformat() + \"Z\" await websocket.send(now) await asyncio.sleep(random.random() * 3) start_server = websockets.serve(time, \"127.0.0.1\", 5678) asyncio.get_event_loop().run_until_complete(start_server) asyncio.get_event_loop().run_forever() Con un cliente (una p\u00e1gina HTML) que establece la conexi\u00f3n v\u00eda websockets , y muestra en la misma un elemento de texto con la marca de tiempo recibida tras la recepci\u00f3n de cada mensaje: <!DOCTYPE html> <html> <head> <title>WebSocket demo</title> </head> <body> <script> var ws = new WebSocket(\"ws://127.0.0.1:5678/\"), messages = document.createElement('ul'); ws.onmessage = function (event) { var messages = document.getElementsByTagName('ul')[0], message = document.createElement('li'), content = document.createTextNode(event.data); message.appendChild(content); messages.appendChild(message); }; document.body.appendChild(messages); </script> </body> </html> Tarea Ejecuta el servidor en tu m\u00e1quina virtual y, tras guardar el c\u00f3digo fuente del cliente en un fichero cliente.html , \u00e1brelo con un navegador. Observa como la p\u00e1gina se actualiza a medida que recibe mensajes a trav\u00e9s del socket. Si quieres, puedes observar el intercambio de mensajes. \u00bfQu\u00e9 ocurre si, en otra pesta\u00f1a, vuelves a abrir la p\u00e1gina cliente?","title":"Interactuando con un navegador web (client_for_web.html, server_for_web.py)"},{"location":"RPI-II/P4/#un-ejemplo-mas-complejo-sincronizacion-entre-multiples-clientes-server2py-clienthtml","text":"Un servidor websocket puede recibir eventos desde distintos clientes, procesarlos para, por ejemplo, mantener actualizado un estado a nivel de aplicaci\u00f3n, y sincronizar dicho estado entre todos los clientes conectados, envi\u00e1ndoles mensajes de forma as\u00edncrona a trav\u00e9s del socket bidireccional, a modo de \"notificaciones push \". A continuaci\u00f3n, se muestra el c\u00f3digo de un servidor que mantiene dos tipos de informaci\u00f3n de estado siempre actualizada: el valor de un contador ( STATE ), que puede ser modificado por los clientes conectados sumando o restando uno a su valor a trav\u00e9s de mensajes enviados por el socket ; y el n\u00famero de clientes conectados ( USERS ). #!/usr/bin/env python import asyncio import json import logging import websockets logging.basicConfig() STATE = {\"value\": 0} USERS = set() def state_event(): return json.dumps({\"type\": \"state\", **STATE}) def users_event(): return json.dumps({\"type\": \"users\", \"count\": len(USERS)}) async def notify_state(): if USERS: # asyncio.wait doesn't accept an empty list message = state_event() await asyncio.wait([user.send(message) for user in USERS]) async def notify_users(): if USERS: # asyncio.wait doesn't accept an empty list message = users_event() await asyncio.wait([user.send(message) for user in USERS]) async def register(websocket): USERS.add(websocket) await notify_users() async def unregister(websocket): USERS.remove(websocket) await notify_users() async def counter(websocket, path): # register(websocket) sends user_event() to websocket await register(websocket) try: await websocket.send(state_event()) async for message in websocket: data = json.loads(message) if data[\"action\"] == \"minus\": STATE[\"value\"] -= 1 await notify_state() elif data[\"action\"] == \"plus\": STATE[\"value\"] += 1 await notify_state() else: logging.error(\"unsupported event: {}\", data) finally: await unregister(websocket) start_server = websockets.serve(counter, \"localhost\", 6789) asyncio.get_event_loop().run_until_complete(start_server) asyncio.get_event_loop().run_forever() Observa el c\u00f3digo del servidor. El manejador counter procesa cada conexi\u00f3n entrante, registrando a su entrada a un nuevo cliente en el sistema ( register ) y desregistr\u00e1ndolo antes de finalizar ( unregister ). Ante cada registro o desregistro, se notifica a los usuarios este hecho, enviando a cada cliente un peque\u00f1o texto en formato JSON cuyo contenido es: {\"type\": \"users\", \"count\": usuarios} Es decir, un mensaje con dos campos (veremos JSON en la pr\u00f3xima pr\u00e1ctica): campo type , con valor fijo users , y campo count , con un valor entero que indica el n\u00famero de clientes conectados. A continuaci\u00f3n, para cada mensaje recibido a trav\u00e9s del socket, \u00e9ste se procesa, esperando tambi\u00e9n un fichero JSON con la acci\u00f3n que el cliente solicita (sumar o restar 1 al contador), por ejemplo: {\"action\": \"minus\"} o {\"action\": \"plus\"} En funci\u00f3n de la acci\u00f3n solicitada, el servidor actualiza el valor de STATE , y env\u00eda (rutina notify_state ) dicho valor actualizado a TODOS los clientes conectados mediante un peque\u00f1o mensaje de texto en formato JSON: {\"type\": \"state\", \"value\": VALOR} La parte cliente sigue la misma filosof\u00eda, utilizando de nuevo el navegador como plataforma para visualizar la interacci\u00f3n con el cliente. El c\u00f3digo HTML que puedes abrir en tu navegador es el siguiente: <!DOCTYPE html> <html> <head> <title>WebSocket demo</title> <style type=\"text/css\"> body { font-family: \"Courier New\", sans-serif; text-align: center; } .buttons { font-size: 4em; display: flex; justify-content: center; } .button, .value { line-height: 1; padding: 2rem; margin: 2rem; border: medium solid; min-height: 1em; min-width: 1em; } .button { cursor: pointer; user-select: none; } .minus { color: red; } .plus { color: green; } .value { min-width: 2em; } .state { font-size: 2em; } </style> </head> <body> <div class=\"buttons\"> <div class=\"minus button\">-</div> <div class=\"value\">?</div> <div class=\"plus button\">+</div> </div> <div class=\"state\"> <span class=\"users\">?</span> online </div> <script> var minus = document.querySelector('.minus'), plus = document.querySelector('.plus'), value = document.querySelector('.value'), users = document.querySelector('.users'), websocket = new WebSocket(\"ws://127.0.0.1:6789/\"); minus.onclick = function (event) { websocket.send(JSON.stringify({action: 'minus'})); } plus.onclick = function (event) { websocket.send(JSON.stringify({action: 'plus'})); } websocket.onmessage = function (event) { data = JSON.parse(event.data); switch (data.type) { case 'state': value.textContent = data.value; break; case 'users': users.textContent = ( data.count.toString() + \" user\" + (data.count == 1 ? \"\" : \"s\")); break; default: console.error( \"unsupported event\", data); } }; </script> </body> </html> Observa c\u00f3mo el script env\u00eda mensajes de suma o resta en formato JSON acorde al esperado por el servidor, y procesa los mensajes de entrada actualizando la informaci\u00f3n mostrada en pantalla recibida acerca del valor del contador actualizado y n\u00famero de usuarios. Tarea Ejecuta el servidor en tu m\u00e1quina virtual, y m\u00faltiples clientes en distintas ventanas/pesta\u00f1as del navegador (con ventanas lo ver\u00e1s mejor). Interact\u00faa desde un cliente aumentando o reduciendo el valor del contador, y observa c\u00f3mo dicho valor es actualizado (a trav\u00e9s del servidor) en el resto de clientes abiertos. Conecta y desconecta nuevos clientes y observa tambi\u00e9n como el campo correspondiente en la p\u00e1gina web se actualiza correctamente. Si quieres, puedes analizar el tr\u00e1fico Websockets generado v\u00eda Wireshark.","title":"Un ejemplo m\u00e1s complejo: sincronizaci\u00f3n entre m\u00faltiples clientes (server2.py, client.html)"},{"location":"RPI-II/P4/#websockets-en-el-esp32","text":"El soporte a nivel de cliente para el protocolo websockets est\u00e1 integrado en ESP-IDF a trav\u00e9sd el componente websocket client , cuya documentaci\u00f3n puede consultarse a trav\u00e9s de este enlace . El componente websocket client ofrece soporte para el protocolo websocket sobre TCP y tambi\u00e9n, opcionalmente, sobre TLS. Como todos los componentes en ESP-IDF, el componente websocket emite eventos que pueden ser tratados por parte de la aplicaci\u00f3n, entre los cuales destacan: WEBSOCKET_EVENT_CONNECTED : se emite una vez el cliente se ha conectado al servidor, sin intercambio de datos. WEBSOCKET_EVENT_DISCONNECTED : se emite en el instante de la desconexi\u00f3n entre cliente y servidor. WEBSOCKET_EVENT_DATA : se emite al recibir datos desde el servidor. Este \u00faltimo evento es de especial inter\u00e9s para nosotros, ya que accarrea la construcci\u00f3n de una estructura de tipo esp_websocket_event_data_t en la que se almacena el mensaje recibido desde el servidor (tanto en sus campos de control como de datos). Algunos campos de inter\u00e9s dentro de la estructura son: const char * data_ptr : puntero a los datos recibidos ( payload ). data_len : tama\u00f1o (en bytes) de los datos recibidos. op_code : c\u00f3digo de operaci\u00f3n asociado al mensaje recibido. La documentaci\u00f3n del componente ofrece informaci\u00f3n sobre campos adicionales, de menor inter\u00e9s para nosotros. Observemos el c\u00f3digo de una posible funci\u00f3n manejadora de eventos del componente websocket : static void websocket_event_handler(void *handler_args, esp_event_base_t base, int32_t event_id, void *event_data) { esp_websocket_event_data_t *data = (esp_websocket_event_data_t *)event_data; switch (event_id) { case WEBSOCKET_EVENT_CONNECTED: ESP_LOGI(TAG, \"WEBSOCKET_EVENT_CONNECTED\"); break; case WEBSOCKET_EVENT_DISCONNECTED: ESP_LOGI(TAG, \"WEBSOCKET_EVENT_DISCONNECTED\"); break; case WEBSOCKET_EVENT_DATA: ESP_LOGI(TAG, \"WEBSOCKET_EVENT_DATA\"); ESP_LOGI(TAG, \"Received opcode=%d\", data->op_code); if (data->op_code == 0x08 && data->data_len == 2) { ESP_LOGW(TAG, \"Received closed message with code=%d\", 256*data->data_ptr[0] + data->data_ptr[1]); } else { ESP_LOGW(TAG, \"Received=%.*s\", data->data_len, (char *)data->data_ptr); } ESP_LOGW(TAG, \"Total payload length=%d, data_len=%d, current payload offset=%d\\r\\n\", data->payload_len, data->data_len, data->payload_offset); xTimerReset(shutdown_signal_timer, portMAX_DELAY); break; case WEBSOCKET_EVENT_ERROR: ESP_LOGI(TAG, \"WEBSOCKET_EVENT_ERROR\"); break; } } Observa el c\u00f3digo. En funci\u00f3n del par\u00e1metro event_id , el manejador toma un camino de ejecuci\u00f3n u otro. Centr\u00e9monos en la recepci\u00f3n de un evento de tipo \u1e80EBSOCKET_EVENT_DATA ; a trav\u00e9s de los distintos campos de la estructura de informaci\u00f3n recibida ( event_data ), es posible: Obtener y mostrar el c\u00f3digo de la operaci\u00f3n ( op_code ). Mostrar el contenido del mensaje recibido ( data_ptr ). Mostrar el tama\u00f1o del mensaje recibido ( data_len y payload_len ). Preguntas \u00bfCu\u00e1l es la diferencia entre los campos data_len y payload_len ? \u00bfPor qu\u00e9 el programa realiza un tratamiento especial cuando op_code == 8 ? Dada la anterior funci\u00f3n manejadora, la inicializaci\u00f3n de un cliente websockets en el ESP32 es sencilla, y se resume en los siguientes pasos: Configuraci\u00f3n de URI (host + puerto) esp_websocket_client_config_t websocket_cfg = {}; websocket_cfg.uri = \"ws://localhost:123\"; esp_websocket_client_handle_t client = esp_websocket_client_init(&websocket_cfg); Asociaci\u00f3n de manejador a eventos Websocket esp_websocket_register_events(client, WEBSOCKET_EVENT_ANY, websocket_event_handler, (void *)client); Inicializaci\u00f3n del cliente esp_websocket_client_start(client); A partir de este punto, la interacci\u00f3n con el servidor se puede realizar en base a funciones de env\u00edo de texto o binario: int esp_websocket_client_send(esp_websocket_client_handle_tclient, const char *data, int len, TickType_t timeout) esp_websocket_client_send_bin(esp_websocket_client_handle_tclient, const char *data, int len, TickType_t timeout) No existen funciones de recepci\u00f3n, ya que \u00e9sta es impl\u00edcita y se notifica v\u00eda eventos.","title":"Websockets en el ESP32"},{"location":"RPI-II/P4/#ejemplo-basico-cliente-echo","text":"Veremos en primer lugar un ejemplo completo de cliente ejecutado sobre el ESP32. En este punto, configura, compila, flashea y monitoriza el ejemplo examples/protocols/websockets . El ejemplo simplemente conecta con un servidor echo Websockets en la nube (disponible en ws://websockets.org ). Dicho servidor simplemente espera, por parte de cada cliente, el env\u00edo a trav\u00e9s de la conexi\u00f3n de una cadena, respondiendo con la misma cadena en sentido contrario, siempre usando el mismo socket . Tarea Observa el c\u00f3digo del ejemplo y su ejecuci\u00f3n. Determina cu\u00e1l es el funcionamiento del ejemplo, y comprueba que los fragmentos de c\u00f3digo anteriores tienen su funci\u00f3n dentro del c\u00f3digo completo. \u00bfC\u00f3mo implementa el programa la espera limitada en tiempo si no se recibe ning\u00fan paquete tras cierto per\u00edodo?","title":"Ejemplo b\u00e1sico: cliente echo"},{"location":"RPI-II/P4/#ejercicio-entregable-comunicacion-asincrona","text":"El objetivo del ejercicio entregable es conseguir que el ESP32 se comunique con el servidor Python que se prob\u00f3 en la secci\u00f3n anterior, y que implementaba comunicaci\u00f3n bidireccional para mantener y difundir el estado interno (contador y n\u00famero de clientes conectados) entre todos los clientes conectados. Para ello, se pide modificar el ejemplo de cliente echo para que: El cliente conecte con el servidor Python especificando su IP y puerto. El cliente sea cien por cien pasivo, es decir, no env\u00ede nunca mensajes al servidor. La funci\u00f3n de manejo de paquetes recibidos trate de forma especial el tipo de mensajes esperado por parte del servidor. Recuerda que se pueden recibir dos tipos de mensajes de texto: Mensajes de estado: {\"type\": \"users\", \"count\": usuarios} Mensajes de usuarios: {\"type\": \"state\", \"value\": VALOR} Observa que ambos mensajes, pese a ser recibidos como texto, corresponden con una representaci\u00f3n JSON de la informaci\u00f3n. Para tratarla desde ESP-IDF, puedes hacer uso del componente cJSON del framework . Por ejemplo, para tratar un mensaje de entrada de tipo \"state\", podr\u00edamos a\u00f1adir la siguiente secuencia de c\u00f3digo en nuestro manejador: #include \"cJSON.h\" // ... if( data->op_code == 1 ) { // Text frame only. cJSON *root = cJSON_Parse((char*)data->data_ptr); char *type = cJSON_GetObjectItem(root,\"type\")->valuestring; ESP_LOGI(TAG, \"type=%s\",type); int field = 0; if( strcmp( type, \"state\" ) == 0) { field = cJSON_GetObjectItem(root,\"value\")->valueint; ESP_LOGI(TAG, \"value=%d\",field); } } Tarea entregable Modifica el firmware de ejemplo websockets para que pueda comunicarse en modo lectura con el servidor Python que mantiene y publicita estado, cuyo c\u00f3digo se te proporciona. El programa ESP-IDF, al menos, mostar\u00e1 por pantalla un mensaje con los datos asociados cada vez que se reciban paquetes de tipo texto ( state o users ). Tambi\u00e9n mostrar\u00e1 un mensaje cada vez que el servidor env\u00ede un mensaje de tipo ping o pong (para ello, consulta el RFC que describe el protocolo para determinar el opcode asociado). Para comprobar el funcionamiento de la soluci\u00f3n, arranca el servidor y al menos dos clientes web. Cuando arranques el ESP32, ambos deber\u00e1n incrementar el n\u00famero de clientes reportado, en respuesta al mensaje enviado por el servidor. Cuando cualquiera de los clientes web incremente el valor del contador, el ESP32 recibir\u00e1 un mensaje con el valor actualizado, del mismo modo que cuando cierres uno de los navegadores web. Tarea opcional Modifica el c\u00f3digo para que el cliente, peri\u00f3dicamente, env\u00ede un mensaje de petici\u00f3n de suma o resta siguiendo las especificaciones y tipos de mensaje que se explicaron anteriormente.","title":"Ejercicio entregable: Comunicaci\u00f3n as\u00edncrona"},{"location":"RPI-II/P5/","text":"Pr\u00e1ctica 5. Servidores REST y representaci\u00f3n de la informaci\u00f3n. JSON y CBOR Objetivos Entender los mecanismos ofrecidos por ESP-IDF para la creaci\u00f3n de un servidor REST HTTP. Implementar, a trav\u00e9s de los mecanismos ofrecidos por ESP-IDF, una API REST extendida en el ESP32. Entender los conceptos b\u00e1sicos de representaci\u00f3n de datos a trav\u00e9s de JSON. Implementar, a trav\u00e9s de la biblioteca cJSON , un tipo de mensaje personalizado para los intercambios de datos entre cliente y servidor. Entender los conceptos b\u00e1sicos de representaci\u00f3n de datos a trav\u00e9s de CBOR, y evaluar sus ventajas con respecto a JSON. Implementar, a trav\u00e9s de la biblioteca tinycbor , un tipo de mensaje personalizado para los intercambios de datos entre cliente y servidor, comparando los tama\u00f1os de payload con respecto al intercambio JSON. Desarrollo de un servidor REST en ESP-IDF En la primera parte de la pr\u00e1ctica, veremos c\u00f3mo desarrollar, utilizando las funcionalidades ofrecidas por ESP-IDF, un servidor HTTP que exponga una API REST mediante la cual ser\u00e1 posible interactuar, en modos lectura y escritura, con un servidor (en nuestro caso, un dispositivo ESP32). Concretamente, trabajaremos con el ejemplo example/protocols/http_server/rest_server de la distribuci\u00f3n de IDF (versi\u00f3n 4.1). Descripci\u00f3n de la API El ejemplo que estudiaremos construye una sencilla interfaz (API) con tres endpoints que permiten interactuar con distintas funcionalidades del ESP32. N\u00f3tese que tanto las URLs como la funcionalidad asociada a ellas es totalmente personalizable, y puede ser ampliada de acuerdo a las necesidades de nuestra aplicaci\u00f3n. La siguiente tabla resume la funcionalidad de cada endpoint , as\u00ed como posibles ejemplos de valores enviados o devueltos a/por el servidor: API M\u00e9todo Ejemplo de recurso le\u00eddo/escrito Descripci\u00f3n URL /api/v1/system/info GET { version:\"v4.0-dev\", cores:2 } Utilizado por los clientes para obtener informaci\u00f3n de la placa (versi\u00f3n, n\u00famero de cores, ...) / /api/v1/temp/raw GET { raw:22 } Utilizado por los clientes para obtener datos de temperatura desde un sensor (no disponible en el ESP32) /chart /api/v1/light/brightness POST { red:160, green:160, blue:160 } Utilizado por los clientes para escribir en la placa valores de control para controlar la luminosidad de LEDs /light Configuraci\u00f3n y compilaci\u00f3n del ejemplo En primer lugar, configura, compila y flashea el ejemplo mencionado. En este caso, las instrucciones se dividen en dos partes: compilaci\u00f3n del firmware para el ESP32, y preparaci\u00f3n de un cliente web sencillo que nos permitir\u00e1 observar la interacci\u00f3n con el mismo. Esta \u00faltima parte no es estrictamente necesaria, pero nos ayudar\u00e1 en la interacci\u00f3n con el dispositivo de forma visual hasta que veamos c\u00f3mo hacerlo a trav\u00e9s de l\u00ednea de comandos. A trav\u00e9s del men\u00fa de configuraci\u00f3n, configura un nombre para el dispositivo (por ejemplo, 'esp_home_tunombre'), e indica que el modo de despliegue ( Website deploy mode ) sea Deploy website to SPI Nor Flash . Por \u00faltimo, configura las credenciales del punto de acceso WiFi al que conectar\u00e1, siguiendo la metodolog\u00eda habitual. En segundo lugar, necesitamos instalar los componentes necesarios para desplegar el cliente web. Para ello, navega al subdirectorio front/web-demo , donde reside el c\u00f3digo fuente del cliente. Ejecuta los siguientes comandos para instalar las dependencias necesarias: sudo apt-get install npm node-vue* npm install npm run build En este punto, ya podr\u00e1s ejecutar, desde el directorio base del ejemplo, la orden de compilaci\u00f3n y flasheado: idf.py build idf.py flash idf.py monitor Interacci\u00f3n con el dispositivo v\u00eda interfaz web Si todo ha ido bien, podr\u00e1s observar en la salida de monitorizaci\u00f3n la IP proporcionada al ESP32. Abre un navegador en la m\u00e1quina virtual o en tu PC (estando conectada a la misma red que tu ESP32), navega hacia la direcci\u00f3n IP del ESP32, y deber\u00edas observar una p\u00e1gina como la siguiente: Esta es una p\u00e1gina web servida por el propio ESP32, que te permitir\u00e1 interactuar con \u00e9l. Concretamente, la p\u00e1gina dispone de dos funcionalidades: Chart : consulta peri\u00f3dicamente el valor de temperatura devuelto por el ESP32 a trav\u00e9s del endpoint /api/v1/temp/raw . Light : permite enviar al ESP32 nuevos valores para las tres componentes de luminosidad que hipot\u00e9ticamente podr\u00eda equipar el ESP32. Tarea Interact\u00faa con el sensor de luminosidad del ESP32 enviando distintos valores. Observa c\u00f3mo la salida de monitorizaci\u00f3n del ESP32 responde mostrando los valores recibidos. Analiza el tr\u00e1fico generado para una de dichas peticiones utilizando Wireshark. \u00bfC\u00f3mo se codifican los datos en el env\u00edo? \u00bfC\u00f3mo se codifican los datos peri\u00f3dicos de temperatura recibidos? Interacci\u00f3n con el dispositivo v\u00eda l\u00ednea de comandos ( curl ) curl es una herramienta orientada a la transferencia de archivos por red. Entre otras (muchas) funcionalidades, curl soporta los m\u00e9todos GET y PUT del protocolo HTTP, justo las necesarias para realizar peticiones de lectura y escritura sobre nuestro servidor HTTP REST. Concretamente, para realizar una petici\u00f3n HTTP GET sobre nuestro servidor, podemos ejecutar: curl http://IP/URI Por ejemplo, la petici\u00f3n: curl http://192.168.1.26/api/v1/temp/raw (siendo 192.168.1.26 la IP del ESP32) nos responder\u00e1 con el valor de temperatura instant\u00e1nea. Del mismo modo, para escribir (m\u00e9todo POST ) sobre el servidor, utilizaremos el par\u00e1metro -d , seguido del recurso que queramos enviar. Ten en cuenta que es responsabilidad del cliente enviar un recurso bien formado e interpretable por el dispositivo: curl -d '{\"red\":70,\"green\":80,\"blue\":99}' -H \"Content-Type: application/json\" -X POST http://192.168.1.26/api/v1/light/brightness Observa que hemos incluido el tipo de recurso enviado ( JSON ) y la operacion solicitada ( POST ). Volveremos a esto en breve. Tarea Comprueba que, efectivamente, el tr\u00e1fico generado por las anteriores \u00f3rdenes es el mismo que el que observaste en el caso del cliente web. Observa qu\u00e9 ocurre si consultas un endpoint inexistente, o si env\u00edas un JSON mal formado o con informaci\u00f3n incorrecta. Implementaci\u00f3n de un servidor HTTP con API REST La implementaci\u00f3n de un servidor HTTP en ESP-IDF se delega al componente HTTP Server , que implementa toda la funcionalida necesaria para tal fin de forma eficiente y ligera. La construcci\u00f3n de un servidor puede resumirse en tres funciones principales (observa la implementaci\u00f3n de la funcion start_rest_server en el fichero rest_server.c ) del ejemplo: httpd_start : crea una instancia de servidor HTTP, y aloja recursos para ella seg\u00fan la configuraci\u00f3n proporcionada. En funci\u00f3n del tr\u00e1fico generado (URIs solicitadas), se utilizar\u00e1n manejadores espec\u00edficos definidos por el usuario para analizarlo y, en caso necesario, enviar respuestas al cliente correspondiente. httpd_stop : finaliza el servidor HTTP, cerrando cualquier conexi\u00f3n previamente establecida con clientes. httpd_register_uri_handler : registra un manejador (una funci\u00f3n definida por el usuario) para tratar una petici\u00f3n sobre una URI determinada. La estructura proporcionada dispone de campos para indicar la URI destino ( uri ), el m\u00e9todo que se espera recibir ( method , por ejemplo HTTPD_GET o HTTPD_POST ) y un puntero a una funci\u00f3n que procesar\u00e1 la petici\u00f3n recibida a trav\u00e9s de la URI indicada. Dicha funci\u00f3n s\u00f3lo se ejecutar\u00e1 si el m\u00e9todo coincide con el indicado. La funci\u00f3n start_rest_server del ejemplo proporciona los mecanismos b\u00e1sicos para la creaci\u00f3n de la API anteriormente descrita. As\u00ed, para crear el endpoint /api/v1/system/info , procederemos, en primer lugar, registr\u00e1ndolo en el servidor, preparando previamente la estructura de tipo httpd_uri_t : httpd_uri_t system_info_get_uri = { .uri = \"/api/v1/system/info\", .method = HTTP_GET, .handler = system_info_get_handler, .user_ctx = rest_context }; httpd_register_uri_handler(server, &system_info_get_uri); En este caso, la operaci\u00f3n asociada a la invocaci\u00f3n del handler ser\u00e1, exclusivamente GET ; de hecho, si invocamos a un m\u00e9todo POST sobre este endpoint , el servidor nos responder\u00e1 autom\u00e1ticamente con un aviso que indicar\u00e1 que dicho m\u00e9todo no est\u00e1 soportado. El procesamiento de la petici\u00f3n GET se realiza en la funci\u00f3n system_info_get_handler , y el esquema que se sigue es, en cualquier caso, sencillo: static esp_err_t system_info_get_handler(httpd_req_t *req) { // Preparaci\u00f3n del tipo de respuesta. httpd_resp_set_type(req, \"application/json\"); // Preparaci\u00f3n del buffer de respuesta. char * buffer = // En el ejemplo preparamos un buffer JSON. // Env\u00edo de respuesta. https_resp_sendstr( req, buffer ); return ESP_OK; Alternativamente, si la respuesta es binaria, podr\u00edamos utilizar la funci\u00f3n https_resp_send( req, buffer, buffer_len ) para procesarla y enviarla (lo necesitar\u00e1s para enviar un buffer binario CBOR). La creaci\u00f3n de un endpoint con soporte para m\u00e9todo POST resulta algo m\u00e1s larga, aunque el registro del mismo no difiere del ejemplo anterior: /* URI handler for light brightness control */ httpd_uri_t light_brightness_post_uri = { .uri = \"/api/v1/light/brightness\", .method = HTTP_POST, .handler = light_brightness_post_handler, .user_ctx = rest_context }; httpd_register_uri_handler(server, &light_brightness_post_uri); Observa el cuerpo de la funci\u00f3n light_brightness_post_handler . La recepci\u00f3n del objeto enviado por parte del cliente se realiza en base a m\u00faltiples invocaciones a la rutina httpd_req_recv : /* Simple handler for light brightness control */ static esp_err_t light_brightness_post_handler(httpd_req_t *req) { int total_len = req->content_len; int cur_len = 0; char *buf = ((rest_server_context_t *)(req->user_ctx))->scratch; int received = 0; if (total_len >= SCRATCH_BUFSIZE) { /* Respond with 500 Internal Server Error */ httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, \"content too long\"); return ESP_FAIL; } while (cur_len < total_len) { received = httpd_req_recv(req, buf + cur_len, total_len); if (received <= 0) { /* Respond with 500 Internal Server Error */ httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, \"Failed to post control value\"); return ESP_FAIL; } cur_len += received; } buf[total_len] = '\\0'; /// A partir de este punto, disponemos en buf del objeto recibido v\u00eda HTTP. /// ... Tarea entregable Observa y estudia los c\u00f3digos de los manejadores implementados en el ejemplo. Extiende la API proporcionada para crear un nuevo endpoint que permita obtener la temperatura (n\u00famero aleatorio), pero transform\u00e1ndola a grados Fahrenheit. En este caso, el valor devuelto en el fichero JSON ser\u00e1 un n\u00famero en punto flotante (en la siguiente secci\u00f3n te se explicar\u00e1 c\u00f3mo hacerlo, por lo que de momento puedes enviar \u00fanicamente la parte entera del mismo). Representaci\u00f3n de la informaci\u00f3n. JSON JSON es un formato de representaci\u00f3n de datos en modo texto para el intercambio de datos entre sistemas inform\u00e1ticos. Se cre\u00f3 inicialmente como una notaci\u00f3n literal de los objetos Javascript, pero dada su amplia aceptaci\u00f3n (realmente como alternativa a XML), se considera a d\u00eda de hoy un componente totalmente independiente al lenguaje. Los tipos de datos soportados por JSON incluyen: Valores num\u00e9ricos: permitiendo n\u00fameros con y sin signo, y con parte decimla en notaci\u00f3n separada por puntos. Cadenas: secuencias de cero o m\u00e1s caracteres. Booleanos: true y false . Arrays: listas ordenadas de cero o m\u00e1s valores de cualquier tipo, separados por comas y encerrados entre corchetes. Objetos: colecciones no ordenadas de pares <nombre>:<valor> , separados por comas y encerrados entre llaves. ESP-IDF incluye el componente cJSON para parsear y construir objetos de tipo JSON de forma sencilla y consistente. La biblioteca cJSON representa datos JSON utilizando una estructura sencilla, v\u00e9ase: /* The cJSON structure: */ typedef struct cJSON { struct cJSON *next; struct cJSON *prev; struct cJSON *child; int type; char *valuestring; /* writing to valueint is DEPRECATED, use cJSON_SetNumberValue instead */ int valueint; double valuedouble; char *string; } cJSON; El campo type informa sobre el tipo de dato contenido en el objeto, v\u00e9ase: cJSON_False ( cJSON_IsFalse() ): representa un valor booleano falso. cJSON_True ( cJSON_IsTrue() ): representa un valor booleano verdadero. cJSON_NULL ( cJSON_IsNULL() ): representa un valor nulo. cJSON_Number ( cJSON_IsNumber() ): representa un valor num\u00e9rico. Dicho valor se almacena en el campo valuedouble como flotante y en valueint como entero. cJSON_String ( cJSON_IsString() ): representa un valor cadena, y se almacena en el campo valuestring como un array de bytes terminado por el car\u00e1cter nulo ('\\0'). cJSON_Array ( cJSON_IsArray() ): representa un array de valores. En el campo child se almacena una lista enlazada con los elementos del array, terminada en NULL. cJSON_Object ( cJSON_IsObject() ): representa un valor objeto. Sus valores se almacenan de la misma manera que el array anterior, pero en el campo string se almacenan adem\u00e1s las claves del objeto a modo de lista. Creaci\u00f3n y parseado de una estructura JSON Para cada tipo de datos, existe una rutina asociada con nombre cJSON_Create... que permite crear un item del tipo correspondiente. Todas estas funciones alojan memoria suficiente como para albergar el dato creado. Dado un objeto JSON en forma de cadena, es posible analizarlo (parsearlo) utilizando la funci\u00f3n cJSON_Parse : cJSON * json = cJSON_Parse( string ); Para imprimir el contenido de una estructura JSON en modo texto, podemos hacer uso de la funci\u00f3n cJSON_Print(json) : char * string = cJSON_Print( json ); Ejemplos Observa de nuevo el contenido de las funciones manejadoras en nuestro servidor REST. Concretamente, c\u00e9ntrate en la funci\u00f3n system_info_get_handler , que construye un objeto JSON con dos campos, de tipo cadena (\"version\") y num\u00e9rico (\"cores\"): /* Simple handler for getting system handler */ static esp_err_t system_info_get_handler(httpd_req_t *req) { // Preparaci\u00f3n del tipo de datos de la respuesta. httpd_resp_set_type(req, \"application/json\"); // Creaci\u00f3n del objeto JSON. cJSON *root = cJSON_CreateObject(); // Obtenci\u00f3n del dato. esp_chip_info_t chip_info; esp_chip_info(&chip_info); // Anyadimos un campo de tipo cadena. cJSON_AddStringToObject(root, \"version\", IDF_VER); // Anyadimos un campo de tipo num\u00e9rico. cJSON_AddNumberToObject(root, \"cores\", chip_info.cores); // Imprimimos a cadena previo al env\u00edo. const char *sys_info = cJSON_Print(root); // Enviamos cabecera + objeto JSON en modo texto v\u00eda HTTP. httpd_resp_sendstr(req, sys_info); // Liberamos recursos. free((void *)sys_info); // Liberamos recursos del objeto JSON. cJSON_Delete(root); return ESP_OK; } La funci\u00f3n light_brightness_post_handler realiza un parseado del objeto JSON recibido. Observa su cuerpo: // buf contiene la cadena recibida a trav\u00e9s de HTTP (m\u00e9todo POST). // ... // Parseamos el objeto JSON. cJSON *root = cJSON_Parse(buf); // Obtenemos tres valores num\u00e9ricos (RGB). int red = cJSON_GetObjectItem(root, \"red\")->valueint; int green = cJSON_GetObjectItem(root, \"green\")->valueint; int blue = cJSON_GetObjectItem(root, \"blue\")->valueint; // Mostramos por pantalla los valores parseados. ESP_LOGI(REST_TAG, \"Light control: red = %d, green = %d, blue = %d\", red, green, blue); // Liberamos recursos JSON. cJSON_Delete(root); // Enviamos una respuesta generica en modo texto. httpd_resp_sendstr(req, \"Post control value successfully\"); return ESP_OK; Tarea entregable Extiende la tarea anterior para a\u00f1adir el dato en formato punto flotante de la temperatura en grados Fahrenheit. Tarea entregable Crea un nuevo endpoint que utilice un formato m\u00e1s complejo de objetos JSON, incluyendo distintos tipos de datos que puedan dar respuesta a un hipot\u00e9tico entorno IoT. Documenta la API generada y el formato de los objetos que has dise\u00f1ado. Puedes, si as\u00ed lo deseas, incluir capturas Wireshark para ilustrar el intercambio de mensajes producido. Nos interesar\u00e1, especialmente, el n\u00famero de bytes transportados para enviar/recibir tus mensajes JSON. Representaci\u00f3n de la informaci\u00f3n. CBOR CBOR ( Concise Binary Object Representation ) es el formato de serializaci\u00f3n de datos recomendado en muchos de los stacks IoT, espec\u00edficamente en aquellos basados en CoAP. Pese a ser un formato binario, CBOR guarda similitudes con JSON, ya que sigue su mismo modelo de datos: valores num\u00e9ricos, strings , arrays, mapas (objetos en JSON) y valores booleanos y nulos. Sin embargo, a diferencia de JSON, un objeto CBOR es autodescriptivo, y en este punto radica una de sus ventajas: es posible intercambiar datos entre un cliente y un servidor sin ce\u00f1irse a un esquema de datos concreto conocido por ambas partes. El hecho de ser un formato binario implica mejoras sustanciales con respecto a JSON, por ejemplo al transportar datos binarios (claves de cifrado, datos gr\u00e1ficos, o valores flotantes sensorizados, entre otros muchos); estos datos sol\u00edan codificarse en JSON utilizando, por ejemplo, formato base64 , a\u00f1adiendo complejidad al proceso de codificaci\u00f3n/decodificaci\u00f3n. En general, el uso de un formato binario implica menor complejidad a la hora de ser integrado en aplicaciones, y es por esta raz\u00f3n por la que se considera \u00f3ptimo para nodos de bajas prestaciones, t\u00edpicos en IoT. El formato CBOR est\u00e1 documentado en el RFC 7049 , y por tanto se considera un est\u00e1ndar bien documentado y estable de cara al futuro. CBOR en el ESP32 ESP-IDF incluye la biblioteca tinyCBOR como implementaci\u00f3n ligera del est\u00e1ndar, que permite tanto codificar distintos tipos de datos a formato CBOR, parsear estructuras CBOR y convertir dichas estructuras tanto a formato texto visualizable como a JSON. TinyCBOR est\u00e1 mantenido como proyecto de software libre por parte de Intel, y su documentaci\u00f3n detallada (se sugiere consultarla) se encuentra disponible en el siguiente enlace . Estudiaremos el funcionamiento de tinyCBOR a trav\u00e9s de un ejemplo funcional (lo puedes encontrar en examples/protocols/cbor ). El ejemplo muestra los mecanismos necesarios para, en primer lugar, crear un objeto CBOR completo utilizando la biblioteca, y en segundo lugar, el mecanismo para convertir dicho objeto a representaci\u00f3n JSON, as\u00ed como para parsearlo manualmente. En primer lugar, compila, flashea y ejecuta el ejemplo. Ver\u00e1s que la salida deber\u00eda ser similar a la siguiente: I (320) example: encoded buffer size 67 I (320) example: convert CBOR to JSON [{\"chip\":\"esp32\",\"unicore\":false,\"ip\":[192,168,1,100]},3.1400001049041748,\"simple(99)\",\"2019-07-10 09:00:00+0000\",\"undefined\"] I (340) example: decode CBOR manually Array[ Map{ chip esp32 unicore false ip Array[ 192 168 1 100 ] } 3.14 simple(99) 2019-07-10 09:00:00+0000 undefined ] Observa que la estructura del objeto CBOR ser\u00e1 medianamente compleja: constar\u00e1 de un array formado por cinco elementos: Un mapa (conjunto no ordenado de pares clave-valor ), combinando cadenas, booleanos y un segundo array para especificar una direcci\u00f3n IP. Un valor flotante (3.14). Un valor num\u00e9rico \"simple\" (99). Una fecha (en forma de cadena). Un valor indefinido. El firmware procede en tres etapas: Etapa 1: creaci\u00f3n (codificaci\u00f3n) del objeto CBOR Observa el cuerpo de la tarea principal ( app_main ). El codificador CBOR se basa en dos variables: CborEncoder Root_encoder; // Codificador CBOR. uint8_t buf[100]; // Buffer para alojar el objeto CBOR (array de bytes). En segundo lugar, y ya que utilizaremos un array y un mapa, necesitaremos constructores especiales para dichos objetos: // Creaci\u00f3n de Array. CborEncoder array_encoder; CborEncoder map_encoder; cbor_encoder_create_array(&root_encoder, &array_encoder, 5); // [ // 1. Creaci\u00f3n del Mapa. cbor_encoder_create_map(&array_encoder, &map_encoder, 3); // { A partir de este punto, podemos proceder con la construcci\u00f3n de los objetos siguiendo el esquema deseado: // chip: esp32 (cadena:cadena) cbor_encode_text_stringz(&map_encoder, \"chip\"); cbor_encode_text_stringz(&map_encoder, \"esp32\"); // unicore: false (cadena:booleano) cbor_encode_text_stringz(&map_encoder, \"unicore\"); cbor_encode_boolean(&map_encoder, false); // IP:[192,168,1,100] (cadena:array) cbor_encode_text_stringz(&map_encoder, \"ip\"); CborEncoder array2; cbor_encoder_create_array(&map_encoder, &array2, 4); // [ // Valores num\u00e9ricos. cbor_encode_uint(&array2, 192); cbor_encode_uint(&array2, 168); cbor_encode_uint(&array2, 1); cbor_encode_uint(&array2, 100); cbor_encoder_close_container(&map_encoder, &array2); // ] cbor_encoder_close_container(&array_encoder, &map_encoder); // } // 2. Flotante cbor_encode_float(&array_encoder, 3.14); // 3. Valor simple cbor_encode_simple_value(&array_encoder, 99); // 4. Cadena cbor_encode_text_stringz(&array_encoder, \"2019-07-10 09:00:00+0000\"); // 5. Undefined value. cbor_encode_undefined(&array_encoder); cbor_encoder_close_container(&root_encoder, &array_encoder); // ] // Mostramos el tama\u00f1o del buffer creado. ESP_LOGI(TAG, \"encoded buffer size %d\", cbor_encoder_get_buffer_size(&root_encoder, buf)); Etapa 2: conversi\u00f3n a JSON La conversi\u00f3n a JSON (t\u00edpicamente por motivos de visualizaci\u00f3n o depuraci\u00f3n), puede realizarse del siguiente modo: // Initialize the cbor parser and the value iterator cbor_parser_init(buf, sizeof(buf), 0, &root_parser, &it); ESP_LOGI(TAG, \"convert CBOR to JSON\"); // Dump the values in JSON format cbor_value_to_json(stdout, &it, 0); Etapa 3: parseado manual de un objeto CBOR Por \u00faltimo, el parseado manual del objeto CBOR se deja como ejercicio de estudio para el alumno, y est\u00e1 implementado en la funci\u00f3n example_dump_cbor_buffer del ejemplo. B\u00e1sicamente, la funci\u00f3n itera por cada uno de los elementos del objeto CBOR, consultando el tipo de cada elemento y actuando en consecuencia. Para aquellos tipos complejos (e.g. arrays o mapas), la funci\u00f3n se invoca recursivamente hasta encontrar un elemento de tipo b\u00e1sico. En este caso, simplemente imprime por pantalla su valor (e.g. en el caso de un entero, caso CborIntegerType ). Tarea entregable Se pide extender la API REST con un nuevo endpoint que permita obtener la misma informaci\u00f3n que el endpoint JSON desarrollado en la anterior tarea, pero en esta ocasi\u00f3n, utilizando formato CBOR. El objetivo del ejercicio es comparar la cantidad de tr\u00e1fico generado en cada representaci\u00f3n, por lo que se sugiere que el objeto intercambiado sea relativamente complejo (es decir, incluya disintos tipos de datos num\u00e9ricos, arrays, o mapas). A continuaci\u00f3n se incluyen notas adicionales que te permitir\u00e1n depurar tu desarrollo, observando los valores devueltos por el servidor HTTP. Notas adicionales: creaci\u00f3n y consulta de un endpoint CBOR en la API REST Las modificaciones a realizar en la funci\u00f3n manejadora del endpoint para responder con un objeto CBOR son m\u00ednimas. De hecho, se centran simplemente en el tipo de respuesta y el mecanismo a usar para enviarla, v\u00e9ase: static esp_err_t system_info_get_handler(httpd_req_t *req) { // Tipo de respuesta. httpd_resp_set_type(req, \"application/cbor\"); CborEncoder root_encoder; uint8_t buf[100]; // Codificador CBOR. cbor_encoder_init(&root_encoder, buf, sizeof(buf), 0); // Codificamos CBOR. // ... // Enviamos respuesta, consultando previamente el tama\u00f1o del buffer codificado. httpd_resp_send(req, (char*)buf, cbor_encoder_get_buffer_size( &root_encoder, buf)); return ESP_OK; Para consultar desde l\u00ednea de comandos sobre este endpoint , podemos utilizar directamente curl , volcando la salida recibida a un fichero (por ejemplo, output.cbor ): curl http://192.168.1.26/api/v1/system/info > output.cbor Si visualizas el contenido del fichero, ver\u00e1s que contiene datos binarios dif\u00edcilmente interpretables. A continuaci\u00f3n veremos distintos mecanismos de visualizaci\u00f3n. Notas adicionales: visualizaci\u00f3n de datos CBOR Una opci\u00f3n de visualizaci\u00f3n consiste en utilizar la web cbor.me . En el panel derecho, podr\u00e1s pegar el contenido binario le\u00eddo. Si necesitas realizar la conversi\u00f3n antes de pegarlo en la web, puedes hacerlo con la orden: xxd -ps output.cbor Un ejemplo de salida (a pegar en el panel derecho de la web), podr\u00eda ser: $ xxd -ps output.cbor 85a3646368697065657370333267756e69636f7265f46269708418c018a8 011864fa4048f5c3f8637818323031392d30372d31302030393a30303a30 302b30303030f7 Deber\u00edas observar una salida similar a la siguiente (ten en cuenta que la herramiente autom\u00e1ticamente indenta el contenido del panel derecho; recuerda que simplemente debes pegar la salida generada por xxd ): Otra opci\u00f3n de visualizaci\u00f3n puede ser un programa Python (podr\u00edas integrarlo en tu servidor TCP/UDP, por ejemplo), que haga uso del m\u00f3dulo cbor2 ( documentaci\u00f3n ). Para comprobar su funcionamiento, primero inst\u00e1lalo: pip install cbor2 Y comprueba si efectivamente funciona utilizando el siguiente programa Python: from cbor2 import dumps, loads, dump, load with open('output.cbor', 'rb') as fp: obj = load(fp) print(obj) Al ejecutarlo, observar\u00e1s el contenido del objeto: python cbor.py [{'chip': 'esp32', 'unicore': False, 'ip': [192, 168, 1, 100]}, 3.140000104904175, CBORSimpleValue(value=99), '2019-07-10 09:00:00+0000', undefined]","title":"Pr\u00e1ctica 5"},{"location":"RPI-II/P5/#practica-5-servidores-rest-y-representacion-de-la-informacion-json-y-cbor","text":"","title":"Pr\u00e1ctica 5. Servidores REST y representaci\u00f3n de la informaci\u00f3n. JSON y CBOR"},{"location":"RPI-II/P5/#objetivos","text":"Entender los mecanismos ofrecidos por ESP-IDF para la creaci\u00f3n de un servidor REST HTTP. Implementar, a trav\u00e9s de los mecanismos ofrecidos por ESP-IDF, una API REST extendida en el ESP32. Entender los conceptos b\u00e1sicos de representaci\u00f3n de datos a trav\u00e9s de JSON. Implementar, a trav\u00e9s de la biblioteca cJSON , un tipo de mensaje personalizado para los intercambios de datos entre cliente y servidor. Entender los conceptos b\u00e1sicos de representaci\u00f3n de datos a trav\u00e9s de CBOR, y evaluar sus ventajas con respecto a JSON. Implementar, a trav\u00e9s de la biblioteca tinycbor , un tipo de mensaje personalizado para los intercambios de datos entre cliente y servidor, comparando los tama\u00f1os de payload con respecto al intercambio JSON.","title":"Objetivos"},{"location":"RPI-II/P5/#desarrollo-de-un-servidor-rest-en-esp-idf","text":"En la primera parte de la pr\u00e1ctica, veremos c\u00f3mo desarrollar, utilizando las funcionalidades ofrecidas por ESP-IDF, un servidor HTTP que exponga una API REST mediante la cual ser\u00e1 posible interactuar, en modos lectura y escritura, con un servidor (en nuestro caso, un dispositivo ESP32). Concretamente, trabajaremos con el ejemplo example/protocols/http_server/rest_server de la distribuci\u00f3n de IDF (versi\u00f3n 4.1).","title":"Desarrollo de un servidor REST en ESP-IDF"},{"location":"RPI-II/P5/#descripcion-de-la-api","text":"El ejemplo que estudiaremos construye una sencilla interfaz (API) con tres endpoints que permiten interactuar con distintas funcionalidades del ESP32. N\u00f3tese que tanto las URLs como la funcionalidad asociada a ellas es totalmente personalizable, y puede ser ampliada de acuerdo a las necesidades de nuestra aplicaci\u00f3n. La siguiente tabla resume la funcionalidad de cada endpoint , as\u00ed como posibles ejemplos de valores enviados o devueltos a/por el servidor: API M\u00e9todo Ejemplo de recurso le\u00eddo/escrito Descripci\u00f3n URL /api/v1/system/info GET { version:\"v4.0-dev\", cores:2 } Utilizado por los clientes para obtener informaci\u00f3n de la placa (versi\u00f3n, n\u00famero de cores, ...) / /api/v1/temp/raw GET { raw:22 } Utilizado por los clientes para obtener datos de temperatura desde un sensor (no disponible en el ESP32) /chart /api/v1/light/brightness POST { red:160, green:160, blue:160 } Utilizado por los clientes para escribir en la placa valores de control para controlar la luminosidad de LEDs /light","title":"Descripci\u00f3n de la API"},{"location":"RPI-II/P5/#configuracion-y-compilacion-del-ejemplo","text":"En primer lugar, configura, compila y flashea el ejemplo mencionado. En este caso, las instrucciones se dividen en dos partes: compilaci\u00f3n del firmware para el ESP32, y preparaci\u00f3n de un cliente web sencillo que nos permitir\u00e1 observar la interacci\u00f3n con el mismo. Esta \u00faltima parte no es estrictamente necesaria, pero nos ayudar\u00e1 en la interacci\u00f3n con el dispositivo de forma visual hasta que veamos c\u00f3mo hacerlo a trav\u00e9s de l\u00ednea de comandos. A trav\u00e9s del men\u00fa de configuraci\u00f3n, configura un nombre para el dispositivo (por ejemplo, 'esp_home_tunombre'), e indica que el modo de despliegue ( Website deploy mode ) sea Deploy website to SPI Nor Flash . Por \u00faltimo, configura las credenciales del punto de acceso WiFi al que conectar\u00e1, siguiendo la metodolog\u00eda habitual. En segundo lugar, necesitamos instalar los componentes necesarios para desplegar el cliente web. Para ello, navega al subdirectorio front/web-demo , donde reside el c\u00f3digo fuente del cliente. Ejecuta los siguientes comandos para instalar las dependencias necesarias: sudo apt-get install npm node-vue* npm install npm run build En este punto, ya podr\u00e1s ejecutar, desde el directorio base del ejemplo, la orden de compilaci\u00f3n y flasheado: idf.py build idf.py flash idf.py monitor","title":"Configuraci\u00f3n y compilaci\u00f3n del ejemplo"},{"location":"RPI-II/P5/#interaccion-con-el-dispositivo-via-interfaz-web","text":"Si todo ha ido bien, podr\u00e1s observar en la salida de monitorizaci\u00f3n la IP proporcionada al ESP32. Abre un navegador en la m\u00e1quina virtual o en tu PC (estando conectada a la misma red que tu ESP32), navega hacia la direcci\u00f3n IP del ESP32, y deber\u00edas observar una p\u00e1gina como la siguiente: Esta es una p\u00e1gina web servida por el propio ESP32, que te permitir\u00e1 interactuar con \u00e9l. Concretamente, la p\u00e1gina dispone de dos funcionalidades: Chart : consulta peri\u00f3dicamente el valor de temperatura devuelto por el ESP32 a trav\u00e9s del endpoint /api/v1/temp/raw . Light : permite enviar al ESP32 nuevos valores para las tres componentes de luminosidad que hipot\u00e9ticamente podr\u00eda equipar el ESP32. Tarea Interact\u00faa con el sensor de luminosidad del ESP32 enviando distintos valores. Observa c\u00f3mo la salida de monitorizaci\u00f3n del ESP32 responde mostrando los valores recibidos. Analiza el tr\u00e1fico generado para una de dichas peticiones utilizando Wireshark. \u00bfC\u00f3mo se codifican los datos en el env\u00edo? \u00bfC\u00f3mo se codifican los datos peri\u00f3dicos de temperatura recibidos?","title":"Interacci\u00f3n con el dispositivo v\u00eda interfaz web"},{"location":"RPI-II/P5/#interaccion-con-el-dispositivo-via-linea-de-comandos-curl","text":"curl es una herramienta orientada a la transferencia de archivos por red. Entre otras (muchas) funcionalidades, curl soporta los m\u00e9todos GET y PUT del protocolo HTTP, justo las necesarias para realizar peticiones de lectura y escritura sobre nuestro servidor HTTP REST. Concretamente, para realizar una petici\u00f3n HTTP GET sobre nuestro servidor, podemos ejecutar: curl http://IP/URI Por ejemplo, la petici\u00f3n: curl http://192.168.1.26/api/v1/temp/raw (siendo 192.168.1.26 la IP del ESP32) nos responder\u00e1 con el valor de temperatura instant\u00e1nea. Del mismo modo, para escribir (m\u00e9todo POST ) sobre el servidor, utilizaremos el par\u00e1metro -d , seguido del recurso que queramos enviar. Ten en cuenta que es responsabilidad del cliente enviar un recurso bien formado e interpretable por el dispositivo: curl -d '{\"red\":70,\"green\":80,\"blue\":99}' -H \"Content-Type: application/json\" -X POST http://192.168.1.26/api/v1/light/brightness Observa que hemos incluido el tipo de recurso enviado ( JSON ) y la operacion solicitada ( POST ). Volveremos a esto en breve. Tarea Comprueba que, efectivamente, el tr\u00e1fico generado por las anteriores \u00f3rdenes es el mismo que el que observaste en el caso del cliente web. Observa qu\u00e9 ocurre si consultas un endpoint inexistente, o si env\u00edas un JSON mal formado o con informaci\u00f3n incorrecta.","title":"Interacci\u00f3n con el dispositivo v\u00eda l\u00ednea de comandos (curl)"},{"location":"RPI-II/P5/#implementacion-de-un-servidor-http-con-api-rest","text":"La implementaci\u00f3n de un servidor HTTP en ESP-IDF se delega al componente HTTP Server , que implementa toda la funcionalida necesaria para tal fin de forma eficiente y ligera. La construcci\u00f3n de un servidor puede resumirse en tres funciones principales (observa la implementaci\u00f3n de la funcion start_rest_server en el fichero rest_server.c ) del ejemplo: httpd_start : crea una instancia de servidor HTTP, y aloja recursos para ella seg\u00fan la configuraci\u00f3n proporcionada. En funci\u00f3n del tr\u00e1fico generado (URIs solicitadas), se utilizar\u00e1n manejadores espec\u00edficos definidos por el usuario para analizarlo y, en caso necesario, enviar respuestas al cliente correspondiente. httpd_stop : finaliza el servidor HTTP, cerrando cualquier conexi\u00f3n previamente establecida con clientes. httpd_register_uri_handler : registra un manejador (una funci\u00f3n definida por el usuario) para tratar una petici\u00f3n sobre una URI determinada. La estructura proporcionada dispone de campos para indicar la URI destino ( uri ), el m\u00e9todo que se espera recibir ( method , por ejemplo HTTPD_GET o HTTPD_POST ) y un puntero a una funci\u00f3n que procesar\u00e1 la petici\u00f3n recibida a trav\u00e9s de la URI indicada. Dicha funci\u00f3n s\u00f3lo se ejecutar\u00e1 si el m\u00e9todo coincide con el indicado. La funci\u00f3n start_rest_server del ejemplo proporciona los mecanismos b\u00e1sicos para la creaci\u00f3n de la API anteriormente descrita. As\u00ed, para crear el endpoint /api/v1/system/info , procederemos, en primer lugar, registr\u00e1ndolo en el servidor, preparando previamente la estructura de tipo httpd_uri_t : httpd_uri_t system_info_get_uri = { .uri = \"/api/v1/system/info\", .method = HTTP_GET, .handler = system_info_get_handler, .user_ctx = rest_context }; httpd_register_uri_handler(server, &system_info_get_uri); En este caso, la operaci\u00f3n asociada a la invocaci\u00f3n del handler ser\u00e1, exclusivamente GET ; de hecho, si invocamos a un m\u00e9todo POST sobre este endpoint , el servidor nos responder\u00e1 autom\u00e1ticamente con un aviso que indicar\u00e1 que dicho m\u00e9todo no est\u00e1 soportado. El procesamiento de la petici\u00f3n GET se realiza en la funci\u00f3n system_info_get_handler , y el esquema que se sigue es, en cualquier caso, sencillo: static esp_err_t system_info_get_handler(httpd_req_t *req) { // Preparaci\u00f3n del tipo de respuesta. httpd_resp_set_type(req, \"application/json\"); // Preparaci\u00f3n del buffer de respuesta. char * buffer = // En el ejemplo preparamos un buffer JSON. // Env\u00edo de respuesta. https_resp_sendstr( req, buffer ); return ESP_OK; Alternativamente, si la respuesta es binaria, podr\u00edamos utilizar la funci\u00f3n https_resp_send( req, buffer, buffer_len ) para procesarla y enviarla (lo necesitar\u00e1s para enviar un buffer binario CBOR). La creaci\u00f3n de un endpoint con soporte para m\u00e9todo POST resulta algo m\u00e1s larga, aunque el registro del mismo no difiere del ejemplo anterior: /* URI handler for light brightness control */ httpd_uri_t light_brightness_post_uri = { .uri = \"/api/v1/light/brightness\", .method = HTTP_POST, .handler = light_brightness_post_handler, .user_ctx = rest_context }; httpd_register_uri_handler(server, &light_brightness_post_uri); Observa el cuerpo de la funci\u00f3n light_brightness_post_handler . La recepci\u00f3n del objeto enviado por parte del cliente se realiza en base a m\u00faltiples invocaciones a la rutina httpd_req_recv : /* Simple handler for light brightness control */ static esp_err_t light_brightness_post_handler(httpd_req_t *req) { int total_len = req->content_len; int cur_len = 0; char *buf = ((rest_server_context_t *)(req->user_ctx))->scratch; int received = 0; if (total_len >= SCRATCH_BUFSIZE) { /* Respond with 500 Internal Server Error */ httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, \"content too long\"); return ESP_FAIL; } while (cur_len < total_len) { received = httpd_req_recv(req, buf + cur_len, total_len); if (received <= 0) { /* Respond with 500 Internal Server Error */ httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, \"Failed to post control value\"); return ESP_FAIL; } cur_len += received; } buf[total_len] = '\\0'; /// A partir de este punto, disponemos en buf del objeto recibido v\u00eda HTTP. /// ... Tarea entregable Observa y estudia los c\u00f3digos de los manejadores implementados en el ejemplo. Extiende la API proporcionada para crear un nuevo endpoint que permita obtener la temperatura (n\u00famero aleatorio), pero transform\u00e1ndola a grados Fahrenheit. En este caso, el valor devuelto en el fichero JSON ser\u00e1 un n\u00famero en punto flotante (en la siguiente secci\u00f3n te se explicar\u00e1 c\u00f3mo hacerlo, por lo que de momento puedes enviar \u00fanicamente la parte entera del mismo).","title":"Implementaci\u00f3n de un servidor HTTP con API REST"},{"location":"RPI-II/P5/#representacion-de-la-informacion-json","text":"JSON es un formato de representaci\u00f3n de datos en modo texto para el intercambio de datos entre sistemas inform\u00e1ticos. Se cre\u00f3 inicialmente como una notaci\u00f3n literal de los objetos Javascript, pero dada su amplia aceptaci\u00f3n (realmente como alternativa a XML), se considera a d\u00eda de hoy un componente totalmente independiente al lenguaje. Los tipos de datos soportados por JSON incluyen: Valores num\u00e9ricos: permitiendo n\u00fameros con y sin signo, y con parte decimla en notaci\u00f3n separada por puntos. Cadenas: secuencias de cero o m\u00e1s caracteres. Booleanos: true y false . Arrays: listas ordenadas de cero o m\u00e1s valores de cualquier tipo, separados por comas y encerrados entre corchetes. Objetos: colecciones no ordenadas de pares <nombre>:<valor> , separados por comas y encerrados entre llaves. ESP-IDF incluye el componente cJSON para parsear y construir objetos de tipo JSON de forma sencilla y consistente. La biblioteca cJSON representa datos JSON utilizando una estructura sencilla, v\u00e9ase: /* The cJSON structure: */ typedef struct cJSON { struct cJSON *next; struct cJSON *prev; struct cJSON *child; int type; char *valuestring; /* writing to valueint is DEPRECATED, use cJSON_SetNumberValue instead */ int valueint; double valuedouble; char *string; } cJSON; El campo type informa sobre el tipo de dato contenido en el objeto, v\u00e9ase: cJSON_False ( cJSON_IsFalse() ): representa un valor booleano falso. cJSON_True ( cJSON_IsTrue() ): representa un valor booleano verdadero. cJSON_NULL ( cJSON_IsNULL() ): representa un valor nulo. cJSON_Number ( cJSON_IsNumber() ): representa un valor num\u00e9rico. Dicho valor se almacena en el campo valuedouble como flotante y en valueint como entero. cJSON_String ( cJSON_IsString() ): representa un valor cadena, y se almacena en el campo valuestring como un array de bytes terminado por el car\u00e1cter nulo ('\\0'). cJSON_Array ( cJSON_IsArray() ): representa un array de valores. En el campo child se almacena una lista enlazada con los elementos del array, terminada en NULL. cJSON_Object ( cJSON_IsObject() ): representa un valor objeto. Sus valores se almacenan de la misma manera que el array anterior, pero en el campo string se almacenan adem\u00e1s las claves del objeto a modo de lista.","title":"Representaci\u00f3n de la informaci\u00f3n. JSON"},{"location":"RPI-II/P5/#creacion-y-parseado-de-una-estructura-json","text":"Para cada tipo de datos, existe una rutina asociada con nombre cJSON_Create... que permite crear un item del tipo correspondiente. Todas estas funciones alojan memoria suficiente como para albergar el dato creado. Dado un objeto JSON en forma de cadena, es posible analizarlo (parsearlo) utilizando la funci\u00f3n cJSON_Parse : cJSON * json = cJSON_Parse( string ); Para imprimir el contenido de una estructura JSON en modo texto, podemos hacer uso de la funci\u00f3n cJSON_Print(json) : char * string = cJSON_Print( json );","title":"Creaci\u00f3n y parseado de una estructura JSON"},{"location":"RPI-II/P5/#ejemplos","text":"Observa de nuevo el contenido de las funciones manejadoras en nuestro servidor REST. Concretamente, c\u00e9ntrate en la funci\u00f3n system_info_get_handler , que construye un objeto JSON con dos campos, de tipo cadena (\"version\") y num\u00e9rico (\"cores\"): /* Simple handler for getting system handler */ static esp_err_t system_info_get_handler(httpd_req_t *req) { // Preparaci\u00f3n del tipo de datos de la respuesta. httpd_resp_set_type(req, \"application/json\"); // Creaci\u00f3n del objeto JSON. cJSON *root = cJSON_CreateObject(); // Obtenci\u00f3n del dato. esp_chip_info_t chip_info; esp_chip_info(&chip_info); // Anyadimos un campo de tipo cadena. cJSON_AddStringToObject(root, \"version\", IDF_VER); // Anyadimos un campo de tipo num\u00e9rico. cJSON_AddNumberToObject(root, \"cores\", chip_info.cores); // Imprimimos a cadena previo al env\u00edo. const char *sys_info = cJSON_Print(root); // Enviamos cabecera + objeto JSON en modo texto v\u00eda HTTP. httpd_resp_sendstr(req, sys_info); // Liberamos recursos. free((void *)sys_info); // Liberamos recursos del objeto JSON. cJSON_Delete(root); return ESP_OK; } La funci\u00f3n light_brightness_post_handler realiza un parseado del objeto JSON recibido. Observa su cuerpo: // buf contiene la cadena recibida a trav\u00e9s de HTTP (m\u00e9todo POST). // ... // Parseamos el objeto JSON. cJSON *root = cJSON_Parse(buf); // Obtenemos tres valores num\u00e9ricos (RGB). int red = cJSON_GetObjectItem(root, \"red\")->valueint; int green = cJSON_GetObjectItem(root, \"green\")->valueint; int blue = cJSON_GetObjectItem(root, \"blue\")->valueint; // Mostramos por pantalla los valores parseados. ESP_LOGI(REST_TAG, \"Light control: red = %d, green = %d, blue = %d\", red, green, blue); // Liberamos recursos JSON. cJSON_Delete(root); // Enviamos una respuesta generica en modo texto. httpd_resp_sendstr(req, \"Post control value successfully\"); return ESP_OK; Tarea entregable Extiende la tarea anterior para a\u00f1adir el dato en formato punto flotante de la temperatura en grados Fahrenheit. Tarea entregable Crea un nuevo endpoint que utilice un formato m\u00e1s complejo de objetos JSON, incluyendo distintos tipos de datos que puedan dar respuesta a un hipot\u00e9tico entorno IoT. Documenta la API generada y el formato de los objetos que has dise\u00f1ado. Puedes, si as\u00ed lo deseas, incluir capturas Wireshark para ilustrar el intercambio de mensajes producido. Nos interesar\u00e1, especialmente, el n\u00famero de bytes transportados para enviar/recibir tus mensajes JSON.","title":"Ejemplos"},{"location":"RPI-II/P5/#representacion-de-la-informacion-cbor","text":"CBOR ( Concise Binary Object Representation ) es el formato de serializaci\u00f3n de datos recomendado en muchos de los stacks IoT, espec\u00edficamente en aquellos basados en CoAP. Pese a ser un formato binario, CBOR guarda similitudes con JSON, ya que sigue su mismo modelo de datos: valores num\u00e9ricos, strings , arrays, mapas (objetos en JSON) y valores booleanos y nulos. Sin embargo, a diferencia de JSON, un objeto CBOR es autodescriptivo, y en este punto radica una de sus ventajas: es posible intercambiar datos entre un cliente y un servidor sin ce\u00f1irse a un esquema de datos concreto conocido por ambas partes. El hecho de ser un formato binario implica mejoras sustanciales con respecto a JSON, por ejemplo al transportar datos binarios (claves de cifrado, datos gr\u00e1ficos, o valores flotantes sensorizados, entre otros muchos); estos datos sol\u00edan codificarse en JSON utilizando, por ejemplo, formato base64 , a\u00f1adiendo complejidad al proceso de codificaci\u00f3n/decodificaci\u00f3n. En general, el uso de un formato binario implica menor complejidad a la hora de ser integrado en aplicaciones, y es por esta raz\u00f3n por la que se considera \u00f3ptimo para nodos de bajas prestaciones, t\u00edpicos en IoT. El formato CBOR est\u00e1 documentado en el RFC 7049 , y por tanto se considera un est\u00e1ndar bien documentado y estable de cara al futuro.","title":"Representaci\u00f3n de la informaci\u00f3n. CBOR"},{"location":"RPI-II/P5/#cbor-en-el-esp32","text":"ESP-IDF incluye la biblioteca tinyCBOR como implementaci\u00f3n ligera del est\u00e1ndar, que permite tanto codificar distintos tipos de datos a formato CBOR, parsear estructuras CBOR y convertir dichas estructuras tanto a formato texto visualizable como a JSON. TinyCBOR est\u00e1 mantenido como proyecto de software libre por parte de Intel, y su documentaci\u00f3n detallada (se sugiere consultarla) se encuentra disponible en el siguiente enlace . Estudiaremos el funcionamiento de tinyCBOR a trav\u00e9s de un ejemplo funcional (lo puedes encontrar en examples/protocols/cbor ). El ejemplo muestra los mecanismos necesarios para, en primer lugar, crear un objeto CBOR completo utilizando la biblioteca, y en segundo lugar, el mecanismo para convertir dicho objeto a representaci\u00f3n JSON, as\u00ed como para parsearlo manualmente. En primer lugar, compila, flashea y ejecuta el ejemplo. Ver\u00e1s que la salida deber\u00eda ser similar a la siguiente: I (320) example: encoded buffer size 67 I (320) example: convert CBOR to JSON [{\"chip\":\"esp32\",\"unicore\":false,\"ip\":[192,168,1,100]},3.1400001049041748,\"simple(99)\",\"2019-07-10 09:00:00+0000\",\"undefined\"] I (340) example: decode CBOR manually Array[ Map{ chip esp32 unicore false ip Array[ 192 168 1 100 ] } 3.14 simple(99) 2019-07-10 09:00:00+0000 undefined ] Observa que la estructura del objeto CBOR ser\u00e1 medianamente compleja: constar\u00e1 de un array formado por cinco elementos: Un mapa (conjunto no ordenado de pares clave-valor ), combinando cadenas, booleanos y un segundo array para especificar una direcci\u00f3n IP. Un valor flotante (3.14). Un valor num\u00e9rico \"simple\" (99). Una fecha (en forma de cadena). Un valor indefinido. El firmware procede en tres etapas:","title":"CBOR en el ESP32"},{"location":"RPI-II/P5/#etapa-1-creacion-codificacion-del-objeto-cbor","text":"Observa el cuerpo de la tarea principal ( app_main ). El codificador CBOR se basa en dos variables: CborEncoder Root_encoder; // Codificador CBOR. uint8_t buf[100]; // Buffer para alojar el objeto CBOR (array de bytes). En segundo lugar, y ya que utilizaremos un array y un mapa, necesitaremos constructores especiales para dichos objetos: // Creaci\u00f3n de Array. CborEncoder array_encoder; CborEncoder map_encoder; cbor_encoder_create_array(&root_encoder, &array_encoder, 5); // [ // 1. Creaci\u00f3n del Mapa. cbor_encoder_create_map(&array_encoder, &map_encoder, 3); // { A partir de este punto, podemos proceder con la construcci\u00f3n de los objetos siguiendo el esquema deseado: // chip: esp32 (cadena:cadena) cbor_encode_text_stringz(&map_encoder, \"chip\"); cbor_encode_text_stringz(&map_encoder, \"esp32\"); // unicore: false (cadena:booleano) cbor_encode_text_stringz(&map_encoder, \"unicore\"); cbor_encode_boolean(&map_encoder, false); // IP:[192,168,1,100] (cadena:array) cbor_encode_text_stringz(&map_encoder, \"ip\"); CborEncoder array2; cbor_encoder_create_array(&map_encoder, &array2, 4); // [ // Valores num\u00e9ricos. cbor_encode_uint(&array2, 192); cbor_encode_uint(&array2, 168); cbor_encode_uint(&array2, 1); cbor_encode_uint(&array2, 100); cbor_encoder_close_container(&map_encoder, &array2); // ] cbor_encoder_close_container(&array_encoder, &map_encoder); // } // 2. Flotante cbor_encode_float(&array_encoder, 3.14); // 3. Valor simple cbor_encode_simple_value(&array_encoder, 99); // 4. Cadena cbor_encode_text_stringz(&array_encoder, \"2019-07-10 09:00:00+0000\"); // 5. Undefined value. cbor_encode_undefined(&array_encoder); cbor_encoder_close_container(&root_encoder, &array_encoder); // ] // Mostramos el tama\u00f1o del buffer creado. ESP_LOGI(TAG, \"encoded buffer size %d\", cbor_encoder_get_buffer_size(&root_encoder, buf));","title":"Etapa 1: creaci\u00f3n (codificaci\u00f3n) del objeto CBOR"},{"location":"RPI-II/P5/#etapa-2-conversion-a-json","text":"La conversi\u00f3n a JSON (t\u00edpicamente por motivos de visualizaci\u00f3n o depuraci\u00f3n), puede realizarse del siguiente modo: // Initialize the cbor parser and the value iterator cbor_parser_init(buf, sizeof(buf), 0, &root_parser, &it); ESP_LOGI(TAG, \"convert CBOR to JSON\"); // Dump the values in JSON format cbor_value_to_json(stdout, &it, 0);","title":"Etapa 2: conversi\u00f3n a JSON"},{"location":"RPI-II/P5/#etapa-3-parseado-manual-de-un-objeto-cbor","text":"Por \u00faltimo, el parseado manual del objeto CBOR se deja como ejercicio de estudio para el alumno, y est\u00e1 implementado en la funci\u00f3n example_dump_cbor_buffer del ejemplo. B\u00e1sicamente, la funci\u00f3n itera por cada uno de los elementos del objeto CBOR, consultando el tipo de cada elemento y actuando en consecuencia. Para aquellos tipos complejos (e.g. arrays o mapas), la funci\u00f3n se invoca recursivamente hasta encontrar un elemento de tipo b\u00e1sico. En este caso, simplemente imprime por pantalla su valor (e.g. en el caso de un entero, caso CborIntegerType ). Tarea entregable Se pide extender la API REST con un nuevo endpoint que permita obtener la misma informaci\u00f3n que el endpoint JSON desarrollado en la anterior tarea, pero en esta ocasi\u00f3n, utilizando formato CBOR. El objetivo del ejercicio es comparar la cantidad de tr\u00e1fico generado en cada representaci\u00f3n, por lo que se sugiere que el objeto intercambiado sea relativamente complejo (es decir, incluya disintos tipos de datos num\u00e9ricos, arrays, o mapas). A continuaci\u00f3n se incluyen notas adicionales que te permitir\u00e1n depurar tu desarrollo, observando los valores devueltos por el servidor HTTP.","title":"Etapa 3: parseado manual de un objeto CBOR"},{"location":"RPI-II/P5/#notas-adicionales-creacion-y-consulta-de-un-endpoint-cbor-en-la-api-rest","text":"Las modificaciones a realizar en la funci\u00f3n manejadora del endpoint para responder con un objeto CBOR son m\u00ednimas. De hecho, se centran simplemente en el tipo de respuesta y el mecanismo a usar para enviarla, v\u00e9ase: static esp_err_t system_info_get_handler(httpd_req_t *req) { // Tipo de respuesta. httpd_resp_set_type(req, \"application/cbor\"); CborEncoder root_encoder; uint8_t buf[100]; // Codificador CBOR. cbor_encoder_init(&root_encoder, buf, sizeof(buf), 0); // Codificamos CBOR. // ... // Enviamos respuesta, consultando previamente el tama\u00f1o del buffer codificado. httpd_resp_send(req, (char*)buf, cbor_encoder_get_buffer_size( &root_encoder, buf)); return ESP_OK; Para consultar desde l\u00ednea de comandos sobre este endpoint , podemos utilizar directamente curl , volcando la salida recibida a un fichero (por ejemplo, output.cbor ): curl http://192.168.1.26/api/v1/system/info > output.cbor Si visualizas el contenido del fichero, ver\u00e1s que contiene datos binarios dif\u00edcilmente interpretables. A continuaci\u00f3n veremos distintos mecanismos de visualizaci\u00f3n.","title":"Notas adicionales: creaci\u00f3n y consulta de un endpoint CBOR en la API REST"},{"location":"RPI-II/P5/#notas-adicionales-visualizacion-de-datos-cbor","text":"Una opci\u00f3n de visualizaci\u00f3n consiste en utilizar la web cbor.me . En el panel derecho, podr\u00e1s pegar el contenido binario le\u00eddo. Si necesitas realizar la conversi\u00f3n antes de pegarlo en la web, puedes hacerlo con la orden: xxd -ps output.cbor Un ejemplo de salida (a pegar en el panel derecho de la web), podr\u00eda ser: $ xxd -ps output.cbor 85a3646368697065657370333267756e69636f7265f46269708418c018a8 011864fa4048f5c3f8637818323031392d30372d31302030393a30303a30 302b30303030f7 Deber\u00edas observar una salida similar a la siguiente (ten en cuenta que la herramiente autom\u00e1ticamente indenta el contenido del panel derecho; recuerda que simplemente debes pegar la salida generada por xxd ): Otra opci\u00f3n de visualizaci\u00f3n puede ser un programa Python (podr\u00edas integrarlo en tu servidor TCP/UDP, por ejemplo), que haga uso del m\u00f3dulo cbor2 ( documentaci\u00f3n ). Para comprobar su funcionamiento, primero inst\u00e1lalo: pip install cbor2 Y comprueba si efectivamente funciona utilizando el siguiente programa Python: from cbor2 import dumps, loads, dump, load with open('output.cbor', 'rb') as fp: obj = load(fp) print(obj) Al ejecutarlo, observar\u00e1s el contenido del objeto: python cbor.py [{'chip': 'esp32', 'unicore': False, 'ip': [192, 168, 1, 100]}, 3.140000104904175, CBORSimpleValue(value=99), '2019-07-10 09:00:00+0000', undefined]","title":"Notas adicionales: visualizaci\u00f3n de datos CBOR"},{"location":"RPI-II/P5/notas/","text":"Implementaci\u00f3n de una interfaz REST v\u00eda HTTP Ejemplo Ejemplo: restful_server navegar a front/webdemo apt-get install npm node-vue* npm install y npm run build en direcrorio front/web-demo idf.py build","title":"Notas"},{"location":"RPI-II/P5/notas/#implementacion-de-una-interfaz-rest-via-http","text":"","title":"Implementaci\u00f3n de una interfaz REST v\u00eda HTTP"},{"location":"RPI-II/P5/notas/#ejemplo","text":"Ejemplo: restful_server navegar a front/webdemo apt-get install npm node-vue* npm install y npm run build en direcrorio front/web-demo idf.py build","title":"Ejemplo"},{"location":"RPI-II/P6/","text":"Pr\u00e1ctica 6. El protocolo MQTT (I). Despliegue de clientes y servidores/ brokers . An\u00e1lisis de tr\u00e1fico Objetivos Familiarizarse con el uso de brokers y clientes de suscripci\u00f3n/publicaci\u00f3n utilizando MQTT. Desplegar un sistema basado en MQTT local, incluyendo broker y clientes. Utilizar Eclipse Paho para integrar funcionalidad MQTT en programas Python. Familiarizarse con el uso de wildcards MQTT. Publicaci\u00f3n/suscripci\u00f3n contra un broker en la nube En la primera parte de la pr\u00e1ctica, utilizaremos un servidor/ broker disponible en la nube para su uso libre por parte de los usuarios ( test.mosquitto.org ). Este servidor suele utilizarse con fines de pruebas b\u00e1sicas y depuraci\u00f3n, y hay que ser consciente de que toda la informaci\u00f3n que en \u00e9l se publica puede ser le\u00edda por cualquier suscriptor. Debe tenerse este dato en cuenta a la hora de publicar informaci\u00f3n sensible a trav\u00e9s de MQTT cuando se use el servidor de pruebas. El servidor escucha en los siguientes puertos: 1883 : MQTT, sin encriptaci\u00f3n. 8883 : MQTT, con encriptaci\u00f3n. 8884 : MQTT, con encriptaci\u00f3n, certificado de cliente requerido. 8080 : MQTT sobre WebSockets, sin encriptaci\u00f3n. 8081 : MQTT sobre WebSockets, con encriptaci\u00f3n. Para realizar publicaciones/suscripciones contra el broker utilizaremos la distribuci\u00f3n mosquitto del proyecto Eclipse IoT. Aunque mosquitto es principalmente una implementaci\u00f3n de broker MQTT, nosotros la utilizaremos en este paso a modo de cliente, lo que nos permitir\u00e1 suscribirnos o publicar sobre cualquier topic MQTT. En primer lugar, instala mosquitto : sudo apt-get install mosquitto mosquitto-clients mosquitto-dev libmosquitto* Si todo ha ido bien, deber\u00edas disponer de dos binarios listos para ejecuci\u00f3n: mosquitto_sub : permite suscribirse a un determinado topic utilizando un broker . mosquitto_pub : permite publicar un mensaje asociado a un determinado topic utilizando un broker . Tarea Observa la ayuda de ambas ordenes, utilizando el argumento --help . Identifica los par\u00e1metros que te permitir\u00e1n especificar el broker destino, el topic a utilizar y, en el caso de la publicaci\u00f3n, el mensaje a enviar. Suscrib\u00e1monos al topic # en el broker , utilizando para ello la orden: mosquitto_sub -h test.mosquitto.org -t \"#\" Tarea Pausa la salida en cuanto puedas. \u00bfA qu\u00e9 corresponden los mensajes que est\u00e1s obteniendo? A continuaci\u00f3n, vamos a realizar un proceso de publicaci\u00f3n/suscripcion con un topic conocido (por ejemplo, /MIOT/tunombre/ ). Para publicar un mensaje bajo dicho topic : mosquitto_pub -h test.mosquitto.org -t \"/MIOT/tunombre\" -m \"Hola, soy tunombre\" Tarea Suscr\u00edbete al topic /MIOT/tunombre y observa si recibes los resultados tras la publicaci\u00f3n correspondiente. \u00bfC\u00f3mo podr\u00edas suscribirte a todos los mensajes publicados por compa\u00f1eros? Tarea entregable Realiza un an\u00e1lisis del intercambio de mensajes necesario para un proceso de publicaci\u00f3n/suscripci\u00f3n contra el broker de test. Incide en el tipo de protocolo de capa de transporte que utiliza MQTT, mensajes de datos y control, sobrecarga del protocolo de capa de aplicaci\u00f3n, y en general, cualquier aspecto que consideres de inter\u00e9s. Despliegue de un broker local usando Eclipse Mosquitto El uso de un servidor remoto presenta ventajas (facilidad de uso), pero una gran cantidad de inconvenientes (seguridad, imposibilidad de configuraci\u00f3n avanzada, ...) En esta secci\u00f3n, configuraremos un broker mosquitto para el despliegue de una infraestructura MQTT local o remota bajo nuestro control. El arranque de un broker (servidor) mosquitto se realiza mediante el propio comando mosquitto : mosquitto [-c config file] [ -d | --daemon ] [-p port number] [-v] Sin embargo, en la mayor\u00eda de distribuciones Linux, el broker arranca por defecto y se ejecuta constantemente en segundo plano. Para comprobar el estado de funcionamiento del broker , basta con ejecutar: sudo service mosquitto status Observar\u00e1s un mensaje que indica que el servicio est\u00e1 activo. Las opciones restart , start o stop te permitir\u00e1n controlar el estado del broker en todo momento. Tarea Comprueba que, con el broker arrancado, puedes realizar un proceso de suscripci\u00f3n/publicaci\u00f3n contra el mismo. El broker mosquitto permite monitorizar sus propias estad\u00edsticas e informaci\u00f3n de estado utilizando el protocolo MQTT. As\u00ed, los topics $SYS retornan, bien peri\u00f3dicamente o bien cuando sucede un evento de inter\u00e9s, la informaci\u00f3n de estado del broker . Puedes consultar m\u00e1s detalles en la p\u00e1gina de manual de mosquitto (comando man mosquitto ), en el ep\u00edgrafe BROKER STATUS . Note Comprueba el estado del broker mientras realizas procesos de suscripci\u00f3n/publicaci\u00f3n reportando bytes recibidos/enviados, n\u00famero de conexiones activas e inactivas, y n\u00famero de mensajes enviados/recibidos por el broker . Desarrollo de un cliente local usando Eclipse Paho Los clientes mosquitto_pub y mosquitto_sub son b\u00e1sicamente herramientas de desarrollo y pruebas, pero resulta interesante conocer bibliotecas que permitan la integraci\u00f3n de MQTT en programas existentes. Una de ellas es Eclipse Paho . Paho es una infraestructura desarrollada en el proyecto Eclipse IoT para dar soporte a implementaciones de protocolos de mensajer\u00eda M2M e IoT, aunque, en este momento, su uso principal se centra exclusivamente en MQTT. En nuestro caso, utilizaremos la versi\u00f3n Python de la biblioteca, instalable v\u00eda: pip install paho-mqtt Dispones de la documentaci\u00f3n del m\u00f3dulo a trav\u00e9s de este enlace . El despliegue de un ejemplo sencillo para un cliente que se conecta a un broker y se suscribe al t\u00f3pico $SYS , imprimiendo los mensajes recibidos, resultar\u00eda, utilizando Paho, en el siguiente c\u00f3digo Python: import paho.mqtt.client as mqtt # Funcion callback invocada cuandl el cliente recibe un CONNACK desde el broker. def on_connect(client, userdata, flags, rc): print(\"Connected with result code \"+str(rc)) # Suscribirse en on_connect() asegura que si se pierde la conexi\u00f3n y # se reestablece, las suscripciones se renovar\u00e1n. client.subscribe(\"$SYS/#\") # Funcion callback al recibir un mensaje de publicacion (PUBLISH) desde el # broker. def on_message(client, userdata, msg): print(msg.topic+\" \"+str(msg.payload)) client = mqtt.Client() client.on_connect = on_connect client.on_message = on_message client.connect(\"mqtt.eclipse.org\", 1883, 60) # Llamada bloqueante que procesa el tr\u00e1fico de red, invoca callbacks # y maneja la reconexi\u00f3n al broker. client.loop_forever() La clase cliente puede utilizarse para: Crear una instancia de cliente MQTT. Conectar a un broker usando las funciones de la familia connect*() . Invocar a funciones de la familia loop*() para mantener el tr\u00e1fico de datos con el servidor. Utilizar subscribe() para suscribirse a un topic y recibir mensajes. Utilizar publish() publicar mensajes en el broker . Utilizar disconnect() para desconectar del broker . Los callbacks se invocar\u00e1n autom\u00e1ticamente para permitir el procesamiento de eventos. De entre los m\u00e1s utilizados, destacan: ON_CONNECT : invocado cuando el broker responde a nuestra petici\u00f3n de conexi\u00f3n. Ejemplo: def on_connect(client, userdata, flags, rc): print(\"Connection returned result: \"+connack_string(rc)) ON_DISCONNECT : invocado cuando el cliente se desconecta del broker . Ejemplo: def on_disconnect(client, userdata, rc): if rc != 0: print(\"Unexpected disconnection.\") ON_MESSAGE : invocado cuando se recibe un mensaje en un topic al que el cliente est\u00e1 suscrito. Ejemplo: def on_message(client, userdata, message): print(\"Received message '\" + str(message.payload) + \"' on topic '\" + message.topic + \"' with QoS \" + str(message.qos)) Para publicar de forma puntual sobre un broker (sin mantener una conexi\u00f3n establecida), es posible utilizar la siguiente secuencia de ordenes: import paho.mqtt.publish as publish publish.single(\"paho/test/single\", \"payload\", hostname=\"mqtt.eclipse.org\") Del mismo modo, podemos suscribirnos de forma puntual mediante una llamada bloqueante a: import paho.mqtt.subscribe as subscribe msg = subscribe.simple(\"paho/test/simple\", hostname=\"mqtt.eclipse.org\") print(\"%s %s\" % (msg.topic, msg.payload)) Toda la informaci\u00f3n y documentaci\u00f3n asociada al m\u00f3dulo puede consultarse aqu\u00ed . Wildcards Adem\u00e1s de permitir el uso de topics completos para el proceso de suscripci\u00f3n, los topics pueden incluir wildcards o comodines en su estructura. + es la wildcard utilizada para obtener correspondencias con un \u00fanico nivel de la jerarqu\u00eda. As\u00ed, para un topic a/b/c/d , las siguientes suscripciones corresponder\u00e1n con \u00e9xito: a/b/c/d +/b/c/d a/+/c/d a/+/+/d +/+/+/+ Pero no las siguientes: a/b/c b/+/c/d +/+/+ La segunda wildcard soportada es # , y permite corresponencias con cualquier nivel sucesivo de la jerarqu\u00eda. As\u00ed, para un topic a/b/c/d , las siguientes suscripciones corresponder\u00e1n con \u00e9xito: a/b/c/d # a/# a/b/# a/b/c/# +/b/c/# Tarea entregable Cada alumno propondr\u00e1 una soluci\u00f3n para monitorizar un edificio inteligente a trav\u00e9s de un sistema de mensajer\u00eda MQTT. Para ello, cabe destacar que el edificio constar\u00e1 de: Un identificador del tipo EDIFICIO_TUPUESTODELABORATORIO. Un conjunto de plantas, identificadas por la cadena \"P_NUMPLANTA\". En cada planta, cuatro alas (norte -N-, sur -S-, este -E-, oeste -O-) En cada ala, un conjunto de salas, identificadas por un valor num\u00e9rico. En cada sala, cuatro sensores: TEMP (temperatura), HUM (humedad), LUX (luminosidad), VIBR (vibraci\u00f3n). Se pide, en primer lugar, dise\u00f1ar la jerarqu\u00eda de topics que permita una correcta monitorizaci\u00f3n de los edificios. En segundo lugar, se desarrollar\u00e1 un programa Python cliente que publique, peri\u00f3dicamente y de forma aleatoria, objetos JSON (opcionalmente puedes utilizar CBOR) que incluyan el valor de temperatura, humedad, luminosidad o vibraci\u00f3n para una determinada sala del edificio, elegida tambi\u00e9n aleatoriamente, a trav\u00e9s del topic correspondiente. Estos mensajes estar\u00e1n espaciados en el tiempo un n\u00famero aleatorio de segundos. En tercer lugar, se piden las wildcards que permitan consultar distintos tipos de informaci\u00f3n jer\u00e1rquica. Por ejemplo: Todos los mensajes de temperatura para el edificio. Todos los mensajes de vibraci\u00f3n del ala oeste de la planta 2 del edificio. Todos los mensajes de sensorizaci\u00f3n de la sala 4 del ala Sur de la planta 7 del edificio. ... En \u00faltimo lugar, se pide desarrollar un programa Python que act\u00fae a modo de alarma, y que muestre mensajes s\u00f3lo si alg\u00fan valor recibido para los datos sensorizados supera un umbral preestablecido. En dicho caso, el programa mostrar\u00e1 el edificio, planta, ala, sala y sensor que ha producido la alarma, junto con su valor num\u00e9rico. Puedes utilizar el m\u00f3dulo JSON para parsear los objetos recibidos.","title":"Pr\u00e1ctica 6 (I)"},{"location":"RPI-II/P6/#practica-6-el-protocolo-mqtt-i-despliegue-de-clientes-y-servidoresbrokers-analisis-de-trafico","text":"","title":"Pr\u00e1ctica 6. El protocolo MQTT (I). Despliegue de clientes y servidores/brokers. An\u00e1lisis de tr\u00e1fico"},{"location":"RPI-II/P6/#objetivos","text":"Familiarizarse con el uso de brokers y clientes de suscripci\u00f3n/publicaci\u00f3n utilizando MQTT. Desplegar un sistema basado en MQTT local, incluyendo broker y clientes. Utilizar Eclipse Paho para integrar funcionalidad MQTT en programas Python. Familiarizarse con el uso de wildcards MQTT.","title":"Objetivos"},{"location":"RPI-II/P6/#publicacionsuscripcion-contra-un-broker-en-la-nube","text":"En la primera parte de la pr\u00e1ctica, utilizaremos un servidor/ broker disponible en la nube para su uso libre por parte de los usuarios ( test.mosquitto.org ). Este servidor suele utilizarse con fines de pruebas b\u00e1sicas y depuraci\u00f3n, y hay que ser consciente de que toda la informaci\u00f3n que en \u00e9l se publica puede ser le\u00edda por cualquier suscriptor. Debe tenerse este dato en cuenta a la hora de publicar informaci\u00f3n sensible a trav\u00e9s de MQTT cuando se use el servidor de pruebas. El servidor escucha en los siguientes puertos: 1883 : MQTT, sin encriptaci\u00f3n. 8883 : MQTT, con encriptaci\u00f3n. 8884 : MQTT, con encriptaci\u00f3n, certificado de cliente requerido. 8080 : MQTT sobre WebSockets, sin encriptaci\u00f3n. 8081 : MQTT sobre WebSockets, con encriptaci\u00f3n. Para realizar publicaciones/suscripciones contra el broker utilizaremos la distribuci\u00f3n mosquitto del proyecto Eclipse IoT. Aunque mosquitto es principalmente una implementaci\u00f3n de broker MQTT, nosotros la utilizaremos en este paso a modo de cliente, lo que nos permitir\u00e1 suscribirnos o publicar sobre cualquier topic MQTT. En primer lugar, instala mosquitto : sudo apt-get install mosquitto mosquitto-clients mosquitto-dev libmosquitto* Si todo ha ido bien, deber\u00edas disponer de dos binarios listos para ejecuci\u00f3n: mosquitto_sub : permite suscribirse a un determinado topic utilizando un broker . mosquitto_pub : permite publicar un mensaje asociado a un determinado topic utilizando un broker . Tarea Observa la ayuda de ambas ordenes, utilizando el argumento --help . Identifica los par\u00e1metros que te permitir\u00e1n especificar el broker destino, el topic a utilizar y, en el caso de la publicaci\u00f3n, el mensaje a enviar. Suscrib\u00e1monos al topic # en el broker , utilizando para ello la orden: mosquitto_sub -h test.mosquitto.org -t \"#\" Tarea Pausa la salida en cuanto puedas. \u00bfA qu\u00e9 corresponden los mensajes que est\u00e1s obteniendo? A continuaci\u00f3n, vamos a realizar un proceso de publicaci\u00f3n/suscripcion con un topic conocido (por ejemplo, /MIOT/tunombre/ ). Para publicar un mensaje bajo dicho topic : mosquitto_pub -h test.mosquitto.org -t \"/MIOT/tunombre\" -m \"Hola, soy tunombre\" Tarea Suscr\u00edbete al topic /MIOT/tunombre y observa si recibes los resultados tras la publicaci\u00f3n correspondiente. \u00bfC\u00f3mo podr\u00edas suscribirte a todos los mensajes publicados por compa\u00f1eros? Tarea entregable Realiza un an\u00e1lisis del intercambio de mensajes necesario para un proceso de publicaci\u00f3n/suscripci\u00f3n contra el broker de test. Incide en el tipo de protocolo de capa de transporte que utiliza MQTT, mensajes de datos y control, sobrecarga del protocolo de capa de aplicaci\u00f3n, y en general, cualquier aspecto que consideres de inter\u00e9s.","title":"Publicaci\u00f3n/suscripci\u00f3n contra un broker en la nube"},{"location":"RPI-II/P6/#despliegue-de-un-broker-local-usando-eclipse-mosquitto","text":"El uso de un servidor remoto presenta ventajas (facilidad de uso), pero una gran cantidad de inconvenientes (seguridad, imposibilidad de configuraci\u00f3n avanzada, ...) En esta secci\u00f3n, configuraremos un broker mosquitto para el despliegue de una infraestructura MQTT local o remota bajo nuestro control. El arranque de un broker (servidor) mosquitto se realiza mediante el propio comando mosquitto : mosquitto [-c config file] [ -d | --daemon ] [-p port number] [-v] Sin embargo, en la mayor\u00eda de distribuciones Linux, el broker arranca por defecto y se ejecuta constantemente en segundo plano. Para comprobar el estado de funcionamiento del broker , basta con ejecutar: sudo service mosquitto status Observar\u00e1s un mensaje que indica que el servicio est\u00e1 activo. Las opciones restart , start o stop te permitir\u00e1n controlar el estado del broker en todo momento. Tarea Comprueba que, con el broker arrancado, puedes realizar un proceso de suscripci\u00f3n/publicaci\u00f3n contra el mismo. El broker mosquitto permite monitorizar sus propias estad\u00edsticas e informaci\u00f3n de estado utilizando el protocolo MQTT. As\u00ed, los topics $SYS retornan, bien peri\u00f3dicamente o bien cuando sucede un evento de inter\u00e9s, la informaci\u00f3n de estado del broker . Puedes consultar m\u00e1s detalles en la p\u00e1gina de manual de mosquitto (comando man mosquitto ), en el ep\u00edgrafe BROKER STATUS . Note Comprueba el estado del broker mientras realizas procesos de suscripci\u00f3n/publicaci\u00f3n reportando bytes recibidos/enviados, n\u00famero de conexiones activas e inactivas, y n\u00famero de mensajes enviados/recibidos por el broker .","title":"Despliegue de un broker local usando Eclipse Mosquitto"},{"location":"RPI-II/P6/#desarrollo-de-un-cliente-local-usando-eclipse-paho","text":"Los clientes mosquitto_pub y mosquitto_sub son b\u00e1sicamente herramientas de desarrollo y pruebas, pero resulta interesante conocer bibliotecas que permitan la integraci\u00f3n de MQTT en programas existentes. Una de ellas es Eclipse Paho . Paho es una infraestructura desarrollada en el proyecto Eclipse IoT para dar soporte a implementaciones de protocolos de mensajer\u00eda M2M e IoT, aunque, en este momento, su uso principal se centra exclusivamente en MQTT. En nuestro caso, utilizaremos la versi\u00f3n Python de la biblioteca, instalable v\u00eda: pip install paho-mqtt Dispones de la documentaci\u00f3n del m\u00f3dulo a trav\u00e9s de este enlace . El despliegue de un ejemplo sencillo para un cliente que se conecta a un broker y se suscribe al t\u00f3pico $SYS , imprimiendo los mensajes recibidos, resultar\u00eda, utilizando Paho, en el siguiente c\u00f3digo Python: import paho.mqtt.client as mqtt # Funcion callback invocada cuandl el cliente recibe un CONNACK desde el broker. def on_connect(client, userdata, flags, rc): print(\"Connected with result code \"+str(rc)) # Suscribirse en on_connect() asegura que si se pierde la conexi\u00f3n y # se reestablece, las suscripciones se renovar\u00e1n. client.subscribe(\"$SYS/#\") # Funcion callback al recibir un mensaje de publicacion (PUBLISH) desde el # broker. def on_message(client, userdata, msg): print(msg.topic+\" \"+str(msg.payload)) client = mqtt.Client() client.on_connect = on_connect client.on_message = on_message client.connect(\"mqtt.eclipse.org\", 1883, 60) # Llamada bloqueante que procesa el tr\u00e1fico de red, invoca callbacks # y maneja la reconexi\u00f3n al broker. client.loop_forever() La clase cliente puede utilizarse para: Crear una instancia de cliente MQTT. Conectar a un broker usando las funciones de la familia connect*() . Invocar a funciones de la familia loop*() para mantener el tr\u00e1fico de datos con el servidor. Utilizar subscribe() para suscribirse a un topic y recibir mensajes. Utilizar publish() publicar mensajes en el broker . Utilizar disconnect() para desconectar del broker . Los callbacks se invocar\u00e1n autom\u00e1ticamente para permitir el procesamiento de eventos. De entre los m\u00e1s utilizados, destacan: ON_CONNECT : invocado cuando el broker responde a nuestra petici\u00f3n de conexi\u00f3n. Ejemplo: def on_connect(client, userdata, flags, rc): print(\"Connection returned result: \"+connack_string(rc)) ON_DISCONNECT : invocado cuando el cliente se desconecta del broker . Ejemplo: def on_disconnect(client, userdata, rc): if rc != 0: print(\"Unexpected disconnection.\") ON_MESSAGE : invocado cuando se recibe un mensaje en un topic al que el cliente est\u00e1 suscrito. Ejemplo: def on_message(client, userdata, message): print(\"Received message '\" + str(message.payload) + \"' on topic '\" + message.topic + \"' with QoS \" + str(message.qos)) Para publicar de forma puntual sobre un broker (sin mantener una conexi\u00f3n establecida), es posible utilizar la siguiente secuencia de ordenes: import paho.mqtt.publish as publish publish.single(\"paho/test/single\", \"payload\", hostname=\"mqtt.eclipse.org\") Del mismo modo, podemos suscribirnos de forma puntual mediante una llamada bloqueante a: import paho.mqtt.subscribe as subscribe msg = subscribe.simple(\"paho/test/simple\", hostname=\"mqtt.eclipse.org\") print(\"%s %s\" % (msg.topic, msg.payload)) Toda la informaci\u00f3n y documentaci\u00f3n asociada al m\u00f3dulo puede consultarse aqu\u00ed .","title":"Desarrollo de un cliente local usando Eclipse Paho"},{"location":"RPI-II/P6/#wildcards","text":"Adem\u00e1s de permitir el uso de topics completos para el proceso de suscripci\u00f3n, los topics pueden incluir wildcards o comodines en su estructura. + es la wildcard utilizada para obtener correspondencias con un \u00fanico nivel de la jerarqu\u00eda. As\u00ed, para un topic a/b/c/d , las siguientes suscripciones corresponder\u00e1n con \u00e9xito: a/b/c/d +/b/c/d a/+/c/d a/+/+/d +/+/+/+ Pero no las siguientes: a/b/c b/+/c/d +/+/+ La segunda wildcard soportada es # , y permite corresponencias con cualquier nivel sucesivo de la jerarqu\u00eda. As\u00ed, para un topic a/b/c/d , las siguientes suscripciones corresponder\u00e1n con \u00e9xito: a/b/c/d # a/# a/b/# a/b/c/# +/b/c/# Tarea entregable Cada alumno propondr\u00e1 una soluci\u00f3n para monitorizar un edificio inteligente a trav\u00e9s de un sistema de mensajer\u00eda MQTT. Para ello, cabe destacar que el edificio constar\u00e1 de: Un identificador del tipo EDIFICIO_TUPUESTODELABORATORIO. Un conjunto de plantas, identificadas por la cadena \"P_NUMPLANTA\". En cada planta, cuatro alas (norte -N-, sur -S-, este -E-, oeste -O-) En cada ala, un conjunto de salas, identificadas por un valor num\u00e9rico. En cada sala, cuatro sensores: TEMP (temperatura), HUM (humedad), LUX (luminosidad), VIBR (vibraci\u00f3n). Se pide, en primer lugar, dise\u00f1ar la jerarqu\u00eda de topics que permita una correcta monitorizaci\u00f3n de los edificios. En segundo lugar, se desarrollar\u00e1 un programa Python cliente que publique, peri\u00f3dicamente y de forma aleatoria, objetos JSON (opcionalmente puedes utilizar CBOR) que incluyan el valor de temperatura, humedad, luminosidad o vibraci\u00f3n para una determinada sala del edificio, elegida tambi\u00e9n aleatoriamente, a trav\u00e9s del topic correspondiente. Estos mensajes estar\u00e1n espaciados en el tiempo un n\u00famero aleatorio de segundos. En tercer lugar, se piden las wildcards que permitan consultar distintos tipos de informaci\u00f3n jer\u00e1rquica. Por ejemplo: Todos los mensajes de temperatura para el edificio. Todos los mensajes de vibraci\u00f3n del ala oeste de la planta 2 del edificio. Todos los mensajes de sensorizaci\u00f3n de la sala 4 del ala Sur de la planta 7 del edificio. ... En \u00faltimo lugar, se pide desarrollar un programa Python que act\u00fae a modo de alarma, y que muestre mensajes s\u00f3lo si alg\u00fan valor recibido para los datos sensorizados supera un umbral preestablecido. En dicho caso, el programa mostrar\u00e1 el edificio, planta, ala, sala y sensor que ha producido la alarma, junto con su valor num\u00e9rico. Puedes utilizar el m\u00f3dulo JSON para parsear los objetos recibidos.","title":"Wildcards"},{"location":"RPI-II/P6-II/","text":"Pr\u00e1ctica 6. El protocolo MQTT (II). Despliegue de clientes en el ESP32 Objetivos Familiarizarse con el componente MQTT en ESP-IDF. Desplegar un cliente completo MQTT en el ESP32, incluyendo rutinas de publicaci\u00f3n y suscripci\u00f3n. Implementar QoS y LWT en el ESP32. El componente MQTT en ESP-IDF El componente ESP-MQTT es una implementaci\u00f3n del protocolo MQTT en su parte cliente, que permite la implementaci\u00f3n completa de clientes MQTT en el ESP32, incluyendo rutinas de publicaci\u00f3n y suscripci\u00f3n a brokers existentes. El componente soporte MQTT sobre TCP por defecto, as\u00ed como funcionalidades avanzadas como SSL/TLS o MQTT sobre Websockets. Adem\u00e1s, permite el despliegue de m\u00faltiples instancias de cliente MQTT sobre la misma placa; el componente implementa tambi\u00e9n par\u00e1metros avanzados soportados por el protocolo MQTT, como autenticaci\u00f3n (mediante nombre de usuario y contrase\u00f1a), mensajes last will y tres niveles de calidad de servicio (QoS). Eventos Como otros componentes, la interacci\u00f3n entre el cliente MQTT y la aplicaci\u00f3n se basa en la recepci\u00f3n de eventos, entre los que destacan: MQTT_EVENT_BEFORE_CONNECT : El cliente se ha inicializado y va a comenzar el proceso de conexi\u00f3n con el broker . MQTT_EVENT_CONNECTED : El cliente ha establecido de forma exitosa una conexi\u00f3n con el broker y est\u00e1 listo para enviar y recibir datos. MQTT_EVENT_DISCONNECTED : El cliente ha abortado la conexi\u00f3n. MQTT_EVENT_SUBSCRIBED : El broker ha confirmado la petici\u00f3n de suscripci\u00f3n del cliente. Los datos contendr\u00e1n el ID del mensaje de suscripci\u00f3n. MQTT_EVENT_UNSUBSCRIBED : El broker confirma la petici\u00f3n de desuscripci\u00f3n del cliente. Los datos contendr\u00e1n el ID del mensaje de desuscripci\u00f3n . MQTT_EVENT_PUBLISHED : El broker ha acusado la recepci\u00f3n de un mensaje previamente publicado por el cliente. Este evento s\u00f3lo se producir\u00e1 cuando QoS sea 1 o 2, ya que el nivel 0 de QoS no utiliza acuses de recibo. Los datos asociados al evento contendr\u00e1n el ID del mensaje publicado. MQTT_EVENT_DATA : El cliente ha recibido un mensaje publicado en el broker . Los datos asociados al evento contienen el ID del mensaje, nombre del topic , datos recibidos y su longitud. API esp_mqtt_client_handle_t esp_mqtt_client_init(const esp_mqtt_client_config_t *config) Rutina de inicializaci\u00f3n del cliente MQTT. Devuelve un manejador de la conexi\u00f3n, o NULL en caso de error. El par\u00e1metro config es una estructura con los par\u00e1metros que regir\u00e1n la conexi\u00f3n, entre los que destacan (v\u00e9ase la documentaci\u00f3n del componente para par\u00e1metros adicionales): esp_event_loop_handle_t event_loop_handle : manejador para eventos MQTT. const char *uri : URI del broker MQTT. uint32_t port : puerto del broker MQTT. const char *username : nombre de usuario, en caso de estar soportado por el broker . const char *password : contrase\u00f1a, en caso de estar soportada por el broker . const char *lwt_topic : topic del mensaje LWT ( Last Will and Testament ). const char *lwt_msg : contenido del mensaje LWT. int lwt_qos : QoS del mensaje LWT. int lwt_retain : flag retain para el mensaje LWT. int lwt_msg_len : longitud del mensaje LWT. int keepalive : valor del temporizador de keepalive (por defecto 120 segundos). esp_err_t esp_mqtt_client_start(esp_mqtt_client_handle_t client) Rutina de arranque del cliente MQTT. Su \u00fanico par\u00e1metro es el manejador devuelto por la anterior rutina. int esp_mqtt_client_subscribe(esp_mqtt_client_handle_t client, const char *topic, int qos) Realiza la suscripci\u00f3n del cliente a un topic con el QoS determinado a trav\u00e9s de su tercer par\u00e1metro. El cliente debe estar conectado al broker para enviar el mensaje de suscripci\u00f3n. int esp_mqtt_client_unsubscribe(esp_mqtt_client_handle_t client, const char *topic) Desuscribe al cliente de un determinado topic. El ciente debe estar conectado al broker para poder enviar el mensaje correspondiente. int esp_mqtt_client_publish(esp_mqtt_client_handle_t client, const char *topic, const char *data, int len, int qos, int retain) El cliente publica un mensaje en el broker . El cliente no tiene que estar conectado al broker para enviar el mensaje de publicaci\u00f3n. En dicho caso, si qos=0 , los mensajes se descartar\u00e1n, y si qos>=1 , los mensajes se encolar\u00e1n a la espera de ser enviados. Devuelve el identificador del mensaje publicado (si qos=0 , el valor de retorno siempre ser\u00e1 0), o -1 en caso de error. Par\u00e1metros de inter\u00e9s: client : manejador del cliente MQTT. topic : topic (en forma de cadena) bajo el cual se publicar\u00e1 el mensaje. data : contenido del mensaje a publicar (es posible publicar un mensaje sin contenido, en cuyo caso se proporcionar\u00e1 un valor NULL en este par\u00e1metro). len : longitud de los datos a enviar. Si se proporciona el valor 0 , se calcula su longitud a partir de la cadena data . qos : nivel de QoS deseado. retain : flag Retain . Tarea Analiza el ejemplo examples/protocols/mqtt/tcp , y configuralo para que utilice como broker el que desplegaste en la m\u00e1quina virtual (aseg\u00farate de que tanto m\u00e1quina virtual como ESP32 pertenecen a la misma red). Realiza procesos de publicaci\u00f3n y suscripci\u00f3n en la m\u00e1quina virtual que permitan visualizar los mensajes publicados por el ESP32 en tu terminal Linux, y los mensajes publicados desde el terminal Linux en la salida de monitorizaci\u00f3n del ESP32. Modifica el ejemplo y analiza el tr\u00e1fico generado (a trav\u00e9s de Wireshark) para los siguientes casos: Publicaci\u00f3n de mensajes con niveles de QoS 0, 1 y 2. Activaci\u00f3n o desactivaci\u00f3n del flag retain en la publicaci\u00f3n desde el ESP32. Configuraci\u00f3n de un mensaje LWT con el topic /disconnected . Para ello, reduce el valor de keepalive a 10 segundos, para que la detecci\u00f3n de desconexi\u00f3n sea m\u00e1s r\u00e1pida. Deber\u00e1s observar el env\u00edo del mensaje con dicho topic transcurrido dicho tiempo desde una desconexi\u00f3n forzada del ESP32 si est\u00e1s suscrito al mismo desde tu terminal Linux. Tarea Modifica el ejemplo proporcionado para que se integre en tu entorno de monitorizaci\u00f3n de un edificio. As\u00ed, el firmware proceder\u00e1 creando una tarea que, peri\u00f3dicamente (cada interval segundos), publique un valor aleatorio para los cuatro par\u00e1metros monitorizados. Adem\u00e1s, deber\u00e1s dise\u00f1a un sistema basado en MQTT mediante el cual puedas controlar, externamente, el comportamiento del sensor, atendiendo a los siguientes criterios: El tiempo ( interval ) mediante que transcurrir\u00e1 entre publicaciones ser\u00e1 configurable a trav\u00e9s de un proceso de publicaci\u00f3n desde tu terminal Linux y suscripci\u00f3n del ESP32 a un topic determinado. La sensorizaci\u00f3n (y publicaci\u00f3n de datos) podr\u00e1 activarse o desactivarse bajo demanda a trav\u00e9s de la publicaci\u00f3n desde tu terminal Linux y suscripci\u00f3n del ESP32 a un topic determinado. Por ejemplo, imagina que tu sensor publica mensajes de sensorizaci\u00f3n en el topic /EDIFICIO_3/P_4/N/12/(TEMP|HUM|LUX|VIBR) . Para controlar el intervalo de publicaci\u00f3n de datos desde dicho ESP32 y fijarlo a 1 segundo, podr\u00edamos publicar un mensaje utilizando la orden: mosquitto_pub -t /EDIFICIO_3/P_4/N/12/interval -m \"1000\" -h IP_BROKER Para desactivar el sensor, podr\u00edamos utilizar: mosquitto_pub -t /EDIFICIO_3/P_4/N/12/disable -m \"\" -h IP_BROKER Para activar el sensor, podr\u00edamos utilizar: mosquitto_pub -t /EDIFICIO_3/P_4/N/12/enable -m \"\" -h IP_BROKER Opcionalmente, puedes ampliar tu soluci\u00f3n para que cada sensor se active o desactive individualmente bajo demanda. En este caso, elige y documenta el topic utilizado.","title":"Pr\u00e1ctica 6 (II)"},{"location":"RPI-II/P6-II/#practica-6-el-protocolo-mqtt-ii-despliegue-de-clientes-en-el-esp32","text":"","title":"Pr\u00e1ctica 6. El protocolo MQTT (II). Despliegue de clientes en el ESP32"},{"location":"RPI-II/P6-II/#objetivos","text":"Familiarizarse con el componente MQTT en ESP-IDF. Desplegar un cliente completo MQTT en el ESP32, incluyendo rutinas de publicaci\u00f3n y suscripci\u00f3n. Implementar QoS y LWT en el ESP32.","title":"Objetivos"},{"location":"RPI-II/P6-II/#el-componente-mqtt-en-esp-idf","text":"El componente ESP-MQTT es una implementaci\u00f3n del protocolo MQTT en su parte cliente, que permite la implementaci\u00f3n completa de clientes MQTT en el ESP32, incluyendo rutinas de publicaci\u00f3n y suscripci\u00f3n a brokers existentes. El componente soporte MQTT sobre TCP por defecto, as\u00ed como funcionalidades avanzadas como SSL/TLS o MQTT sobre Websockets. Adem\u00e1s, permite el despliegue de m\u00faltiples instancias de cliente MQTT sobre la misma placa; el componente implementa tambi\u00e9n par\u00e1metros avanzados soportados por el protocolo MQTT, como autenticaci\u00f3n (mediante nombre de usuario y contrase\u00f1a), mensajes last will y tres niveles de calidad de servicio (QoS).","title":"El componente MQTT en ESP-IDF"},{"location":"RPI-II/P6-II/#eventos","text":"Como otros componentes, la interacci\u00f3n entre el cliente MQTT y la aplicaci\u00f3n se basa en la recepci\u00f3n de eventos, entre los que destacan: MQTT_EVENT_BEFORE_CONNECT : El cliente se ha inicializado y va a comenzar el proceso de conexi\u00f3n con el broker . MQTT_EVENT_CONNECTED : El cliente ha establecido de forma exitosa una conexi\u00f3n con el broker y est\u00e1 listo para enviar y recibir datos. MQTT_EVENT_DISCONNECTED : El cliente ha abortado la conexi\u00f3n. MQTT_EVENT_SUBSCRIBED : El broker ha confirmado la petici\u00f3n de suscripci\u00f3n del cliente. Los datos contendr\u00e1n el ID del mensaje de suscripci\u00f3n. MQTT_EVENT_UNSUBSCRIBED : El broker confirma la petici\u00f3n de desuscripci\u00f3n del cliente. Los datos contendr\u00e1n el ID del mensaje de desuscripci\u00f3n . MQTT_EVENT_PUBLISHED : El broker ha acusado la recepci\u00f3n de un mensaje previamente publicado por el cliente. Este evento s\u00f3lo se producir\u00e1 cuando QoS sea 1 o 2, ya que el nivel 0 de QoS no utiliza acuses de recibo. Los datos asociados al evento contendr\u00e1n el ID del mensaje publicado. MQTT_EVENT_DATA : El cliente ha recibido un mensaje publicado en el broker . Los datos asociados al evento contienen el ID del mensaje, nombre del topic , datos recibidos y su longitud.","title":"Eventos"},{"location":"RPI-II/P6-II/#api","text":"esp_mqtt_client_handle_t esp_mqtt_client_init(const esp_mqtt_client_config_t *config) Rutina de inicializaci\u00f3n del cliente MQTT. Devuelve un manejador de la conexi\u00f3n, o NULL en caso de error. El par\u00e1metro config es una estructura con los par\u00e1metros que regir\u00e1n la conexi\u00f3n, entre los que destacan (v\u00e9ase la documentaci\u00f3n del componente para par\u00e1metros adicionales): esp_event_loop_handle_t event_loop_handle : manejador para eventos MQTT. const char *uri : URI del broker MQTT. uint32_t port : puerto del broker MQTT. const char *username : nombre de usuario, en caso de estar soportado por el broker . const char *password : contrase\u00f1a, en caso de estar soportada por el broker . const char *lwt_topic : topic del mensaje LWT ( Last Will and Testament ). const char *lwt_msg : contenido del mensaje LWT. int lwt_qos : QoS del mensaje LWT. int lwt_retain : flag retain para el mensaje LWT. int lwt_msg_len : longitud del mensaje LWT. int keepalive : valor del temporizador de keepalive (por defecto 120 segundos). esp_err_t esp_mqtt_client_start(esp_mqtt_client_handle_t client) Rutina de arranque del cliente MQTT. Su \u00fanico par\u00e1metro es el manejador devuelto por la anterior rutina. int esp_mqtt_client_subscribe(esp_mqtt_client_handle_t client, const char *topic, int qos) Realiza la suscripci\u00f3n del cliente a un topic con el QoS determinado a trav\u00e9s de su tercer par\u00e1metro. El cliente debe estar conectado al broker para enviar el mensaje de suscripci\u00f3n. int esp_mqtt_client_unsubscribe(esp_mqtt_client_handle_t client, const char *topic) Desuscribe al cliente de un determinado topic. El ciente debe estar conectado al broker para poder enviar el mensaje correspondiente. int esp_mqtt_client_publish(esp_mqtt_client_handle_t client, const char *topic, const char *data, int len, int qos, int retain) El cliente publica un mensaje en el broker . El cliente no tiene que estar conectado al broker para enviar el mensaje de publicaci\u00f3n. En dicho caso, si qos=0 , los mensajes se descartar\u00e1n, y si qos>=1 , los mensajes se encolar\u00e1n a la espera de ser enviados. Devuelve el identificador del mensaje publicado (si qos=0 , el valor de retorno siempre ser\u00e1 0), o -1 en caso de error. Par\u00e1metros de inter\u00e9s: client : manejador del cliente MQTT. topic : topic (en forma de cadena) bajo el cual se publicar\u00e1 el mensaje. data : contenido del mensaje a publicar (es posible publicar un mensaje sin contenido, en cuyo caso se proporcionar\u00e1 un valor NULL en este par\u00e1metro). len : longitud de los datos a enviar. Si se proporciona el valor 0 , se calcula su longitud a partir de la cadena data . qos : nivel de QoS deseado. retain : flag Retain . Tarea Analiza el ejemplo examples/protocols/mqtt/tcp , y configuralo para que utilice como broker el que desplegaste en la m\u00e1quina virtual (aseg\u00farate de que tanto m\u00e1quina virtual como ESP32 pertenecen a la misma red). Realiza procesos de publicaci\u00f3n y suscripci\u00f3n en la m\u00e1quina virtual que permitan visualizar los mensajes publicados por el ESP32 en tu terminal Linux, y los mensajes publicados desde el terminal Linux en la salida de monitorizaci\u00f3n del ESP32. Modifica el ejemplo y analiza el tr\u00e1fico generado (a trav\u00e9s de Wireshark) para los siguientes casos: Publicaci\u00f3n de mensajes con niveles de QoS 0, 1 y 2. Activaci\u00f3n o desactivaci\u00f3n del flag retain en la publicaci\u00f3n desde el ESP32. Configuraci\u00f3n de un mensaje LWT con el topic /disconnected . Para ello, reduce el valor de keepalive a 10 segundos, para que la detecci\u00f3n de desconexi\u00f3n sea m\u00e1s r\u00e1pida. Deber\u00e1s observar el env\u00edo del mensaje con dicho topic transcurrido dicho tiempo desde una desconexi\u00f3n forzada del ESP32 si est\u00e1s suscrito al mismo desde tu terminal Linux. Tarea Modifica el ejemplo proporcionado para que se integre en tu entorno de monitorizaci\u00f3n de un edificio. As\u00ed, el firmware proceder\u00e1 creando una tarea que, peri\u00f3dicamente (cada interval segundos), publique un valor aleatorio para los cuatro par\u00e1metros monitorizados. Adem\u00e1s, deber\u00e1s dise\u00f1a un sistema basado en MQTT mediante el cual puedas controlar, externamente, el comportamiento del sensor, atendiendo a los siguientes criterios: El tiempo ( interval ) mediante que transcurrir\u00e1 entre publicaciones ser\u00e1 configurable a trav\u00e9s de un proceso de publicaci\u00f3n desde tu terminal Linux y suscripci\u00f3n del ESP32 a un topic determinado. La sensorizaci\u00f3n (y publicaci\u00f3n de datos) podr\u00e1 activarse o desactivarse bajo demanda a trav\u00e9s de la publicaci\u00f3n desde tu terminal Linux y suscripci\u00f3n del ESP32 a un topic determinado. Por ejemplo, imagina que tu sensor publica mensajes de sensorizaci\u00f3n en el topic /EDIFICIO_3/P_4/N/12/(TEMP|HUM|LUX|VIBR) . Para controlar el intervalo de publicaci\u00f3n de datos desde dicho ESP32 y fijarlo a 1 segundo, podr\u00edamos publicar un mensaje utilizando la orden: mosquitto_pub -t /EDIFICIO_3/P_4/N/12/interval -m \"1000\" -h IP_BROKER Para desactivar el sensor, podr\u00edamos utilizar: mosquitto_pub -t /EDIFICIO_3/P_4/N/12/disable -m \"\" -h IP_BROKER Para activar el sensor, podr\u00edamos utilizar: mosquitto_pub -t /EDIFICIO_3/P_4/N/12/enable -m \"\" -h IP_BROKER Opcionalmente, puedes ampliar tu soluci\u00f3n para que cada sensor se active o desactive individualmente bajo demanda. En este caso, elige y documenta el topic utilizado.","title":"API"},{"location":"RPI-II/P7/","text":"Pr\u00e1ctica 7. El protocolo CoAP Objetivos El objetivo de esta pr\u00e1ctica es realizar una introducci\u00f3n al protocolo CoAP, uno de los m\u00e1s extendidos a d\u00eda de hoy para llevar a cabo comunicaciones M2M. Los objetivos did\u00e1cticos de la pr\u00e1ctica son: Entender la estructura cliente-servidor del protocolo CoAP. Comprender los mensajes utilizados para establecer una comunicaci\u00f3n CoAP, tanto a nivel de sintaxis como de sem\u00e1ntica. Modificar una aplicaci\u00f3n cliente/servidor ejemplo basada en libcoap que realice una comunicaci\u00f3n sencilla a trav\u00e9s del protocolo CoAP en un entorno Linux. Estudiar el componente libcoap en ESP-IDF para reproducir el comportamiento del servidor CoAP para ofrecer su fucionalidad desde un ESP32. Instalaci\u00f3n y requisitos previos En esta pr\u00e1ctica realizaremos un estudio del protocolo CoAP utilizando una implementaci\u00f3n ya desarrollada para un sistema cliente/servidor que hace uso del protocolo CoAP, distribuida a trav\u00e9s de la biblioteca libcoap . N\u00f3tese que se trata de una pr\u00e1ctica introductoria, ya que el protocolo CoAP se utilizar\u00e1, en sucesivas pr\u00e1cticas, para dar soporte a protocolos de m\u00e1s alto nivel (principalmente LWM2M). El objetivo principal de la pr\u00e1ctica es, pues, introducir a alto nivel las caracter\u00edsticas de CoAP como protocolo de capa de aplicaci\u00f3n, as\u00ed como ser capaces de interactuar con un servidor existente a trav\u00e9s de herramientas ya desarrolladas. De forma adicional, se estudiar\u00e1 la posibilidad de implementar un servidor CoAP en el ESP32. Instalaci\u00f3n de requisitos adicionales y libcoap En primer lugar, instalemos los prerequisitos necesarios para hacer funcionar {\\tt libcoap}. Para ello, en la m\u00e1quina virtual, ejecutaremos las siguientes \u00f3rdenes: sudo apt-get update sudo apt-get install libtool Procedemos ahora con la instalaci\u00f3n de {\\tt libcoap}. Para ello, descarga la \u00faltima versi\u00f3n de la biblioteca desde la p\u00e1gina web del proyecto, descompr\u00edmelo y pasa a la fase de compilaci\u00f3n e instalaci\u00f3n: sh autogen.sh ./configure --enable-examples --enable-dtls --with-openssl --disable-documentation make make install Si no hay ning\u00fan error, libcoap se habr\u00e1 instalado con \u00e9xito. Ser\u00e1 de especial inter\u00e9s para nosotros la instalaci\u00f3n de programas servidor ( coap-server ) y cliente ( coap-client ) de ejemplo en el directorio examples . Tarea Ejecuta los programas servidor y cliente CoAP del directorio examples . Estudia sus opciones y par\u00e1metros de configuraci\u00f3n. \u00bfEn qu\u00e9 puertos y bajo qu\u00e9 protocolos escucha el servidor CoAP tras su arranque? Intercambio de mensajes CoAP Tarea entregable En la presente secci\u00f3n se proponen distintos intercambios de mensajes CoAP entre el cliente y el servidor de ejemplo proporcionados como parte de la instalaci\u00f3n de libcoap . Para cada uno de ellos, se pide un estudio b\u00e1sico de los paquetes intercambiados, haciendo especial hincapi\u00e9 en la pila de protocolos utilizados, contenido de los paquetes y n\u00famero de paquetes intercambiados. Este estudio, incluyendo capturas y comentarios adicionales, conformar\u00e1 el entregable asociado a la pr\u00e1ctica. Arranque del servidor CoAP En primer lugar, realizaremos un intercambio b\u00e1sico de mensajes CoAP entre el cliente y el servidor. Para ello, abriremos dos terminales desde las que ejecutaremos, respectivamente, el servidor y el cliente. Tarea Investiga las opciones disponibles en el cliente y servidor con respecto a la cantidad de mensajes de depuraci\u00f3n a mostrar. Ejecuta el servidor CoAP con suficiente nivel de detalle en los mensajes de depuraci\u00f3n. Una vez arrancado el servidor, ejecuta la orden correspondiente desde l\u00ednea de \u00f3rdenes para averiguar qu\u00e9 puertos ha abierto, y por tanto c\u00f3mo nos podemos comunicar con \u00e9l. Averigua si estos puertos son bien conocidos well-known , valor menor a 1024) y, en su caso, c\u00f3mo pueden modificarse. Obtenci\u00f3n de informaci\u00f3n del servidor ( Resource Discovery ) En primer lugar, obtendremos la informaci\u00f3n sobre los recursos disponibles en el servidor CoAP. Para ello, realizaremos una petici\u00f3n GET sobre el recurso /.well-known/core del servidor. Esta transacci\u00f3n nos devolver\u00e1 los recursos disponibles en el mismo, as\u00ed como algunas caracter\u00edsticas adicionales. Tarea \u00bfQu\u00e9 recursos est\u00e1n disponibles en el servidor? Estudia el c\u00f3digo fuente del mismo para observar la correlaci\u00f3n entre los recursos descubiertos y los programados en el c\u00f3digo. Averigua el significado de los atributos rt , ct , if y *title. Obtenci\u00f3n de informaci\u00f3n desde recursos Utilizando el cliente CoAP proporcionado, resulta sencillo realizar consultas para obtener datos desde el servidor. Para ello, utilizaremos la acci\u00f3n (verbo) {\\tt GET}, seguido del recurso a consultar y, opcionalmente, de una consulta concreta. Tarea Consulta la marca de tiempo proporcionada por el servidor en modo legible (por ejemplo, Dec 13 14:20:43 ), y tambi\u00e9n en forma de ticks de reloj, utilizando la consulta adecuada. \u00bfQu\u00e9 valor de retorno (c\u00f3digo) incluye la respuesta CoAP si el proceso ha tenido \u00e9xito? Modificaci\u00f3n de recursos Al igual que con el verbo GET, es posible realizar modificaciones en el servidor utilizando el verbo PUT. Consulta la ayuda del cliente proporcionado para observar alg\u00fan ejemplo que d\u00e9 soporte a esta funcionalidad. Tarea Modifica la marca de tiempo que proporciona el servidor CoAP. \u00bfQu\u00e9 valor de retorno (c\u00f3digo) incluye la respuesta CoAP si el proceso ha tenido \u00e9xito? Eliminaci\u00f3n y creaci\u00f3n de recursos Es posible eliminar un determinado recurso (en el ejemplo, el temporizador), utilizando el verbo DELETE . Investiga c\u00f3mo hacerlo desde el cliente proporcionado. Tarea Elimina el recurso time del servidor y, a continuaci\u00f3n, modifica la marca de tiempo mediante una orden PUT }. \u00bfQu\u00e9 valores de retorno (c\u00f3digo) se devuelven en ambos casos?} Suscripci\u00f3n (observaci\u00f3n) de recursos Es posible suscribirse a los cambios en el valor de un recurso utilizando la opci\u00f3n -s del cliente. Tarea Activa la observaci\u00f3n sobre el recurso time del servidor y analiza tanto la frecuencia de respuesta como el intercambio de mensajes producido (a trav\u00e9s de Wireshark ). \u00bfSe producen peticiones peri\u00f3dicas usando GET ? CoAP sobre TCP Alternativamente, CoAP puede funcionar utilizando el protocolo de capa de transporte TCP. En este caso, como es l\u00f3gico, se establecer\u00e1 una conexi\u00f3n entre cliente y servidor previa a cualquier intercambio de datos. Tarea Fuerza el uso de TCP en el cliente mediante la opci\u00f3n correspondiente y estudia las principales diferencias entre los mensajes intercambiados con respecto al uso de UDP. \u00bfCu\u00e1l es la eficiencia al utilizar UDP y TCP como protocolos de transporte para CoAP? Tareas entregables Tarea entregable Deber\u00e1s entregar una memoria en la que se incida en detalles observados y aprendidos acerca del protocolo CoAP, con especial atenci\u00f3n a las capturas obtenidas a trav\u00e9s de Wireshark. Tarea entregable Estudia el c\u00f3digo del servidor proporcionado, especialmente de la funci\u00f3n init_resources , y a\u00f1ade un nuevo recurso llamado temperature . Este recurso aceptar\u00e1 dos consultas distintas: ?celsius (consulta por defecto) devolver\u00e1 el valor de temperatura expresado en grados cent\u00edgrados, mientras que \\tt fahrenheit devolver\u00e1 la temperatura en grados Fahrenheit. En este caso, el valor de temperatura se obtendr\u00e1 directamente a trav\u00e9s de un n\u00famero aleatorio, pero se valorar\u00e1 su obtenci\u00f3n a partir de un sensor real. Tarea entregable ESP-IDF incluye un port de libcoap . El ejemplo examples/protocols/coap_server implementa un servidor CoAP b\u00e1sico, con un s\u00f3lo recurso (puedes consultarlo t\u00fa mismo/a obteniendo la informaci\u00f3n del recurso /well-known/core ). Analiza el c\u00f3digo y observa que la biblioteca libcoap se utiliza de forma exacta a como has estudiado en el c\u00f3digo del servidor de ejemplo. Se pide modificar el firmware para dar soporte al recurso time de forma id\u00e9ntica (con la misma sem\u00e1ntica) que la utilizada en el host .","title":"Pr\u00e1ctica 7"},{"location":"RPI-II/P7/#practica-7-el-protocolo-coap","text":"","title":"Pr\u00e1ctica 7. El protocolo CoAP"},{"location":"RPI-II/P7/#objetivos","text":"El objetivo de esta pr\u00e1ctica es realizar una introducci\u00f3n al protocolo CoAP, uno de los m\u00e1s extendidos a d\u00eda de hoy para llevar a cabo comunicaciones M2M. Los objetivos did\u00e1cticos de la pr\u00e1ctica son: Entender la estructura cliente-servidor del protocolo CoAP. Comprender los mensajes utilizados para establecer una comunicaci\u00f3n CoAP, tanto a nivel de sintaxis como de sem\u00e1ntica. Modificar una aplicaci\u00f3n cliente/servidor ejemplo basada en libcoap que realice una comunicaci\u00f3n sencilla a trav\u00e9s del protocolo CoAP en un entorno Linux. Estudiar el componente libcoap en ESP-IDF para reproducir el comportamiento del servidor CoAP para ofrecer su fucionalidad desde un ESP32.","title":"Objetivos"},{"location":"RPI-II/P7/#instalacion-y-requisitos-previos","text":"En esta pr\u00e1ctica realizaremos un estudio del protocolo CoAP utilizando una implementaci\u00f3n ya desarrollada para un sistema cliente/servidor que hace uso del protocolo CoAP, distribuida a trav\u00e9s de la biblioteca libcoap . N\u00f3tese que se trata de una pr\u00e1ctica introductoria, ya que el protocolo CoAP se utilizar\u00e1, en sucesivas pr\u00e1cticas, para dar soporte a protocolos de m\u00e1s alto nivel (principalmente LWM2M). El objetivo principal de la pr\u00e1ctica es, pues, introducir a alto nivel las caracter\u00edsticas de CoAP como protocolo de capa de aplicaci\u00f3n, as\u00ed como ser capaces de interactuar con un servidor existente a trav\u00e9s de herramientas ya desarrolladas. De forma adicional, se estudiar\u00e1 la posibilidad de implementar un servidor CoAP en el ESP32.","title":"Instalaci\u00f3n y requisitos previos"},{"location":"RPI-II/P7/#instalacion-de-requisitos-adicionales-y-libcoap","text":"En primer lugar, instalemos los prerequisitos necesarios para hacer funcionar {\\tt libcoap}. Para ello, en la m\u00e1quina virtual, ejecutaremos las siguientes \u00f3rdenes: sudo apt-get update sudo apt-get install libtool Procedemos ahora con la instalaci\u00f3n de {\\tt libcoap}. Para ello, descarga la \u00faltima versi\u00f3n de la biblioteca desde la p\u00e1gina web del proyecto, descompr\u00edmelo y pasa a la fase de compilaci\u00f3n e instalaci\u00f3n: sh autogen.sh ./configure --enable-examples --enable-dtls --with-openssl --disable-documentation make make install Si no hay ning\u00fan error, libcoap se habr\u00e1 instalado con \u00e9xito. Ser\u00e1 de especial inter\u00e9s para nosotros la instalaci\u00f3n de programas servidor ( coap-server ) y cliente ( coap-client ) de ejemplo en el directorio examples . Tarea Ejecuta los programas servidor y cliente CoAP del directorio examples . Estudia sus opciones y par\u00e1metros de configuraci\u00f3n. \u00bfEn qu\u00e9 puertos y bajo qu\u00e9 protocolos escucha el servidor CoAP tras su arranque?","title":"Instalaci\u00f3n de requisitos adicionales y libcoap"},{"location":"RPI-II/P7/#intercambio-de-mensajes-coap","text":"Tarea entregable En la presente secci\u00f3n se proponen distintos intercambios de mensajes CoAP entre el cliente y el servidor de ejemplo proporcionados como parte de la instalaci\u00f3n de libcoap . Para cada uno de ellos, se pide un estudio b\u00e1sico de los paquetes intercambiados, haciendo especial hincapi\u00e9 en la pila de protocolos utilizados, contenido de los paquetes y n\u00famero de paquetes intercambiados. Este estudio, incluyendo capturas y comentarios adicionales, conformar\u00e1 el entregable asociado a la pr\u00e1ctica.","title":"Intercambio de mensajes CoAP"},{"location":"RPI-II/P7/#arranque-del-servidor-coap","text":"En primer lugar, realizaremos un intercambio b\u00e1sico de mensajes CoAP entre el cliente y el servidor. Para ello, abriremos dos terminales desde las que ejecutaremos, respectivamente, el servidor y el cliente. Tarea Investiga las opciones disponibles en el cliente y servidor con respecto a la cantidad de mensajes de depuraci\u00f3n a mostrar. Ejecuta el servidor CoAP con suficiente nivel de detalle en los mensajes de depuraci\u00f3n. Una vez arrancado el servidor, ejecuta la orden correspondiente desde l\u00ednea de \u00f3rdenes para averiguar qu\u00e9 puertos ha abierto, y por tanto c\u00f3mo nos podemos comunicar con \u00e9l. Averigua si estos puertos son bien conocidos well-known , valor menor a 1024) y, en su caso, c\u00f3mo pueden modificarse.","title":"Arranque del servidor CoAP"},{"location":"RPI-II/P7/#obtencion-de-informacion-del-servidor-resource-discovery","text":"En primer lugar, obtendremos la informaci\u00f3n sobre los recursos disponibles en el servidor CoAP. Para ello, realizaremos una petici\u00f3n GET sobre el recurso /.well-known/core del servidor. Esta transacci\u00f3n nos devolver\u00e1 los recursos disponibles en el mismo, as\u00ed como algunas caracter\u00edsticas adicionales. Tarea \u00bfQu\u00e9 recursos est\u00e1n disponibles en el servidor? Estudia el c\u00f3digo fuente del mismo para observar la correlaci\u00f3n entre los recursos descubiertos y los programados en el c\u00f3digo. Averigua el significado de los atributos rt , ct , if y *title.","title":"Obtenci\u00f3n de informaci\u00f3n del servidor (Resource Discovery)"},{"location":"RPI-II/P7/#obtencion-de-informacion-desde-recursos","text":"Utilizando el cliente CoAP proporcionado, resulta sencillo realizar consultas para obtener datos desde el servidor. Para ello, utilizaremos la acci\u00f3n (verbo) {\\tt GET}, seguido del recurso a consultar y, opcionalmente, de una consulta concreta. Tarea Consulta la marca de tiempo proporcionada por el servidor en modo legible (por ejemplo, Dec 13 14:20:43 ), y tambi\u00e9n en forma de ticks de reloj, utilizando la consulta adecuada. \u00bfQu\u00e9 valor de retorno (c\u00f3digo) incluye la respuesta CoAP si el proceso ha tenido \u00e9xito?","title":"Obtenci\u00f3n de informaci\u00f3n desde recursos"},{"location":"RPI-II/P7/#modificacion-de-recursos","text":"Al igual que con el verbo GET, es posible realizar modificaciones en el servidor utilizando el verbo PUT. Consulta la ayuda del cliente proporcionado para observar alg\u00fan ejemplo que d\u00e9 soporte a esta funcionalidad. Tarea Modifica la marca de tiempo que proporciona el servidor CoAP. \u00bfQu\u00e9 valor de retorno (c\u00f3digo) incluye la respuesta CoAP si el proceso ha tenido \u00e9xito?","title":"Modificaci\u00f3n de recursos"},{"location":"RPI-II/P7/#eliminacion-y-creacion-de-recursos","text":"Es posible eliminar un determinado recurso (en el ejemplo, el temporizador), utilizando el verbo DELETE . Investiga c\u00f3mo hacerlo desde el cliente proporcionado. Tarea Elimina el recurso time del servidor y, a continuaci\u00f3n, modifica la marca de tiempo mediante una orden PUT }. \u00bfQu\u00e9 valores de retorno (c\u00f3digo) se devuelven en ambos casos?}","title":"Eliminaci\u00f3n y creaci\u00f3n de recursos"},{"location":"RPI-II/P7/#suscripcion-observacion-de-recursos","text":"Es posible suscribirse a los cambios en el valor de un recurso utilizando la opci\u00f3n -s del cliente. Tarea Activa la observaci\u00f3n sobre el recurso time del servidor y analiza tanto la frecuencia de respuesta como el intercambio de mensajes producido (a trav\u00e9s de Wireshark ). \u00bfSe producen peticiones peri\u00f3dicas usando GET ?","title":"Suscripci\u00f3n (observaci\u00f3n) de recursos"},{"location":"RPI-II/P7/#coap-sobre-tcp","text":"Alternativamente, CoAP puede funcionar utilizando el protocolo de capa de transporte TCP. En este caso, como es l\u00f3gico, se establecer\u00e1 una conexi\u00f3n entre cliente y servidor previa a cualquier intercambio de datos. Tarea Fuerza el uso de TCP en el cliente mediante la opci\u00f3n correspondiente y estudia las principales diferencias entre los mensajes intercambiados con respecto al uso de UDP. \u00bfCu\u00e1l es la eficiencia al utilizar UDP y TCP como protocolos de transporte para CoAP?","title":"CoAP sobre TCP"},{"location":"RPI-II/P7/#tareas-entregables","text":"Tarea entregable Deber\u00e1s entregar una memoria en la que se incida en detalles observados y aprendidos acerca del protocolo CoAP, con especial atenci\u00f3n a las capturas obtenidas a trav\u00e9s de Wireshark. Tarea entregable Estudia el c\u00f3digo del servidor proporcionado, especialmente de la funci\u00f3n init_resources , y a\u00f1ade un nuevo recurso llamado temperature . Este recurso aceptar\u00e1 dos consultas distintas: ?celsius (consulta por defecto) devolver\u00e1 el valor de temperatura expresado en grados cent\u00edgrados, mientras que \\tt fahrenheit devolver\u00e1 la temperatura en grados Fahrenheit. En este caso, el valor de temperatura se obtendr\u00e1 directamente a trav\u00e9s de un n\u00famero aleatorio, pero se valorar\u00e1 su obtenci\u00f3n a partir de un sensor real. Tarea entregable ESP-IDF incluye un port de libcoap . El ejemplo examples/protocols/coap_server implementa un servidor CoAP b\u00e1sico, con un s\u00f3lo recurso (puedes consultarlo t\u00fa mismo/a obteniendo la informaci\u00f3n del recurso /well-known/core ). Analiza el c\u00f3digo y observa que la biblioteca libcoap se utiliza de forma exacta a como has estudiado en el c\u00f3digo del servidor de ejemplo. Se pide modificar el firmware para dar soporte al recurso time de forma id\u00e9ntica (con la misma sem\u00e1ntica) que la utilizada en el host .","title":"Tareas entregables"},{"location":"RPI-II/P8/","text":"Pr\u00e1ctica 8. El protocolo LWM2M Objetivos Familiarizarse con el protocolo LWM2M, tanto en la interacci\u00f3n con servidores como en la generaci\u00f3n y definici\u00f3n de objetos y recursos. Familiarizarse con el protocolo de bootstrapping LWM2M y entender su importancia en entornos reales. Conocer dos herramientas para el desarrollo de sistemas basados en LWM2M: Wakaama y Leshan. Experimentar con el proceso de definici\u00f3n de objetos en Wakaama. Observar y poner en marcha un proceso de provisionamiento ( bootstrapping ) usando Wakaama. Desplegar servidores locales LWM2M usando tanto Wakaama como Leshan. El protocolo LWM2M OMA Lightweight M2M (LWM2M) es un protocolo impulsado por la Open Mobile Alliance para la comunicaci\u00f3n M2M entre dispositivos y su gesti\u00f3n en entornos IoT. LWM2M est\u00e1 construido sobre el protocolo CoAP, y soporta, a nivel de transporte, el protocolo UDP (tambi\u00e9n presenta soporte para SMS). Entre las funcionalidades b\u00e1sicas de LWM2M destacan la existencia de servidores LWM2M, bootstrapping , control de acceso, gesti\u00f3n de dispositivos, actualizaciones de firmware , localizaci\u00f3n o estad\u00edsticas de conectividad. Adem\u00e1s, soporta seguridad a trav\u00e9s de DTLS. Concretamente, la primera especificaci\u00f3n de LWM2M (versi\u00f3n 1.0) introdujo las siguientes caracter\u00edsticas b\u00e1sicas: Definici\u00f3n de un modelo simple para la definici\u00f3n de recursos, basado en objetos. Definici\u00f3n de operaciones de creaci\u00f3n, consulta, modificaci\u00f3n, borrado y configuraci\u00f3n de recursos. Observaci\u00f3n/notificaci\u00f3n sobre recursos. Soporte para formato de datos JSON, texto plano y TLV. Colas de mensajes para soportar modos de bajo consumo en dispositivos. Soporte para m\u00faltiples servidores LWM2M. Objetos b\u00e1sicos LWM2M: Seguridad, Servidor, Control de Acceso, Dispositivo, Conectividad, Actualizaci\u00f3n de Firmware, Localizaci\u00f3n, Estad\u00edsticas de Conectividad. Para m\u00e1s informaci\u00f3n sobre los objetos predefinidos, consulta el siguiente enlace . Versiones subsiguientes del protocolo (1.1 y 1.2) introdujeron caracter\u00edsticas adicionales, como por ejemplo: Mejora del proceso de bootstrapping . Mejora del soporte para PKI. Soporte para TCP/TLS. Soporte para CBOR. Soporte para MQTT y HTTP como protocolos subyacentes. Implementaciones LWM2M En la presente pr\u00e1ctica, utilizaremos dos paquetes de software pertenecientes al proyecto Eclipse IoT, ambos con soporte completo para LWM2M. Cada uno de ellos presenta ventajas e inconvenientes que es necesario conocer. Eclipse Wakaama Eclipse Wakaama es un conjunto de ficheros fuente escritos en C que permiten ser integrados en cualquier proyecto para proporcionar funcionalidad de cliente , servidor y servidor de bootstrap LWM2M hasta su versi\u00f3n 1.1. En el lado cliente, Wakaama permite la definici\u00f3n de objetos conforme al est\u00e1ndar, as\u00ed como la recepci\u00f3n de comandos desde servidores y su enrutado hacia el objeto u objetos correspondientes. Desde el punto de vista servidor, Wakaama proporciona APIs para enviar comandos a clientes LWM2M registrados. Todo el proyecto es compatible con POSIX, y en esta pr\u00e1ctica experimentaremos con su funcionalidad trabajando desde Linux (modo cliente, servidor y servidor de bootstrap ) y desde el ESP32 (modo cliente). Instalaci\u00f3n Utilizaremos una versi\u00f3n espec\u00edfica que permitir\u00e1 ser ejecutada tanto en Linux como en el ESP32. Para ello, clonamos en primer lugar la versi\u00f3n correspondiente del proyecto (es importante que utilices este commit espec\u00edfico): git clone https://github.com/eclipse/wakaama.git cd wakaama git reset --hard 31d64c0c41fae9653c1fa53ef58d1a44e49017fa El proyecto Wakaama proporciona cuatro componentes que utilizaremos durante la pr\u00e1ctica, todos dentro del directorio examples : bootstrap_server : implementa un servidor de bootstrap con l\u00ednea de comandos propia. client : implementa un cliente complejo, con definici\u00f3n de nueve objetos que siguen las especificaciones de la OMA m\u00e1s uno propio, y soporte para bootstrapping . lightclient : implementa un cliente sencillo, con definici\u00f3n de tres objetos seg\u00fan especificaciones OMA y un cuarto objeto propio. server : implementa un servidor LWM2M que ofrece l\u00ednea de comandos para la interacci\u00f3n con clientes registrados. El modo de compilar cada uno de los ejemplos es exactamente el mismo: Dir\u00edgete al directorio del ejemplo. Crea un directorio build y accede a \u00e9l. Configura el proyecto con la orden cmake .. . Compila el ejemplo con la orden make . Si todo ha ido bien, deber\u00edas tener un binario distinto en el directorio build correspondiente, con los que trabajar\u00e1s el resto de la pr\u00e1ctica. Tarea Compila cada uno de los ejemplos anteriormente mencionados en tu m\u00e1quina virtual, utilizando los par\u00e1metros por defecto para cada uno de ellos. Eclipse Leshan Eclipse Leshan es un proyecto alternativo que proporciona implementaciones en Java de clientes, servidores y servidores de bootstrap LWM2M, y est\u00e1 especialmente dise\u00f1ado para ser adaptable y extensible, permitiendo a los desarrolladores implementar sus propias versiones de cada uno de los tres anteriores elmentos adaptados a sus necesidades espec\u00edficas. Al igual que Wakaama, Leshan proporciona la definici\u00f3n e interacci\u00f3n con objetos IPSO, construcci\u00f3n sobre DTLS y utilizaci\u00f3n de CoAP como protocolo subyacente. Adem\u00e1s, el proyecto proporciona dos servidores de test que resultan muy \u00fatiles a la hora de desarrollar, v\u00e9ase: Servidor LWM2M en leshan.eclipseprojects.io , disponible en coap://leshan.eclipseprojects.io:5683 y coaps://leshan.eclipseprojects.io:5684 . Servidor de bootstrap en leshan.eclipseprojects.io/bs , disponible en coap://leshan.eclipseprojects.io:5783 y coaps://leshan.eclipseprojects.io:5784 . Instalaci\u00f3n Instala en primer lugar los prerequisitos necesarios para la correcta instalaci\u00f3n de Leshan (pueden variar en funci\u00f3n de tu distribuci\u00f3n Linux): sudo apt-get update sudo apt-get install openjdk-14-jdk maven git-core Clona el repositorio oficial de Leshan desde la siguiente direcci\u00f3n: git clone https://github.com/eclipse/leshan.git Por \u00faltimo, compila el proyecto: cd leshan mvn clean install Tras la fase de instalaci\u00f3n, podr\u00e1s lanzar tanto el servidor LWM2M: java -jar leshan-server-demo/target/leshan-server-demo-*-SNAPSHOT-jar-with-dependencies.jar La opci\u00f3n -h te permitir\u00e1 observar la ayuda del servidor. Como el servidor de bootstrapping : java -jar leshan-bsserver-demo/target/leshan-bsserver-demo-*-SNAPSHOT-jar-with-dependencies.jar La opci\u00f3n -h te permitir\u00e1 observar la ayuda del servidor. En ambos casos, la salida asociada a la ejecuci\u00f3n de los servidores nos indicar\u00e1n la URL que podremos consultar desde cualquier navegador para obtener informaci\u00f3n del mismo, as\u00ed como la URL y puerto de escucha de cada uno, que deberemos indicar en los clientes correspondientes. Tarea Instala Eclipse Leshan y arranca el servidor LWM2M. Accede a la p\u00e1gina web de gesti\u00f3n y comprueba que efectivamente funciona. A continucaci\u00f3n, detenlo y haz lo propio con el servidor de bootstrapping . Eclipse Wakaama. Cliente y servidor LWM2M El objetivo principal de esta parte de la pr\u00e1ctica ser\u00e1 disponer de un sistema completo LWM2M basado en un cliente y dos servidores (uno LWM2M, otro de bootstrapping ), todos funcionando bajo Eclipse Wakaama. Para ello, en primer lugar, arrancaremos el servidor Wakaama en una de las terminales. Observa que el servidor, tras arrancar, expone una sencilla l\u00ednea de comandos que podemos aprovechar para interactuar con \u00e9l: ./lwm2mserver > help help Type 'help [COMMAND]' for more details on a command. list List registered clients. read Read from a client. disc Discover resources of a client. write Write to a client. time Write time-related attributes to a client. attr Write value-related attributes to a client. clear Clear attributes of a client. exec Execute a client resource. del Delete a client Object instance. create Create an Object instance. observe Observe from a client. cancel Cancel an observe. q Quit the server. La orden help muestra la ayuda global, pudi\u00e9ndose especializar para cada comando concreto: > help read read CLIENT# URI CLIENT#: client number as returned by command 'list' URI: uri to read such as /3, /3/0/2, /1024/11, /1024/0/1 Result will be displayed asynchronously. Si en este instante listamos un los clientes registrados, veremos que no hay ninguno: > list No client. En segundo lugar, vamos a arrancar el cliente Wakaama. Por defecto, este cliente intentar\u00e1 conectar con un servidor LWM2M existente en localhost , puerto 5683. En cualquier caso, estos valores pueden modificarse en la propia invocaci\u00f3n (consulta la opci\u00f3n -h para m\u00e1s informaci\u00f3n sobre par\u00e1metros disponibles): ./lwm2mclient Trying to bind LWM2M Client to port 56830 LWM2M Client \"testlwm2mclient\" started on port 56830 > Opening connection to server at ::1:5683 -> State: STATE_REGISTERING 13 bytes received from [::1]:5683 64 41 69 06 06 69 E8 86 82 72 64 01 30 dAi..i...rd.0 -> State: STATE_READY > help help Type 'help [COMMAND]' for more details on a command. list List known servers. change Change the value of resource. update Trigger a registration update bootstrap Initiate a DI bootstrap process dispb Display current backup of objects/instances/resources (only security and server objects are backupped) ls List Objects and Instances disp Display current objects/instances/resources dump Dump an Object add Add support of object 31024 rm Remove support of object 31024 quit Quit the client gracefully. ^C Quit the client abruptly (without sending a de-register message). > -> State: STATE_READY Al igual que el servidor, el cliente soporta la introducci\u00f3n de comandos por parte del usuario. Observa que hemos ejecutado el comando help para mostrar los comandos disponibles. Adem\u00e1s, el cliente ha pasado desde un estado STATE_REGISTERING a un estado STATE_READY , lo que significa que se ha registrado correctamente en el servidor con el nombre testlwm2mclient . Observa ahora la salida del servidor, y ver\u00e1s que \u00e9ste ha realizado un proceso de descubrimiento de recursos en el cliente conectado. Concretamente, el servidor reporta la informaci\u00f3n relativa al nuevo cliente conectado: New client #0 registered. Client #0: name: \"testlwm2mclient\" version: \"1.1\" binding: \"UDP\" lifetime: 300 sec objects: /1/0, /2/0, /3/0, /4/0, /5/0, /6/0, /7/0, /31024/10, /31024/11, /31024/12, Concretamente, el n\u00famero asociado al cliente es el 0 . Podemos recuperar esta informaci\u00f3n en todo momento con el comando list en el servidor. En el cliente, puedes seleccionar el nombre que se utilizar\u00e1 en el proceso de registro con la opci\u00f3n -n . Tarea entregable Observa, utilizando Wireshark, el proceso de registro de un cliente en un servidor, y analiza el contenido del mensaje o mensajes intercambiados entre ambos. \u00bfQu\u00e9 protocolos se utilizan? El cliente con el que estamos trabajando es suficientemente complejo en su funcionamiento, y permite observar c\u00f3mo se implementa el soporte tanto para objetos predefinidos por la OMA como para objetos propios. Concretamente, el cliente implementa nueve objetos distintos: Security Object ( id=0 ). Server Object ( id=1 ). Access Control Object ( id=2 ), como un simple esqueleto, sin funcionalidad asociada. Device Object ( id=3 ), que contiene (y devuelve) valores espec\u00edficos codificados en base al ap\u00e9ndice E de la especificaci\u00f3n t\u00e9cnica de LWM2M. Connectivity Monitoring Object ( id=4 ), como un simple esqueleto, sin funcionalidad. Firmware Update Object ( id=5 ), como un simple esqueleto, sin funcionalidad. Location Object ( id=6 ), como un simple esqueleto, sin funcionalidad. Connectivity Statistics Object ( id=7 ), como un simple esqueleto, sin funcionalidad. Test Object ( id=31024 ), con la siguiente descripci\u00f3n: Objetos: Objeto ID Multiples Instancias Obligatorio Test 31024 S\u00ed No Recurso: Nombre ID Operaciones M\u00faltiples Instancias Obligatorio Tipo Rango test 1 R/W No Yes Integer 0-255 exec 2 E No Yes dec 3 R/W No Yes Float En el cliente, el comando dump nos permitir\u00e1 observar el contenido de una instancia determinada de un objeto, o de todas ellas. En el servidor, el comando read nos permitir\u00e1 hacer lo propio. Tarea entregable Analiza el valor actual de los objetos /3 y el objeto de test, tanto desde el cliente (comando dump ) como desde el servidor (comando read ). En \u00faltimo caso, realiza una captura de tr\u00e1fico v\u00eda Wireshark y analiza los mensajes intercambiados entre ambos extremos. Para escribir en un determinado recurso desde el servidor, podemos hacer uso del comando write de la siguiente forma: write 0 /31024/10/1 91 As\u00ed, estar\u00edamos escribiendo en el recurso 1 de la instancia 10 del objeto 31024 el valor entero 91. Tarea entregable Realiza escrituras en objetos del cliente y analiza el nuevo valor, comprobando que efectivamente se han llevado a cabo. Realiza una captura de tr\u00e1fico v\u00eda Wireshark y analiza los mensajes intercambiados entre ambos extremos en el caso de una escritura. Observa tambi\u00e9n que el servidor permite la observaci\u00f3n de recursos espec\u00edficos (comando observe ). Experimenta con esta opci\u00f3n y observa el tr\u00e1fico generado (puedes modificar el valor de un recurso desde el propio cliente y ver qu\u00e9 ocurre en el servidor). Por \u00faltimo, con la orden quit desconectamos del servidor. Observa tambi\u00e9n los mensajes CoAP que se generan en este caso. Definici\u00f3n de un objeto en Eclipse Wakaama Como has podido observar, el ejemplo de cliente define una serie de objetos, algunos especificados por la OMA, y otros personalizados. En este \u00faltimo caso, al que nos referiremos como test_object , se utilizan e ilustran algunas de las funcionalidades b\u00e1sicas de Wakaama como infraestructura para el desarrollo de Smart Objects v\u00eda LWM2M. Observa tanto el c\u00f3digo del cliente LWM2M (fichero fuente lwm2mclient.c del ejemplo client ) como la definici\u00f3n del objeto de test (fichero fuente test_object.c ). El primer fichero implementa la l\u00f3gica principal del cliente, incluyendo gesti\u00f3n de la conexi\u00f3n, l\u00f3gica de an\u00e1lisis de comandos introducidos por el usuario, gesti\u00f3n de bootstrapping , etc. Concretamente, nos interesa analizar las l\u00edneas relativas a la invocaci\u00f3n de la funci\u00f3n get_test_object , en cuyo interior se definen tanto los recursos como el comportamiento de nuestro cliente ante distintos tipos de operaciones sobre ellos. Observa que, al igual que para nuestro objeto de test, existen funciones similares para el resto de objetos definidos (obviamente podr\u00edan existir m\u00e1s), con un fichero fuente donde se define el comportamiento de cada uno de ellos. Uno de estos objetos es test_object.c . La principal funci\u00f3n de entrada a este m\u00f3dulo es precisamente get_test_object() . Observa que, en ella, se define el identificador del objeto, as\u00ed como cada uno de los recursos que expone (en este caso, tres), sus valores iniciales, y las funciones que se utilizar\u00e1n como callbacks asociados a cada posible operaci\u00f3n: lwm2m_object_t * testObj; testObj = (lwm2m_object_t *)lwm2m_malloc(sizeof(lwm2m_object_t)); if (NULL != testObj) { int i; prv_instance_t * targetP; memset(testObj, 0, sizeof(lwm2m_object_t)); testObj->objID = TEST_OBJECT_ID; for (i=0 ; i < 3 ; i++) { targetP = (prv_instance_t *)lwm2m_malloc(sizeof(prv_instance_t)); if (NULL == targetP) return NULL; memset(targetP, 0, sizeof(prv_instance_t)); targetP->shortID = 10 + i; targetP->test = 20 + i; targetP->dec = -30 + i + (double)i/100.0; testObj->instanceList = LWM2M_LIST_ADD(testObj->instanceList, targetP); } /* * From a single instance object, two more functions are available. * - The first one (createFunc) create a new instance and filled it with the provided informations. If an ID is * provided a check is done for verifying his disponibility, or a new one is generated. * - The other one (deleteFunc) delete an instance by removing it from the instance list (and freeing the memory * allocated to it) */ testObj->readFunc = prv_read; testObj->discoverFunc = prv_discover; testObj->writeFunc = prv_write; testObj->executeFunc = prv_exec; testObj->createFunc = prv_create; testObj->deleteFunc = prv_delete; } return testObj; Estas funciones de callback est\u00e1n definidas en el propio fichero, y su contenido es personalizable en funci\u00f3n del dise\u00f1o del objeto. Observemos, por ejemplo, el contenido de la funci\u00f3n asociada a la lectura, prv_read : static uint8_t prv_read(uint16_t instanceId, int * numDataP, lwm2m_data_t ** dataArrayP, lwm2m_object_t * objectP) { prv_instance_t * targetP; int i; targetP = (prv_instance_t *)lwm2m_list_find(objectP->instanceList, instanceId); if (NULL == targetP) return COAP_404_NOT_FOUND; if (*numDataP == 0) { *dataArrayP = lwm2m_data_new(2); if (*dataArrayP == NULL) return COAP_500_INTERNAL_SERVER_ERROR; *numDataP = 2; (*dataArrayP)[0].id = 1; (*dataArrayP)[1].id = 3; } for (i = 0 ; i < *numDataP ; i++) { switch ((*dataArrayP)[i].id) { case 1: lwm2m_data_encode_int(targetP->test, *dataArrayP + i); break; case 2: return COAP_405_METHOD_NOT_ALLOWED; case 3: lwm2m_data_encode_float(targetP->dec, *dataArrayP + i); break; default: return COAP_404_NOT_FOUND; } } return COAP_205_CONTENT; } Observa que en primer lugar se busca la instancia del objeto solicitada, devolvi\u00e9ndose el error correspondiente en caso de no existir (puedes comprobar esta funcionalidad solicitando desde el servidor la lectura de una instancia inexistente). El par\u00e1metro numDataP nos indica el recurso concreto que se desea leer, o todos si dicho valor es 0. Tras tomar el valor actual a servir, \u00e9ste se codifica en funci\u00f3n del tipo de datos predefinido para el recurso espec\u00edfico solicitado. En caso de no estar soportado el m\u00e9todo para un recurso espec\u00edfico, se devuelve el error correspondiente (en este caso 405 ). En caso de solicitar un recurso inexistente, se devuelve el error 404 . Tarea Comprueba que el comportamiento del objeto de test es el esperado, interactuando con \u00e9l desde el servidor utilizando todos los m\u00e9todos disponibles. Puedes modificar su comportamiento, a\u00f1adir invocaciones a rutinas de log , o lo que consideres de utilidad. Eclipse Wakaama. Bootstrapping En este punto, el cliente Wakaama se conecta directamente con el servidor que hemos lanzado, y cuya direcci\u00f3n IP y puerto son los proporcionados por defecto en el c\u00f3digo. Llevado el cliente a un sensor, esto har\u00eda que nunca pudiese variar, durante el ciclo de vida del mismo, el servidor (o servidores) a los que conecta. Esto hace tambi\u00e9n que un cliente pueda \u00fanicamente conectar con un servidor LWM2M, cuando en algunas ocasiones es deseable replicar los mensajes enviados a m\u00faltiples servidores, bien por razones de tolerancia a fallos, o bien por necesidades de la aplicaci\u00f3n. Para solucionar este problema, los firmwares de f\u00e1brica suelen conocer \u00fanicamente la direcci\u00f3n o direcciones fijas de uno o varios servidores de bootstrap que, ante peticiones de provisionamiento, proporcionan al cliente las credenciales de seguridad y las direcciones de los servidores LWM2M en los que deben registrarse. As\u00ed, resulta sencillo manejar din\u00e1micamente ambos aspectos sin necesitar reflashear el firmware del sensor. En nuestro caso, utilizaremos un sencillo servidor de bootstrap proporcionado por Wakaama, aunque Leshan ofrece mecanismos mucho m\u00e1s sofisticados para realizar este mismo proceso, con su propio esqueleto de servidor bootstrap e interfaces REST (con monitores web) para gestionar el proceso. En primer lugar, dir\u00edgete al directorio que contiene el servidor bootstrap de Wakaama. All\u00ed encontrar\u00e1s un fichero de configuraci\u00f3n ( bootstrap_server.ini ) para el proceso de bootstrapping , cuyo contenido es completamente estructurado. El servidor, ante una petici\u00f3n de bootstrapping por parte de un cliente, responde en funci\u00f3n del contenido del fichero, que sigue las siguientes directivas: Las secciones soportadas son [Server] y [Endpoint] . [Server] describe una cuenta en un servidor LWM2M: Las claves soportadas en esta secci\u00f3n son: id: Identificador del servidor. (OBLIGATORIO). uri: URI del servidor LWM2M (OBLIGATORIO). bootstrap: YES o NO. Determina si este servidor es un servidor de bootstrap. Su valor por defecto es NO. lifetime: tiempo de vida del registro (opcional). security: modo de seguridad. Valores soportados: NoSec, PSK, RPK and Certificate (OBLIGATORIO). public: clave p\u00fablica o identidad del cliente, definida por el recurso /0/x/3 . server: clave p\u00fablica del servidor, definida por el recurso /0/x/4 . secret: clave privada definida por el recurso /0/x/5 . [Endpoint] contiene las operaciones de bootstrapping Si no se especifica un nombre (Name) las operaciones se enviar\u00e1n a cualquier cliente desconocido que solicite bootstrapping Si se especifica, las operaciones se enviar\u00e1n s\u00f3lo al cliente con el correspondiente nombre. Las operaciones se env\u00edan en el orden definido en el fichero. Las claves soportadas en esta secci\u00f3n son: - Name: Nombre del cliente (OPCIONAL). - Delete: Debe ser una URI LWM2M v\u00e1lida, incluida / . Env\u00eda una operaci\u00f3n delete en la URI indicada. - Server: [Value] es un ID de servidor que debe existir en la secci\u00f3n correspondiente. Env\u00eda operaciones de escritura sobre el objeto correspondiente del cliente para definir el servidor sobre el que debe conectar. Tarea Analiza e intenta entender el contenido por defecto del fichero de bootstrapping proporcionado. Puedes de momento obviar los par\u00e1metros referentes a seguridad, ya que los trataremos en la pr\u00f3xima pr\u00e1ctica. Tarea entregable Modifica el fichero de configuraci\u00f3n para que, ante la petici\u00f3n de un cliente con nombre determinado, conecte, por este orden, a un servidor LWM2M en la m\u00e1quina local, y al servidor de pruebas de Leshan en Internet. Adem\u00e1s, elimina cualquier intento de borrado de recursos en la informaci\u00f3n de bootstrapping para dicho cliente. Para arrancar el servidor bootstrap , basta con ejecutar (puedes utilizar otro fichero de configuraci\u00f3n): ./build/bootstrap_server -f bootstrap_server.ini El servidor quedar\u00e1 a la espera de peticiones por parte del cualquier cliente en el puerto 5685, tal y como indica su salida. Se puede forzar un proceso de bootstrapping con el comando boot , pero en este punto no es necesario. A continuaci\u00f3n, lanzaremos un cliente indicando que deseamos un proceso de bootstrapping contra el servidor local. Aseg\u00farate de dar un nombre a tu dispositivo que te permita diferenciarlo de cualquier otro : Nota importante Antes de realizar este ejercicio, debes modificar una l\u00ednea del fichero lwm2mclient.c , reemplazando la l\u00ednea que contiene data.addressFamily = AF_INET6; por data.addressFamily = AF_INET; . ./lwm2mclient -h localhost -p 5685 -b -c -n midispositivo Trying to bind LWM2M Client to port 56830 LWM2M Client \"testlwm2mclient\" started on port 56830 > New Battery Level: 38 value changed! Opening connection to server at localhost:5685 -> State: STATE_BOOTSTRAPPING -> State: STATE_BOOTSTRAPPING -> State: STATE_BOOTSTRAPPING Observa que las opciones de invocaci\u00f3n han cambiado, y hemos usado -b para indicar que deseamos un proceso de bootstrapping contra el servidor proporcionado. Como nota adicional, la opci\u00f3n -c simplemente actualiza de forma peri\u00f3dica la lectura del nivel de bater\u00eda (esto no es en absoluto obligatorio, pero as\u00ed podremos observar sus cambios desde el servidor). Si todo ha ido bien, el cliente estar\u00e1 ahora registrado en dos servidores: el local Wakaama (observa su salida) y el remoto Leshan, al que puedes acceder a trav\u00e9s de la direcci\u00f3n leshan.eclipseprojects.io . Eclipse Leshan. Despliegue de un servidor local En este punto, tu cliente deber\u00eda estar conectado tanto a tu servidor LWM2M Wakaama local, como a un servidor Leshan en la nube. Aprovecha esta situaci\u00f3n para observar las funcionalides del servidor Leshan. Deber\u00edas, para un dispositivo con nombre \"foo\" observar algo como esto: Observa que todos y cada uno de los objetos de los que hablamos anteriormente se muestran ahora en pantalla tras el proceso de registro. Adem\u00e1s, para aquellos que son bien conocidos (estandarizados por la OMA), se muestran nombres legibles, no s\u00f3lo URIs. Tarea Busca y observa el recurso que te indica el nivel de bater\u00eda del cliente, y observa c\u00f3mo se actualiza autom\u00e1ticamente cuando var\u00eda en el cliente (ver\u00e1s a la vez un cambio en el servidor y un mensaje en el cliente). Interact\u00faa con el objeto de test que se defini\u00f3 anteriormente. En todos los casos, observa que, efectivamente, el tr\u00e1fico generado corresponde al esperado. Para replicar dicha instalaci\u00f3n en tu m\u00e1quina local, rescata la instalaci\u00f3n de Leshan que realizaste en la primera parte de la pr\u00e1ctica, y arranca el servidor LWM2M usando la siguiente orden: java -jar leshan-server-demo/target/leshan-server-demo-*-SNAPSHOT-jar-with-dependencies.jar Tarea entregable Arranca el servidor Leshan para que escuche en un puerto diferente al que est\u00e1 escuchando ya el servidor Wakaama, para que puedan convivir en la misma m\u00e1quina. Modifica tu proceso de provisionamiento para que el cliente o clientes se conecten a ambos servidores. Tarea entregable El principal objetivo de esta parte es que seas capaz de definir un objeto e instanciarlo, con una cantidad de recursos suficientemente rica como para observar y ejercitar las capacidades de LWM2M en general, y de Eclipse Wakaama en particular. Por ello, se pide que definas, en primer lugar, uno o m\u00faltiples objetos y sus recursos que podr\u00edan formar parte de un hipot\u00e9tico sensor IoT. En segundo lugar, se pide que, siguiendo las directivas del c\u00f3digo analizado, lo implementes en Eclipse Wakaama y seas capaz de interactuar con \u00e9l desde un servidor Leshan y/o Wakaama utilizando adem\u00e1s un proceso de provisionamiento o bootstrapping .","title":"Pr\u00e1ctica 8"},{"location":"RPI-II/P8/#practica-8-el-protocolo-lwm2m","text":"","title":"Pr\u00e1ctica 8. El protocolo LWM2M"},{"location":"RPI-II/P8/#objetivos","text":"Familiarizarse con el protocolo LWM2M, tanto en la interacci\u00f3n con servidores como en la generaci\u00f3n y definici\u00f3n de objetos y recursos. Familiarizarse con el protocolo de bootstrapping LWM2M y entender su importancia en entornos reales. Conocer dos herramientas para el desarrollo de sistemas basados en LWM2M: Wakaama y Leshan. Experimentar con el proceso de definici\u00f3n de objetos en Wakaama. Observar y poner en marcha un proceso de provisionamiento ( bootstrapping ) usando Wakaama. Desplegar servidores locales LWM2M usando tanto Wakaama como Leshan.","title":"Objetivos"},{"location":"RPI-II/P8/#el-protocolo-lwm2m","text":"OMA Lightweight M2M (LWM2M) es un protocolo impulsado por la Open Mobile Alliance para la comunicaci\u00f3n M2M entre dispositivos y su gesti\u00f3n en entornos IoT. LWM2M est\u00e1 construido sobre el protocolo CoAP, y soporta, a nivel de transporte, el protocolo UDP (tambi\u00e9n presenta soporte para SMS). Entre las funcionalidades b\u00e1sicas de LWM2M destacan la existencia de servidores LWM2M, bootstrapping , control de acceso, gesti\u00f3n de dispositivos, actualizaciones de firmware , localizaci\u00f3n o estad\u00edsticas de conectividad. Adem\u00e1s, soporta seguridad a trav\u00e9s de DTLS. Concretamente, la primera especificaci\u00f3n de LWM2M (versi\u00f3n 1.0) introdujo las siguientes caracter\u00edsticas b\u00e1sicas: Definici\u00f3n de un modelo simple para la definici\u00f3n de recursos, basado en objetos. Definici\u00f3n de operaciones de creaci\u00f3n, consulta, modificaci\u00f3n, borrado y configuraci\u00f3n de recursos. Observaci\u00f3n/notificaci\u00f3n sobre recursos. Soporte para formato de datos JSON, texto plano y TLV. Colas de mensajes para soportar modos de bajo consumo en dispositivos. Soporte para m\u00faltiples servidores LWM2M. Objetos b\u00e1sicos LWM2M: Seguridad, Servidor, Control de Acceso, Dispositivo, Conectividad, Actualizaci\u00f3n de Firmware, Localizaci\u00f3n, Estad\u00edsticas de Conectividad. Para m\u00e1s informaci\u00f3n sobre los objetos predefinidos, consulta el siguiente enlace . Versiones subsiguientes del protocolo (1.1 y 1.2) introdujeron caracter\u00edsticas adicionales, como por ejemplo: Mejora del proceso de bootstrapping . Mejora del soporte para PKI. Soporte para TCP/TLS. Soporte para CBOR. Soporte para MQTT y HTTP como protocolos subyacentes.","title":"El protocolo LWM2M"},{"location":"RPI-II/P8/#implementaciones-lwm2m","text":"En la presente pr\u00e1ctica, utilizaremos dos paquetes de software pertenecientes al proyecto Eclipse IoT, ambos con soporte completo para LWM2M. Cada uno de ellos presenta ventajas e inconvenientes que es necesario conocer.","title":"Implementaciones LWM2M"},{"location":"RPI-II/P8/#eclipse-wakaama","text":"Eclipse Wakaama es un conjunto de ficheros fuente escritos en C que permiten ser integrados en cualquier proyecto para proporcionar funcionalidad de cliente , servidor y servidor de bootstrap LWM2M hasta su versi\u00f3n 1.1. En el lado cliente, Wakaama permite la definici\u00f3n de objetos conforme al est\u00e1ndar, as\u00ed como la recepci\u00f3n de comandos desde servidores y su enrutado hacia el objeto u objetos correspondientes. Desde el punto de vista servidor, Wakaama proporciona APIs para enviar comandos a clientes LWM2M registrados. Todo el proyecto es compatible con POSIX, y en esta pr\u00e1ctica experimentaremos con su funcionalidad trabajando desde Linux (modo cliente, servidor y servidor de bootstrap ) y desde el ESP32 (modo cliente).","title":"Eclipse Wakaama"},{"location":"RPI-II/P8/#instalacion","text":"Utilizaremos una versi\u00f3n espec\u00edfica que permitir\u00e1 ser ejecutada tanto en Linux como en el ESP32. Para ello, clonamos en primer lugar la versi\u00f3n correspondiente del proyecto (es importante que utilices este commit espec\u00edfico): git clone https://github.com/eclipse/wakaama.git cd wakaama git reset --hard 31d64c0c41fae9653c1fa53ef58d1a44e49017fa El proyecto Wakaama proporciona cuatro componentes que utilizaremos durante la pr\u00e1ctica, todos dentro del directorio examples : bootstrap_server : implementa un servidor de bootstrap con l\u00ednea de comandos propia. client : implementa un cliente complejo, con definici\u00f3n de nueve objetos que siguen las especificaciones de la OMA m\u00e1s uno propio, y soporte para bootstrapping . lightclient : implementa un cliente sencillo, con definici\u00f3n de tres objetos seg\u00fan especificaciones OMA y un cuarto objeto propio. server : implementa un servidor LWM2M que ofrece l\u00ednea de comandos para la interacci\u00f3n con clientes registrados. El modo de compilar cada uno de los ejemplos es exactamente el mismo: Dir\u00edgete al directorio del ejemplo. Crea un directorio build y accede a \u00e9l. Configura el proyecto con la orden cmake .. . Compila el ejemplo con la orden make . Si todo ha ido bien, deber\u00edas tener un binario distinto en el directorio build correspondiente, con los que trabajar\u00e1s el resto de la pr\u00e1ctica. Tarea Compila cada uno de los ejemplos anteriormente mencionados en tu m\u00e1quina virtual, utilizando los par\u00e1metros por defecto para cada uno de ellos.","title":"Instalaci\u00f3n"},{"location":"RPI-II/P8/#eclipse-leshan","text":"Eclipse Leshan es un proyecto alternativo que proporciona implementaciones en Java de clientes, servidores y servidores de bootstrap LWM2M, y est\u00e1 especialmente dise\u00f1ado para ser adaptable y extensible, permitiendo a los desarrolladores implementar sus propias versiones de cada uno de los tres anteriores elmentos adaptados a sus necesidades espec\u00edficas. Al igual que Wakaama, Leshan proporciona la definici\u00f3n e interacci\u00f3n con objetos IPSO, construcci\u00f3n sobre DTLS y utilizaci\u00f3n de CoAP como protocolo subyacente. Adem\u00e1s, el proyecto proporciona dos servidores de test que resultan muy \u00fatiles a la hora de desarrollar, v\u00e9ase: Servidor LWM2M en leshan.eclipseprojects.io , disponible en coap://leshan.eclipseprojects.io:5683 y coaps://leshan.eclipseprojects.io:5684 . Servidor de bootstrap en leshan.eclipseprojects.io/bs , disponible en coap://leshan.eclipseprojects.io:5783 y coaps://leshan.eclipseprojects.io:5784 .","title":"Eclipse Leshan"},{"location":"RPI-II/P8/#instalacion_1","text":"Instala en primer lugar los prerequisitos necesarios para la correcta instalaci\u00f3n de Leshan (pueden variar en funci\u00f3n de tu distribuci\u00f3n Linux): sudo apt-get update sudo apt-get install openjdk-14-jdk maven git-core Clona el repositorio oficial de Leshan desde la siguiente direcci\u00f3n: git clone https://github.com/eclipse/leshan.git Por \u00faltimo, compila el proyecto: cd leshan mvn clean install Tras la fase de instalaci\u00f3n, podr\u00e1s lanzar tanto el servidor LWM2M: java -jar leshan-server-demo/target/leshan-server-demo-*-SNAPSHOT-jar-with-dependencies.jar La opci\u00f3n -h te permitir\u00e1 observar la ayuda del servidor. Como el servidor de bootstrapping : java -jar leshan-bsserver-demo/target/leshan-bsserver-demo-*-SNAPSHOT-jar-with-dependencies.jar La opci\u00f3n -h te permitir\u00e1 observar la ayuda del servidor. En ambos casos, la salida asociada a la ejecuci\u00f3n de los servidores nos indicar\u00e1n la URL que podremos consultar desde cualquier navegador para obtener informaci\u00f3n del mismo, as\u00ed como la URL y puerto de escucha de cada uno, que deberemos indicar en los clientes correspondientes. Tarea Instala Eclipse Leshan y arranca el servidor LWM2M. Accede a la p\u00e1gina web de gesti\u00f3n y comprueba que efectivamente funciona. A continucaci\u00f3n, detenlo y haz lo propio con el servidor de bootstrapping .","title":"Instalaci\u00f3n"},{"location":"RPI-II/P8/#eclipse-wakaama-cliente-y-servidor-lwm2m","text":"El objetivo principal de esta parte de la pr\u00e1ctica ser\u00e1 disponer de un sistema completo LWM2M basado en un cliente y dos servidores (uno LWM2M, otro de bootstrapping ), todos funcionando bajo Eclipse Wakaama. Para ello, en primer lugar, arrancaremos el servidor Wakaama en una de las terminales. Observa que el servidor, tras arrancar, expone una sencilla l\u00ednea de comandos que podemos aprovechar para interactuar con \u00e9l: ./lwm2mserver > help help Type 'help [COMMAND]' for more details on a command. list List registered clients. read Read from a client. disc Discover resources of a client. write Write to a client. time Write time-related attributes to a client. attr Write value-related attributes to a client. clear Clear attributes of a client. exec Execute a client resource. del Delete a client Object instance. create Create an Object instance. observe Observe from a client. cancel Cancel an observe. q Quit the server. La orden help muestra la ayuda global, pudi\u00e9ndose especializar para cada comando concreto: > help read read CLIENT# URI CLIENT#: client number as returned by command 'list' URI: uri to read such as /3, /3/0/2, /1024/11, /1024/0/1 Result will be displayed asynchronously. Si en este instante listamos un los clientes registrados, veremos que no hay ninguno: > list No client. En segundo lugar, vamos a arrancar el cliente Wakaama. Por defecto, este cliente intentar\u00e1 conectar con un servidor LWM2M existente en localhost , puerto 5683. En cualquier caso, estos valores pueden modificarse en la propia invocaci\u00f3n (consulta la opci\u00f3n -h para m\u00e1s informaci\u00f3n sobre par\u00e1metros disponibles): ./lwm2mclient Trying to bind LWM2M Client to port 56830 LWM2M Client \"testlwm2mclient\" started on port 56830 > Opening connection to server at ::1:5683 -> State: STATE_REGISTERING 13 bytes received from [::1]:5683 64 41 69 06 06 69 E8 86 82 72 64 01 30 dAi..i...rd.0 -> State: STATE_READY > help help Type 'help [COMMAND]' for more details on a command. list List known servers. change Change the value of resource. update Trigger a registration update bootstrap Initiate a DI bootstrap process dispb Display current backup of objects/instances/resources (only security and server objects are backupped) ls List Objects and Instances disp Display current objects/instances/resources dump Dump an Object add Add support of object 31024 rm Remove support of object 31024 quit Quit the client gracefully. ^C Quit the client abruptly (without sending a de-register message). > -> State: STATE_READY Al igual que el servidor, el cliente soporta la introducci\u00f3n de comandos por parte del usuario. Observa que hemos ejecutado el comando help para mostrar los comandos disponibles. Adem\u00e1s, el cliente ha pasado desde un estado STATE_REGISTERING a un estado STATE_READY , lo que significa que se ha registrado correctamente en el servidor con el nombre testlwm2mclient . Observa ahora la salida del servidor, y ver\u00e1s que \u00e9ste ha realizado un proceso de descubrimiento de recursos en el cliente conectado. Concretamente, el servidor reporta la informaci\u00f3n relativa al nuevo cliente conectado: New client #0 registered. Client #0: name: \"testlwm2mclient\" version: \"1.1\" binding: \"UDP\" lifetime: 300 sec objects: /1/0, /2/0, /3/0, /4/0, /5/0, /6/0, /7/0, /31024/10, /31024/11, /31024/12, Concretamente, el n\u00famero asociado al cliente es el 0 . Podemos recuperar esta informaci\u00f3n en todo momento con el comando list en el servidor. En el cliente, puedes seleccionar el nombre que se utilizar\u00e1 en el proceso de registro con la opci\u00f3n -n . Tarea entregable Observa, utilizando Wireshark, el proceso de registro de un cliente en un servidor, y analiza el contenido del mensaje o mensajes intercambiados entre ambos. \u00bfQu\u00e9 protocolos se utilizan? El cliente con el que estamos trabajando es suficientemente complejo en su funcionamiento, y permite observar c\u00f3mo se implementa el soporte tanto para objetos predefinidos por la OMA como para objetos propios. Concretamente, el cliente implementa nueve objetos distintos: Security Object ( id=0 ). Server Object ( id=1 ). Access Control Object ( id=2 ), como un simple esqueleto, sin funcionalidad asociada. Device Object ( id=3 ), que contiene (y devuelve) valores espec\u00edficos codificados en base al ap\u00e9ndice E de la especificaci\u00f3n t\u00e9cnica de LWM2M. Connectivity Monitoring Object ( id=4 ), como un simple esqueleto, sin funcionalidad. Firmware Update Object ( id=5 ), como un simple esqueleto, sin funcionalidad. Location Object ( id=6 ), como un simple esqueleto, sin funcionalidad. Connectivity Statistics Object ( id=7 ), como un simple esqueleto, sin funcionalidad. Test Object ( id=31024 ), con la siguiente descripci\u00f3n: Objetos: Objeto ID Multiples Instancias Obligatorio Test 31024 S\u00ed No Recurso: Nombre ID Operaciones M\u00faltiples Instancias Obligatorio Tipo Rango test 1 R/W No Yes Integer 0-255 exec 2 E No Yes dec 3 R/W No Yes Float En el cliente, el comando dump nos permitir\u00e1 observar el contenido de una instancia determinada de un objeto, o de todas ellas. En el servidor, el comando read nos permitir\u00e1 hacer lo propio. Tarea entregable Analiza el valor actual de los objetos /3 y el objeto de test, tanto desde el cliente (comando dump ) como desde el servidor (comando read ). En \u00faltimo caso, realiza una captura de tr\u00e1fico v\u00eda Wireshark y analiza los mensajes intercambiados entre ambos extremos. Para escribir en un determinado recurso desde el servidor, podemos hacer uso del comando write de la siguiente forma: write 0 /31024/10/1 91 As\u00ed, estar\u00edamos escribiendo en el recurso 1 de la instancia 10 del objeto 31024 el valor entero 91. Tarea entregable Realiza escrituras en objetos del cliente y analiza el nuevo valor, comprobando que efectivamente se han llevado a cabo. Realiza una captura de tr\u00e1fico v\u00eda Wireshark y analiza los mensajes intercambiados entre ambos extremos en el caso de una escritura. Observa tambi\u00e9n que el servidor permite la observaci\u00f3n de recursos espec\u00edficos (comando observe ). Experimenta con esta opci\u00f3n y observa el tr\u00e1fico generado (puedes modificar el valor de un recurso desde el propio cliente y ver qu\u00e9 ocurre en el servidor). Por \u00faltimo, con la orden quit desconectamos del servidor. Observa tambi\u00e9n los mensajes CoAP que se generan en este caso.","title":"Eclipse Wakaama. Cliente y servidor LWM2M"},{"location":"RPI-II/P8/#definicion-de-un-objeto-en-eclipse-wakaama","text":"Como has podido observar, el ejemplo de cliente define una serie de objetos, algunos especificados por la OMA, y otros personalizados. En este \u00faltimo caso, al que nos referiremos como test_object , se utilizan e ilustran algunas de las funcionalidades b\u00e1sicas de Wakaama como infraestructura para el desarrollo de Smart Objects v\u00eda LWM2M. Observa tanto el c\u00f3digo del cliente LWM2M (fichero fuente lwm2mclient.c del ejemplo client ) como la definici\u00f3n del objeto de test (fichero fuente test_object.c ). El primer fichero implementa la l\u00f3gica principal del cliente, incluyendo gesti\u00f3n de la conexi\u00f3n, l\u00f3gica de an\u00e1lisis de comandos introducidos por el usuario, gesti\u00f3n de bootstrapping , etc. Concretamente, nos interesa analizar las l\u00edneas relativas a la invocaci\u00f3n de la funci\u00f3n get_test_object , en cuyo interior se definen tanto los recursos como el comportamiento de nuestro cliente ante distintos tipos de operaciones sobre ellos. Observa que, al igual que para nuestro objeto de test, existen funciones similares para el resto de objetos definidos (obviamente podr\u00edan existir m\u00e1s), con un fichero fuente donde se define el comportamiento de cada uno de ellos. Uno de estos objetos es test_object.c . La principal funci\u00f3n de entrada a este m\u00f3dulo es precisamente get_test_object() . Observa que, en ella, se define el identificador del objeto, as\u00ed como cada uno de los recursos que expone (en este caso, tres), sus valores iniciales, y las funciones que se utilizar\u00e1n como callbacks asociados a cada posible operaci\u00f3n: lwm2m_object_t * testObj; testObj = (lwm2m_object_t *)lwm2m_malloc(sizeof(lwm2m_object_t)); if (NULL != testObj) { int i; prv_instance_t * targetP; memset(testObj, 0, sizeof(lwm2m_object_t)); testObj->objID = TEST_OBJECT_ID; for (i=0 ; i < 3 ; i++) { targetP = (prv_instance_t *)lwm2m_malloc(sizeof(prv_instance_t)); if (NULL == targetP) return NULL; memset(targetP, 0, sizeof(prv_instance_t)); targetP->shortID = 10 + i; targetP->test = 20 + i; targetP->dec = -30 + i + (double)i/100.0; testObj->instanceList = LWM2M_LIST_ADD(testObj->instanceList, targetP); } /* * From a single instance object, two more functions are available. * - The first one (createFunc) create a new instance and filled it with the provided informations. If an ID is * provided a check is done for verifying his disponibility, or a new one is generated. * - The other one (deleteFunc) delete an instance by removing it from the instance list (and freeing the memory * allocated to it) */ testObj->readFunc = prv_read; testObj->discoverFunc = prv_discover; testObj->writeFunc = prv_write; testObj->executeFunc = prv_exec; testObj->createFunc = prv_create; testObj->deleteFunc = prv_delete; } return testObj; Estas funciones de callback est\u00e1n definidas en el propio fichero, y su contenido es personalizable en funci\u00f3n del dise\u00f1o del objeto. Observemos, por ejemplo, el contenido de la funci\u00f3n asociada a la lectura, prv_read : static uint8_t prv_read(uint16_t instanceId, int * numDataP, lwm2m_data_t ** dataArrayP, lwm2m_object_t * objectP) { prv_instance_t * targetP; int i; targetP = (prv_instance_t *)lwm2m_list_find(objectP->instanceList, instanceId); if (NULL == targetP) return COAP_404_NOT_FOUND; if (*numDataP == 0) { *dataArrayP = lwm2m_data_new(2); if (*dataArrayP == NULL) return COAP_500_INTERNAL_SERVER_ERROR; *numDataP = 2; (*dataArrayP)[0].id = 1; (*dataArrayP)[1].id = 3; } for (i = 0 ; i < *numDataP ; i++) { switch ((*dataArrayP)[i].id) { case 1: lwm2m_data_encode_int(targetP->test, *dataArrayP + i); break; case 2: return COAP_405_METHOD_NOT_ALLOWED; case 3: lwm2m_data_encode_float(targetP->dec, *dataArrayP + i); break; default: return COAP_404_NOT_FOUND; } } return COAP_205_CONTENT; } Observa que en primer lugar se busca la instancia del objeto solicitada, devolvi\u00e9ndose el error correspondiente en caso de no existir (puedes comprobar esta funcionalidad solicitando desde el servidor la lectura de una instancia inexistente). El par\u00e1metro numDataP nos indica el recurso concreto que se desea leer, o todos si dicho valor es 0. Tras tomar el valor actual a servir, \u00e9ste se codifica en funci\u00f3n del tipo de datos predefinido para el recurso espec\u00edfico solicitado. En caso de no estar soportado el m\u00e9todo para un recurso espec\u00edfico, se devuelve el error correspondiente (en este caso 405 ). En caso de solicitar un recurso inexistente, se devuelve el error 404 . Tarea Comprueba que el comportamiento del objeto de test es el esperado, interactuando con \u00e9l desde el servidor utilizando todos los m\u00e9todos disponibles. Puedes modificar su comportamiento, a\u00f1adir invocaciones a rutinas de log , o lo que consideres de utilidad.","title":"Definici\u00f3n de un objeto en Eclipse Wakaama"},{"location":"RPI-II/P8/#eclipse-wakaama-bootstrapping","text":"En este punto, el cliente Wakaama se conecta directamente con el servidor que hemos lanzado, y cuya direcci\u00f3n IP y puerto son los proporcionados por defecto en el c\u00f3digo. Llevado el cliente a un sensor, esto har\u00eda que nunca pudiese variar, durante el ciclo de vida del mismo, el servidor (o servidores) a los que conecta. Esto hace tambi\u00e9n que un cliente pueda \u00fanicamente conectar con un servidor LWM2M, cuando en algunas ocasiones es deseable replicar los mensajes enviados a m\u00faltiples servidores, bien por razones de tolerancia a fallos, o bien por necesidades de la aplicaci\u00f3n. Para solucionar este problema, los firmwares de f\u00e1brica suelen conocer \u00fanicamente la direcci\u00f3n o direcciones fijas de uno o varios servidores de bootstrap que, ante peticiones de provisionamiento, proporcionan al cliente las credenciales de seguridad y las direcciones de los servidores LWM2M en los que deben registrarse. As\u00ed, resulta sencillo manejar din\u00e1micamente ambos aspectos sin necesitar reflashear el firmware del sensor. En nuestro caso, utilizaremos un sencillo servidor de bootstrap proporcionado por Wakaama, aunque Leshan ofrece mecanismos mucho m\u00e1s sofisticados para realizar este mismo proceso, con su propio esqueleto de servidor bootstrap e interfaces REST (con monitores web) para gestionar el proceso. En primer lugar, dir\u00edgete al directorio que contiene el servidor bootstrap de Wakaama. All\u00ed encontrar\u00e1s un fichero de configuraci\u00f3n ( bootstrap_server.ini ) para el proceso de bootstrapping , cuyo contenido es completamente estructurado. El servidor, ante una petici\u00f3n de bootstrapping por parte de un cliente, responde en funci\u00f3n del contenido del fichero, que sigue las siguientes directivas: Las secciones soportadas son [Server] y [Endpoint] . [Server] describe una cuenta en un servidor LWM2M: Las claves soportadas en esta secci\u00f3n son: id: Identificador del servidor. (OBLIGATORIO). uri: URI del servidor LWM2M (OBLIGATORIO). bootstrap: YES o NO. Determina si este servidor es un servidor de bootstrap. Su valor por defecto es NO. lifetime: tiempo de vida del registro (opcional). security: modo de seguridad. Valores soportados: NoSec, PSK, RPK and Certificate (OBLIGATORIO). public: clave p\u00fablica o identidad del cliente, definida por el recurso /0/x/3 . server: clave p\u00fablica del servidor, definida por el recurso /0/x/4 . secret: clave privada definida por el recurso /0/x/5 . [Endpoint] contiene las operaciones de bootstrapping Si no se especifica un nombre (Name) las operaciones se enviar\u00e1n a cualquier cliente desconocido que solicite bootstrapping Si se especifica, las operaciones se enviar\u00e1n s\u00f3lo al cliente con el correspondiente nombre. Las operaciones se env\u00edan en el orden definido en el fichero. Las claves soportadas en esta secci\u00f3n son: - Name: Nombre del cliente (OPCIONAL). - Delete: Debe ser una URI LWM2M v\u00e1lida, incluida / . Env\u00eda una operaci\u00f3n delete en la URI indicada. - Server: [Value] es un ID de servidor que debe existir en la secci\u00f3n correspondiente. Env\u00eda operaciones de escritura sobre el objeto correspondiente del cliente para definir el servidor sobre el que debe conectar. Tarea Analiza e intenta entender el contenido por defecto del fichero de bootstrapping proporcionado. Puedes de momento obviar los par\u00e1metros referentes a seguridad, ya que los trataremos en la pr\u00f3xima pr\u00e1ctica. Tarea entregable Modifica el fichero de configuraci\u00f3n para que, ante la petici\u00f3n de un cliente con nombre determinado, conecte, por este orden, a un servidor LWM2M en la m\u00e1quina local, y al servidor de pruebas de Leshan en Internet. Adem\u00e1s, elimina cualquier intento de borrado de recursos en la informaci\u00f3n de bootstrapping para dicho cliente. Para arrancar el servidor bootstrap , basta con ejecutar (puedes utilizar otro fichero de configuraci\u00f3n): ./build/bootstrap_server -f bootstrap_server.ini El servidor quedar\u00e1 a la espera de peticiones por parte del cualquier cliente en el puerto 5685, tal y como indica su salida. Se puede forzar un proceso de bootstrapping con el comando boot , pero en este punto no es necesario. A continuaci\u00f3n, lanzaremos un cliente indicando que deseamos un proceso de bootstrapping contra el servidor local. Aseg\u00farate de dar un nombre a tu dispositivo que te permita diferenciarlo de cualquier otro : Nota importante Antes de realizar este ejercicio, debes modificar una l\u00ednea del fichero lwm2mclient.c , reemplazando la l\u00ednea que contiene data.addressFamily = AF_INET6; por data.addressFamily = AF_INET; . ./lwm2mclient -h localhost -p 5685 -b -c -n midispositivo Trying to bind LWM2M Client to port 56830 LWM2M Client \"testlwm2mclient\" started on port 56830 > New Battery Level: 38 value changed! Opening connection to server at localhost:5685 -> State: STATE_BOOTSTRAPPING -> State: STATE_BOOTSTRAPPING -> State: STATE_BOOTSTRAPPING Observa que las opciones de invocaci\u00f3n han cambiado, y hemos usado -b para indicar que deseamos un proceso de bootstrapping contra el servidor proporcionado. Como nota adicional, la opci\u00f3n -c simplemente actualiza de forma peri\u00f3dica la lectura del nivel de bater\u00eda (esto no es en absoluto obligatorio, pero as\u00ed podremos observar sus cambios desde el servidor). Si todo ha ido bien, el cliente estar\u00e1 ahora registrado en dos servidores: el local Wakaama (observa su salida) y el remoto Leshan, al que puedes acceder a trav\u00e9s de la direcci\u00f3n leshan.eclipseprojects.io .","title":"Eclipse Wakaama. Bootstrapping"},{"location":"RPI-II/P8/#eclipse-leshan-despliegue-de-un-servidor-local","text":"En este punto, tu cliente deber\u00eda estar conectado tanto a tu servidor LWM2M Wakaama local, como a un servidor Leshan en la nube. Aprovecha esta situaci\u00f3n para observar las funcionalides del servidor Leshan. Deber\u00edas, para un dispositivo con nombre \"foo\" observar algo como esto: Observa que todos y cada uno de los objetos de los que hablamos anteriormente se muestran ahora en pantalla tras el proceso de registro. Adem\u00e1s, para aquellos que son bien conocidos (estandarizados por la OMA), se muestran nombres legibles, no s\u00f3lo URIs. Tarea Busca y observa el recurso que te indica el nivel de bater\u00eda del cliente, y observa c\u00f3mo se actualiza autom\u00e1ticamente cuando var\u00eda en el cliente (ver\u00e1s a la vez un cambio en el servidor y un mensaje en el cliente). Interact\u00faa con el objeto de test que se defini\u00f3 anteriormente. En todos los casos, observa que, efectivamente, el tr\u00e1fico generado corresponde al esperado. Para replicar dicha instalaci\u00f3n en tu m\u00e1quina local, rescata la instalaci\u00f3n de Leshan que realizaste en la primera parte de la pr\u00e1ctica, y arranca el servidor LWM2M usando la siguiente orden: java -jar leshan-server-demo/target/leshan-server-demo-*-SNAPSHOT-jar-with-dependencies.jar Tarea entregable Arranca el servidor Leshan para que escuche en un puerto diferente al que est\u00e1 escuchando ya el servidor Wakaama, para que puedan convivir en la misma m\u00e1quina. Modifica tu proceso de provisionamiento para que el cliente o clientes se conecten a ambos servidores. Tarea entregable El principal objetivo de esta parte es que seas capaz de definir un objeto e instanciarlo, con una cantidad de recursos suficientemente rica como para observar y ejercitar las capacidades de LWM2M en general, y de Eclipse Wakaama en particular. Por ello, se pide que definas, en primer lugar, uno o m\u00faltiples objetos y sus recursos que podr\u00edan formar parte de un hipot\u00e9tico sensor IoT. En segundo lugar, se pide que, siguiendo las directivas del c\u00f3digo analizado, lo implementes en Eclipse Wakaama y seas capaz de interactuar con \u00e9l desde un servidor Leshan y/o Wakaama utilizando adem\u00e1s un proceso de provisionamiento o bootstrapping .","title":"Eclipse Leshan. Despliegue de un servidor local"},{"location":"RPI-II/P9/","text":"Pr\u00e1ctica 9. Node-RED Introducci\u00f3n y objetivos Node-RED es una herramienta de c\u00f3digo abierto desarrollada inicialmente por IBM y que, estando orientada a flujos de datos, proporciona mecanismos para asociar dispositivos hardware, APIs y servicios online dentro de un ecosistema IoT. Node-RED es una herramienta gr\u00e1fica, utilizable desde cualquier navegador web, que permite la craci\u00f3n y edici\u00f3n de flujos de datos que tomen datos de entrada (mediante nodos de entrada), los procesen (mediante nodos de procesamiento) y proporcionen salidas (mediante nodos de salida). Todos los elementos, incluyendo flujos complejos definidos por el usuario, pueden almacenarse en formato JSON para ser importados a continuaci\u00f3n en otras instalaciones. Node-RED permite la interconexi\u00f3n de elementos software y hardware mediante virtualmente cualquier protocolo conocido, facilitando el despliegue de infraestructuras IoT. El desarrollo de la pr\u00e1ctica difiere sobre el utilizado en pr\u00e1cticas anteriores. En este caso, el presente bolet\u00edn \u00fanicamente incluye informaci\u00f3n e instrucciones para la instalaci\u00f3n de la herramienta Node-RED en la m\u00e1quina virtual del curso (alternativamente, es posible instalar Node-RED en cualquier m\u00e1quina f\u00edsica), as\u00ed como la propuesta de ejercicio entregable a dise\u00f1ar e implementar. Se proporcionar\u00e1n las explicaciones y demostraciones necesarias durante la sesi\u00f3n de laboratorio para entender los conceptos b\u00e1sicos relativos a la instalaci\u00f3n y uso b\u00e1sico de la herramienta Node-RED. Instalaci\u00f3n y puesta en marcha Para instalar Node-RED en la m\u00e1quina virtual del curso, es suficiente con utilizar el gestor npm : sudo npm install -g --unsafe-perm node-red Al finalzar, si todo ha ido bien, deber\u00edas observar una salida similar a la siguiente: + node-red@1.1.0 added 332 packages from 341 contributors in 18.494s found 0 vulnerabilities Para ejecutar Node-RED, una vez instalado, es posible utilizar la orden node-red desde cualquier terminal. Para detener el proceso, es suficiente con utilizar Ctrl-C : $ node-red Welcome to Node-RED =================== 30 Jun 23:43:39 - [info] Node-RED version: v1.1.0 30 Jun 23:43:39 - [info] Node.js version: v10.21.0 30 Jun 23:43:39 - [info] Darwin 18.7.0 x64 LE 30 Jun 23:43:39 - [info] Loading palette nodes 30 Jun 23:43:44 - [warn] rpi-gpio : Raspberry Pi specific node set inactive 30 Jun 23:43:44 - [info] Settings file : /Users/nol/.node-red/settings.js 30 Jun 23:43:44 - [info] HTTP Static : /Users/nol/node-red/web 30 Jun 23:43:44 - [info] Context store : 'default' [module=localfilesystem] 30 Jun 23:43:44 - [info] User directory : /Users/nol/.node-red 30 Jun 23:43:44 - [warn] Projects disabled : set editorTheme.projects.enabled=true to enable 30 Jun 23:43:44 - [info] Creating new flows file : flows_noltop.json 30 Jun 23:43:44 - [info] Starting flows 30 Jun 23:43:44 - [info] Started flows 30 Jun 23:43:44 - [info] Server now running at http://127.0.0.1:1880/red/ Con el software arrancado, es posible acceder al editor Node-RED a trav\u00e9s de la direcci\u00f3n http://localhost:1880 en cualquier navegador. Tras arrancarlo, observar\u00e1s cuatro \u00e1reas en el editor: Barra principal , en la parte superior, con los botones Deploy y de Men\u00fa principal . Panel de nodos , en la parte izquierda, que proporciona acceso directo a todos los nodos disponibles en Node-RED. Es posible instalar nuevos nodos a trav\u00e9s de la Paleta de Nodos, disponible a trav\u00e9s del men\u00fa principal ( Manage Palette ). Estos nodos pueden ser arrastrados al editor para conformar nuevos flujos de datos. Panel de edici\u00f3n o espacio de trabajo , en la parte central de la pantalla, donde podr\u00e1s arrastrar y unir nuevos nodos. Es posible crear nuevos flujos en pesta\u00f1as independientes. Panel de informaci\u00f3n , en la parte derecha de la pantalla, donde destaca el bot\u00f3n Debug , mediante el cual veremos la salida de los nodos de tipo Debug en nuestros flujos. Ejemplo 1 Se muestra a continuaci\u00f3n un breve ejemplo b\u00e1sico de utilizaci\u00f3n del editor Node-RED, que incluye el uso de nodos Inject , Debug y Function . Nodo Inject El nodo Inject permite inyectar mensajes en un flujo, bien pulsando en el bot\u00f3n asociado al nodo, o estableciendo un intervalo de tiempo entre inyecciones. Busca en el panel izquierdo un nodo de tipo Inject y arr\u00e1stralo al espacio de trabajo. En el panel de informaci\u00f3n podr\u00e1s consultar los datos asociados al nodo, as\u00ed como informaci\u00f3n de ayuda para utilizarlo. Nodo Debug El nodo Debug permite que cualquier mensaje entrante se muestre en el panel de depuraci\u00f3n, en la parte derecha de la pantalla. Por defecto, \u00fanicamente muestra el payload del mensaje, aunque puede configurarse para mostrar el objeto completo. Arrastra un nodo de tipo Debug al espacio de trabajo. Uni\u00f3n y despliegue ( Deploy ) Conecta los nodos Inject y Debug estableciendo un enlace ( Wire ) entre ambos. Despliega el flujo usando el bot\u00f3n Deploy en la barra principal de Node-RED. Esto desplegar\u00e1 el fujo en el servidor. Selecciona la opci\u00f3n Debug en el panel de informaci\u00f3n, y presiona el bot\u00f3n del nodo Inject . Deber\u00edas ver n\u00fameros aparecer en el panel. Por defecto, el nodo Inject emite el n\u00famero de milisegundos desde el 1 de enero de 1970 como payload . Modifica (temporalmente) el nodo Debug para que muestre todo el mensaje en lugar del payload . Despliega de nuevo el flujo y observa las diferencias. Vuelve a configurar el nodo Debug tal y como estaba cuando lo insertaste. Nodo Function El nodo Function permite procesar el mensaje de entrada mediante una funci\u00f3n JavaScript. Borra el Wire existente y a\u00f1ade un nodo Function entre los nodos Inject y Debug . Haz doble clic en el nuevo nodo para abrir el di\u00e1logo de edici\u00f3n. Copia el siguiente c\u00f3digo en el campo Function : // Create a Date object from the payload var date = new Date(msg.payload); // Change the payload to be a formatted Date string msg.payload = date.toString(); // Return the message so it can be sent on return msg; Clica en Done y despliega el flujo. Observa que, ahora, los mensajes de depuraci\u00f3n muestran marcas de tiempo en formato visible. Ten en cuenta que un nodo siempre recibe un mensaje ( msg ) de entrada y devuelve un mensaje ( msg ) de salida. Ambos objetos contienen, por convenio, un campo payload . Para m\u00e1s informaci\u00f3n sobre el uso de funciones y trabajo con mensajes, incluyendo m\u00faltiples valores de retorno y trabajo con valores globales a todo el entorno, se recomienda estudiar la siguiente documentaci\u00f3n: Trabajo con mensajes : enlace a documentaci\u00f3n . Trabajo con funciones : enlace a documentaci\u00f3n . Ejemplo 2 Nodo Inject En el anterior ejemplo, vimos c\u00f3mo crear un nodo Inject para activar el flujo cuando se pulsaba su bot\u00f3n asociado. En este ejemplo, vamos a configurar el nodo Inject para que active el flujo en intervalos regulares. Arrastra un nuevo nodo Inject en el espacio de trabajo. Clica en \u00e9l dos veces y, en el di\u00e1logo de edici\u00f3n, usala opci\u00f3n Repeat interval , fij\u00e1ndolo en un intervalo regular. Cierra el di\u00e1logo de edici\u00f3n. Nodo HTTP Request El nodo de tipo HTTP Request puede utilizarse para descargar una p\u00e1gina web o recurso HTTP. A\u00f1ade uno al espacio de trabajo, y ed\u00edtalo para que su propiedad URL apunte a https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/significant_month.csv . Esta URL es un repositorio de terremotos en el \u00faltimo mes, pulicado por el organismo oficial correspondiente, devueltos en formato CSV. Nodo CSV A\u00f1ade un nuevo nodo CSV y edita sus propiedades. Activa la opci\u00f3n First row contains column names y finaliza la edici\u00f3n. Nodo Debug y cableado A\u00f1ade un nodo Debug y une los nodos creados: Conecta la salida del nodo Inject a la entrada del nodo HTTP Request . Conecta la salida del nodo HTTP Request a la entrada del nodo CSV . Conecta la salida del nodo CSV a la entrada del nodo Debug . Nodo Switch A\u00f1ade un nodo Switch al espacio de trabajo. Edita sus propiedades y configuralo para comprobar la propiedad msg.payload.mag , usando la operaci\u00f3n >= sobre un valor num\u00e9rico y el valor 6.2 , por ejemplo. A\u00f1ade un segundo Wire entre el nodo CSV y el nodo Switch . Nodo Change A\u00f1ade un nodo Change , conectado a la salida del nodo Switch . Configuralo para establecer el valor de msg.payload a ALARMA . Nodo Debug A\u00f1ade un nodo Debug y despliega el flujo. En el panel de Debug , deber\u00e1s obsevar, para cada activaci\u00f3n del nodo Inject , una salida similar a esta: msg.payload : Object {\"time\":\"2017-11-19T15:09:03.120Z\",\"latitude\":-21.5167,\"longitude\":168.5426,\"depth\":14.19,\"mag\":6.6,\"magType\":\"mww\",\"gap\":21,\"dmin\":0.478,\"rms\":0.86,\"net\":\"us\",\"id\":\"us2000brgk\",\"updated\":\"2017-11-19T17:10:58.449Z\",\"place\":\"68km E of Tadine, New Caledonia\",\"type\":\"earthquake\",\"horizontalError\":6.2,\"depthError\":2.8,\"magError\":0.037,\"magNst\":72,\"status\":\"reviewed\",\"locationSource\":\"us\",\"magSource\":\"us\"} Puedes clicar en la peque\u00f1a flecha a la izquierda de cada propiedad para expandirla y examinar sus contenidos. Si existe cualquier terremoto de magnitud mayor a 6.2 , observar\u00e1s una salida adicional: msg.payload : string(6) \"ALARMA\" Para m\u00e1s informaci\u00f3n sobre los nodos b\u00e1sicos en Node-RED, puedes consultar: The Core Nodes : enlace a documentaci\u00f3n . Cliente MQTT y despliegue de un panel de control El nodo MQTT in permite realizar suscripciones a topics determinados en brokers MQTT. Arrastra un nuevo nodo MQTT in en tu espacio de trabajo y configura el broker asociado a localhost , puerto por defecto. Establece un topic de inter\u00e9s. Conecta un nodo Debug y despliega el flujo. Desde tu consola, publica mensajes v\u00eda mosquitto_pub y comprueba que, efectivamente, son visibles en Node-RED. A continuaci\u00f3n, crearemos un peque\u00f1o panel de control para la representaci\u00f3n gr\u00e1fica del valor publicado. En primer lugar, deber\u00e1s instalar el nodo node-red-dashboard desde el men\u00fa principal, opci\u00f3n Manage palette . Tras su instalaci\u00f3n, ver\u00e1s que aparecen nuevos nodos en el panel de nodos; \u00e9stos nos permitir\u00e1n dise\u00f1ar e implementar un panel de control b\u00e1sico basado en Widgets . Arrastra un nodo de tipo Gauge al espacio de trabajo, y configura sus valores por defecto. Conecta la salida de tu nodo MQTT in a la entrada del nuevo nodo Gauge . Despliega el flujo, y navega hasta http://localhost:1880/ui , donde deber\u00e1s observar el panel de control con el widget que has creado. Interact\u00faa con \u00e9l publicando mensajes v\u00eda MQTT. Para m\u00e1s informaci\u00f3n sobre el despliegue de paneles de control, puedes consultar: Node-Red-Dashboard : enlace a documentaci\u00f3n . Documentaci\u00f3n adicional Las gu\u00edas de usuario oficiales de Node-RED son un buen punto de partida para profundizar en el uso de la infraestructura. De entre ellas, la parte m\u00e1s importante para comenzar es la que introduce los conceptos b\u00e1sicos de Node-RED, incluyendo el trabajo con nodos, flujos, contexto (importante para trabajar con valores globales y compartidos por todos los nodos en un flujo, por ejemplo), mensajes, wires , etc.: Node-RED Concepts : enlace a documentaci\u00f3n . La gu\u00eda Node-RED Guide contiene interesante documentaci\u00f3n adicional/avanzada tanto en el despliegue de flujos como en el uso de paneles de control locales o usando servicios remotos (por ejemplo, Freeboard ): Node-RED Guide : enlace a documentaci\u00f3n . Ejercicio entregable Se pide estudiar la documentaci\u00f3n asociada a Node-RED, tanto en su web oficial como en la gu\u00eda de programaci\u00f3n Node-RED Guide (espec\u00edficamente sus cuatro primeras partes. Junto con la explicaci\u00f3n proporcionada por el profesor y los anteriores ejemplos, este estudio permitir\u00e1 el desarrollo de la pr\u00e1ctica. Tarea entregable La pr\u00e1ctica consiste en el dise\u00f1o y desarrollo de un sistema basado en flujos de datos construido sobre Node-RED, que implemente un mecanismo de monitorizaci\u00f3n de par\u00e1metros ambientales (por ejemplo, temperatura) y notificaci\u00f3n (alarmas) ante ciertas circunstancias (por ejemplo, superar una determinada temperatura fijada como umbral). Los alumnos dise\u00f1ar\u00e1n el sistema y lo implementar\u00e1n, cumpliendo las siguientes premisas: (2 puntos) . El sistema utilizar\u00e1, al menos , un dispositivo externo (ESP32, SensorTag, Tel\u00e9fono M\u00f3vil, ...) para la recolecci\u00f3n de datos. Se valorar\u00e1 el uso de m\u00e1s de un dispositivo. (2 puntos) . El sistema depositar\u00e1 o interactuar\u00e1 con, al menos , un sistema externo (servidor de correo, Twitter, Telegram, IBM Bluemix, ...). (2 puntos) . El sistema depositar\u00e1 los datos observados en alg\u00fan medio persistente (Base de Datos no relacional, ficheros, ...) para permitir su posterior an\u00e1lisis y en un panel de control. (2 puntos) . El sistema actuar\u00e1 como un sistema de alarma \u00fanicamente ante ciertas condiciones de entrada (por ejemplo, al recibir un valor desde un sensor superior a un umbral establecido; dicho valor podr\u00eda, por ejemplo, configurarse v\u00eda MQTT o a trav\u00e9s de un panel de control). (2 puntos) . El sistema utilizar\u00e1, al menos, un tipo de nodo no instalado por defecto en la instalaci\u00f3n b\u00e1sica de Node-RED. Se entregar\u00e1 el fichero o ficheros JSON que describen los nodos, as\u00ed como una breve memoria que describa el sistema dise\u00f1ado y el trabajo realizado, haciendo hincapi\u00e9 en las dificultades encontradas y aquellos aspectos que se consideren de inter\u00e9s por parte del alumno/a.","title":"Pr\u00e1ctica 9"},{"location":"RPI-II/P9/#practica-9-node-red","text":"","title":"Pr\u00e1ctica 9. Node-RED"},{"location":"RPI-II/P9/#introduccion-y-objetivos","text":"Node-RED es una herramienta de c\u00f3digo abierto desarrollada inicialmente por IBM y que, estando orientada a flujos de datos, proporciona mecanismos para asociar dispositivos hardware, APIs y servicios online dentro de un ecosistema IoT. Node-RED es una herramienta gr\u00e1fica, utilizable desde cualquier navegador web, que permite la craci\u00f3n y edici\u00f3n de flujos de datos que tomen datos de entrada (mediante nodos de entrada), los procesen (mediante nodos de procesamiento) y proporcionen salidas (mediante nodos de salida). Todos los elementos, incluyendo flujos complejos definidos por el usuario, pueden almacenarse en formato JSON para ser importados a continuaci\u00f3n en otras instalaciones. Node-RED permite la interconexi\u00f3n de elementos software y hardware mediante virtualmente cualquier protocolo conocido, facilitando el despliegue de infraestructuras IoT. El desarrollo de la pr\u00e1ctica difiere sobre el utilizado en pr\u00e1cticas anteriores. En este caso, el presente bolet\u00edn \u00fanicamente incluye informaci\u00f3n e instrucciones para la instalaci\u00f3n de la herramienta Node-RED en la m\u00e1quina virtual del curso (alternativamente, es posible instalar Node-RED en cualquier m\u00e1quina f\u00edsica), as\u00ed como la propuesta de ejercicio entregable a dise\u00f1ar e implementar. Se proporcionar\u00e1n las explicaciones y demostraciones necesarias durante la sesi\u00f3n de laboratorio para entender los conceptos b\u00e1sicos relativos a la instalaci\u00f3n y uso b\u00e1sico de la herramienta Node-RED.","title":"Introducci\u00f3n y objetivos"},{"location":"RPI-II/P9/#instalacion-y-puesta-en-marcha","text":"Para instalar Node-RED en la m\u00e1quina virtual del curso, es suficiente con utilizar el gestor npm : sudo npm install -g --unsafe-perm node-red Al finalzar, si todo ha ido bien, deber\u00edas observar una salida similar a la siguiente: + node-red@1.1.0 added 332 packages from 341 contributors in 18.494s found 0 vulnerabilities Para ejecutar Node-RED, una vez instalado, es posible utilizar la orden node-red desde cualquier terminal. Para detener el proceso, es suficiente con utilizar Ctrl-C : $ node-red Welcome to Node-RED =================== 30 Jun 23:43:39 - [info] Node-RED version: v1.1.0 30 Jun 23:43:39 - [info] Node.js version: v10.21.0 30 Jun 23:43:39 - [info] Darwin 18.7.0 x64 LE 30 Jun 23:43:39 - [info] Loading palette nodes 30 Jun 23:43:44 - [warn] rpi-gpio : Raspberry Pi specific node set inactive 30 Jun 23:43:44 - [info] Settings file : /Users/nol/.node-red/settings.js 30 Jun 23:43:44 - [info] HTTP Static : /Users/nol/node-red/web 30 Jun 23:43:44 - [info] Context store : 'default' [module=localfilesystem] 30 Jun 23:43:44 - [info] User directory : /Users/nol/.node-red 30 Jun 23:43:44 - [warn] Projects disabled : set editorTheme.projects.enabled=true to enable 30 Jun 23:43:44 - [info] Creating new flows file : flows_noltop.json 30 Jun 23:43:44 - [info] Starting flows 30 Jun 23:43:44 - [info] Started flows 30 Jun 23:43:44 - [info] Server now running at http://127.0.0.1:1880/red/ Con el software arrancado, es posible acceder al editor Node-RED a trav\u00e9s de la direcci\u00f3n http://localhost:1880 en cualquier navegador. Tras arrancarlo, observar\u00e1s cuatro \u00e1reas en el editor: Barra principal , en la parte superior, con los botones Deploy y de Men\u00fa principal . Panel de nodos , en la parte izquierda, que proporciona acceso directo a todos los nodos disponibles en Node-RED. Es posible instalar nuevos nodos a trav\u00e9s de la Paleta de Nodos, disponible a trav\u00e9s del men\u00fa principal ( Manage Palette ). Estos nodos pueden ser arrastrados al editor para conformar nuevos flujos de datos. Panel de edici\u00f3n o espacio de trabajo , en la parte central de la pantalla, donde podr\u00e1s arrastrar y unir nuevos nodos. Es posible crear nuevos flujos en pesta\u00f1as independientes. Panel de informaci\u00f3n , en la parte derecha de la pantalla, donde destaca el bot\u00f3n Debug , mediante el cual veremos la salida de los nodos de tipo Debug en nuestros flujos.","title":"Instalaci\u00f3n y puesta en marcha"},{"location":"RPI-II/P9/#ejemplo-1","text":"Se muestra a continuaci\u00f3n un breve ejemplo b\u00e1sico de utilizaci\u00f3n del editor Node-RED, que incluye el uso de nodos Inject , Debug y Function .","title":"Ejemplo 1"},{"location":"RPI-II/P9/#nodo-inject","text":"El nodo Inject permite inyectar mensajes en un flujo, bien pulsando en el bot\u00f3n asociado al nodo, o estableciendo un intervalo de tiempo entre inyecciones. Busca en el panel izquierdo un nodo de tipo Inject y arr\u00e1stralo al espacio de trabajo. En el panel de informaci\u00f3n podr\u00e1s consultar los datos asociados al nodo, as\u00ed como informaci\u00f3n de ayuda para utilizarlo.","title":"Nodo Inject"},{"location":"RPI-II/P9/#nodo-debug","text":"El nodo Debug permite que cualquier mensaje entrante se muestre en el panel de depuraci\u00f3n, en la parte derecha de la pantalla. Por defecto, \u00fanicamente muestra el payload del mensaje, aunque puede configurarse para mostrar el objeto completo. Arrastra un nodo de tipo Debug al espacio de trabajo.","title":"Nodo Debug"},{"location":"RPI-II/P9/#union-y-despliegue-deploy","text":"Conecta los nodos Inject y Debug estableciendo un enlace ( Wire ) entre ambos. Despliega el flujo usando el bot\u00f3n Deploy en la barra principal de Node-RED. Esto desplegar\u00e1 el fujo en el servidor. Selecciona la opci\u00f3n Debug en el panel de informaci\u00f3n, y presiona el bot\u00f3n del nodo Inject . Deber\u00edas ver n\u00fameros aparecer en el panel. Por defecto, el nodo Inject emite el n\u00famero de milisegundos desde el 1 de enero de 1970 como payload . Modifica (temporalmente) el nodo Debug para que muestre todo el mensaje en lugar del payload . Despliega de nuevo el flujo y observa las diferencias. Vuelve a configurar el nodo Debug tal y como estaba cuando lo insertaste.","title":"Uni\u00f3n y despliegue (Deploy)"},{"location":"RPI-II/P9/#nodo-function","text":"El nodo Function permite procesar el mensaje de entrada mediante una funci\u00f3n JavaScript. Borra el Wire existente y a\u00f1ade un nodo Function entre los nodos Inject y Debug . Haz doble clic en el nuevo nodo para abrir el di\u00e1logo de edici\u00f3n. Copia el siguiente c\u00f3digo en el campo Function : // Create a Date object from the payload var date = new Date(msg.payload); // Change the payload to be a formatted Date string msg.payload = date.toString(); // Return the message so it can be sent on return msg; Clica en Done y despliega el flujo. Observa que, ahora, los mensajes de depuraci\u00f3n muestran marcas de tiempo en formato visible. Ten en cuenta que un nodo siempre recibe un mensaje ( msg ) de entrada y devuelve un mensaje ( msg ) de salida. Ambos objetos contienen, por convenio, un campo payload . Para m\u00e1s informaci\u00f3n sobre el uso de funciones y trabajo con mensajes, incluyendo m\u00faltiples valores de retorno y trabajo con valores globales a todo el entorno, se recomienda estudiar la siguiente documentaci\u00f3n: Trabajo con mensajes : enlace a documentaci\u00f3n . Trabajo con funciones : enlace a documentaci\u00f3n .","title":"Nodo Function"},{"location":"RPI-II/P9/#ejemplo-2","text":"","title":"Ejemplo 2"},{"location":"RPI-II/P9/#nodo-inject_1","text":"En el anterior ejemplo, vimos c\u00f3mo crear un nodo Inject para activar el flujo cuando se pulsaba su bot\u00f3n asociado. En este ejemplo, vamos a configurar el nodo Inject para que active el flujo en intervalos regulares. Arrastra un nuevo nodo Inject en el espacio de trabajo. Clica en \u00e9l dos veces y, en el di\u00e1logo de edici\u00f3n, usala opci\u00f3n Repeat interval , fij\u00e1ndolo en un intervalo regular. Cierra el di\u00e1logo de edici\u00f3n.","title":"Nodo Inject"},{"location":"RPI-II/P9/#nodo-http-request","text":"El nodo de tipo HTTP Request puede utilizarse para descargar una p\u00e1gina web o recurso HTTP. A\u00f1ade uno al espacio de trabajo, y ed\u00edtalo para que su propiedad URL apunte a https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/significant_month.csv . Esta URL es un repositorio de terremotos en el \u00faltimo mes, pulicado por el organismo oficial correspondiente, devueltos en formato CSV.","title":"Nodo HTTP Request"},{"location":"RPI-II/P9/#nodo-csv","text":"A\u00f1ade un nuevo nodo CSV y edita sus propiedades. Activa la opci\u00f3n First row contains column names y finaliza la edici\u00f3n.","title":"Nodo CSV"},{"location":"RPI-II/P9/#nodo-debug-y-cableado","text":"A\u00f1ade un nodo Debug y une los nodos creados: Conecta la salida del nodo Inject a la entrada del nodo HTTP Request . Conecta la salida del nodo HTTP Request a la entrada del nodo CSV . Conecta la salida del nodo CSV a la entrada del nodo Debug .","title":"Nodo Debug y cableado"},{"location":"RPI-II/P9/#nodo-switch","text":"A\u00f1ade un nodo Switch al espacio de trabajo. Edita sus propiedades y configuralo para comprobar la propiedad msg.payload.mag , usando la operaci\u00f3n >= sobre un valor num\u00e9rico y el valor 6.2 , por ejemplo. A\u00f1ade un segundo Wire entre el nodo CSV y el nodo Switch .","title":"Nodo Switch"},{"location":"RPI-II/P9/#nodo-change","text":"A\u00f1ade un nodo Change , conectado a la salida del nodo Switch . Configuralo para establecer el valor de msg.payload a ALARMA .","title":"Nodo Change"},{"location":"RPI-II/P9/#nodo-debug_1","text":"A\u00f1ade un nodo Debug y despliega el flujo. En el panel de Debug , deber\u00e1s obsevar, para cada activaci\u00f3n del nodo Inject , una salida similar a esta: msg.payload : Object {\"time\":\"2017-11-19T15:09:03.120Z\",\"latitude\":-21.5167,\"longitude\":168.5426,\"depth\":14.19,\"mag\":6.6,\"magType\":\"mww\",\"gap\":21,\"dmin\":0.478,\"rms\":0.86,\"net\":\"us\",\"id\":\"us2000brgk\",\"updated\":\"2017-11-19T17:10:58.449Z\",\"place\":\"68km E of Tadine, New Caledonia\",\"type\":\"earthquake\",\"horizontalError\":6.2,\"depthError\":2.8,\"magError\":0.037,\"magNst\":72,\"status\":\"reviewed\",\"locationSource\":\"us\",\"magSource\":\"us\"} Puedes clicar en la peque\u00f1a flecha a la izquierda de cada propiedad para expandirla y examinar sus contenidos. Si existe cualquier terremoto de magnitud mayor a 6.2 , observar\u00e1s una salida adicional: msg.payload : string(6) \"ALARMA\" Para m\u00e1s informaci\u00f3n sobre los nodos b\u00e1sicos en Node-RED, puedes consultar: The Core Nodes : enlace a documentaci\u00f3n .","title":"Nodo Debug"},{"location":"RPI-II/P9/#cliente-mqtt-y-despliegue-de-un-panel-de-control","text":"El nodo MQTT in permite realizar suscripciones a topics determinados en brokers MQTT. Arrastra un nuevo nodo MQTT in en tu espacio de trabajo y configura el broker asociado a localhost , puerto por defecto. Establece un topic de inter\u00e9s. Conecta un nodo Debug y despliega el flujo. Desde tu consola, publica mensajes v\u00eda mosquitto_pub y comprueba que, efectivamente, son visibles en Node-RED. A continuaci\u00f3n, crearemos un peque\u00f1o panel de control para la representaci\u00f3n gr\u00e1fica del valor publicado. En primer lugar, deber\u00e1s instalar el nodo node-red-dashboard desde el men\u00fa principal, opci\u00f3n Manage palette . Tras su instalaci\u00f3n, ver\u00e1s que aparecen nuevos nodos en el panel de nodos; \u00e9stos nos permitir\u00e1n dise\u00f1ar e implementar un panel de control b\u00e1sico basado en Widgets . Arrastra un nodo de tipo Gauge al espacio de trabajo, y configura sus valores por defecto. Conecta la salida de tu nodo MQTT in a la entrada del nuevo nodo Gauge . Despliega el flujo, y navega hasta http://localhost:1880/ui , donde deber\u00e1s observar el panel de control con el widget que has creado. Interact\u00faa con \u00e9l publicando mensajes v\u00eda MQTT. Para m\u00e1s informaci\u00f3n sobre el despliegue de paneles de control, puedes consultar: Node-Red-Dashboard : enlace a documentaci\u00f3n .","title":"Cliente MQTT y despliegue de un panel de control"},{"location":"RPI-II/P9/#documentacion-adicional","text":"Las gu\u00edas de usuario oficiales de Node-RED son un buen punto de partida para profundizar en el uso de la infraestructura. De entre ellas, la parte m\u00e1s importante para comenzar es la que introduce los conceptos b\u00e1sicos de Node-RED, incluyendo el trabajo con nodos, flujos, contexto (importante para trabajar con valores globales y compartidos por todos los nodos en un flujo, por ejemplo), mensajes, wires , etc.: Node-RED Concepts : enlace a documentaci\u00f3n . La gu\u00eda Node-RED Guide contiene interesante documentaci\u00f3n adicional/avanzada tanto en el despliegue de flujos como en el uso de paneles de control locales o usando servicios remotos (por ejemplo, Freeboard ): Node-RED Guide : enlace a documentaci\u00f3n .","title":"Documentaci\u00f3n adicional"},{"location":"RPI-II/P9/#ejercicio-entregable","text":"Se pide estudiar la documentaci\u00f3n asociada a Node-RED, tanto en su web oficial como en la gu\u00eda de programaci\u00f3n Node-RED Guide (espec\u00edficamente sus cuatro primeras partes. Junto con la explicaci\u00f3n proporcionada por el profesor y los anteriores ejemplos, este estudio permitir\u00e1 el desarrollo de la pr\u00e1ctica. Tarea entregable La pr\u00e1ctica consiste en el dise\u00f1o y desarrollo de un sistema basado en flujos de datos construido sobre Node-RED, que implemente un mecanismo de monitorizaci\u00f3n de par\u00e1metros ambientales (por ejemplo, temperatura) y notificaci\u00f3n (alarmas) ante ciertas circunstancias (por ejemplo, superar una determinada temperatura fijada como umbral). Los alumnos dise\u00f1ar\u00e1n el sistema y lo implementar\u00e1n, cumpliendo las siguientes premisas: (2 puntos) . El sistema utilizar\u00e1, al menos , un dispositivo externo (ESP32, SensorTag, Tel\u00e9fono M\u00f3vil, ...) para la recolecci\u00f3n de datos. Se valorar\u00e1 el uso de m\u00e1s de un dispositivo. (2 puntos) . El sistema depositar\u00e1 o interactuar\u00e1 con, al menos , un sistema externo (servidor de correo, Twitter, Telegram, IBM Bluemix, ...). (2 puntos) . El sistema depositar\u00e1 los datos observados en alg\u00fan medio persistente (Base de Datos no relacional, ficheros, ...) para permitir su posterior an\u00e1lisis y en un panel de control. (2 puntos) . El sistema actuar\u00e1 como un sistema de alarma \u00fanicamente ante ciertas condiciones de entrada (por ejemplo, al recibir un valor desde un sensor superior a un umbral establecido; dicho valor podr\u00eda, por ejemplo, configurarse v\u00eda MQTT o a trav\u00e9s de un panel de control). (2 puntos) . El sistema utilizar\u00e1, al menos, un tipo de nodo no instalado por defecto en la instalaci\u00f3n b\u00e1sica de Node-RED. Se entregar\u00e1 el fichero o ficheros JSON que describen los nodos, as\u00ed como una breve memoria que describa el sistema dise\u00f1ado y el trabajo realizado, haciendo hincapi\u00e9 en las dificultades encontradas y aquellos aspectos que se consideren de inter\u00e9s por parte del alumno/a.","title":"Ejercicio entregable"}]}