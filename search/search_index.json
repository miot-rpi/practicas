{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Redes, Protocolos e Interfaces Calendario RPI-I Pr\u00e1ctica D\u00eda T\u00edtulo 1 05/10 Introducci\u00f3n al entorno de desarrollo 12/10 FESTIVO 2 19/10 WiFi 3 26/10 WiFi Mesh 02/11 FESTIVO 09/11 FESTIVO 4 16/11 Bluetooth Low Energy 5 23/11 BLE Mesh 6 30/11 6LowPAN (Simulaci\u00f3n) 07/12 FESTIVO 7 14/12 6LowPAN (SensorTag) 8 21/12 LoRA Calendario RPI-II Pr\u00e1ctica D\u00eda T\u00edtulo 1 01/10 Sockets TCP/UDP (Linux) 2 08/10 Sockets TCP/UDP (ESP32) 3 15/10 TLS y DTLS 4 22/10 HTTP/Websockets 5 29/11 Representaci\u00f3n de la informaci\u00f3n. CBOR 6 05/11 MQTT (I) 6 12/11 MQTT (II) 7 19/11 CoAP 8 26/11 LWM2M (I) 8 03/12 LWM2M (II) 9 10/12 Node-RED 10 17/12 Entornos Cloud / Frameworks IoT","title":"Calendario"},{"location":"#redes-protocolos-e-interfaces","text":"","title":"Redes, Protocolos e Interfaces"},{"location":"#calendario-rpi-i","text":"Pr\u00e1ctica D\u00eda T\u00edtulo 1 05/10 Introducci\u00f3n al entorno de desarrollo 12/10 FESTIVO 2 19/10 WiFi 3 26/10 WiFi Mesh 02/11 FESTIVO 09/11 FESTIVO 4 16/11 Bluetooth Low Energy 5 23/11 BLE Mesh 6 30/11 6LowPAN (Simulaci\u00f3n) 07/12 FESTIVO 7 14/12 6LowPAN (SensorTag) 8 21/12 LoRA","title":"Calendario RPI-I"},{"location":"#calendario-rpi-ii","text":"Pr\u00e1ctica D\u00eda T\u00edtulo 1 01/10 Sockets TCP/UDP (Linux) 2 08/10 Sockets TCP/UDP (ESP32) 3 15/10 TLS y DTLS 4 22/10 HTTP/Websockets 5 29/11 Representaci\u00f3n de la informaci\u00f3n. CBOR 6 05/11 MQTT (I) 6 12/11 MQTT (II) 7 19/11 CoAP 8 26/11 LWM2M (I) 8 03/12 LWM2M (II) 9 10/12 Node-RED 10 17/12 Entornos Cloud / Frameworks IoT","title":"Calendario RPI-II"},{"location":"RPI-I/P1/","text":"Pr\u00e1ctica 1. Introducci\u00f3n al entorno de desarrollo ESP-IDF Objetivos Conocer dos entornos b\u00e1sicos de desarrollo para el ESP32: uno basado en l\u00ednea de comandos, y otro en la herramienta PlatformIO Ser capaz de compilar, flashear y monitorizar proyectos sencillos basados en ESP-IDF Entender el funcionamiento b\u00e1sico de una aplicaci\u00f3n ESP-IDF que haga uso de las capacidades WiFi del ESP32 Personalizar variables de configuraci\u00f3n de proyectos ESP-IDF Responder a eventos b\u00e1sicos de red en ESP-IDF Introducci\u00f3n ESP-IDF ( Espressif IoT Development Framework ) es el entorno de desarrollo oficial de Espressif para los SoCs ESP32 y ESP32-S. Este entorno de desarrollo y conjunto de herramientas permite desarrollar firmwares eficientes para dichas placas utilizando las interfaces de comunicaci\u00f3n WiFi y Bluetooth, as\u00ed como gestionar m\u00faltiples caracter\u00edsticas de los SoCs que iremos desgranando en futuras pr\u00e1cticas. ESP-IDF utiliza como base FreeRTOS para la construcci\u00f3n del firmware , aunque a\u00f1ade multitud de componentes para ofrecer un soporte de mayor nivel para la interacci\u00f3n con protocolos de comunicaci\u00f3n de bajo y alto nivel, la mayor\u00eda de ellos enfocados al \u00e1mbito de comunicaci\u00f3n en Internet de las Cosas. La presente pr\u00e1ctica pretende ser una introducci\u00f3n b\u00e1sica a la puesta en marcha del entorno de desarrollo ESP-IDF sobre un sistema operativo Linux, ofreciendo dos alternativas b\u00e1sicas: l\u00ednea de comandos y un plugin espec\u00edfico para VSCode (PlatformIO). Adem\u00e1s, veremos de forma superficial la estructura b\u00e1sica de un programa sencillo desarrollado usando ESP-IDF, as\u00ed como ejemplos b\u00e1sicos para la puesta en marcha de la interfaz WiFi sobre una placa ESP32. Recuerda La presente pr\u00e1ctica no tiene tarea entregable asociada m\u00e1s all\u00e1 de una memoria justificativa del trabajo realizado. Por tanto, recuerda apuntar y reportar los pasos y tareas realizadas durante su desarrollo para plasmarlas en una breve memoria entregable final. Flujo de trabajo. Entorno basado en l\u00ednea de comandos Instalaci\u00f3n de prerequisitos ESP-IDF requiere ciertos paquetes software instalados en el sistema para poder desarrollar los c\u00f3digos y descargarlos sobre el ESP32. Se muestran a continuaci\u00f3n los requisitos y modo de instalaci\u00f3n para m\u00e1quinas Ubuntu/Debian (como la m\u00e1quina virtual del curso), aunque la documentaci\u00f3n de ESP-IDF incluye instrucciones para otras distribuciones y sistemas operativos, incluyendo Windows y MacOS. En tu m\u00e1quina virtual, instala los paquetes necesarios utilizando (como superusuario): sudo apt-get install git wget flex bison gperf python python3-pip python-setuptools cmake ninja-build ccache libffi-dev libssl-dev dfu-util Adem\u00e1s, es necesario, en todo caso, que el usuario que est\u00e9s utilizando pertenezca al grupo dialout (puedes editar el fichero /etc/group a\u00f1adiendo a tu usuario a la l\u00ednea que indica el grupo correspondiente, e iniciando de nuevo tu sesi\u00f3n). Instala y configura Python 3 para su uso por defecto en tu distribuci\u00f3n: sudo apt-get install python3 python3-pip python3-setuptools sudo update-alternatives --install /usr/bin/python python /usr/bin/python3 10 Obtenci\u00f3n de ESP-IDF Utilizaremos las versiones de ESP-IDF a obtener directamente desde el repositorio Github oficial (concretamente, en su versi\u00f3n 4.1). Para ello, ejecuta desde tu directorio de inicio: mkdir -p ~/esp cd ~/esp git clone --recursive https://github.com/espressif/esp-idf.git cd esp-idf git fetch git checkout release/v4.1 git pull git submodule update --init --recursive Instalaci\u00f3n de herramientas adicionales Desde el directorio esp-idf , ejecuta el script install.sh para instalar las herramientas ( toolchain ) espec\u00edficas para tu versi\u00f3n: sh install.sh Preparaci\u00f3n del entorno Tras el inicio de cada sesi\u00f3n, deber\u00e1s establecer valores correctos para ciertas variables de entorno. Afortunadamente, se proporciona un script ( export.sh ) que te permitir\u00e1 establecerlas de forma autom\u00e1tica: . export.sh Puedes a\u00f1adir esta l\u00ednea en cualquier fichero de inicio de sesi\u00f3n para no tener que ejecutar el comando cada vez. En cualquier caso, en este punto deber\u00edas tener acceso a un programa llamado idf.py , a trav\u00e9s del cual gestionaremos el flujo de trabajo. Compru\u00e9balo y observa si la version de IDF con la que est\u00e1s trabajando es efectivamente la 4.1 (el n\u00famero de subversi\u00f3n podr\u00eda variar en tu salida): $ idf.py --version ESP-IDF v4.1-332-g7b7c64107 Preparaci\u00f3n del proyecto En esta primera parte, nos basaremos en un ejemplo sencillo de c\u00f3digo desarrollado en base a ESP-IDF. No es el objetivo de esta pr\u00e1ctica analizar en detalle los la estructura de dicho c\u00f3digo (al menos de momento), sino utilizarlo para ilustrar el flujo de trabajo t\u00edpico en un proyecto ESP-IDF. Recuerda Tras la ejecuci\u00f3n del script export.sh , tendr\u00e1s definida una variable de entorno llamada IDF_PATH . Consulta su valor y comprueba que apunta, efectivamente, al directorio de instalaci\u00f3n de IDF. La utilizaremos a partir de ahora para referirnos a \u00e9l. Para empezar, toma el ejemplo hello_world proporcionado como parte de la instalaci\u00f3n b\u00e1sica de IDF, y c\u00f3pialo en cualquier directorio del sistema de ficheros: cp -R $IDF_PATH/examples/get-started/hello_world $HOME/ cd $HOME/hello_world Compilaci\u00f3n El proceso de compilaci\u00f3n b\u00e1sico utiliza el script idf.py : idf.py build Si todo ha ido bien, en el directorio build se habr\u00e1n generado los objetos y binarios listos para ser flasheados en el ESP32. Flasheado El proceso de flasheado b\u00e1sico utiliza el script idf.py : idf.py -p PUERTO flash En este punto, el ESP32 debe estar conectado utilizando el cable microUSB, y si est\u00e1s trabajando en una m\u00e1quina virtual, debe haberse hecho visible a la misma (por ejemplo, en VirtualBox, a trav\u00e9s del men\u00fa Dispositivos->USB->Silicon Labs USB to UART Bridge Controller ). En todo caso, la salida del comando dmesg tras la conexi\u00f3n del dispositivo te proporcionar\u00e1 informaci\u00f3n sobre el PUERTO que debes utilizar en el proceso de flasheado y montorizaci\u00f3n posterior. Monitorizaci\u00f3n Si todo ha ido bien, el proceso de monitorizaci\u00f3n nos permitir\u00e1 observar la salida del programa que tenemos ejecutando en la placa. Para ello, de nuevo, usamos el script idf.py : idf.py -p PUERTO monitor Nota Comprueba que, efectivamente, puedes realizar el proceso de compilaci\u00f3n, flasheado y monitorizaci\u00f3n del programa sobre la placa ESP32. Recuerda que el bot\u00f3n EN , justo al lado del conector microUSB, forzar\u00e1 un reseteo de la misma. Flujo de trabajo. Entorno basado en PlatformIO El anterior flujo de trabajo puede tambi\u00e9n desarrollarse desde otros entornos de desarrollo. En nuestro caso, se muestran a continuaci\u00f3n los pasos principales para la integraci\u00f3n de ESP-IDF con VSCode, utilizando la plataforma PlatformIO . Las m\u00e1quinas virtuales proporcionadas en el curso ya tienen instalada la \u00faltima versi\u00f3n de PlatformIO y ESP-IDF, por lo que se refiere al lector a la documentaci\u00f3n oficial de PlatformIO para llevar a cabo dicha instalaci\u00f3n en otros sistemas operativos. Configuraci\u00f3n de un proyecto La forma m\u00e1s sencilla de crear un nuevo proyecto consiste en pulsar el bot\u00f3n PlatformIO Home situado en la parte inferior de la pantalla: A continuaci\u00f3n, clica en New Project y selecciona como placa de desarrollo ESP DevkitC o Espressif ESP32 Dev Module . Selecciona ESP-IDF como framework de desarrollo para el proyecto: Adici\u00f3n de ficheros a un proyecto Crea un nuevo fichero main.c (si no existe) en el directorio src de tu proyecto, o modifica el que ya existe utilizando, por ejemplo, el siguiente c\u00f3digo: #include <string.h> #include \"freertos/FreeRTOS.h\" #include \"freertos/task.h\" #include \"esp_system.h\" #include \"esp_wifi.h\" #include \"esp_event.h\" #include \"esp_log.h\" #include \"nvs_flash.h\" #include \"lwip/err.h\" #include \"lwip/sys.h\" #define EXAMPLE_ESP_WIFI_SSID \"mywifissid\" #define EXAMPLE_ESP_WIFI_PASS \"mywifipass\" #define EXAMPLE_MAX_STA_CONN (3) static const char *TAG = \"wifi softAP\"; static void wifi_event_handler(void* arg, esp_event_base_t event_base, int32_t event_id, void* event_data) { if (event_id == WIFI_EVENT_AP_STACONNECTED) { wifi_event_ap_staconnected_t* event = (wifi_event_ap_staconnected_t*) event_data; ESP_LOGI(TAG, \"station \"MACSTR\" join, AID=%d\", MAC2STR(event->mac), event->aid); } else if (event_id == WIFI_EVENT_AP_STADISCONNECTED) { wifi_event_ap_stadisconnected_t* event = (wifi_event_ap_stadisconnected_t*) event_data; ESP_LOGI(TAG, \"station \"MACSTR\" leave, AID=%d\", MAC2STR(event->mac), event->aid); } } void wifi_init_softap() { tcpip_adapter_init(); ESP_ERROR_CHECK(esp_event_loop_create_default()); wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT(); ESP_ERROR_CHECK(esp_wifi_init(&cfg)); ESP_ERROR_CHECK(esp_event_handler_register(WIFI_EVENT, ESP_EVENT_ANY_ID, &wifi_event_handler, NULL)); wifi_config_t wifi_config = { .ap = { .ssid = EXAMPLE_ESP_WIFI_SSID, .ssid_len = strlen(EXAMPLE_ESP_WIFI_SSID), .password = EXAMPLE_ESP_WIFI_PASS, .max_connection = EXAMPLE_MAX_STA_CONN, .authmode = WIFI_AUTH_WPA_WPA2_PSK }, }; if (strlen(EXAMPLE_ESP_WIFI_PASS) == 0) { wifi_config.ap.authmode = WIFI_AUTH_OPEN; } ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_AP)); ESP_ERROR_CHECK(esp_wifi_set_config(ESP_IF_WIFI_AP, &wifi_config)); ESP_ERROR_CHECK(esp_wifi_start()); ESP_LOGI(TAG, \"wifi_init_softap finished. SSID:%s password:%s\", EXAMPLE_ESP_WIFI_SSID, EXAMPLE_ESP_WIFI_PASS); } void app_main() { //Initialize NVS esp_err_t ret = nvs_flash_init(); if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) { ESP_ERROR_CHECK(nvs_flash_erase()); ret = nvs_flash_init(); } ESP_ERROR_CHECK(ret); ESP_LOGI(TAG, \"ESP_WIFI_MODE_AP\"); wifi_init_softap(); } De momento no analizaremos el funcionamiento del c\u00f3digo (lo haremos m\u00e1s adelante) pero b\u00e1sicamente establece un Punto de Acceso inal\u00e1mbrico abierto a conexiones autenticadas v\u00eda WPA2. Compilaci\u00f3n del proyecto Para compilar del proyecto, despliega la paleta de comandos (men\u00fa View -> Command Palette ) y ejecuta la orden PlatformIO: Build desde ella. Tambi\u00e9n puedes presionar el bot\u00f3n Build (con forma de check ) en la barra inferior de PlatformIO: Si todo ha ido bien, deber\u00edas ver un mensaje final similar al siguiente en la terminal del sistema: Flasheado del proyecto Para llevar a cabo el proceso de subida ( upload ) del proyecto a la placa, podemos utilizar la orden PlatformIO: Upload a trav\u00e9s de la paleta de comandos, o bien presionar el bot\u00f3n correspondiente en la barra inferior (con un s\u00edmbolo de flecha a izquierda): Monitorizaci\u00f3n del proyecto Por \u00faltimo, podemos monitorizar el proyecto utilizando la orden PlatformIO: Monitor de la paleta de comandos o a trav\u00e9s de la barra inferior, usando el bot\u00f3n con un enchufe como s\u00edmbolo: An\u00e1lisis de un proyecto sencillo ( Hola, mundo ) en ESP-IDF Nota Las siguientes tareas pueden realizarse desde l\u00ednea de comandos o utilizando PlatformIO. Para familiarizarse con en entorno de bajo nivel, sin embargo, se sugiere el uso de l\u00ednea de comandos. Observa la estructura general del directorio hello_world que compilaste anteriormente. Espec\u00edficamente, nos interesar\u00e1 inspeccionar la estructura b\u00e1sica de un programa principal para ESP-IDF, en este caso hello_world_main.c . #include <stdio.h> #include \"sdkconfig.h\" #include \"freertos/FreeRTOS.h\" #include \"freertos/task.h\" #include \"esp_system.h\" #include \"esp_spi_flash.h\" void app_main(void) { printf(\"Hello world!\\n\"); /* Print chip information */ esp_chip_info_t chip_info; esp_chip_info(&chip_info); printf(\"This is %s chip with %d CPU cores, WiFi%s%s, \", CONFIG_IDF_TARGET, chip_info.cores, (chip_info.features & CHIP_FEATURE_BT) ? \"/BT\" : \"\", (chip_info.features & CHIP_FEATURE_BLE) ? \"/BLE\" : \"\"); printf(\"silicon revision %d, \", chip_info.revision); printf(\"%dMB %s flash\\n\", spi_flash_get_chip_size() / (1024 * 1024), (chip_info.features & CHIP_FEATURE_EMB_FLASH) ? \"embedded\" : \"external\"); printf(\"Minimum free heap size: %d bytes\\n\", esp_get_minimum_free_heap_size()); for (int i = 10; i >= 0; i--) { printf(\"Restarting in %d seconds...\\n\", i); vTaskDelay(1000 / portTICK_PERIOD_MS); } printf(\"Restarting now.\\n\"); fflush(stdout); esp_restart(); } A alto nivel, la funci\u00f3n app_main es el punto de entrada a todo programa desarrollado usando ESP-IDF. De modo m\u00e1s espec\u00edfico, tras la carga del sistema , la llamada tarea principal ( main task ) ejecuta el c\u00f3digo proporcionado por el usuario e implementado en la funci\u00f3n app_main . Tanto el tama\u00f1o de pila asignado como la prioridad de esta tarea puede ser configuradas por el desarrollador a trav\u00e9s del sistema de configuraci\u00f3n de ESP-IDF (lo veremos m\u00e1s adelante). Normalmente, esta funci\u00f3n se utiliza para llevar a cabo tareas iniciales de configuraci\u00f3n o para crear y lanzar a ejecuci\u00f3n otras tareas. De cualquier modo (como es el caso), se puede implementar cualquier funcionalidad dentro de la funci\u00f3n app_main . En este ejemplo, se muestra en primer lugar informaci\u00f3n gen\u00e9rica sobre el SoC que est\u00e1 ejecutando el firmware : /* Print chip information */ esp_chip_info_t chip_info; esp_chip_info(&chip_info); printf(\"This is %s chip with %d CPU cores, WiFi%s%s, \", CONFIG_IDF_TARGET, chip_info.cores, (chip_info.features & CHIP_FEATURE_BT) ? \"/BT\" : \"\", (chip_info.features & CHIP_FEATURE_BLE) ? \"/BLE\" : \"\"); printf(\"silicon revision %d, \", chip_info.revision); printf(\"%dMB %s flash\\n\", spi_flash_get_chip_size() / (1024 * 1024), (chip_info.features & CHIP_FEATURE_EMB_FLASH) ? \"embedded\" : \"external\"); printf(\"Minimum free heap size: %d bytes\\n\", esp_get_minimum_free_heap_size()); A continuaci\u00f3n, dentro de un bucle sencillo, el sistema muestra un mensaje y difiere la ejecuci\u00f3n de la tarea durante un per\u00edodo determinado de tiempo utilizando la funci\u00f3n vTaskDelay de FreeRTOS. Esta funci\u00f3n recibe el n\u00famero de ticks de reloj que se desea utilizar, por lo que el tiempo real que la tarea diferir\u00e1 su ejecuci\u00f3n depende de la duraci\u00f3n de dicho tick . Por ello, la constante portTIC_PERIOD_MS puede utilizarse para calcular dicho tiempo: for (int i = 10; i >= 0; i--) { printf(\"Restarting in %d seconds...\\n\", i); vTaskDelay(1000 / portTICK_PERIOD_MS); } Finalmente, la tarea reinicia el sistema tras la finalizaci\u00f3n de la tarea principal: printf(\"Restarting now.\\n\"); fflush(stdout); esp_restart(); Tarea Modifica el per\u00edodo de suspensi\u00f3n de la tarea para que sea mayor o menor, y comprueba que efectivamente esto modifica el comportamiento del firmware cargado. Modifica el programa para que se muestre tambi\u00e9n por pantalla si el SoC tiene capacidades WiFi y si incluye memoria FLASH (para ello, puedes consultar la siguiente p\u00e1gina ). Creaci\u00f3n de tareas El anterior proyecto puede replantearse para que no sea la tarea principal la que ejecute la l\u00f3gica del programa. Para ello, es necesario introducir brevemente la API b\u00e1sica para gesti\u00f3n (en nuestro caso, creaci\u00f3n) de tareas. Ver\u00e1s muchos m\u00e1s detalles sobre esta API en la asignatura ANIOT, por lo que no veremos aqu\u00ed m\u00e1s detalles de los estrictamente necesarios. La funci\u00f3n xTaskCreate (incluida en task.h ) permite la creaci\u00f3n de nuevas tareas: BaseType_t xTaskCreate( TaskFunction_t pvTaskCode, const char * const pcName, configSTACK_DEPTH_TYPE usStackDepth, void *pvParameters, UBaseType_t uxPriority, TaskHandle_t *pxCreatedTask ); Concretamente, crea una nueva tarea y la a\u00f1ade a la lista de tareas listas para ejecuci\u00f3n, recibiendo como par\u00e1metros: pvTaskCode : Puntero a la funci\u00f3n de entrada para la tarea. Las tareas suelen implementarse como un bucle infinito, y no deber\u00eda, en su cuerpo, retornar o simplemente finalizar abruptamente. En cambio, una tarea puede ser destruida externamente a trav\u00e9s de su manejador (\u00faltimo par\u00e1metro en la creaci\u00f3n), o internamente (desde el propio c\u00f3digo de la tarea), tal y como se muestra en el siguiente ejemplo extra\u00eddo directamente desde la documentaci\u00f3n de FreeRTOS: void vATaskFunction( void *pvParameters ) { for( ;; ) { -- Task application code here. -- } /* Tasks must not attempt to return from their implementing function or otherwise exit. In newer FreeRTOS port attempting to do so will result in an configASSERT() being called if it is defined. If it is necessary for a task to exit then have the task call vTaskDelete( NULL ) to ensure its exit is clean. */ vTaskDelete( NULL ); } pcName : Nombre (en forma de cadena) descriptivo de la tarea a ejecutar, t\u00edpicamente usado en tiempo de depuraci\u00f3n. usStackDepth : N\u00famero de palabras a alojar para utilizar como pila para la tarea. pvParameters : Par\u00e1metros a proporcionar a la funci\u00f3n de entrada para la tarea. uxPriority : Prioridad asignada a la tarea. pxCreatedTask : Manejador opcional para la tarea. As\u00ed, la funcionalidad del programa Hola, mundo que hemos analizado anteriormente, podr\u00eda reestrcturarse en base a una \u00fanica tarea: void hello_task(void *pvParameter) { printf(\"Hello world!\\n\"); for (int i = 10; i >= 0; i--) { printf(\"Restarting in %d seconds...\\n\", i); vTaskDelay(1000 / portTICK_RATE_MS); } printf(\"Restarting now.\\n\"); fflush(stdout); esp_restart(); } Que podr\u00eda ser creada desde la tarea principal: void app_main() { nvs_flash_init(); xTaskCreate( &hello_task, \"hello_task\", 2048, NULL, 5, NULL ); } Tarea Implementa una modificaci\u00f3n del programa hello_world que implemente y planifique dos tareas independientes con distinta funcionalidad (en este caso, es suficiente con mostrar por pantalla alg\u00fan mensaje) y distintos tiempos de suspensi\u00f3n. Comprueba que, efectivamente, ambas tareas se ejecutan concurrentemente. Personalizaci\u00f3n del proyecto ESP-IDF utiliza la biblioteca kconfiglib para proporcionar un sistema de configuracion de proyectos en tiempo de compilaci\u00f3n sencillo y extensible. Para ilustrar su funcionamiento, utilizaremos el ejemplo blink que puedes encontrar en la distribuci\u00f3n de ESP-IDF que has clonado anteriormente (copia el ejemplo en cualquier punto de tu jerarqu\u00eda de directorios antes de comenzar). Para configurar un proyecto ESP-IDF, simplemente utiliza la siguiente orden: idf.py menuconfig La ejecuci\u00f3n de la orden anterior te permitir\u00e1 navegar por un conjunto de opciones de car\u00e1cter general, que te permitir\u00e1n configurar las caracter\u00edsticas espec\u00edficas del proyecto a compilar (por ejemplo, seleccionando los componentes que deseas habilitar en la construcci\u00f3n del mismo). Tarea Navega por las opciones que aparecen en los men\u00fas de configuraci\u00f3n para familiarizarte con ellos. Los utilizar\u00e1s en futuras pr\u00e1cticas. En el proyecto blink , observa que una de las opciones del men\u00fa de navegaci\u00f3n, llamada Example configuration , incluye una opci\u00f3n llamada Blink GPIO number . M\u00e1s all\u00e1 de su funcionalidad (define el n\u00famero de pin GPIO a activar/desactivar para iluminar un LED), es de inter\u00e9s para nosotros el hecho de que esta opci\u00f3n de configuraci\u00f3n definir\u00e1 en tiempo de compilaci\u00f3n el valor de una constante (en este caso CONFIG_BLINK_GPIO ) que podemos utilizar directamente en cualquier fichero de nuestro proyecto. Nota Observa el uso que da el c\u00f3digo del proyecto blink a la constante CONFIG_BLINK_GPIO . Esta opci\u00f3n de configuraci\u00f3n no forma parte de las opciones por defecto de ESP-IDF, sino que ha sido a\u00f1adida por los desarrolladores del proyecto blink . Observa y estudia el formato y contenido del fichero main/Kconfig.projbuild que se proporciona como parte del fichero. En \u00e9l, se definen las caracter\u00edsticas (nombre, rango, valor por defecto y descripcion) de la opci\u00f3n de configuraci\u00f3n a definir. Tarea Modifica el proyecto hello_world para que defina dos opciones de configuraci\u00f3n que permitir\u00e1n definir el tiempo de espera de cada una de las dos tareas que hayas definido en tu anterior soluci\u00f3n. Haz uso de ellas en tu c\u00f3digo y comprueba que efectivamente su modificaci\u00f3n a trav\u00e9s del sistema de men\u00fas permite una personalizaci\u00f3n del comportamiento de tus c\u00f3digos. Gesti\u00f3n de redes WiFi. Ejemplo 1. Escaneado de redes WiFi A modo de ejemplo, y en preparaci\u00f3n para los c\u00f3digos con los que trabajaremos en futuras pr\u00e1cticas, vamos a analizar a continuaci\u00f3n un ejemplo concreto de firmware cuya tarea es el escaneado de redes inal\u00e1mbricas al alcance del ESP32, y su reporte a trav\u00e9s del puerto serie del mismo. Para cada red escaneada, se reportar\u00e1n sus caracter\u00edsticas principales. Tarea Compila, flashea y monitoriza el ejemplo scan situado en el directorio examples/wifi/scan . Recuerda copiarlo antes a cualquier otro directorio de tu home . Antes de compilarlo, modifica el n\u00famero m\u00e1ximo de redes a escanear a trav\u00e9s del men\u00fa de configuraci\u00f3n del ejemplo para ampliarlo a 20. Crea un punto de acceso WiFi con tu tel\u00e9fono m\u00f3vil y observa que, efectivamente, es escaneado por el ejemplo. Observa su funcionamiento. Realmente, el firmware simplemente escanea un subconjunto de las redes disponibles, reportando algunas de sus caracter\u00edsticas (por ejemplo, SSID, modo de autenticaci\u00f3n o canal primario). Tarea Analiza el c\u00f3digo de la funci\u00f3n wifi_scan (tarea principal). Espec\u00edficamente, c\u00e9ntrate en las l\u00edneas que permiten activar y configurar el escaneado de redes. Intenta entender el funcionamiento general del programa, consultando y apuntando el cometido de cada l\u00ednea, con especial inter\u00e9s a aquellas funciones con prefijo esp_wifi_* . Anota en la memoria entregable el cometido de cada una de ellas, consultando la documentaci\u00f3n oficial . Gesti\u00f3n de redes WiFi. Ejemplo 2. Gesti\u00f3n de eventos de red El segundo ejemplo consiste en la creaci\u00f3n de un firmware para conexi\u00f3n del ESP32 a un punto de acceso existente. Este ejemplo nos permitir\u00e1 observar, a grandes rasgos, el sistema de gesti\u00f3n de eventos en FreeRTOS/ESP-IDF, que estudiar\u00e1s en m\u00e1s detalle en ANIOT y que permite gestionar, entre otros, las respuestas a eventos de red, como por ejemplo la obtenci\u00f3n de direcci\u00f3n IP o la conexi\u00f3n exitosa a un punto de acceso. Tarea Compila, flashea y monitoriza el ejemplo station situado en el directorio examples/wifi/getting_started . Recuerda copiarlo antes a cualquier otro directorio de tu home . Antes de compilarlo, modifica el SSID de la red al que conectar\u00e1, as\u00ed como la contrase\u00f1a elegida (puedes usar el mismo punto de acceso que creaste anteriormente como objetivo de tu conexi\u00f3n) a trav\u00e9s del sistema de men\u00fas de configuraci\u00f3n. Observa su funcionamiento. El firmware simplemente inicializa el dispositivo en modo station (en contraposici\u00f3n al modo Access Point , que veremos en la pr\u00f3xima sesi\u00f3n), realizando una conexi\u00f3n al punto de acceso preconfigurado a trav\u00e9s del men\u00fa de configuraci\u00f3n. Analiza el c\u00f3digo de la funci\u00f3n wifi_init_sta . Esta funci\u00f3n, que implementa la tarea principal, se divide b\u00e1sicamente en dos partes: Gesti\u00f3n de eventos . Observa el mecanismo mediante el cual se registra y se asocia la recepci\u00f3n de un evento a la ejecuci\u00f3n de un manejador o funci\u00f3n determinada. Pregunta \u00bfQu\u00e9 eventos se asocian a la ejecuci\u00f3n de qu\u00e9 funci\u00f3n en el firmware que est\u00e1s estudiando? Configuraci\u00f3n de la conexi\u00f3n a un punto de acceso . La configuraci\u00f3n de la conexi\u00f3n se realiza a trav\u00e9s de los campos correspondientes de una estructura de tipo wifi_config_t . Observa los campos b\u00e1sicos que necesita, c\u00f3mo fuerza el uso de WPA2 y c\u00f3mo recoge los datos de conexi\u00f3n (SSID y contrase\u00f1a) a trav\u00e9s del sistema de configuraci\u00f3n. Observa tambi\u00e9n c\u00f3mo, una vez realizadas dichas personalizaciones, inicializa el sistema de comunicaci\u00f3n inal\u00e1mbrica a trav\u00e9s de esp_wifi_start() . Consulta la documentaci\u00f3n relativa a dichas funciones y anota en tu memoria entregable aquellos aspectos que consideres m\u00e1s relevantes. Tarea Modifica el firmware para que el handler de tratamiento de la obtenci\u00f3n de una direcci\u00f3n IP sea independiente del tratamiento del resto de eventos del sistema WiFi que ya se est\u00e1n considerando. Comprueba que, efectivamente sigue observ\u00e1ndose la salida asociada a dicho evento, aun cuando ambas funciones sean independientes. Entrega o a\u00f1ade a la memoria el c\u00f3digo modificado.","title":"Pr\u00e1ctica 1"},{"location":"RPI-I/P1/#practica-1-introduccion-al-entorno-de-desarrollo-esp-idf","text":"","title":"Pr\u00e1ctica 1. Introducci\u00f3n al entorno de desarrollo ESP-IDF"},{"location":"RPI-I/P1/#objetivos","text":"Conocer dos entornos b\u00e1sicos de desarrollo para el ESP32: uno basado en l\u00ednea de comandos, y otro en la herramienta PlatformIO Ser capaz de compilar, flashear y monitorizar proyectos sencillos basados en ESP-IDF Entender el funcionamiento b\u00e1sico de una aplicaci\u00f3n ESP-IDF que haga uso de las capacidades WiFi del ESP32 Personalizar variables de configuraci\u00f3n de proyectos ESP-IDF Responder a eventos b\u00e1sicos de red en ESP-IDF","title":"Objetivos"},{"location":"RPI-I/P1/#introduccion","text":"ESP-IDF ( Espressif IoT Development Framework ) es el entorno de desarrollo oficial de Espressif para los SoCs ESP32 y ESP32-S. Este entorno de desarrollo y conjunto de herramientas permite desarrollar firmwares eficientes para dichas placas utilizando las interfaces de comunicaci\u00f3n WiFi y Bluetooth, as\u00ed como gestionar m\u00faltiples caracter\u00edsticas de los SoCs que iremos desgranando en futuras pr\u00e1cticas. ESP-IDF utiliza como base FreeRTOS para la construcci\u00f3n del firmware , aunque a\u00f1ade multitud de componentes para ofrecer un soporte de mayor nivel para la interacci\u00f3n con protocolos de comunicaci\u00f3n de bajo y alto nivel, la mayor\u00eda de ellos enfocados al \u00e1mbito de comunicaci\u00f3n en Internet de las Cosas. La presente pr\u00e1ctica pretende ser una introducci\u00f3n b\u00e1sica a la puesta en marcha del entorno de desarrollo ESP-IDF sobre un sistema operativo Linux, ofreciendo dos alternativas b\u00e1sicas: l\u00ednea de comandos y un plugin espec\u00edfico para VSCode (PlatformIO). Adem\u00e1s, veremos de forma superficial la estructura b\u00e1sica de un programa sencillo desarrollado usando ESP-IDF, as\u00ed como ejemplos b\u00e1sicos para la puesta en marcha de la interfaz WiFi sobre una placa ESP32. Recuerda La presente pr\u00e1ctica no tiene tarea entregable asociada m\u00e1s all\u00e1 de una memoria justificativa del trabajo realizado. Por tanto, recuerda apuntar y reportar los pasos y tareas realizadas durante su desarrollo para plasmarlas en una breve memoria entregable final.","title":"Introducci\u00f3n"},{"location":"RPI-I/P1/#flujo-de-trabajo-entorno-basado-en-linea-de-comandos","text":"","title":"Flujo de trabajo. Entorno basado en l\u00ednea de comandos"},{"location":"RPI-I/P1/#instalacion-de-prerequisitos","text":"ESP-IDF requiere ciertos paquetes software instalados en el sistema para poder desarrollar los c\u00f3digos y descargarlos sobre el ESP32. Se muestran a continuaci\u00f3n los requisitos y modo de instalaci\u00f3n para m\u00e1quinas Ubuntu/Debian (como la m\u00e1quina virtual del curso), aunque la documentaci\u00f3n de ESP-IDF incluye instrucciones para otras distribuciones y sistemas operativos, incluyendo Windows y MacOS. En tu m\u00e1quina virtual, instala los paquetes necesarios utilizando (como superusuario): sudo apt-get install git wget flex bison gperf python python3-pip python-setuptools cmake ninja-build ccache libffi-dev libssl-dev dfu-util Adem\u00e1s, es necesario, en todo caso, que el usuario que est\u00e9s utilizando pertenezca al grupo dialout (puedes editar el fichero /etc/group a\u00f1adiendo a tu usuario a la l\u00ednea que indica el grupo correspondiente, e iniciando de nuevo tu sesi\u00f3n). Instala y configura Python 3 para su uso por defecto en tu distribuci\u00f3n: sudo apt-get install python3 python3-pip python3-setuptools sudo update-alternatives --install /usr/bin/python python /usr/bin/python3 10","title":"Instalaci\u00f3n de prerequisitos"},{"location":"RPI-I/P1/#obtencion-de-esp-idf","text":"Utilizaremos las versiones de ESP-IDF a obtener directamente desde el repositorio Github oficial (concretamente, en su versi\u00f3n 4.1). Para ello, ejecuta desde tu directorio de inicio: mkdir -p ~/esp cd ~/esp git clone --recursive https://github.com/espressif/esp-idf.git cd esp-idf git fetch git checkout release/v4.1 git pull git submodule update --init --recursive","title":"Obtenci\u00f3n de ESP-IDF"},{"location":"RPI-I/P1/#instalacion-de-herramientas-adicionales","text":"Desde el directorio esp-idf , ejecuta el script install.sh para instalar las herramientas ( toolchain ) espec\u00edficas para tu versi\u00f3n: sh install.sh","title":"Instalaci\u00f3n de herramientas adicionales"},{"location":"RPI-I/P1/#preparacion-del-entorno","text":"Tras el inicio de cada sesi\u00f3n, deber\u00e1s establecer valores correctos para ciertas variables de entorno. Afortunadamente, se proporciona un script ( export.sh ) que te permitir\u00e1 establecerlas de forma autom\u00e1tica: . export.sh Puedes a\u00f1adir esta l\u00ednea en cualquier fichero de inicio de sesi\u00f3n para no tener que ejecutar el comando cada vez. En cualquier caso, en este punto deber\u00edas tener acceso a un programa llamado idf.py , a trav\u00e9s del cual gestionaremos el flujo de trabajo. Compru\u00e9balo y observa si la version de IDF con la que est\u00e1s trabajando es efectivamente la 4.1 (el n\u00famero de subversi\u00f3n podr\u00eda variar en tu salida): $ idf.py --version ESP-IDF v4.1-332-g7b7c64107","title":"Preparaci\u00f3n del entorno"},{"location":"RPI-I/P1/#preparacion-del-proyecto","text":"En esta primera parte, nos basaremos en un ejemplo sencillo de c\u00f3digo desarrollado en base a ESP-IDF. No es el objetivo de esta pr\u00e1ctica analizar en detalle los la estructura de dicho c\u00f3digo (al menos de momento), sino utilizarlo para ilustrar el flujo de trabajo t\u00edpico en un proyecto ESP-IDF. Recuerda Tras la ejecuci\u00f3n del script export.sh , tendr\u00e1s definida una variable de entorno llamada IDF_PATH . Consulta su valor y comprueba que apunta, efectivamente, al directorio de instalaci\u00f3n de IDF. La utilizaremos a partir de ahora para referirnos a \u00e9l. Para empezar, toma el ejemplo hello_world proporcionado como parte de la instalaci\u00f3n b\u00e1sica de IDF, y c\u00f3pialo en cualquier directorio del sistema de ficheros: cp -R $IDF_PATH/examples/get-started/hello_world $HOME/ cd $HOME/hello_world","title":"Preparaci\u00f3n del proyecto"},{"location":"RPI-I/P1/#compilacion","text":"El proceso de compilaci\u00f3n b\u00e1sico utiliza el script idf.py : idf.py build Si todo ha ido bien, en el directorio build se habr\u00e1n generado los objetos y binarios listos para ser flasheados en el ESP32.","title":"Compilaci\u00f3n"},{"location":"RPI-I/P1/#flasheado","text":"El proceso de flasheado b\u00e1sico utiliza el script idf.py : idf.py -p PUERTO flash En este punto, el ESP32 debe estar conectado utilizando el cable microUSB, y si est\u00e1s trabajando en una m\u00e1quina virtual, debe haberse hecho visible a la misma (por ejemplo, en VirtualBox, a trav\u00e9s del men\u00fa Dispositivos->USB->Silicon Labs USB to UART Bridge Controller ). En todo caso, la salida del comando dmesg tras la conexi\u00f3n del dispositivo te proporcionar\u00e1 informaci\u00f3n sobre el PUERTO que debes utilizar en el proceso de flasheado y montorizaci\u00f3n posterior.","title":"Flasheado"},{"location":"RPI-I/P1/#monitorizacion","text":"Si todo ha ido bien, el proceso de monitorizaci\u00f3n nos permitir\u00e1 observar la salida del programa que tenemos ejecutando en la placa. Para ello, de nuevo, usamos el script idf.py : idf.py -p PUERTO monitor Nota Comprueba que, efectivamente, puedes realizar el proceso de compilaci\u00f3n, flasheado y monitorizaci\u00f3n del programa sobre la placa ESP32. Recuerda que el bot\u00f3n EN , justo al lado del conector microUSB, forzar\u00e1 un reseteo de la misma.","title":"Monitorizaci\u00f3n"},{"location":"RPI-I/P1/#flujo-de-trabajo-entorno-basado-en-platformio","text":"El anterior flujo de trabajo puede tambi\u00e9n desarrollarse desde otros entornos de desarrollo. En nuestro caso, se muestran a continuaci\u00f3n los pasos principales para la integraci\u00f3n de ESP-IDF con VSCode, utilizando la plataforma PlatformIO . Las m\u00e1quinas virtuales proporcionadas en el curso ya tienen instalada la \u00faltima versi\u00f3n de PlatformIO y ESP-IDF, por lo que se refiere al lector a la documentaci\u00f3n oficial de PlatformIO para llevar a cabo dicha instalaci\u00f3n en otros sistemas operativos.","title":"Flujo de trabajo. Entorno basado en PlatformIO"},{"location":"RPI-I/P1/#configuracion-de-un-proyecto","text":"La forma m\u00e1s sencilla de crear un nuevo proyecto consiste en pulsar el bot\u00f3n PlatformIO Home situado en la parte inferior de la pantalla: A continuaci\u00f3n, clica en New Project y selecciona como placa de desarrollo ESP DevkitC o Espressif ESP32 Dev Module . Selecciona ESP-IDF como framework de desarrollo para el proyecto:","title":"Configuraci\u00f3n de un proyecto"},{"location":"RPI-I/P1/#adicion-de-ficheros-a-un-proyecto","text":"Crea un nuevo fichero main.c (si no existe) en el directorio src de tu proyecto, o modifica el que ya existe utilizando, por ejemplo, el siguiente c\u00f3digo: #include <string.h> #include \"freertos/FreeRTOS.h\" #include \"freertos/task.h\" #include \"esp_system.h\" #include \"esp_wifi.h\" #include \"esp_event.h\" #include \"esp_log.h\" #include \"nvs_flash.h\" #include \"lwip/err.h\" #include \"lwip/sys.h\" #define EXAMPLE_ESP_WIFI_SSID \"mywifissid\" #define EXAMPLE_ESP_WIFI_PASS \"mywifipass\" #define EXAMPLE_MAX_STA_CONN (3) static const char *TAG = \"wifi softAP\"; static void wifi_event_handler(void* arg, esp_event_base_t event_base, int32_t event_id, void* event_data) { if (event_id == WIFI_EVENT_AP_STACONNECTED) { wifi_event_ap_staconnected_t* event = (wifi_event_ap_staconnected_t*) event_data; ESP_LOGI(TAG, \"station \"MACSTR\" join, AID=%d\", MAC2STR(event->mac), event->aid); } else if (event_id == WIFI_EVENT_AP_STADISCONNECTED) { wifi_event_ap_stadisconnected_t* event = (wifi_event_ap_stadisconnected_t*) event_data; ESP_LOGI(TAG, \"station \"MACSTR\" leave, AID=%d\", MAC2STR(event->mac), event->aid); } } void wifi_init_softap() { tcpip_adapter_init(); ESP_ERROR_CHECK(esp_event_loop_create_default()); wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT(); ESP_ERROR_CHECK(esp_wifi_init(&cfg)); ESP_ERROR_CHECK(esp_event_handler_register(WIFI_EVENT, ESP_EVENT_ANY_ID, &wifi_event_handler, NULL)); wifi_config_t wifi_config = { .ap = { .ssid = EXAMPLE_ESP_WIFI_SSID, .ssid_len = strlen(EXAMPLE_ESP_WIFI_SSID), .password = EXAMPLE_ESP_WIFI_PASS, .max_connection = EXAMPLE_MAX_STA_CONN, .authmode = WIFI_AUTH_WPA_WPA2_PSK }, }; if (strlen(EXAMPLE_ESP_WIFI_PASS) == 0) { wifi_config.ap.authmode = WIFI_AUTH_OPEN; } ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_AP)); ESP_ERROR_CHECK(esp_wifi_set_config(ESP_IF_WIFI_AP, &wifi_config)); ESP_ERROR_CHECK(esp_wifi_start()); ESP_LOGI(TAG, \"wifi_init_softap finished. SSID:%s password:%s\", EXAMPLE_ESP_WIFI_SSID, EXAMPLE_ESP_WIFI_PASS); } void app_main() { //Initialize NVS esp_err_t ret = nvs_flash_init(); if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) { ESP_ERROR_CHECK(nvs_flash_erase()); ret = nvs_flash_init(); } ESP_ERROR_CHECK(ret); ESP_LOGI(TAG, \"ESP_WIFI_MODE_AP\"); wifi_init_softap(); } De momento no analizaremos el funcionamiento del c\u00f3digo (lo haremos m\u00e1s adelante) pero b\u00e1sicamente establece un Punto de Acceso inal\u00e1mbrico abierto a conexiones autenticadas v\u00eda WPA2.","title":"Adici\u00f3n de ficheros a un proyecto"},{"location":"RPI-I/P1/#compilacion-del-proyecto","text":"Para compilar del proyecto, despliega la paleta de comandos (men\u00fa View -> Command Palette ) y ejecuta la orden PlatformIO: Build desde ella. Tambi\u00e9n puedes presionar el bot\u00f3n Build (con forma de check ) en la barra inferior de PlatformIO: Si todo ha ido bien, deber\u00edas ver un mensaje final similar al siguiente en la terminal del sistema:","title":"Compilaci\u00f3n del proyecto"},{"location":"RPI-I/P1/#flasheado-del-proyecto","text":"Para llevar a cabo el proceso de subida ( upload ) del proyecto a la placa, podemos utilizar la orden PlatformIO: Upload a trav\u00e9s de la paleta de comandos, o bien presionar el bot\u00f3n correspondiente en la barra inferior (con un s\u00edmbolo de flecha a izquierda):","title":"Flasheado del proyecto"},{"location":"RPI-I/P1/#monitorizacion-del-proyecto","text":"Por \u00faltimo, podemos monitorizar el proyecto utilizando la orden PlatformIO: Monitor de la paleta de comandos o a trav\u00e9s de la barra inferior, usando el bot\u00f3n con un enchufe como s\u00edmbolo:","title":"Monitorizaci\u00f3n del proyecto"},{"location":"RPI-I/P1/#analisis-de-un-proyecto-sencillo-hola-mundo-en-esp-idf","text":"Nota Las siguientes tareas pueden realizarse desde l\u00ednea de comandos o utilizando PlatformIO. Para familiarizarse con en entorno de bajo nivel, sin embargo, se sugiere el uso de l\u00ednea de comandos. Observa la estructura general del directorio hello_world que compilaste anteriormente. Espec\u00edficamente, nos interesar\u00e1 inspeccionar la estructura b\u00e1sica de un programa principal para ESP-IDF, en este caso hello_world_main.c . #include <stdio.h> #include \"sdkconfig.h\" #include \"freertos/FreeRTOS.h\" #include \"freertos/task.h\" #include \"esp_system.h\" #include \"esp_spi_flash.h\" void app_main(void) { printf(\"Hello world!\\n\"); /* Print chip information */ esp_chip_info_t chip_info; esp_chip_info(&chip_info); printf(\"This is %s chip with %d CPU cores, WiFi%s%s, \", CONFIG_IDF_TARGET, chip_info.cores, (chip_info.features & CHIP_FEATURE_BT) ? \"/BT\" : \"\", (chip_info.features & CHIP_FEATURE_BLE) ? \"/BLE\" : \"\"); printf(\"silicon revision %d, \", chip_info.revision); printf(\"%dMB %s flash\\n\", spi_flash_get_chip_size() / (1024 * 1024), (chip_info.features & CHIP_FEATURE_EMB_FLASH) ? \"embedded\" : \"external\"); printf(\"Minimum free heap size: %d bytes\\n\", esp_get_minimum_free_heap_size()); for (int i = 10; i >= 0; i--) { printf(\"Restarting in %d seconds...\\n\", i); vTaskDelay(1000 / portTICK_PERIOD_MS); } printf(\"Restarting now.\\n\"); fflush(stdout); esp_restart(); } A alto nivel, la funci\u00f3n app_main es el punto de entrada a todo programa desarrollado usando ESP-IDF. De modo m\u00e1s espec\u00edfico, tras la carga del sistema , la llamada tarea principal ( main task ) ejecuta el c\u00f3digo proporcionado por el usuario e implementado en la funci\u00f3n app_main . Tanto el tama\u00f1o de pila asignado como la prioridad de esta tarea puede ser configuradas por el desarrollador a trav\u00e9s del sistema de configuraci\u00f3n de ESP-IDF (lo veremos m\u00e1s adelante). Normalmente, esta funci\u00f3n se utiliza para llevar a cabo tareas iniciales de configuraci\u00f3n o para crear y lanzar a ejecuci\u00f3n otras tareas. De cualquier modo (como es el caso), se puede implementar cualquier funcionalidad dentro de la funci\u00f3n app_main . En este ejemplo, se muestra en primer lugar informaci\u00f3n gen\u00e9rica sobre el SoC que est\u00e1 ejecutando el firmware : /* Print chip information */ esp_chip_info_t chip_info; esp_chip_info(&chip_info); printf(\"This is %s chip with %d CPU cores, WiFi%s%s, \", CONFIG_IDF_TARGET, chip_info.cores, (chip_info.features & CHIP_FEATURE_BT) ? \"/BT\" : \"\", (chip_info.features & CHIP_FEATURE_BLE) ? \"/BLE\" : \"\"); printf(\"silicon revision %d, \", chip_info.revision); printf(\"%dMB %s flash\\n\", spi_flash_get_chip_size() / (1024 * 1024), (chip_info.features & CHIP_FEATURE_EMB_FLASH) ? \"embedded\" : \"external\"); printf(\"Minimum free heap size: %d bytes\\n\", esp_get_minimum_free_heap_size()); A continuaci\u00f3n, dentro de un bucle sencillo, el sistema muestra un mensaje y difiere la ejecuci\u00f3n de la tarea durante un per\u00edodo determinado de tiempo utilizando la funci\u00f3n vTaskDelay de FreeRTOS. Esta funci\u00f3n recibe el n\u00famero de ticks de reloj que se desea utilizar, por lo que el tiempo real que la tarea diferir\u00e1 su ejecuci\u00f3n depende de la duraci\u00f3n de dicho tick . Por ello, la constante portTIC_PERIOD_MS puede utilizarse para calcular dicho tiempo: for (int i = 10; i >= 0; i--) { printf(\"Restarting in %d seconds...\\n\", i); vTaskDelay(1000 / portTICK_PERIOD_MS); } Finalmente, la tarea reinicia el sistema tras la finalizaci\u00f3n de la tarea principal: printf(\"Restarting now.\\n\"); fflush(stdout); esp_restart(); Tarea Modifica el per\u00edodo de suspensi\u00f3n de la tarea para que sea mayor o menor, y comprueba que efectivamente esto modifica el comportamiento del firmware cargado. Modifica el programa para que se muestre tambi\u00e9n por pantalla si el SoC tiene capacidades WiFi y si incluye memoria FLASH (para ello, puedes consultar la siguiente p\u00e1gina ).","title":"An\u00e1lisis de un proyecto sencillo (Hola, mundo) en ESP-IDF"},{"location":"RPI-I/P1/#creacion-de-tareas","text":"El anterior proyecto puede replantearse para que no sea la tarea principal la que ejecute la l\u00f3gica del programa. Para ello, es necesario introducir brevemente la API b\u00e1sica para gesti\u00f3n (en nuestro caso, creaci\u00f3n) de tareas. Ver\u00e1s muchos m\u00e1s detalles sobre esta API en la asignatura ANIOT, por lo que no veremos aqu\u00ed m\u00e1s detalles de los estrictamente necesarios. La funci\u00f3n xTaskCreate (incluida en task.h ) permite la creaci\u00f3n de nuevas tareas: BaseType_t xTaskCreate( TaskFunction_t pvTaskCode, const char * const pcName, configSTACK_DEPTH_TYPE usStackDepth, void *pvParameters, UBaseType_t uxPriority, TaskHandle_t *pxCreatedTask ); Concretamente, crea una nueva tarea y la a\u00f1ade a la lista de tareas listas para ejecuci\u00f3n, recibiendo como par\u00e1metros: pvTaskCode : Puntero a la funci\u00f3n de entrada para la tarea. Las tareas suelen implementarse como un bucle infinito, y no deber\u00eda, en su cuerpo, retornar o simplemente finalizar abruptamente. En cambio, una tarea puede ser destruida externamente a trav\u00e9s de su manejador (\u00faltimo par\u00e1metro en la creaci\u00f3n), o internamente (desde el propio c\u00f3digo de la tarea), tal y como se muestra en el siguiente ejemplo extra\u00eddo directamente desde la documentaci\u00f3n de FreeRTOS: void vATaskFunction( void *pvParameters ) { for( ;; ) { -- Task application code here. -- } /* Tasks must not attempt to return from their implementing function or otherwise exit. In newer FreeRTOS port attempting to do so will result in an configASSERT() being called if it is defined. If it is necessary for a task to exit then have the task call vTaskDelete( NULL ) to ensure its exit is clean. */ vTaskDelete( NULL ); } pcName : Nombre (en forma de cadena) descriptivo de la tarea a ejecutar, t\u00edpicamente usado en tiempo de depuraci\u00f3n. usStackDepth : N\u00famero de palabras a alojar para utilizar como pila para la tarea. pvParameters : Par\u00e1metros a proporcionar a la funci\u00f3n de entrada para la tarea. uxPriority : Prioridad asignada a la tarea. pxCreatedTask : Manejador opcional para la tarea. As\u00ed, la funcionalidad del programa Hola, mundo que hemos analizado anteriormente, podr\u00eda reestrcturarse en base a una \u00fanica tarea: void hello_task(void *pvParameter) { printf(\"Hello world!\\n\"); for (int i = 10; i >= 0; i--) { printf(\"Restarting in %d seconds...\\n\", i); vTaskDelay(1000 / portTICK_RATE_MS); } printf(\"Restarting now.\\n\"); fflush(stdout); esp_restart(); } Que podr\u00eda ser creada desde la tarea principal: void app_main() { nvs_flash_init(); xTaskCreate( &hello_task, \"hello_task\", 2048, NULL, 5, NULL ); } Tarea Implementa una modificaci\u00f3n del programa hello_world que implemente y planifique dos tareas independientes con distinta funcionalidad (en este caso, es suficiente con mostrar por pantalla alg\u00fan mensaje) y distintos tiempos de suspensi\u00f3n. Comprueba que, efectivamente, ambas tareas se ejecutan concurrentemente.","title":"Creaci\u00f3n de tareas"},{"location":"RPI-I/P1/#personalizacion-del-proyecto","text":"ESP-IDF utiliza la biblioteca kconfiglib para proporcionar un sistema de configuracion de proyectos en tiempo de compilaci\u00f3n sencillo y extensible. Para ilustrar su funcionamiento, utilizaremos el ejemplo blink que puedes encontrar en la distribuci\u00f3n de ESP-IDF que has clonado anteriormente (copia el ejemplo en cualquier punto de tu jerarqu\u00eda de directorios antes de comenzar). Para configurar un proyecto ESP-IDF, simplemente utiliza la siguiente orden: idf.py menuconfig La ejecuci\u00f3n de la orden anterior te permitir\u00e1 navegar por un conjunto de opciones de car\u00e1cter general, que te permitir\u00e1n configurar las caracter\u00edsticas espec\u00edficas del proyecto a compilar (por ejemplo, seleccionando los componentes que deseas habilitar en la construcci\u00f3n del mismo). Tarea Navega por las opciones que aparecen en los men\u00fas de configuraci\u00f3n para familiarizarte con ellos. Los utilizar\u00e1s en futuras pr\u00e1cticas. En el proyecto blink , observa que una de las opciones del men\u00fa de navegaci\u00f3n, llamada Example configuration , incluye una opci\u00f3n llamada Blink GPIO number . M\u00e1s all\u00e1 de su funcionalidad (define el n\u00famero de pin GPIO a activar/desactivar para iluminar un LED), es de inter\u00e9s para nosotros el hecho de que esta opci\u00f3n de configuraci\u00f3n definir\u00e1 en tiempo de compilaci\u00f3n el valor de una constante (en este caso CONFIG_BLINK_GPIO ) que podemos utilizar directamente en cualquier fichero de nuestro proyecto. Nota Observa el uso que da el c\u00f3digo del proyecto blink a la constante CONFIG_BLINK_GPIO . Esta opci\u00f3n de configuraci\u00f3n no forma parte de las opciones por defecto de ESP-IDF, sino que ha sido a\u00f1adida por los desarrolladores del proyecto blink . Observa y estudia el formato y contenido del fichero main/Kconfig.projbuild que se proporciona como parte del fichero. En \u00e9l, se definen las caracter\u00edsticas (nombre, rango, valor por defecto y descripcion) de la opci\u00f3n de configuraci\u00f3n a definir. Tarea Modifica el proyecto hello_world para que defina dos opciones de configuraci\u00f3n que permitir\u00e1n definir el tiempo de espera de cada una de las dos tareas que hayas definido en tu anterior soluci\u00f3n. Haz uso de ellas en tu c\u00f3digo y comprueba que efectivamente su modificaci\u00f3n a trav\u00e9s del sistema de men\u00fas permite una personalizaci\u00f3n del comportamiento de tus c\u00f3digos.","title":"Personalizaci\u00f3n del proyecto"},{"location":"RPI-I/P1/#gestion-de-redes-wifi-ejemplo-1-escaneado-de-redes-wifi","text":"A modo de ejemplo, y en preparaci\u00f3n para los c\u00f3digos con los que trabajaremos en futuras pr\u00e1cticas, vamos a analizar a continuaci\u00f3n un ejemplo concreto de firmware cuya tarea es el escaneado de redes inal\u00e1mbricas al alcance del ESP32, y su reporte a trav\u00e9s del puerto serie del mismo. Para cada red escaneada, se reportar\u00e1n sus caracter\u00edsticas principales. Tarea Compila, flashea y monitoriza el ejemplo scan situado en el directorio examples/wifi/scan . Recuerda copiarlo antes a cualquier otro directorio de tu home . Antes de compilarlo, modifica el n\u00famero m\u00e1ximo de redes a escanear a trav\u00e9s del men\u00fa de configuraci\u00f3n del ejemplo para ampliarlo a 20. Crea un punto de acceso WiFi con tu tel\u00e9fono m\u00f3vil y observa que, efectivamente, es escaneado por el ejemplo. Observa su funcionamiento. Realmente, el firmware simplemente escanea un subconjunto de las redes disponibles, reportando algunas de sus caracter\u00edsticas (por ejemplo, SSID, modo de autenticaci\u00f3n o canal primario). Tarea Analiza el c\u00f3digo de la funci\u00f3n wifi_scan (tarea principal). Espec\u00edficamente, c\u00e9ntrate en las l\u00edneas que permiten activar y configurar el escaneado de redes. Intenta entender el funcionamiento general del programa, consultando y apuntando el cometido de cada l\u00ednea, con especial inter\u00e9s a aquellas funciones con prefijo esp_wifi_* . Anota en la memoria entregable el cometido de cada una de ellas, consultando la documentaci\u00f3n oficial .","title":"Gesti\u00f3n de redes WiFi. Ejemplo 1. Escaneado de redes WiFi"},{"location":"RPI-I/P1/#gestion-de-redes-wifi-ejemplo-2-gestion-de-eventos-de-red","text":"El segundo ejemplo consiste en la creaci\u00f3n de un firmware para conexi\u00f3n del ESP32 a un punto de acceso existente. Este ejemplo nos permitir\u00e1 observar, a grandes rasgos, el sistema de gesti\u00f3n de eventos en FreeRTOS/ESP-IDF, que estudiar\u00e1s en m\u00e1s detalle en ANIOT y que permite gestionar, entre otros, las respuestas a eventos de red, como por ejemplo la obtenci\u00f3n de direcci\u00f3n IP o la conexi\u00f3n exitosa a un punto de acceso. Tarea Compila, flashea y monitoriza el ejemplo station situado en el directorio examples/wifi/getting_started . Recuerda copiarlo antes a cualquier otro directorio de tu home . Antes de compilarlo, modifica el SSID de la red al que conectar\u00e1, as\u00ed como la contrase\u00f1a elegida (puedes usar el mismo punto de acceso que creaste anteriormente como objetivo de tu conexi\u00f3n) a trav\u00e9s del sistema de men\u00fas de configuraci\u00f3n. Observa su funcionamiento. El firmware simplemente inicializa el dispositivo en modo station (en contraposici\u00f3n al modo Access Point , que veremos en la pr\u00f3xima sesi\u00f3n), realizando una conexi\u00f3n al punto de acceso preconfigurado a trav\u00e9s del men\u00fa de configuraci\u00f3n. Analiza el c\u00f3digo de la funci\u00f3n wifi_init_sta . Esta funci\u00f3n, que implementa la tarea principal, se divide b\u00e1sicamente en dos partes: Gesti\u00f3n de eventos . Observa el mecanismo mediante el cual se registra y se asocia la recepci\u00f3n de un evento a la ejecuci\u00f3n de un manejador o funci\u00f3n determinada. Pregunta \u00bfQu\u00e9 eventos se asocian a la ejecuci\u00f3n de qu\u00e9 funci\u00f3n en el firmware que est\u00e1s estudiando? Configuraci\u00f3n de la conexi\u00f3n a un punto de acceso . La configuraci\u00f3n de la conexi\u00f3n se realiza a trav\u00e9s de los campos correspondientes de una estructura de tipo wifi_config_t . Observa los campos b\u00e1sicos que necesita, c\u00f3mo fuerza el uso de WPA2 y c\u00f3mo recoge los datos de conexi\u00f3n (SSID y contrase\u00f1a) a trav\u00e9s del sistema de configuraci\u00f3n. Observa tambi\u00e9n c\u00f3mo, una vez realizadas dichas personalizaciones, inicializa el sistema de comunicaci\u00f3n inal\u00e1mbrica a trav\u00e9s de esp_wifi_start() . Consulta la documentaci\u00f3n relativa a dichas funciones y anota en tu memoria entregable aquellos aspectos que consideres m\u00e1s relevantes. Tarea Modifica el firmware para que el handler de tratamiento de la obtenci\u00f3n de una direcci\u00f3n IP sea independiente del tratamiento del resto de eventos del sistema WiFi que ya se est\u00e1n considerando. Comprueba que, efectivamente sigue observ\u00e1ndose la salida asociada a dicho evento, aun cuando ambas funciones sean independientes. Entrega o a\u00f1ade a la memoria el c\u00f3digo modificado.","title":"Gesti\u00f3n de redes WiFi. Ejemplo 2. Gesti\u00f3n de eventos de red"},{"location":"RPI-I/P2/","text":"Pr\u00e1ctica 2. Soporte WiFi en ESP32","title":"Pr\u00e1ctica 2"},{"location":"RPI-I/P2/#practica-2-soporte-wifi-en-esp32","text":"","title":"Pr\u00e1ctica 2. Soporte WiFi en ESP32"},{"location":"RPI-I/P3/","text":"Pr\u00e1ctica 3. WiFi Mesh","title":"Pr\u00e1ctica 3"},{"location":"RPI-I/P3/#practica-3-wifi-mesh","text":"","title":"Pr\u00e1ctica 3. WiFi Mesh"},{"location":"RPI-I/P4/","text":"Pr\u00e1ctica 4. Bluetooth Low Energy (BLE)","title":"Pr\u00e1ctica 4"},{"location":"RPI-I/P5/","text":"Pr\u00e1ctica 4. Bluetooth Mesh","title":"Pr\u00e1ctica 5"},{"location":"RPI-I/P5/#practica-4-bluetooth-mesh","text":"","title":"Pr\u00e1ctica 4. Bluetooth Mesh"},{"location":"RPI-I/P6/","text":"Pr\u00e1ctica 6. 6LowPAN (simulaci\u00f3n en Cooja)","title":"Pr\u00e1ctica 6"},{"location":"RPI-I/P6/#practica-6-6lowpan-simulacion-en-cooja","text":"","title":"Pr\u00e1ctica 6. 6LowPAN (simulaci\u00f3n en Cooja)"},{"location":"RPI-I/P7/","text":"Pr\u00e1ctica 6. 6LowPAN (SensorTag)","title":"Pr\u00e1ctica 7"},{"location":"RPI-I/P7/#practica-6-6lowpan-sensortag","text":"","title":"Pr\u00e1ctica 6. 6LowPAN (SensorTag)"},{"location":"RPI-I/P8/","text":"Pr\u00e1ctica 8. LoRA","title":"Pr\u00e1ctica 8"},{"location":"RPI-I/P8/#practica-8-lora","text":"","title":"Pr\u00e1ctica 8. LoRA"},{"location":"RPI-II/P1/","text":"Pr\u00e1ctica 1. Programaci\u00f3n con sockets en Python Objetivos Familiarizarse con la API de sockets en Python. Desarrollar esquemas b\u00e1sicos de sistemas cliente/servidor TCP y UDP utilizando Python. Ser capaces de analizar el tr\u00e1fico generado en una conexi\u00f3n TCP y UDP a trav\u00e9s de Wireshark. Dise\u00f1ar un protocolo de capa de aplicaci\u00f3n para simular una aplicaci\u00f3n cliente/servidor utilizando TCP y UDP. Observar la diferencia en tr\u00e1fico generado para una misma aplicaci\u00f3n utilizando TCP y UDP. Implementar servidores multi-hilo en Python. Introducci\u00f3n La historia de los sockets se remonta al origen de ARPANET, en 1971, y su posterior estandarizaci\u00f3n en forma de API dentro del sistema operativo Berkeley Software Distribution (BSD) , liberado en 1983, bajo el nombre de sockets de Berkeley . Con la popularizaci\u00f3n de Internet en los a\u00f1os 90, y de la mano de la World Wide Web , la programaci\u00f3n de red sufri\u00f3 tambi\u00e9n una notable evoluci\u00f3n. Los servidores web y los navegadores no fueron (ni son) las \u00fanicas aplicaciones basadas en sockets . De hecho, los sistemas cliente/servidor son a d\u00eda de hoy ubicuos e incluyen, por supuesto, a todos los protocolos de alto nivel que dan soporte a Internet de las Cosas. De hecho, a d\u00eda de hoy, aunque los potocolos de alto nivel (capa de aplicaci\u00f3n) han evolucionado hasta niveles de sofisticaci\u00f3n no considerados en sus inicios, la API de bajo nivel sobre la que se basan se mantiene inalterada. El tipo m\u00e1s com\u00fan de aplicaciones basadas en sockets se basa en el paradigma cliente/servidor, donde una de las partes act\u00faa como servidor , esperando pasivamente conexiones desde un conjunto de uno o m\u00e1s clientes . A continuaci\u00f3n, veremos c\u00f3mo desarrollar este tipo de paradigma desde Python, utilizando sockets Berkeley . Existen tambi\u00e9n los llamados Unix domain sockets , que permiten la comunicaci\u00f3n directa entre procesos en el mismo host , aunque quedan fuera de nuestro inter\u00e9s en el \u00e1mbito de IoT. La API de sockets en Python El m\u00f3dulo socket de Python proporciona una interfaz completa para trabajar con la API de sockets de Berkeley . En la presente pr\u00e1ctica, trabajaremos exclusivamente con esta API para desarrollar aplicaciones cliente/servidor utilizando los protocolos TCP y UDP. Las funciones y m\u00e9todos principales de la API de sockets son: socket() - bind() - listen() - accept() - connect() - connect_ex() - send() - recv() - close() - Python prorpociona una API consistente y completa mapeada directamente a las anteriores llamadas al sistema, t\u00edpicamente escritas en lenguaje C. Como parte de su biblioteca est\u00e1ndar, Python tambi\u00e9n proporciona clases que facilitan el trabajo con las funciones de bajo nivel. Aunque no lo cubriremos, el m\u00f3dulo socketserver proporciona una forma sencilla de crear servidores de red. Existen tambi\u00e9n numerosos m\u00f3dulos disponibles para implementar protocolos de alto nivel (por ejemplo HTTP o SMTP), v\u00e9ase . Sockets TCP En Python, los sockets TCP se crean en Python utilizando socket.socket() , especificando el tipo de socket como socket.SOCK_STREAM . El protocolo de control de transmisi\u00f3n (TCP) se caracteriza por dos rasgos principales: Es confiable : se implementan mecanismos de detecci\u00f3n de p\u00e9rdidas en la red y reenv\u00edo de paquetes perdidos. Garantiza una entrega de paquetes en orden : los datos se entregan a las capas superiores (aplicaciones) en el mismo orden en el que fueron enviados. En contra, los sockets UDP se crean a trav\u00e9s de socket.SOCK_DGRAM , y no son confiables ni garantizan la entrega de paquetes en orden. Por tanto, es el desarrollador de aplicaciones quien, en caso de as\u00ed desearlo en el dise\u00f1o de la aplicaci\u00f3n, debe implementar estos mecanismos de forma espec\u00edfica. En el siguiente diagrama se muestra la secuencia t\u00edpica de invocaciones a la API de sockets para TCP: En la figura, la columna de la izquierda representa al servidor, mientras que la columna de la derecha representa al cliente en la conexi\u00f3n TCP. Observa las invocaciones necesarias para configurar un socket a la escucha de conexiones entrantes: socket() bind() listen() accept() En este extremo, un socket escucha ( listen ) potenciales conexiones entrantes desde clientes. Cuando un cliente solicita conectar, el servidor acepta ( accept ) la conexi\u00f3n, complet\u00e1ndola. El cliente invoca a connect() para establecer una conexi\u00f3n con el servidor e inicia el proceso de conexi\u00f3n a tres v\u00edas ( three-way connection ). Una vez establecida la conexi\u00f3n, los datos se intercambian entre cliente y servidor a trav\u00e9s de invocaciones a send() y recv() . Finalmente, el socket se destruye (esto es, la conexi\u00f3n entre ambos extremos se cierra) a trav\u00e9s de una invocaci\u00f3n a close() en cada extremo. Cliente/servidor echo TCP Veamos un ejemplo sencillo para crear un par cliente-servidor. En este caso, el servidor simplemente responder\u00e1 con la misma cadena que reciba desde el cliente. Servidor echo #!/usr/bin/env python3 #### servidor_echo.py import socket HOST = '127.0.0.1' # Interfaz est\u00e1ndar de loopback (localhost) PORT = 65432 # Puerto de escucha (los puertos mayores a 1023 son no privilegiados) with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: s.bind((HOST, PORT)) s.listen() conn, addr = s.accept() with conn: print('Conectado ', addr) while True: data = conn.recv(1024) if not data: break conn.sendall(data) Nota De momento, no importa si no entiendes todas las l\u00edneas en el anterior c\u00f3digo. Simplemente se trata de un punto de partida para desarrollar un servidor sencillo. Sin embargo, es conveniente que copies el c\u00f3digo en un fichero de texto (por ejemplo, llamado servidor_echo.py ) para que podeamos probarlo. Veamos l\u00ednea a l\u00ednea las partes m\u00e1s importantes del anterior c\u00f3digo. socket.socket() crea un objeto socket . Observa que, al crearse a trav\u00e9s de una construcci\u00f3n with , no es necesario invocar expl\u00edcitamente a s.close() , aunque debes tener en cuenta que el objeto es destruido al finalizar la construcci\u00f3n: with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: pass # Es posible usar el socket win invocar a s.close(). Los argumentos que se proporcionan a socket() especifican la familia de direcciones ( AF_INET ) y tipo de socket ( SOCK_STREAM ). AF_INET es la familia de direcciones de Internet para IPv4. SOCK_STREAM es el tipo de socket que permite la creaci\u00f3n de conexiones TCP. bind() se utiliza para asociar el socket a una interfaz de red y n\u00famero de puerto espec\u00edficos: HOST = '127.0.0.1' # Interfaz est\u00e1ndar de loopback (localhost) PORT = 65432 # Puerto de escucha (los puertos mayores a 1023 son no privilegiados) # ... s.bind((HOST, PORT)) Los valores proporcionados a bind() dependen de la familia de direcciones seleccionada para el socket . En este ejemplo, al utilizar AF_INET , espera una tupla con \u00fanicamente dos valores (host, puerto) . Para determinar el host , es posible utilizar un nombre de host , una direcci\u00f3n IP o una cadena vac\u00eda. Si utilizamos una direcci\u00f3n IP, \u00e9sta debe ser especificarse mediante una cadena que contenga una direcci\u00f3n IPv4 bien formada. La direcci\u00f3n 127.0.0.1 es la direcci\u00f3n IPv4 est\u00e1ndar para la interfaz de loopback , por lo que \u00fanicamente procesos que est\u00e9n ejecut\u00e1ndose en el propio host podr\u00e1n comunicar con el servidor. Si proporcionamos una cadena vac\u00eda, el servidro aceptar\u00e1 conexiones entrantes a trav\u00e9s de todas las interfaces IPv4 disponibles en el sistema. El n\u00famero de puerto ( port ) se especifica con un valor entero entre 1 y 65535, y espcifica el puerto (en este caso, TCP) a trav\u00e9s del cual el servidor aceptar\u00e1 conexiones desde los clientes. La mayor\u00eda de sistemas requieren permisos de superusuario para escuchar a trav\u00e9s de los puertos ( well-known ), es decir, con valor inferior a 1024. Continuando con el ejemplo, listen() posibilita que un servidor pueda, en el futuro, aceptar ( accept() ) conexiones entrantes. En otras palabras, pone a la escucha al socket : s.listen() conn, addr = s.accept() La invocaci\u00f3n a accept() bloquea el proceso y espera a una conexi\u00f3n entrante. Cuando un cliente conecta, devuelve un objeto socket que representa la conexi\u00f3n, as\u00ed como una tupla ( addr ) que contiene la direcci\u00f3n del cliente. Concretamente, esta tupla contiene los valores (host, port) que almacenan la direcci\u00f3n IPv4 y puerto del cliente que solicita la conexi\u00f3n. Observa que, en el ejemplo, conn es el objeto socket que usaremos para comunicar con el cliente: conn, addr = s.accept() with conn: print('Conectado ', addr) while True: data = conn.recv(1024) if not data: break conn.sendall(data) Tras obtener el objeto devuelto por accept() , dise\u00f1amos el servidor como un bucle infinito que invoca repetidamente a llamadas bloqueantes a conn.recv() . As\u00ed, leemos los datos enviados por el cliente y los reenviamos sin modificaci\u00f3n utilizando conn.sendall() . Si conn.recv() devuelve un objeto de tipo bytes vac\u00edo ( b'' ) significa que el cliente cerr\u00f3 la conexi\u00f3n, en cuyo caso el bucle termina, destruy\u00e9ndose el socket al salir de la sentencia with . Cliente echo Veamos a continuaci\u00f3n la estructura general del cliente (puedes usar, por ejemplo, cliente_echo.py como nombre para el fichero): #!/usr/bin/env python3 ### cliente_echo.py import socket HOST = '127.0.0.1' # IP del servidor PORT = 65432 # Puerto de escucha del servidor with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: s.connect((HOST, PORT)) s.sendall(b'Hola, mundo') data = s.recv(1024) print('Recibido ', repr(data)) En comparaci\u00f3n con el servidor, la estructura del cliente es m\u00e1s simple; simplemente crea un nuevo objeto socket , conecta con el servidor e invoca a s.sendall() para enviar el mensaje. Finalmente, espera la recepci\u00f3n de la respuesta utilizando s.recv() y la imprime por pantalla. Ejecuci\u00f3n del cliente y servidor echo A continuaci\u00f3n, ejecutaremos cliente y servidor para observar el estado de las conexiones durante su ciclo de vida. Ejecuta en una terminal el servidor: $ python3 ./servidor-echo.py Como ves, la terminal se bloquea (de hecho, el servidor permanece en estado bloqueado) en la invocaci\u00f3n: conn, addr = s.accept() Realmente, el servidor est\u00e1 esperando a que haya conexiones entrantes por parte de un cliente. Abre otra terminal y ejecuta el cliente: $ python3 cliente-echo.py Recibido 'Hola, mundo' En la ventana del servidor, deber\u00edas ver algo similar a: $ python3 ./servidor-echo.py Conectado ('127.0.0.1, 61234') En esta salida, el servidor ha mostrado por pantalla la tupla devuelta por s.accept() , que incluye la direcci\u00f3n IP y el n\u00famero de puerto TCP. Dicho n\u00famero de puerto (en el ejemplo anterior, 61234) es seleccionado aleatoriamente por el sistema operativo y puede variar en tu ejecuci\u00f3n. Herramientas para observar el estado del socket Podemos utilizar la herramienta netstat para observar el estado actual de los sockets en cualquier sistema operativo (macOS, Linux e incluso Windows). Por ejemplo, esta ser\u00eda la salida de netstat en Linux tras ejecutar el servidor: netstat -an | grep 65432 Conexiones activas de Internet (servidores y establecidos) Proto Recib Enviad Direcci\u00f3n local Direcci\u00f3n remota Estado tcp 0 0 127.0.0.1:65432 0.0.0.0:* ESCUCHAR Observa que hemos filtrado la salida de la orden netcat seg\u00fan el n\u00famero de puerto utilizado. Observa el valor de las columnas Proto, Direcci\u00f3n local y Estado . Nota Otra forma de observar el estado de las conexiones es a trav\u00e9s de la orden lsof -i -n . Ejec\u00fatala y observa su salida. Capturas de tr\u00e1fico v\u00eda Wireshark Wireshark es una herramienta de c\u00f3digo abierto ampliamente utilizada para analizar protocolos de comunicaci\u00f3n de red en cualquiera de las capas de la pila TCP/IP (como tambi\u00e9n en otros protocolos). Wireshark implementa un amplio abanico de filtros para definir criterios de b\u00fasqueda en las capturas de tr\u00e1fico, aunque de momento, en nuestro caso, no ser\u00e1 necesario utilizar filtros espec\u00edficos. Para arrancar Wireshark en la m\u00e1quina virtual proporcionada (o en cualquier instalaci\u00f3n b\u00e1sica Linux), teclea en tu terminal: $ sudo wireshark Tras el arranque, podemos comenzar una nueva captura de tr\u00e1fico a trav\u00e9s del men\u00fa Capture , opci\u00f3n Start . La pantalla de selecci\u00f3n de interfaz nos permitir\u00e1 definir en qu\u00e9 interfaz de red se realizar\u00e1 la captura. En nuestro caso, ya que vamos a comunicar dos procesos en la misma m\u00e1quina, elegiremos la interfaz de Loopback (lo) y comenzaremos la captura. Tarea Arranca Wireshark y prepara una captura sobre la interfaz de loopback . Ejecuta el servidor echo TCP y el cliente correspondiente, y analiza el tr\u00e1fico generado. Especialmente, f\u00edjate en el proceso de establecimiento de conexi\u00f3n en tres v\u00edas, paquetes de Acknowledge tras el env\u00edo de cada mensaje y, en general, en cualquier otro aspecto que consideres de inter\u00e9s. Sockets UDP La creaci\u00f3n y gesti\u00f3n de sockets UDP en Python resulta todav\u00eda m\u00e1s sencilla. Observa el siguiente c\u00f3digo, que crea un servidor UDP utilizando la API de sockets Python: import socket udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) udp_socket.bind((\"localhost\", 5005)) data = udp_socket.recv(512) print(data) Primero, importamos la biblioteca socket de recepci\u00f3n, igual que en el caso de TCP. Obviamente, en este caso el tipo de socket pasa a ser socket.DOCK_DGRAM , para indicar que deseamos utilizar UDP en la comunicaci\u00f3n. El programa espera a la recepci\u00f3n de un paquete utilizando el m\u00e9todo bloqueante recv , cuyo \u00fanico par\u00e1metro indica el n\u00famero m\u00e1ximo de bytes que deseamos recibir. Cuando un paquete llega al socket, el metodo recv devolver\u00e1 un array de bytes, que ser\u00e1 almacenado en la variable que deseemos. El env\u00edo de datos a trav\u00e9s de un socket UDP es tambi\u00e9n sencillo: import socket udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) udp_socket.bind((\"localhost\", 0)) data = b\"Hola, mundo!\" udp_socket.sendto(data,(\"localhost\", 5005)) Observa que, en este caso, asociamos ( bind ) el socket a un puerto especificado como 0. Este valor especial indica al sistema operativo que elija para la transimisi\u00f3n un puerto origen aleatorio de entre los disponibles en el sistema. A continuaci\u00f3n, creamos los datos a enviar y los enviamos utilizando el m\u00e9todo sendto() . Este m\u00e9todo tomados argumentos: datos a enviar, y precisamente la direcci\u00f3n de env\u00edo. Los datos enviados a trav\u00e9s del socket deben formar parte de un array de bytes (por ello, la cadena a enviar viene precedida por el car\u00e1cter b ). Tarea Comprueba que, efectivamente, los c\u00f3digos de env\u00edo y recepci\u00f3n a trav\u00e9s de UDP funcionan como se espera. Nota Desde la versi\u00f3n 3 de Python, las cadenas se codifican utilizando Unicode. Al contrario que ASCII, conde cada caracter tiene una representaci\u00f3n en byte directa, Unicode utiliza enteros par representar cada caracter, que deben ser codificados para obtener una representaci\u00f3n en forma de byte. Uno de esos esquemas de codificaci\u00f3n es UTF-8. Por ejemplo, el siguiente c\u00f3digo muestra c\u00f3mo codificar una cadena Unicode en una representaci\u00f3n de bytes: cadena= \"Hola\" data = cadena.encode(\"UTF-8\") print(data, type(data)) lo cual genera b\"Hola\" <class 'bytes'> que puede ya ser enviado directamente por red. Hasta este punto, los programas UDP han sido totalmente unidireccionales en el env\u00edo/recepci\u00f3n de datos, pero obviamente, un socket UDP es un canal de comunicaci\u00f3n bidireccional. Tarea Implementa una funcionalidad similar al servidor echo que vimos para TCP, pero utilizando en este caso UDP. Realiza una captura de tr\u00e1fico en Wireshark similar a la realizada en el caso de TCP, y observa las principales diferencias entre ellas a nivel de tr\u00e1fico generado. Env\u00edo de datos binarios a trav\u00e9s de sockets Hasta este punto, hemos visto \u00fanicamente c\u00f3mo enviar cadenas de texto a trav\u00e9s de sockets TCP o UDP, pero es muy probable que sea necesario (o conveniente), en ocasiones, enviar datos directamente en formato binario (por ejemplo, valores num\u00e9ricos en punto flotante o enteros). Utilizando el m\u00f3dulo struct de Python podemos especificar qu\u00e9 tipo o tipos de datos se almacenan en una secuencia de bytes y c\u00f3mo decodificarlos. Tambi\u00e9n es posible especificar en qu\u00e9 lugar de la secuencia se alojan dichos datos, permitiendo el empaquetado de m\u00faltiples datos de distintos tipos de forma sencilla, y su posterior decodificaci\u00f3n en el otro extremo de la comunicaci\u00f3n. Nota Para todos los detalles del m\u00f3dulo struct , consulta la p\u00e1gina oficial de documentaci\u00f3n . El m\u00f3dulo struct proporciona dos m\u00e9todos de inter\u00e9s: pack y unpack . La siguiente sentencia: struct.pack(\">iii\", 1, 2, 3) utiliza el m\u00e9todo pack para realizar un empaquetado de datos. Concretamente, observa como el m\u00e9todo recibe dos par\u00e1metros: En primer lugar, el par\u00e1metro de formato \">iii\" . Define como debe codificarse cada valor en la secuencia de bytes. El primer car\u00e1cter indica el endianness utilizado, en este caso big endian (utilizar\u00edamos \">\" para big endian , \"<\" para little endian y \"=\" para network (big) endian). En segundo lugar, los valores a empaquetar. Observa que el formato, adem\u00e1s, incluye el n\u00famero y tipo de los datos a empaquetar (en este caso, tres valores detipo entero). Para otros tipos de datos, consulta la documentaci\u00f3n del m\u00f3dulo. Desempaquetar los datos enviados en el extremo opuesto es intuitivo: a, b, c = struct.unpack( \">iii\" ) A continuaci\u00f3n, mostramos un ejemplo de sistema cliente/servidor TCP que hace uso del m\u00f3dulo struct para realizar el env\u00edo de dos datos enteros y uno flotante entre un cliente y un servidor. # Cliente import binascii import socket import struct import sys # Socket TCP sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_address = ('localhost', 10001) sock.connect(server_address) packed_data = struct.pack(\"=iif\", 1, 4, 2.7) try: # Envio de datos print('Enviando \"%s\"' % binascii.hexlify(packed_data)) sock.sendall(packed_data) finally: print('Cerrando socket') sock.close() # Servidor import binascii import socket import struct import sys # Socket TCP sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_address = ('localhost', 10001) sock.bind(server_address) sock.listen(1) while True: print('Esperando conexiones entrantes') connection, client_address = sock.accept() try: data = connection.recv(1024) print('Recibido \"%s\"' % binascii.hexlify(data)) unpacked_data = struct.unpack(\"=iif\", data) print('Desempaquetado:', unpacked_data) finally: connection.close() Tarea Ejecuta el anterior sistema cliente servidor y analiza el tr\u00e1fico generado, en busca de los datos binarios empaquetados. Experimenta con otros tipos de datos y endianess y observa las diferencias. Tarea entregable Tarea entregable Se pide dise\u00f1ar un sistema cliente/servidor programado en Python, que simule el env\u00edo de un conjunto de datos sensorizados desde un cliente hacia un servidor. El protocolo a utilizar (formato de datos enviado por la red a nivel de aplicaci\u00f3n) debe ser propuesto por el propio alumno y descrito previamente al desarrollo. Se valorar\u00e1 el uso de m\u00faltiples tipos de datos tanto en el env\u00edo de datos sensorizados como de posibles respuestas por parte del servidor. Se desarrollar\u00e1 una versi\u00f3n utilizando TCP y otra equivalente usando UDP. El cliente enviar\u00e1 los datos de forma peri\u00f3dica y se \u00e9stos generar\u00e1n de modo aleatorio. A modo de entrega, se solicitan los c\u00f3digos desarrollados, as\u00ed como un an\u00e1lisis del tr\u00e1fico generado, considerando la sobrecarga (en bytes reales enviados) introducida por cada protocolo de capa de transporte. Ejemplo de sistema cliente/servidor multi-hilo Los ejemplos anteriormente descritos, aunque funcionales, adolecen en su dise\u00f1o de una caracter\u00edstica esencial: el servidor deja de atender peticiones entrantes mientras trata cada nuevo env\u00edo por parte del cliente. Los siguientes ejemplos muestran implementaciones sencillas con soporte multi-hilo para un sistema cliente/servidor escrito en Python. # Servidor TCP concurrente import socket, threading class ClientThread(threading.Thread): def __init__(self,clientAddress,clientsocket): threading.Thread.__init__(self) self.csocket = clientsocket print (\"Nueva conexion anyadida: \", clientAddress) def run(self): print (\"Conexion desde: \", clientAddress) #self.csocket.send(bytes(\"Hi, This is from Server..\",'utf-8')) msg = '' while True: data = self.csocket.recv(2048) msg = data.decode() if msg=='bye': break print (\"Desde el cliente\", msg) self.csocket.send(bytes(msg,'UTF-8')) print (\"Cliente \", clientAddress , \" desconectado...\") LOCALHOST = \"127.0.0.1\" PORT = 8080 server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) server.bind((LOCALHOST, PORT)) print(\"Servidor arrancado...\") print(\"Esperando petici\u00f3n de clientes...\") server.listen(1) while True: clientsock, clientAddress = server.accept() newthread = ClientThread(clientAddress, clientsock) newthread.start() # Cliente TCP. El env\u00edo de la cadena bye indica petici\u00f3n de desconexi\u00f3n. import socket SERVER = \"127.0.0.1\" PORT = 8080 client = socket.socket(socket.AF_INET, socket.SOCK_STREAM) client.connect((SERVER, PORT)) client.sendall(bytes(\"Hola, soy un cliente!!\",'UTF-8')) while True: in_data = client.recv(1024) print(\"Desde el servidor :\" ,in_data.decode()) out_data = input() client.sendall(bytes(out_data,'UTF-8')) if out_data=='end': break client.close() Tarea Estudia el c\u00f3digo del servidor concurrente y observa c\u00f3mo gestiona la creaci\u00f3n de hilos para atender cada petici\u00f3n entrante. Conecta simult\u00e1neamente m\u00faltiples clientes y observa el estado de los sockets mediante las herramientas correspondientes. Tarea entregable opcional Tarea entregable opcional Modifica tu primer entregable para considerar una implementaci\u00f3n multihilo del servidor TCP, siguiendo las directrices de los c\u00f3digos de ejemplo anteriormente proporcionados. Tarea entregable opcional Tarea entregable opcional Modifica el protocolo de env\u00edo para que tu aplicaci\u00f3n cliente/servidor UDP garantice en la medida de lo posible la recepci\u00f3n de los paquetes enviados desde el cliente, as\u00ed como su recepci\u00f3n en orden. Vuelve a analizar el tr\u00e1fico necesario en este caso comparado con una comunicaci\u00f3n b\u00e1sica basada en TCP (donde s\u00ed se garantizan, a nivel de transporte, dichas caracter\u00edsticas).","title":"Pr\u00e1ctica 1"},{"location":"RPI-II/P1/#practica-1-programacion-con-sockets-en-python","text":"","title":"Pr\u00e1ctica 1. Programaci\u00f3n con sockets en Python"},{"location":"RPI-II/P1/#objetivos","text":"Familiarizarse con la API de sockets en Python. Desarrollar esquemas b\u00e1sicos de sistemas cliente/servidor TCP y UDP utilizando Python. Ser capaces de analizar el tr\u00e1fico generado en una conexi\u00f3n TCP y UDP a trav\u00e9s de Wireshark. Dise\u00f1ar un protocolo de capa de aplicaci\u00f3n para simular una aplicaci\u00f3n cliente/servidor utilizando TCP y UDP. Observar la diferencia en tr\u00e1fico generado para una misma aplicaci\u00f3n utilizando TCP y UDP. Implementar servidores multi-hilo en Python.","title":"Objetivos"},{"location":"RPI-II/P1/#introduccion","text":"La historia de los sockets se remonta al origen de ARPANET, en 1971, y su posterior estandarizaci\u00f3n en forma de API dentro del sistema operativo Berkeley Software Distribution (BSD) , liberado en 1983, bajo el nombre de sockets de Berkeley . Con la popularizaci\u00f3n de Internet en los a\u00f1os 90, y de la mano de la World Wide Web , la programaci\u00f3n de red sufri\u00f3 tambi\u00e9n una notable evoluci\u00f3n. Los servidores web y los navegadores no fueron (ni son) las \u00fanicas aplicaciones basadas en sockets . De hecho, los sistemas cliente/servidor son a d\u00eda de hoy ubicuos e incluyen, por supuesto, a todos los protocolos de alto nivel que dan soporte a Internet de las Cosas. De hecho, a d\u00eda de hoy, aunque los potocolos de alto nivel (capa de aplicaci\u00f3n) han evolucionado hasta niveles de sofisticaci\u00f3n no considerados en sus inicios, la API de bajo nivel sobre la que se basan se mantiene inalterada. El tipo m\u00e1s com\u00fan de aplicaciones basadas en sockets se basa en el paradigma cliente/servidor, donde una de las partes act\u00faa como servidor , esperando pasivamente conexiones desde un conjunto de uno o m\u00e1s clientes . A continuaci\u00f3n, veremos c\u00f3mo desarrollar este tipo de paradigma desde Python, utilizando sockets Berkeley . Existen tambi\u00e9n los llamados Unix domain sockets , que permiten la comunicaci\u00f3n directa entre procesos en el mismo host , aunque quedan fuera de nuestro inter\u00e9s en el \u00e1mbito de IoT.","title":"Introducci\u00f3n"},{"location":"RPI-II/P1/#la-api-de-sockets-en-python","text":"El m\u00f3dulo socket de Python proporciona una interfaz completa para trabajar con la API de sockets de Berkeley . En la presente pr\u00e1ctica, trabajaremos exclusivamente con esta API para desarrollar aplicaciones cliente/servidor utilizando los protocolos TCP y UDP. Las funciones y m\u00e9todos principales de la API de sockets son: socket() - bind() - listen() - accept() - connect() - connect_ex() - send() - recv() - close() - Python prorpociona una API consistente y completa mapeada directamente a las anteriores llamadas al sistema, t\u00edpicamente escritas en lenguaje C. Como parte de su biblioteca est\u00e1ndar, Python tambi\u00e9n proporciona clases que facilitan el trabajo con las funciones de bajo nivel. Aunque no lo cubriremos, el m\u00f3dulo socketserver proporciona una forma sencilla de crear servidores de red. Existen tambi\u00e9n numerosos m\u00f3dulos disponibles para implementar protocolos de alto nivel (por ejemplo HTTP o SMTP), v\u00e9ase .","title":"La API de sockets en Python"},{"location":"RPI-II/P1/#sockets-tcp","text":"En Python, los sockets TCP se crean en Python utilizando socket.socket() , especificando el tipo de socket como socket.SOCK_STREAM . El protocolo de control de transmisi\u00f3n (TCP) se caracteriza por dos rasgos principales: Es confiable : se implementan mecanismos de detecci\u00f3n de p\u00e9rdidas en la red y reenv\u00edo de paquetes perdidos. Garantiza una entrega de paquetes en orden : los datos se entregan a las capas superiores (aplicaciones) en el mismo orden en el que fueron enviados. En contra, los sockets UDP se crean a trav\u00e9s de socket.SOCK_DGRAM , y no son confiables ni garantizan la entrega de paquetes en orden. Por tanto, es el desarrollador de aplicaciones quien, en caso de as\u00ed desearlo en el dise\u00f1o de la aplicaci\u00f3n, debe implementar estos mecanismos de forma espec\u00edfica. En el siguiente diagrama se muestra la secuencia t\u00edpica de invocaciones a la API de sockets para TCP: En la figura, la columna de la izquierda representa al servidor, mientras que la columna de la derecha representa al cliente en la conexi\u00f3n TCP. Observa las invocaciones necesarias para configurar un socket a la escucha de conexiones entrantes: socket() bind() listen() accept() En este extremo, un socket escucha ( listen ) potenciales conexiones entrantes desde clientes. Cuando un cliente solicita conectar, el servidor acepta ( accept ) la conexi\u00f3n, complet\u00e1ndola. El cliente invoca a connect() para establecer una conexi\u00f3n con el servidor e inicia el proceso de conexi\u00f3n a tres v\u00edas ( three-way connection ). Una vez establecida la conexi\u00f3n, los datos se intercambian entre cliente y servidor a trav\u00e9s de invocaciones a send() y recv() . Finalmente, el socket se destruye (esto es, la conexi\u00f3n entre ambos extremos se cierra) a trav\u00e9s de una invocaci\u00f3n a close() en cada extremo.","title":"Sockets TCP"},{"location":"RPI-II/P1/#clienteservidor-echo-tcp","text":"Veamos un ejemplo sencillo para crear un par cliente-servidor. En este caso, el servidor simplemente responder\u00e1 con la misma cadena que reciba desde el cliente.","title":"Cliente/servidor echo TCP"},{"location":"RPI-II/P1/#servidor-echo","text":"#!/usr/bin/env python3 #### servidor_echo.py import socket HOST = '127.0.0.1' # Interfaz est\u00e1ndar de loopback (localhost) PORT = 65432 # Puerto de escucha (los puertos mayores a 1023 son no privilegiados) with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: s.bind((HOST, PORT)) s.listen() conn, addr = s.accept() with conn: print('Conectado ', addr) while True: data = conn.recv(1024) if not data: break conn.sendall(data) Nota De momento, no importa si no entiendes todas las l\u00edneas en el anterior c\u00f3digo. Simplemente se trata de un punto de partida para desarrollar un servidor sencillo. Sin embargo, es conveniente que copies el c\u00f3digo en un fichero de texto (por ejemplo, llamado servidor_echo.py ) para que podeamos probarlo. Veamos l\u00ednea a l\u00ednea las partes m\u00e1s importantes del anterior c\u00f3digo. socket.socket() crea un objeto socket . Observa que, al crearse a trav\u00e9s de una construcci\u00f3n with , no es necesario invocar expl\u00edcitamente a s.close() , aunque debes tener en cuenta que el objeto es destruido al finalizar la construcci\u00f3n: with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: pass # Es posible usar el socket win invocar a s.close(). Los argumentos que se proporcionan a socket() especifican la familia de direcciones ( AF_INET ) y tipo de socket ( SOCK_STREAM ). AF_INET es la familia de direcciones de Internet para IPv4. SOCK_STREAM es el tipo de socket que permite la creaci\u00f3n de conexiones TCP. bind() se utiliza para asociar el socket a una interfaz de red y n\u00famero de puerto espec\u00edficos: HOST = '127.0.0.1' # Interfaz est\u00e1ndar de loopback (localhost) PORT = 65432 # Puerto de escucha (los puertos mayores a 1023 son no privilegiados) # ... s.bind((HOST, PORT)) Los valores proporcionados a bind() dependen de la familia de direcciones seleccionada para el socket . En este ejemplo, al utilizar AF_INET , espera una tupla con \u00fanicamente dos valores (host, puerto) . Para determinar el host , es posible utilizar un nombre de host , una direcci\u00f3n IP o una cadena vac\u00eda. Si utilizamos una direcci\u00f3n IP, \u00e9sta debe ser especificarse mediante una cadena que contenga una direcci\u00f3n IPv4 bien formada. La direcci\u00f3n 127.0.0.1 es la direcci\u00f3n IPv4 est\u00e1ndar para la interfaz de loopback , por lo que \u00fanicamente procesos que est\u00e9n ejecut\u00e1ndose en el propio host podr\u00e1n comunicar con el servidor. Si proporcionamos una cadena vac\u00eda, el servidro aceptar\u00e1 conexiones entrantes a trav\u00e9s de todas las interfaces IPv4 disponibles en el sistema. El n\u00famero de puerto ( port ) se especifica con un valor entero entre 1 y 65535, y espcifica el puerto (en este caso, TCP) a trav\u00e9s del cual el servidor aceptar\u00e1 conexiones desde los clientes. La mayor\u00eda de sistemas requieren permisos de superusuario para escuchar a trav\u00e9s de los puertos ( well-known ), es decir, con valor inferior a 1024. Continuando con el ejemplo, listen() posibilita que un servidor pueda, en el futuro, aceptar ( accept() ) conexiones entrantes. En otras palabras, pone a la escucha al socket : s.listen() conn, addr = s.accept() La invocaci\u00f3n a accept() bloquea el proceso y espera a una conexi\u00f3n entrante. Cuando un cliente conecta, devuelve un objeto socket que representa la conexi\u00f3n, as\u00ed como una tupla ( addr ) que contiene la direcci\u00f3n del cliente. Concretamente, esta tupla contiene los valores (host, port) que almacenan la direcci\u00f3n IPv4 y puerto del cliente que solicita la conexi\u00f3n. Observa que, en el ejemplo, conn es el objeto socket que usaremos para comunicar con el cliente: conn, addr = s.accept() with conn: print('Conectado ', addr) while True: data = conn.recv(1024) if not data: break conn.sendall(data) Tras obtener el objeto devuelto por accept() , dise\u00f1amos el servidor como un bucle infinito que invoca repetidamente a llamadas bloqueantes a conn.recv() . As\u00ed, leemos los datos enviados por el cliente y los reenviamos sin modificaci\u00f3n utilizando conn.sendall() . Si conn.recv() devuelve un objeto de tipo bytes vac\u00edo ( b'' ) significa que el cliente cerr\u00f3 la conexi\u00f3n, en cuyo caso el bucle termina, destruy\u00e9ndose el socket al salir de la sentencia with .","title":"Servidor echo"},{"location":"RPI-II/P1/#cliente-echo","text":"Veamos a continuaci\u00f3n la estructura general del cliente (puedes usar, por ejemplo, cliente_echo.py como nombre para el fichero): #!/usr/bin/env python3 ### cliente_echo.py import socket HOST = '127.0.0.1' # IP del servidor PORT = 65432 # Puerto de escucha del servidor with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: s.connect((HOST, PORT)) s.sendall(b'Hola, mundo') data = s.recv(1024) print('Recibido ', repr(data)) En comparaci\u00f3n con el servidor, la estructura del cliente es m\u00e1s simple; simplemente crea un nuevo objeto socket , conecta con el servidor e invoca a s.sendall() para enviar el mensaje. Finalmente, espera la recepci\u00f3n de la respuesta utilizando s.recv() y la imprime por pantalla.","title":"Cliente echo"},{"location":"RPI-II/P1/#ejecucion-del-cliente-y-servidor-echo","text":"A continuaci\u00f3n, ejecutaremos cliente y servidor para observar el estado de las conexiones durante su ciclo de vida. Ejecuta en una terminal el servidor: $ python3 ./servidor-echo.py Como ves, la terminal se bloquea (de hecho, el servidor permanece en estado bloqueado) en la invocaci\u00f3n: conn, addr = s.accept() Realmente, el servidor est\u00e1 esperando a que haya conexiones entrantes por parte de un cliente. Abre otra terminal y ejecuta el cliente: $ python3 cliente-echo.py Recibido 'Hola, mundo' En la ventana del servidor, deber\u00edas ver algo similar a: $ python3 ./servidor-echo.py Conectado ('127.0.0.1, 61234') En esta salida, el servidor ha mostrado por pantalla la tupla devuelta por s.accept() , que incluye la direcci\u00f3n IP y el n\u00famero de puerto TCP. Dicho n\u00famero de puerto (en el ejemplo anterior, 61234) es seleccionado aleatoriamente por el sistema operativo y puede variar en tu ejecuci\u00f3n.","title":"Ejecuci\u00f3n del cliente y servidor echo"},{"location":"RPI-II/P1/#herramientas-para-observar-el-estado-del-socket","text":"Podemos utilizar la herramienta netstat para observar el estado actual de los sockets en cualquier sistema operativo (macOS, Linux e incluso Windows). Por ejemplo, esta ser\u00eda la salida de netstat en Linux tras ejecutar el servidor: netstat -an | grep 65432 Conexiones activas de Internet (servidores y establecidos) Proto Recib Enviad Direcci\u00f3n local Direcci\u00f3n remota Estado tcp 0 0 127.0.0.1:65432 0.0.0.0:* ESCUCHAR Observa que hemos filtrado la salida de la orden netcat seg\u00fan el n\u00famero de puerto utilizado. Observa el valor de las columnas Proto, Direcci\u00f3n local y Estado . Nota Otra forma de observar el estado de las conexiones es a trav\u00e9s de la orden lsof -i -n . Ejec\u00fatala y observa su salida.","title":"Herramientas para observar el estado del socket"},{"location":"RPI-II/P1/#capturas-de-trafico-via-wireshark","text":"Wireshark es una herramienta de c\u00f3digo abierto ampliamente utilizada para analizar protocolos de comunicaci\u00f3n de red en cualquiera de las capas de la pila TCP/IP (como tambi\u00e9n en otros protocolos). Wireshark implementa un amplio abanico de filtros para definir criterios de b\u00fasqueda en las capturas de tr\u00e1fico, aunque de momento, en nuestro caso, no ser\u00e1 necesario utilizar filtros espec\u00edficos. Para arrancar Wireshark en la m\u00e1quina virtual proporcionada (o en cualquier instalaci\u00f3n b\u00e1sica Linux), teclea en tu terminal: $ sudo wireshark Tras el arranque, podemos comenzar una nueva captura de tr\u00e1fico a trav\u00e9s del men\u00fa Capture , opci\u00f3n Start . La pantalla de selecci\u00f3n de interfaz nos permitir\u00e1 definir en qu\u00e9 interfaz de red se realizar\u00e1 la captura. En nuestro caso, ya que vamos a comunicar dos procesos en la misma m\u00e1quina, elegiremos la interfaz de Loopback (lo) y comenzaremos la captura. Tarea Arranca Wireshark y prepara una captura sobre la interfaz de loopback . Ejecuta el servidor echo TCP y el cliente correspondiente, y analiza el tr\u00e1fico generado. Especialmente, f\u00edjate en el proceso de establecimiento de conexi\u00f3n en tres v\u00edas, paquetes de Acknowledge tras el env\u00edo de cada mensaje y, en general, en cualquier otro aspecto que consideres de inter\u00e9s.","title":"Capturas de tr\u00e1fico v\u00eda Wireshark"},{"location":"RPI-II/P1/#sockets-udp","text":"La creaci\u00f3n y gesti\u00f3n de sockets UDP en Python resulta todav\u00eda m\u00e1s sencilla. Observa el siguiente c\u00f3digo, que crea un servidor UDP utilizando la API de sockets Python: import socket udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) udp_socket.bind((\"localhost\", 5005)) data = udp_socket.recv(512) print(data) Primero, importamos la biblioteca socket de recepci\u00f3n, igual que en el caso de TCP. Obviamente, en este caso el tipo de socket pasa a ser socket.DOCK_DGRAM , para indicar que deseamos utilizar UDP en la comunicaci\u00f3n. El programa espera a la recepci\u00f3n de un paquete utilizando el m\u00e9todo bloqueante recv , cuyo \u00fanico par\u00e1metro indica el n\u00famero m\u00e1ximo de bytes que deseamos recibir. Cuando un paquete llega al socket, el metodo recv devolver\u00e1 un array de bytes, que ser\u00e1 almacenado en la variable que deseemos. El env\u00edo de datos a trav\u00e9s de un socket UDP es tambi\u00e9n sencillo: import socket udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) udp_socket.bind((\"localhost\", 0)) data = b\"Hola, mundo!\" udp_socket.sendto(data,(\"localhost\", 5005)) Observa que, en este caso, asociamos ( bind ) el socket a un puerto especificado como 0. Este valor especial indica al sistema operativo que elija para la transimisi\u00f3n un puerto origen aleatorio de entre los disponibles en el sistema. A continuaci\u00f3n, creamos los datos a enviar y los enviamos utilizando el m\u00e9todo sendto() . Este m\u00e9todo tomados argumentos: datos a enviar, y precisamente la direcci\u00f3n de env\u00edo. Los datos enviados a trav\u00e9s del socket deben formar parte de un array de bytes (por ello, la cadena a enviar viene precedida por el car\u00e1cter b ). Tarea Comprueba que, efectivamente, los c\u00f3digos de env\u00edo y recepci\u00f3n a trav\u00e9s de UDP funcionan como se espera. Nota Desde la versi\u00f3n 3 de Python, las cadenas se codifican utilizando Unicode. Al contrario que ASCII, conde cada caracter tiene una representaci\u00f3n en byte directa, Unicode utiliza enteros par representar cada caracter, que deben ser codificados para obtener una representaci\u00f3n en forma de byte. Uno de esos esquemas de codificaci\u00f3n es UTF-8. Por ejemplo, el siguiente c\u00f3digo muestra c\u00f3mo codificar una cadena Unicode en una representaci\u00f3n de bytes: cadena= \"Hola\" data = cadena.encode(\"UTF-8\") print(data, type(data)) lo cual genera b\"Hola\" <class 'bytes'> que puede ya ser enviado directamente por red. Hasta este punto, los programas UDP han sido totalmente unidireccionales en el env\u00edo/recepci\u00f3n de datos, pero obviamente, un socket UDP es un canal de comunicaci\u00f3n bidireccional. Tarea Implementa una funcionalidad similar al servidor echo que vimos para TCP, pero utilizando en este caso UDP. Realiza una captura de tr\u00e1fico en Wireshark similar a la realizada en el caso de TCP, y observa las principales diferencias entre ellas a nivel de tr\u00e1fico generado.","title":"Sockets UDP"},{"location":"RPI-II/P1/#envio-de-datos-binarios-a-traves-de-sockets","text":"Hasta este punto, hemos visto \u00fanicamente c\u00f3mo enviar cadenas de texto a trav\u00e9s de sockets TCP o UDP, pero es muy probable que sea necesario (o conveniente), en ocasiones, enviar datos directamente en formato binario (por ejemplo, valores num\u00e9ricos en punto flotante o enteros). Utilizando el m\u00f3dulo struct de Python podemos especificar qu\u00e9 tipo o tipos de datos se almacenan en una secuencia de bytes y c\u00f3mo decodificarlos. Tambi\u00e9n es posible especificar en qu\u00e9 lugar de la secuencia se alojan dichos datos, permitiendo el empaquetado de m\u00faltiples datos de distintos tipos de forma sencilla, y su posterior decodificaci\u00f3n en el otro extremo de la comunicaci\u00f3n. Nota Para todos los detalles del m\u00f3dulo struct , consulta la p\u00e1gina oficial de documentaci\u00f3n . El m\u00f3dulo struct proporciona dos m\u00e9todos de inter\u00e9s: pack y unpack . La siguiente sentencia: struct.pack(\">iii\", 1, 2, 3) utiliza el m\u00e9todo pack para realizar un empaquetado de datos. Concretamente, observa como el m\u00e9todo recibe dos par\u00e1metros: En primer lugar, el par\u00e1metro de formato \">iii\" . Define como debe codificarse cada valor en la secuencia de bytes. El primer car\u00e1cter indica el endianness utilizado, en este caso big endian (utilizar\u00edamos \">\" para big endian , \"<\" para little endian y \"=\" para network (big) endian). En segundo lugar, los valores a empaquetar. Observa que el formato, adem\u00e1s, incluye el n\u00famero y tipo de los datos a empaquetar (en este caso, tres valores detipo entero). Para otros tipos de datos, consulta la documentaci\u00f3n del m\u00f3dulo. Desempaquetar los datos enviados en el extremo opuesto es intuitivo: a, b, c = struct.unpack( \">iii\" ) A continuaci\u00f3n, mostramos un ejemplo de sistema cliente/servidor TCP que hace uso del m\u00f3dulo struct para realizar el env\u00edo de dos datos enteros y uno flotante entre un cliente y un servidor. # Cliente import binascii import socket import struct import sys # Socket TCP sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_address = ('localhost', 10001) sock.connect(server_address) packed_data = struct.pack(\"=iif\", 1, 4, 2.7) try: # Envio de datos print('Enviando \"%s\"' % binascii.hexlify(packed_data)) sock.sendall(packed_data) finally: print('Cerrando socket') sock.close() # Servidor import binascii import socket import struct import sys # Socket TCP sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_address = ('localhost', 10001) sock.bind(server_address) sock.listen(1) while True: print('Esperando conexiones entrantes') connection, client_address = sock.accept() try: data = connection.recv(1024) print('Recibido \"%s\"' % binascii.hexlify(data)) unpacked_data = struct.unpack(\"=iif\", data) print('Desempaquetado:', unpacked_data) finally: connection.close() Tarea Ejecuta el anterior sistema cliente servidor y analiza el tr\u00e1fico generado, en busca de los datos binarios empaquetados. Experimenta con otros tipos de datos y endianess y observa las diferencias.","title":"Env\u00edo de datos binarios a trav\u00e9s de sockets"},{"location":"RPI-II/P1/#tarea-entregable","text":"Tarea entregable Se pide dise\u00f1ar un sistema cliente/servidor programado en Python, que simule el env\u00edo de un conjunto de datos sensorizados desde un cliente hacia un servidor. El protocolo a utilizar (formato de datos enviado por la red a nivel de aplicaci\u00f3n) debe ser propuesto por el propio alumno y descrito previamente al desarrollo. Se valorar\u00e1 el uso de m\u00faltiples tipos de datos tanto en el env\u00edo de datos sensorizados como de posibles respuestas por parte del servidor. Se desarrollar\u00e1 una versi\u00f3n utilizando TCP y otra equivalente usando UDP. El cliente enviar\u00e1 los datos de forma peri\u00f3dica y se \u00e9stos generar\u00e1n de modo aleatorio. A modo de entrega, se solicitan los c\u00f3digos desarrollados, as\u00ed como un an\u00e1lisis del tr\u00e1fico generado, considerando la sobrecarga (en bytes reales enviados) introducida por cada protocolo de capa de transporte.","title":"Tarea entregable"},{"location":"RPI-II/P1/#ejemplo-de-sistema-clienteservidor-multi-hilo","text":"Los ejemplos anteriormente descritos, aunque funcionales, adolecen en su dise\u00f1o de una caracter\u00edstica esencial: el servidor deja de atender peticiones entrantes mientras trata cada nuevo env\u00edo por parte del cliente. Los siguientes ejemplos muestran implementaciones sencillas con soporte multi-hilo para un sistema cliente/servidor escrito en Python. # Servidor TCP concurrente import socket, threading class ClientThread(threading.Thread): def __init__(self,clientAddress,clientsocket): threading.Thread.__init__(self) self.csocket = clientsocket print (\"Nueva conexion anyadida: \", clientAddress) def run(self): print (\"Conexion desde: \", clientAddress) #self.csocket.send(bytes(\"Hi, This is from Server..\",'utf-8')) msg = '' while True: data = self.csocket.recv(2048) msg = data.decode() if msg=='bye': break print (\"Desde el cliente\", msg) self.csocket.send(bytes(msg,'UTF-8')) print (\"Cliente \", clientAddress , \" desconectado...\") LOCALHOST = \"127.0.0.1\" PORT = 8080 server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) server.bind((LOCALHOST, PORT)) print(\"Servidor arrancado...\") print(\"Esperando petici\u00f3n de clientes...\") server.listen(1) while True: clientsock, clientAddress = server.accept() newthread = ClientThread(clientAddress, clientsock) newthread.start() # Cliente TCP. El env\u00edo de la cadena bye indica petici\u00f3n de desconexi\u00f3n. import socket SERVER = \"127.0.0.1\" PORT = 8080 client = socket.socket(socket.AF_INET, socket.SOCK_STREAM) client.connect((SERVER, PORT)) client.sendall(bytes(\"Hola, soy un cliente!!\",'UTF-8')) while True: in_data = client.recv(1024) print(\"Desde el servidor :\" ,in_data.decode()) out_data = input() client.sendall(bytes(out_data,'UTF-8')) if out_data=='end': break client.close() Tarea Estudia el c\u00f3digo del servidor concurrente y observa c\u00f3mo gestiona la creaci\u00f3n de hilos para atender cada petici\u00f3n entrante. Conecta simult\u00e1neamente m\u00faltiples clientes y observa el estado de los sockets mediante las herramientas correspondientes.","title":"Ejemplo de sistema cliente/servidor multi-hilo"},{"location":"RPI-II/P1/#tarea-entregable-opcional","text":"Tarea entregable opcional Modifica tu primer entregable para considerar una implementaci\u00f3n multihilo del servidor TCP, siguiendo las directrices de los c\u00f3digos de ejemplo anteriormente proporcionados.","title":"Tarea entregable opcional"},{"location":"RPI-II/P1/#tarea-entregable-opcional_1","text":"Tarea entregable opcional Modifica el protocolo de env\u00edo para que tu aplicaci\u00f3n cliente/servidor UDP garantice en la medida de lo posible la recepci\u00f3n de los paquetes enviados desde el cliente, as\u00ed como su recepci\u00f3n en orden. Vuelve a analizar el tr\u00e1fico necesario en este caso comparado con una comunicaci\u00f3n b\u00e1sica basada en TCP (donde s\u00ed se garantizan, a nivel de transporte, dichas caracter\u00edsticas).","title":"Tarea entregable opcional"},{"location":"RPI-II/P10/","text":"Pr\u00e1ctica 10. Frameworks IoT. Cloud","title":"Pr\u00e1ctica 10"},{"location":"RPI-II/P10/#practica-10-frameworks-iot-cloud","text":"","title":"Pr\u00e1ctica 10. Frameworks IoT. Cloud"},{"location":"RPI-II/P2/","text":"Pr\u00e1ctica 2. Sockets TCP y UDP en ESP-IDF Objetivos Familiarizarse con la API de sockets en C. Desarrollar esquemas b\u00e1sicos de sistemas cliente/servidor TCP y UDP utilizando C. Ser capaces de analizar el tr\u00e1fico generado en una conexi\u00f3n TCP y UDP a trav\u00e9s de Wireshark. Dise\u00f1ar un protocolo de capa de aplicaci\u00f3n para simular una aplicaci\u00f3n cliente/servidor utilizando TCP y UDP para interactuar entre un host y la placa ESP32 Introducci\u00f3n En la pr\u00e1ctica anterior, vimos c\u00f3mo desarrollar sistemas cliente/servidor sencillos utilizando Python, tanto en sus variantes TCP como UDP. El objetivo de la presente pr\u00e1ctica es estudiar y desarrollar componentes de red (clientes y servidores TCP y UDP) que puedan ejecutarse sobre el ESP32 haciendo uso de las facilidades propuestas por ESP-IDF. Adem\u00e1s, demostraremos que es posible hacer interactuar clientes y servidores ejecut\u00e1ndose indistintamente en la m\u00e1quina virtual (programados v\u00eda Python) y en la propia placa (utilizando la API de sockets de C). La API de sockets en C Funciones para ordenacion de bytes Como TCP/IP es un est\u00e1ndar universal, y permite comunicaciones entre cualquier plataforma y arquitectura, es necesario disponer de un m\u00e9todo de ordenaci\u00f3n de los bytes para que m\u00e1quinas big-endian y little-endian puedan comunicarse de forma transparente y correcta. Para ello, se suelen proporcionar rutinas de reordenaci\u00f3n de bytes. En plataformas donde los datos ya est\u00e1n correctamente ordenados, estas funciones no tienen ninguna funcionalidad especial, pero en cualquier caso, es necesario utilizarlas siempre para que la comunicaci\u00f3n entre pares sea correcta. Las funciones t\u00edpicas de reordenaci\u00f3n de datos son cuatro: htons , htonl , ntohs y ntohl . Su nombre explica correctamente su sem\u00e1ntica: host to network (short) host to network (long) , network to host (short) y network to host (long) , convirtiendo tipos de datos short y long desde el formato utilizado en transmisiones de red ( network ) a representaci\u00f3n en el host . As\u00ed, siempre que enviemos un dato binario por la red, deber\u00e1 ser transformado utilizando hton* y cuando lo recibamos y debamos procesarlo, utilizando ntoh* . Estructuras de datos Antes de estudiar la API de sockets b\u00e1sica, es necesario mostrar el cometido de un conjunto de estructuras de datos utilizadas comunmente en todas ellas. La m\u00e1s importante es sockaddr_in , que se define como sigue: struct sockaddr_in { short sin_family; u_short sin_port; struct in_addr sin_addr; char sin_zero[8]; }; La estructura in_addr utilizada en sockaddr_in se define como: struct in_addr { u_long s_addr; }; \u00c9sta consiste en un campo de tipo unsigned long int que contiene la direcci\u00f3n IP que se asociar\u00e1 con el socket. La estructura sockaddr_in contiene dos campos importantes: sin_family : que indica al socket qu\u00e9 familia de protocolos se utiliar\u00e1n (usaremos la constante AF_INET para IPv4). sin_port : que indica el puerto asociado al socket. API b\u00e1sica socket() Prototipo: int socket(int family, int type, int protocol); Descripci\u00f3n: Crea un endpoint de comunicaci\u00f3n y devuelve un descriptor de fichero para manejarlo. Par\u00e1metros: family : AF_INET (IPv4), AF_INET6 (IPv6). type : SOCK_DGRAM (UDP), SOCK_STREAM (TCP), SOCK_RAW . protocol : T\u00edpicamente 0 (no usado en sockets de Internet). Valor de retorno: Si tiene \u00e9xito, devuelve el descriptor de socket . Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de socket ( man socket ). bind() Prototipo: int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); Descripci\u00f3n: Asocia un socket a una direcci\u00f3n especificada por addr . Normalmente, es necesario asignar una direcci\u00f3n local v\u00eda esta funci\u00f3n antes de que un socket TCP pueda recibir conexiones. Par\u00e1metros: sockfd : descriptor de socket (devuelto por socket ). addr : direcci\u00f3n a asociar (v\u00e9ase estructura en secci\u00f3n anterior). addrlen : longitud (en bytes) de la anterior estructura. Valor de retorno: Si tiene \u00e9xito, devuelve 0. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de bind ( man bind ). listen() Prototipo: int listen(int sockfd, int backlog); Descripci\u00f3n: Marca el socket proporcionado como pasivo , esto es, un socket que podr\u00e1 ser utilizado para aceptar conexiones entrantes usando la llamada accept . Par\u00e1metros: sockfd : descriptor de socket (devuelto por socket ). backlog : longitud m\u00e1xima que podr\u00e1 tener la cola de conexiones pendientes para el socket . Si se sobrepasa, el cliente recibir\u00e1 un error en su intento de conexi\u00f3n. Valor de retorno: Si tiene \u00e9xito, devuelve 0. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de listen ( man listen ). accept() Prototipo: int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); Descripci\u00f3n: En sockets orientados a conexi\u00f3n, extrae la primera solicitud de conexi\u00f3n de la cola de conexiones pendientes para el socket proporcionado, crea un nuevo socket conectado y devuelve su descriptor. Par\u00e1metros: sockfd : descriptor de socket (devuelto por socket ). addr : es un puntero a una estructura de tipo sockaddr , cuyos campos ser\u00e1n rellenados con los datos de direcci\u00f3n del socket remoto. addrlen : tama\u00f1o de la estructura addr . Valor de retorno: Si tiene \u00e9xito, devuelve el descriptor de socket. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de accept ( man accept ). connect() Prototipo: int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); Descripci\u00f3n: Conecta el socket proporcionada a la direcci\u00f3n espec\u00edficada por addr . Si el socket es UDP, addr ser\u00e1 la direcci\u00f3n a la que se enviar\u00e1n los datagramas por defecto, y la \u00fanica desde la que se recibir\u00e1n datagramas. En caso de TCP, esta llamada inicia el proceso de conexi\u00f3n a la direcci\u00f3n especificada. Par\u00e1metros: sockfd : descriptor de socket (devuelto por socket ). addr : es un puntero a una estructura de tipo sockaddr , cuyos campos indican la direcci\u00f3n de conexi\u00f3n destino. addrlen : tama\u00f1o de la estructura addr . Valor de retorno: Si tiene \u00e9xito, devuelve el descriptor de socket. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de connect ( man connect ). send() Prototipo: ssize_t send(int sockfd, const void *buf, size_t len, int flags); Descripci\u00f3n: En un socket en estado conectado (con receptor conocido) transmite mensajes a un socket remoto. Par\u00e1metros: sockfd : descriptor de socket de env\u00edo. buf : buffer de env\u00edo donde se almacena el mensaje a enviar. len : n\u00famero de bytes a enviar. Valor de retorno: Si tiene \u00e9xito, devuelve el n\u00famero de bytes enviados. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de send ( man send ). recv() / recvfrom() Prototipos: ssize_t recv(int sockfd, void *buf, size_t len, int flags); ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen); Descripci\u00f3n: Reciben mensajes desde un socket , tanto en sockets orientados como no orientados a conexi\u00f3n. recvfrom , a diferencia de recv , recibe par\u00e1metrosd de salida adicionales que almacenan informaci\u00f3n sobre la direcci\u00f3n origen del mensaje. Par\u00e1metros: sockfd : descriptor de socket de recepci\u00f3n. buf : buffer de recepci\u00f3n donde se almacena el mensaje a recibir. len : n\u00famero de bytes a recibir. src_addr : direcci\u00f3n del extremo remoto del socket (origen de la comunicaci\u00f3n). addrlen : tama\u00f1o de la estructura src_addr . Valor de retorno: Si tiene \u00e9xito, devuelve el n\u00famero de bytes recibidos. Devuelve -1 si se produce un error. Detalles: consultad las p\u00e1ginas de manual de recv y recv_from ( man recv y man recv_from ). close() Prototipo: int close(int fd); Descripci\u00f3n: Cierra un socket. Par\u00e1metros: fd : descriptor de socket . Detalles: consultad la p\u00e1gina de manual de close ( man close ). Ejemplos Se proporcionan a continuaci\u00f3n ejemplos completos de uso de la API de sockets en C para el desarrollo de sistemas cliente/servidor sencillos. Para cada uno de ellos, comprueba que, efectivamente, el uso y secuencia de aplicaci\u00f3n de cada llamada sigue las directivas de la figura: Tarea Compila ( gcc ejemplo.c -o ejemplo.x ) y ejecuta ( ./ejemplo.x ) cada par de c\u00f3digos y comprueba su funcionamiento. Estudia con detenimiento el uso de cada rutina y como efectivamente siguen las directivas marcadas anteriormente. Ejemplo: un cliente TCP #include <arpa/inet.h> #include <stdio.h> #include <string.h> #include <sys/socket.h> #include <unistd.h> #include <netinet/in.h> int main() { const int server_port = 9000; struct sockaddr_in server_address; memset(&server_address, 0, sizeof(server_address)); server_address.sin_family = AF_INET; server_address.sin_addr.s_addr = inet_addr(\"127.0.0.1\"); server_address.sin_port = htons(server_port); int sock; if ((sock = socket(PF_INET, SOCK_STREAM, 0)) < 0) { printf(\"Error en socket\\n\"); return 1; } if (connect(sock, (struct sockaddr*)&server_address, sizeof(server_address)) < 0) { printf(\"Error en connect\\n\"); return 1; } const char* data_to_send = \"Hola, RPI!!\"; send(sock, data_to_send, strlen(data_to_send), 0); int n = 0; int len = 0, maxlen = 100; char buffer[maxlen]; char* pbuffer = buffer; while ((n = recv(sock, pbuffer, maxlen, 0)) > 0) { pbuffer += n; maxlen -= n; len += n; buffer[len] = '\\0'; printf(\"Recibido: '%s'\\n\", buffer); } close(sock); return 0; } Ejemplo: un servidor TCP #include <arpa/inet.h> #include <netinet/in.h> #include <stdbool.h> #include <stdio.h> #include <string.h> #include <unistd.h> int main(int argc, char *argv[]) { int SERVER_PORT = 9000; struct sockaddr_in server_address; memset(&server_address, 0, sizeof(server_address)); server_address.sin_family = AF_INET; server_address.sin_port = htons(SERVER_PORT); server_address.sin_addr.s_addr = htonl(INADDR_ANY); int listen_sock; if ((listen_sock = socket(PF_INET, SOCK_STREAM, 0)) < 0) { printf(\"Error en socket\\n\"); return 1; } if ((bind(listen_sock, (struct sockaddr *)&server_address, sizeof(server_address))) < 0) { printf(\"Error en bind\\n\"); return 1; } int wait_size = 16; if (listen(listen_sock, wait_size) < 0) { printf(\"Error en listen\\n\"); return 1; } struct sockaddr_in client_address; int client_address_len = 0; while (true) { int sock; if ((sock = accept(listen_sock, (struct sockaddr *)&client_address, &client_address_len)) < 0) { printf(\"Error en accept\\n\"); return 1; } int n = 0; int len = 0, maxlen = 100; char buffer[maxlen]; char *pbuffer = buffer; printf(\"Cliente conectado con IP: %s\\n\", inet_ntoa(client_address.sin_addr)); while ((n = recv(sock, pbuffer, maxlen, 0)) > 0) { pbuffer += n; maxlen -= n; len += n; printf(\"Recibido: '%s'\\n\", buffer); send(sock, buffer, len, 0); } close(sock); } close(listen_sock); return 0; } Tarea Reproduce el funcionamiento del anterior sistema cliente/servidor echo utilizando UDP. Construcci\u00f3n de mensajes Para enviar mensajes que encapsulen distintos tipos de datos en una sola invocaci\u00f3n, puedes definir un mensaje como el siguiente: typedef struct { int x; int y; } mensaje; Dando valor a cada campo y a continuaci\u00f3n envi\u00e1ndolo proporcionando la direcci\u00f3n de inicio de la estructura, del siguiente modo: mensaje.x = x; mensaje.y = y; send( socketfd, &mensaje, sizeof( mensaje ), 0 ); Tarea Modifica el cliente UDP para que encapsule y env\u00ede una estructura con distintos campos (por ejemplo, dos enteros), que sea recibida por un servidor Python siguiendo las directivas de la anterior pr\u00e1ctica. En este caso, no utilices campos de tipo flotante (veremos c\u00f3mo hacerlo m\u00e1s adelante). El objetivo del ejercicio es simplemente comprobar que la comunicaci\u00f3n entre un cliente programado en C y un servidor programado en Python es posible. No se pretende que desarrolles un sistema complejo. Sistemas cliente/servidor en el ESP32 La raz\u00f3n por la que hemos ejercitado el uso de la API de sockets desde C en Linux es que la implementaci\u00f3n de la pila TCP/IP en ESP-IDF (llamada Lightweight TCP/IP (lwIP) ) implementa al 100% dicha API. Por tanto, tanto la estructura b\u00e1sica de un firmware que implemente un cliente o servidor como la API utilizada permanece inalterada. En esta \u00faltima secci\u00f3n, se pide trabajar con dos ejemplos b\u00e1sicos de implementaci\u00f3n de sistemas cliente/servidor UDP y TCP sobre el ESP32, con el objetivo de estudiar su funcionalidad, comprobar su interoperabilidad y realizar modificaciones para adaptarlas a una hipot\u00e9tica aplicaci\u00f3n IoT. Cliente/servidor UDP en el ESP32 En esta parte, trabajar\u00e1s con dos ejemplos proporcionados dentro de la colecci\u00f3n de ejemplos de ESP-IDF. Por tanto, copia en tu espacio de trabajo (fuera del \u00e1rbol principal de ESP-IDF) los ejemplos: Servidor UDP : examples/protocols/sockets/udp_server/ Cliente UDP : examples/protocols/sockets/udp_client/ Estructura general Observa sus c\u00f3digos ( udp_server.c para el servidor, y udp_client.c para el cliente). Comprueba que, tanto la estructura b\u00e1sica de ambos componentes como las invocaciones a la API de sockets concuerdan con las que vimos para el sistema echo programado en C. Acerca de la tarea principal (funcion app_main ) observa que realiza una serie de llamadas a APIs de configuraci\u00f3n de algunos subsistemas de FreeRTOS, principalmente: // Inicializa la partici\u00f3n NVS (Non-volatile storage) por defecto. ESP_ERROR_CHECK(nvs_flash_init()); // Inicializa la infraestructura ESP-NETIF. ESP_ERROR_CHECK(esp_netif_init()); // Crea un bucle de eventos por defecto. ESP_ERROR_CHECK(esp_event_loop_create_default()); /* Esta funci\u00f3n configura WiFi o Ethernet, tal y como seleccionemos via menuconfig. */ ESP_ERROR_CHECK(example_connect()); xTaskCreate(udp_server_task, \"udp_server\", 4096, NULL, 5, NULL); example_connect() , funci\u00f3n que no forma parte de ESP-IDF, establece una conexi\u00f3n WiFi o Ethernet. La funci\u00f3n es bloqueante, y retorna cuando se ha conseguido establecer una conexi\u00f3n. Las caracter\u00edsticas de la conexi\u00f3n WiFi (SSID y contrase\u00f1a) se deben proporcionar a trav\u00e9s de menuconfig . El objetivo de ESP-NETIF es proporcionar una capa de abstracci\u00f3n por encima de la pila TCP/IP, de modo que pueda migrarse la pila sin que los c\u00f3digos del usuario cambien. Puedes consultar su documentaci\u00f3n en la p\u00e1gina oficial . Por \u00faltimo, se cerea una tarea que ejecutar\u00e1 la l\u00f3gica del servidor (lo mismo ocurre en el cliente). Observa que, en todo el c\u00f3digo, los mensajes de error se anotan utilizando la macro ESP_LOGE y los informativos con ESP_LOGI ; intenta seguir este convenio en tus c\u00f3digos. Despliegue. Opci\u00f3n 1 En este caso, desplegar\u00e1s el cliente en un ESP32 y el servidor en otro. Si no dispones de dos ESP32, puedes trabajar con un compa\u00f1ero. En cualquier caso, ambos ESP32 deben pertenecer a la misma red inal\u00e1mbrica, por lo que deber\u00e1n conectarse a un mismo punto de acceso (el profesor te proporcionar\u00e1 los datos, o simplemente puedes utilizar tu punto de acceso dom\u00e9stico). Configura los siguientes puntos de la infraestructura: Configura el SSID y contrase\u00f1a del punto de acceso v\u00eda menuconfig antes de compilar y flashear el c\u00f3digo tanto en el cliente como en el servidor. En el servidor, configura v\u00eda menuconfig el puerto sobre el que escuchar\u00e1. Arranca primero el nodo servidor y apunta la IP proporcionada por el punto de acceso; util\u00edzala en el cliente para configurar la IP destino de la comunicaci\u00f3n. No olvides configurar tambi\u00e9n el puerto destino de acuerdo al configurado en el servidor v\u00eda menuconfig . \u00can este punto, podr\u00e1s arrancar el cliente y deber\u00edas estar comunicando dos nodos ESP32 v\u00eda UDP. Despliegue. Opci\u00f3n 2 Si s\u00f3lo dispones de un nodo, o si simplemente quieres probar otra forma de comunicaci\u00f3n en la que uno de los equipos es un PC, puedes utilizar alguna de las herramientas del sistema: Nota Ten en cuenta que port\u00e1til (es decir, m\u00e1quina virtual) y ESP32 deben pertenecera la misma red. Para conseguirlo, para tu m\u00e1quina virtual y a\u00f1ade una nueva interfaz de red de tipo bridge conectada a la interfaz Wifi f\u00edsica de tu PC. As\u00ed, tendr\u00e1s una interfaz con IP en la misma red, otorgada directamente por tu punto de acceso. Para recibir un paquete UDP a trav\u00e9s de un puerto (es decir, emular un servidor UDP): nc -ul -p 3333 Para enviar un paquete UDP a una IP/puerto remotos (es decir, emular un cliente): nc -u IP_REMOTA 3333 En el directorio scripts dispones tambi\u00e9n de peque\u00f1os ejemplos de clientes y servidores UDP Python que puedes tambi\u00e9n utilizar. Cliente/servidor TCP en el ESP32 El despliegue de cliente y servidor TCP es equivalente al UDP. Para recibir un paquete TCP a trav\u00e9s de un puerto (es decir, emular un servidor TCP): nc -l IP -p 3333 Para enviar un paquete TCP a una IP/puerto remotos (es decir, emular un cliente): nc IP 3333 En el directorio scripts dispones tambi\u00e9n de peque\u00f1os ejemplos de clientes y servidores TCP Python que puedes tambi\u00e9n utilizar. Tarea Experimenta con los ejemplos proporcionados en ESP-IDF (cliente/servidor TCP y UDP) y consigue ejecutar todos los elementos en la placa. Si s\u00f3lo dispones de una placa, utiliza la m\u00e1quina virtual como cliente/servidor para comprobar el correcto funcionamiento de cada c\u00f3digo. Tarea entregable En este punto, deber\u00edas disponer de un conjunto de c\u00f3digos que implementan sistemas cliente/servidor tanto en un host (utilizando Python y/o C) como en la placa ESP32 (utilizando C y ESP-IDF), y deber\u00edas haber comprobado su correcto funcionamiento. Espec\u00edficamente, dispondr\u00e1s de: Sistema cliente/servidor desarrollado en la Pr\u00e1ctica 1, escrito en Python e implementando un protocolo b\u00e1sico de aplicacion (tipo de mensaje) propuesto por ti. C\u00f3digo b\u00e1sico en C para implementaci\u00f3n de un servidor/cliente echo programado en C, cuyos c\u00f3digos se proporcionan en este bolet\u00edn. C\u00f3digos b\u00e1sicos en C/ESP-IDF para implementar servidores/clientes echo sobre el ESP32. Como tarea entregable, se pide que adaptes tu entrega de la Pr\u00e1ctica 1 para que tanto cliente como servidor puedan funcionar en el host (bien usando tu implementaci\u00f3n Python, o bien utilizando una nueva implementaci\u00f3n en C) o en el ESP32. Se entregar\u00e1n los c\u00f3digos y una breve memoria con capturas de tr\u00e1fico que demuestren el correcto funcionamiento del sistema.","title":"Pr\u00e1ctica 2"},{"location":"RPI-II/P2/#practica-2-sockets-tcp-y-udp-en-esp-idf","text":"","title":"Pr\u00e1ctica 2. Sockets TCP y UDP en ESP-IDF"},{"location":"RPI-II/P2/#objetivos","text":"Familiarizarse con la API de sockets en C. Desarrollar esquemas b\u00e1sicos de sistemas cliente/servidor TCP y UDP utilizando C. Ser capaces de analizar el tr\u00e1fico generado en una conexi\u00f3n TCP y UDP a trav\u00e9s de Wireshark. Dise\u00f1ar un protocolo de capa de aplicaci\u00f3n para simular una aplicaci\u00f3n cliente/servidor utilizando TCP y UDP para interactuar entre un host y la placa ESP32","title":"Objetivos"},{"location":"RPI-II/P2/#introduccion","text":"En la pr\u00e1ctica anterior, vimos c\u00f3mo desarrollar sistemas cliente/servidor sencillos utilizando Python, tanto en sus variantes TCP como UDP. El objetivo de la presente pr\u00e1ctica es estudiar y desarrollar componentes de red (clientes y servidores TCP y UDP) que puedan ejecutarse sobre el ESP32 haciendo uso de las facilidades propuestas por ESP-IDF. Adem\u00e1s, demostraremos que es posible hacer interactuar clientes y servidores ejecut\u00e1ndose indistintamente en la m\u00e1quina virtual (programados v\u00eda Python) y en la propia placa (utilizando la API de sockets de C).","title":"Introducci\u00f3n"},{"location":"RPI-II/P2/#la-api-de-sockets-en-c","text":"","title":"La API de sockets en C"},{"location":"RPI-II/P2/#funciones-para-ordenacion-de-bytes","text":"Como TCP/IP es un est\u00e1ndar universal, y permite comunicaciones entre cualquier plataforma y arquitectura, es necesario disponer de un m\u00e9todo de ordenaci\u00f3n de los bytes para que m\u00e1quinas big-endian y little-endian puedan comunicarse de forma transparente y correcta. Para ello, se suelen proporcionar rutinas de reordenaci\u00f3n de bytes. En plataformas donde los datos ya est\u00e1n correctamente ordenados, estas funciones no tienen ninguna funcionalidad especial, pero en cualquier caso, es necesario utilizarlas siempre para que la comunicaci\u00f3n entre pares sea correcta. Las funciones t\u00edpicas de reordenaci\u00f3n de datos son cuatro: htons , htonl , ntohs y ntohl . Su nombre explica correctamente su sem\u00e1ntica: host to network (short) host to network (long) , network to host (short) y network to host (long) , convirtiendo tipos de datos short y long desde el formato utilizado en transmisiones de red ( network ) a representaci\u00f3n en el host . As\u00ed, siempre que enviemos un dato binario por la red, deber\u00e1 ser transformado utilizando hton* y cuando lo recibamos y debamos procesarlo, utilizando ntoh* .","title":"Funciones para ordenacion de bytes"},{"location":"RPI-II/P2/#estructuras-de-datos","text":"Antes de estudiar la API de sockets b\u00e1sica, es necesario mostrar el cometido de un conjunto de estructuras de datos utilizadas comunmente en todas ellas. La m\u00e1s importante es sockaddr_in , que se define como sigue: struct sockaddr_in { short sin_family; u_short sin_port; struct in_addr sin_addr; char sin_zero[8]; }; La estructura in_addr utilizada en sockaddr_in se define como: struct in_addr { u_long s_addr; }; \u00c9sta consiste en un campo de tipo unsigned long int que contiene la direcci\u00f3n IP que se asociar\u00e1 con el socket. La estructura sockaddr_in contiene dos campos importantes: sin_family : que indica al socket qu\u00e9 familia de protocolos se utiliar\u00e1n (usaremos la constante AF_INET para IPv4). sin_port : que indica el puerto asociado al socket.","title":"Estructuras de datos"},{"location":"RPI-II/P2/#api-basica","text":"","title":"API b\u00e1sica"},{"location":"RPI-II/P2/#socket","text":"Prototipo: int socket(int family, int type, int protocol); Descripci\u00f3n: Crea un endpoint de comunicaci\u00f3n y devuelve un descriptor de fichero para manejarlo. Par\u00e1metros: family : AF_INET (IPv4), AF_INET6 (IPv6). type : SOCK_DGRAM (UDP), SOCK_STREAM (TCP), SOCK_RAW . protocol : T\u00edpicamente 0 (no usado en sockets de Internet). Valor de retorno: Si tiene \u00e9xito, devuelve el descriptor de socket . Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de socket ( man socket ).","title":"socket()"},{"location":"RPI-II/P2/#bind","text":"Prototipo: int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); Descripci\u00f3n: Asocia un socket a una direcci\u00f3n especificada por addr . Normalmente, es necesario asignar una direcci\u00f3n local v\u00eda esta funci\u00f3n antes de que un socket TCP pueda recibir conexiones. Par\u00e1metros: sockfd : descriptor de socket (devuelto por socket ). addr : direcci\u00f3n a asociar (v\u00e9ase estructura en secci\u00f3n anterior). addrlen : longitud (en bytes) de la anterior estructura. Valor de retorno: Si tiene \u00e9xito, devuelve 0. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de bind ( man bind ).","title":"bind()"},{"location":"RPI-II/P2/#listen","text":"Prototipo: int listen(int sockfd, int backlog); Descripci\u00f3n: Marca el socket proporcionado como pasivo , esto es, un socket que podr\u00e1 ser utilizado para aceptar conexiones entrantes usando la llamada accept . Par\u00e1metros: sockfd : descriptor de socket (devuelto por socket ). backlog : longitud m\u00e1xima que podr\u00e1 tener la cola de conexiones pendientes para el socket . Si se sobrepasa, el cliente recibir\u00e1 un error en su intento de conexi\u00f3n. Valor de retorno: Si tiene \u00e9xito, devuelve 0. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de listen ( man listen ).","title":"listen()"},{"location":"RPI-II/P2/#accept","text":"Prototipo: int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); Descripci\u00f3n: En sockets orientados a conexi\u00f3n, extrae la primera solicitud de conexi\u00f3n de la cola de conexiones pendientes para el socket proporcionado, crea un nuevo socket conectado y devuelve su descriptor. Par\u00e1metros: sockfd : descriptor de socket (devuelto por socket ). addr : es un puntero a una estructura de tipo sockaddr , cuyos campos ser\u00e1n rellenados con los datos de direcci\u00f3n del socket remoto. addrlen : tama\u00f1o de la estructura addr . Valor de retorno: Si tiene \u00e9xito, devuelve el descriptor de socket. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de accept ( man accept ).","title":"accept()"},{"location":"RPI-II/P2/#connect","text":"Prototipo: int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); Descripci\u00f3n: Conecta el socket proporcionada a la direcci\u00f3n espec\u00edficada por addr . Si el socket es UDP, addr ser\u00e1 la direcci\u00f3n a la que se enviar\u00e1n los datagramas por defecto, y la \u00fanica desde la que se recibir\u00e1n datagramas. En caso de TCP, esta llamada inicia el proceso de conexi\u00f3n a la direcci\u00f3n especificada. Par\u00e1metros: sockfd : descriptor de socket (devuelto por socket ). addr : es un puntero a una estructura de tipo sockaddr , cuyos campos indican la direcci\u00f3n de conexi\u00f3n destino. addrlen : tama\u00f1o de la estructura addr . Valor de retorno: Si tiene \u00e9xito, devuelve el descriptor de socket. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de connect ( man connect ).","title":"connect()"},{"location":"RPI-II/P2/#send","text":"Prototipo: ssize_t send(int sockfd, const void *buf, size_t len, int flags); Descripci\u00f3n: En un socket en estado conectado (con receptor conocido) transmite mensajes a un socket remoto. Par\u00e1metros: sockfd : descriptor de socket de env\u00edo. buf : buffer de env\u00edo donde se almacena el mensaje a enviar. len : n\u00famero de bytes a enviar. Valor de retorno: Si tiene \u00e9xito, devuelve el n\u00famero de bytes enviados. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de send ( man send ).","title":"send()"},{"location":"RPI-II/P2/#recvrecvfrom","text":"Prototipos: ssize_t recv(int sockfd, void *buf, size_t len, int flags); ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen); Descripci\u00f3n: Reciben mensajes desde un socket , tanto en sockets orientados como no orientados a conexi\u00f3n. recvfrom , a diferencia de recv , recibe par\u00e1metrosd de salida adicionales que almacenan informaci\u00f3n sobre la direcci\u00f3n origen del mensaje. Par\u00e1metros: sockfd : descriptor de socket de recepci\u00f3n. buf : buffer de recepci\u00f3n donde se almacena el mensaje a recibir. len : n\u00famero de bytes a recibir. src_addr : direcci\u00f3n del extremo remoto del socket (origen de la comunicaci\u00f3n). addrlen : tama\u00f1o de la estructura src_addr . Valor de retorno: Si tiene \u00e9xito, devuelve el n\u00famero de bytes recibidos. Devuelve -1 si se produce un error. Detalles: consultad las p\u00e1ginas de manual de recv y recv_from ( man recv y man recv_from ).","title":"recv()/recvfrom()"},{"location":"RPI-II/P2/#close","text":"Prototipo: int close(int fd); Descripci\u00f3n: Cierra un socket. Par\u00e1metros: fd : descriptor de socket . Detalles: consultad la p\u00e1gina de manual de close ( man close ).","title":"close()"},{"location":"RPI-II/P2/#ejemplos","text":"Se proporcionan a continuaci\u00f3n ejemplos completos de uso de la API de sockets en C para el desarrollo de sistemas cliente/servidor sencillos. Para cada uno de ellos, comprueba que, efectivamente, el uso y secuencia de aplicaci\u00f3n de cada llamada sigue las directivas de la figura: Tarea Compila ( gcc ejemplo.c -o ejemplo.x ) y ejecuta ( ./ejemplo.x ) cada par de c\u00f3digos y comprueba su funcionamiento. Estudia con detenimiento el uso de cada rutina y como efectivamente siguen las directivas marcadas anteriormente.","title":"Ejemplos"},{"location":"RPI-II/P2/#ejemplo-un-cliente-tcp","text":"#include <arpa/inet.h> #include <stdio.h> #include <string.h> #include <sys/socket.h> #include <unistd.h> #include <netinet/in.h> int main() { const int server_port = 9000; struct sockaddr_in server_address; memset(&server_address, 0, sizeof(server_address)); server_address.sin_family = AF_INET; server_address.sin_addr.s_addr = inet_addr(\"127.0.0.1\"); server_address.sin_port = htons(server_port); int sock; if ((sock = socket(PF_INET, SOCK_STREAM, 0)) < 0) { printf(\"Error en socket\\n\"); return 1; } if (connect(sock, (struct sockaddr*)&server_address, sizeof(server_address)) < 0) { printf(\"Error en connect\\n\"); return 1; } const char* data_to_send = \"Hola, RPI!!\"; send(sock, data_to_send, strlen(data_to_send), 0); int n = 0; int len = 0, maxlen = 100; char buffer[maxlen]; char* pbuffer = buffer; while ((n = recv(sock, pbuffer, maxlen, 0)) > 0) { pbuffer += n; maxlen -= n; len += n; buffer[len] = '\\0'; printf(\"Recibido: '%s'\\n\", buffer); } close(sock); return 0; }","title":"Ejemplo: un cliente TCP"},{"location":"RPI-II/P2/#ejemplo-un-servidor-tcp","text":"#include <arpa/inet.h> #include <netinet/in.h> #include <stdbool.h> #include <stdio.h> #include <string.h> #include <unistd.h> int main(int argc, char *argv[]) { int SERVER_PORT = 9000; struct sockaddr_in server_address; memset(&server_address, 0, sizeof(server_address)); server_address.sin_family = AF_INET; server_address.sin_port = htons(SERVER_PORT); server_address.sin_addr.s_addr = htonl(INADDR_ANY); int listen_sock; if ((listen_sock = socket(PF_INET, SOCK_STREAM, 0)) < 0) { printf(\"Error en socket\\n\"); return 1; } if ((bind(listen_sock, (struct sockaddr *)&server_address, sizeof(server_address))) < 0) { printf(\"Error en bind\\n\"); return 1; } int wait_size = 16; if (listen(listen_sock, wait_size) < 0) { printf(\"Error en listen\\n\"); return 1; } struct sockaddr_in client_address; int client_address_len = 0; while (true) { int sock; if ((sock = accept(listen_sock, (struct sockaddr *)&client_address, &client_address_len)) < 0) { printf(\"Error en accept\\n\"); return 1; } int n = 0; int len = 0, maxlen = 100; char buffer[maxlen]; char *pbuffer = buffer; printf(\"Cliente conectado con IP: %s\\n\", inet_ntoa(client_address.sin_addr)); while ((n = recv(sock, pbuffer, maxlen, 0)) > 0) { pbuffer += n; maxlen -= n; len += n; printf(\"Recibido: '%s'\\n\", buffer); send(sock, buffer, len, 0); } close(sock); } close(listen_sock); return 0; } Tarea Reproduce el funcionamiento del anterior sistema cliente/servidor echo utilizando UDP.","title":"Ejemplo: un servidor TCP"},{"location":"RPI-II/P2/#construccion-de-mensajes","text":"Para enviar mensajes que encapsulen distintos tipos de datos en una sola invocaci\u00f3n, puedes definir un mensaje como el siguiente: typedef struct { int x; int y; } mensaje; Dando valor a cada campo y a continuaci\u00f3n envi\u00e1ndolo proporcionando la direcci\u00f3n de inicio de la estructura, del siguiente modo: mensaje.x = x; mensaje.y = y; send( socketfd, &mensaje, sizeof( mensaje ), 0 ); Tarea Modifica el cliente UDP para que encapsule y env\u00ede una estructura con distintos campos (por ejemplo, dos enteros), que sea recibida por un servidor Python siguiendo las directivas de la anterior pr\u00e1ctica. En este caso, no utilices campos de tipo flotante (veremos c\u00f3mo hacerlo m\u00e1s adelante). El objetivo del ejercicio es simplemente comprobar que la comunicaci\u00f3n entre un cliente programado en C y un servidor programado en Python es posible. No se pretende que desarrolles un sistema complejo.","title":"Construcci\u00f3n de mensajes"},{"location":"RPI-II/P2/#sistemas-clienteservidor-en-el-esp32","text":"La raz\u00f3n por la que hemos ejercitado el uso de la API de sockets desde C en Linux es que la implementaci\u00f3n de la pila TCP/IP en ESP-IDF (llamada Lightweight TCP/IP (lwIP) ) implementa al 100% dicha API. Por tanto, tanto la estructura b\u00e1sica de un firmware que implemente un cliente o servidor como la API utilizada permanece inalterada. En esta \u00faltima secci\u00f3n, se pide trabajar con dos ejemplos b\u00e1sicos de implementaci\u00f3n de sistemas cliente/servidor UDP y TCP sobre el ESP32, con el objetivo de estudiar su funcionalidad, comprobar su interoperabilidad y realizar modificaciones para adaptarlas a una hipot\u00e9tica aplicaci\u00f3n IoT.","title":"Sistemas cliente/servidor en el ESP32"},{"location":"RPI-II/P2/#clienteservidor-udp-en-el-esp32","text":"En esta parte, trabajar\u00e1s con dos ejemplos proporcionados dentro de la colecci\u00f3n de ejemplos de ESP-IDF. Por tanto, copia en tu espacio de trabajo (fuera del \u00e1rbol principal de ESP-IDF) los ejemplos: Servidor UDP : examples/protocols/sockets/udp_server/ Cliente UDP : examples/protocols/sockets/udp_client/","title":"Cliente/servidor UDP en el ESP32"},{"location":"RPI-II/P2/#estructura-general","text":"Observa sus c\u00f3digos ( udp_server.c para el servidor, y udp_client.c para el cliente). Comprueba que, tanto la estructura b\u00e1sica de ambos componentes como las invocaciones a la API de sockets concuerdan con las que vimos para el sistema echo programado en C. Acerca de la tarea principal (funcion app_main ) observa que realiza una serie de llamadas a APIs de configuraci\u00f3n de algunos subsistemas de FreeRTOS, principalmente: // Inicializa la partici\u00f3n NVS (Non-volatile storage) por defecto. ESP_ERROR_CHECK(nvs_flash_init()); // Inicializa la infraestructura ESP-NETIF. ESP_ERROR_CHECK(esp_netif_init()); // Crea un bucle de eventos por defecto. ESP_ERROR_CHECK(esp_event_loop_create_default()); /* Esta funci\u00f3n configura WiFi o Ethernet, tal y como seleccionemos via menuconfig. */ ESP_ERROR_CHECK(example_connect()); xTaskCreate(udp_server_task, \"udp_server\", 4096, NULL, 5, NULL); example_connect() , funci\u00f3n que no forma parte de ESP-IDF, establece una conexi\u00f3n WiFi o Ethernet. La funci\u00f3n es bloqueante, y retorna cuando se ha conseguido establecer una conexi\u00f3n. Las caracter\u00edsticas de la conexi\u00f3n WiFi (SSID y contrase\u00f1a) se deben proporcionar a trav\u00e9s de menuconfig . El objetivo de ESP-NETIF es proporcionar una capa de abstracci\u00f3n por encima de la pila TCP/IP, de modo que pueda migrarse la pila sin que los c\u00f3digos del usuario cambien. Puedes consultar su documentaci\u00f3n en la p\u00e1gina oficial . Por \u00faltimo, se cerea una tarea que ejecutar\u00e1 la l\u00f3gica del servidor (lo mismo ocurre en el cliente). Observa que, en todo el c\u00f3digo, los mensajes de error se anotan utilizando la macro ESP_LOGE y los informativos con ESP_LOGI ; intenta seguir este convenio en tus c\u00f3digos.","title":"Estructura general"},{"location":"RPI-II/P2/#despliegue-opcion-1","text":"En este caso, desplegar\u00e1s el cliente en un ESP32 y el servidor en otro. Si no dispones de dos ESP32, puedes trabajar con un compa\u00f1ero. En cualquier caso, ambos ESP32 deben pertenecer a la misma red inal\u00e1mbrica, por lo que deber\u00e1n conectarse a un mismo punto de acceso (el profesor te proporcionar\u00e1 los datos, o simplemente puedes utilizar tu punto de acceso dom\u00e9stico). Configura los siguientes puntos de la infraestructura: Configura el SSID y contrase\u00f1a del punto de acceso v\u00eda menuconfig antes de compilar y flashear el c\u00f3digo tanto en el cliente como en el servidor. En el servidor, configura v\u00eda menuconfig el puerto sobre el que escuchar\u00e1. Arranca primero el nodo servidor y apunta la IP proporcionada por el punto de acceso; util\u00edzala en el cliente para configurar la IP destino de la comunicaci\u00f3n. No olvides configurar tambi\u00e9n el puerto destino de acuerdo al configurado en el servidor v\u00eda menuconfig . \u00can este punto, podr\u00e1s arrancar el cliente y deber\u00edas estar comunicando dos nodos ESP32 v\u00eda UDP.","title":"Despliegue. Opci\u00f3n 1"},{"location":"RPI-II/P2/#despliegue-opcion-2","text":"Si s\u00f3lo dispones de un nodo, o si simplemente quieres probar otra forma de comunicaci\u00f3n en la que uno de los equipos es un PC, puedes utilizar alguna de las herramientas del sistema: Nota Ten en cuenta que port\u00e1til (es decir, m\u00e1quina virtual) y ESP32 deben pertenecera la misma red. Para conseguirlo, para tu m\u00e1quina virtual y a\u00f1ade una nueva interfaz de red de tipo bridge conectada a la interfaz Wifi f\u00edsica de tu PC. As\u00ed, tendr\u00e1s una interfaz con IP en la misma red, otorgada directamente por tu punto de acceso. Para recibir un paquete UDP a trav\u00e9s de un puerto (es decir, emular un servidor UDP): nc -ul -p 3333 Para enviar un paquete UDP a una IP/puerto remotos (es decir, emular un cliente): nc -u IP_REMOTA 3333 En el directorio scripts dispones tambi\u00e9n de peque\u00f1os ejemplos de clientes y servidores UDP Python que puedes tambi\u00e9n utilizar.","title":"Despliegue. Opci\u00f3n 2"},{"location":"RPI-II/P2/#clienteservidor-tcp-en-el-esp32","text":"El despliegue de cliente y servidor TCP es equivalente al UDP. Para recibir un paquete TCP a trav\u00e9s de un puerto (es decir, emular un servidor TCP): nc -l IP -p 3333 Para enviar un paquete TCP a una IP/puerto remotos (es decir, emular un cliente): nc IP 3333 En el directorio scripts dispones tambi\u00e9n de peque\u00f1os ejemplos de clientes y servidores TCP Python que puedes tambi\u00e9n utilizar. Tarea Experimenta con los ejemplos proporcionados en ESP-IDF (cliente/servidor TCP y UDP) y consigue ejecutar todos los elementos en la placa. Si s\u00f3lo dispones de una placa, utiliza la m\u00e1quina virtual como cliente/servidor para comprobar el correcto funcionamiento de cada c\u00f3digo. Tarea entregable En este punto, deber\u00edas disponer de un conjunto de c\u00f3digos que implementan sistemas cliente/servidor tanto en un host (utilizando Python y/o C) como en la placa ESP32 (utilizando C y ESP-IDF), y deber\u00edas haber comprobado su correcto funcionamiento. Espec\u00edficamente, dispondr\u00e1s de: Sistema cliente/servidor desarrollado en la Pr\u00e1ctica 1, escrito en Python e implementando un protocolo b\u00e1sico de aplicacion (tipo de mensaje) propuesto por ti. C\u00f3digo b\u00e1sico en C para implementaci\u00f3n de un servidor/cliente echo programado en C, cuyos c\u00f3digos se proporcionan en este bolet\u00edn. C\u00f3digos b\u00e1sicos en C/ESP-IDF para implementar servidores/clientes echo sobre el ESP32. Como tarea entregable, se pide que adaptes tu entrega de la Pr\u00e1ctica 1 para que tanto cliente como servidor puedan funcionar en el host (bien usando tu implementaci\u00f3n Python, o bien utilizando una nueva implementaci\u00f3n en C) o en el ESP32. Se entregar\u00e1n los c\u00f3digos y una breve memoria con capturas de tr\u00e1fico que demuestren el correcto funcionamiento del sistema.","title":"Cliente/servidor TCP en el ESP32"},{"location":"RPI-II/P3/","text":"Pr\u00e1ctica 3. Seguridad (TLS y DTLS) Objetivos Observar el comportamiento de TLS y DTLS para el intercambio cifrado de mensajes. Conocer las diferencias b\u00e1sicas entre TLS y DTLS. Conocer una API b\u00e1sica de programaci\u00f3n de sistemas cliente/servidor usando TLS y DTLS (WolfSSL). Conocer una API b\u00e1sica de programaci\u00f3n de sistemas cliente/servidor en ESP-IDF (ESP-TLS). Contenido del paquete proporcionado y setup b\u00e1sico El paquete proporcionado (puedes descargarlo aqu\u00ed ) incluye ejemplos de sistemas cliente/servidor programados utilizando TLS y DTLS mediante el uso de la biblioteca WolfSSL. Estos c\u00f3digos est\u00e1n dise\u00f1ados para ejecutarse exclusivamente en un sistema Linux, y requieren la instalaci\u00f3n de los paquetes de desarrollo WolfSSL. Para realizar la instalaci\u00f3n, ejecuta en tu m\u00e1quina virtual (esta l\u00ednea podr\u00eda cambiar si usas otra distribuci\u00f3n de Linux, en cuyo caso deber\u00e1s buscar los paquetes equivalentes): sudo apt-get install libwolfssl-dev libwolfssl24 Una vez hecho esto, prueba a realizar la compilaci\u00f3n tanto del ejemplo TLS como DTLS utilizando la orden make en el directorio correspondiente. Si todo ha ido bien, puedes continuar con el an\u00e1lisis de los c\u00f3digos en la siguiente secci\u00f3n. Cliente/servidor TLS. Ejemplo b\u00e1sico en host Servidor TLS Analizaremos en primer lugar el c\u00f3digo b\u00e1sico del servidor TLS. Para ello, observa el contenido del fchero tls/server-tls.c . Cabeceras y constantes El uso de WolfSSL requiere la inclusi\u00f3n de dos cabeceras b\u00e1sicas: #include <wolfssl/options.h> #include <wolfssl/ssl.h> Adem\u00e1s, ya que ser\u00e1n necesarios en el desarrollo, definiremos las rutas al certificado (clave p\u00fablica) del servidor y su clave privada: #define CERT_FILE \"../certs/server-cert.pem\" #define KEY_FILE \"../certs/server-key.pem\" Observa adem\u00e1s que el puerto de escucha del servidor ser\u00e1 el 11111 . Objetos b\u00e1sicos WolfSSL. Contexto y objeto SSL Definiremos dos objetos b\u00e1sicos que se utilizar\u00e1n de forma recurrente en el c\u00f3digo: WOLFSSL_CTX* ctx; WOLFSSL* ssl; El contexto ( ctx ) incluye valores globales para cada conexi\u00f3n SSL, incluyendo informaci\u00f3n sobre certificados. Es posible utilizar un mismo contexto para m\u00faltiples conexiones, siempre que compartan caracter\u00edsticas. Para crear un nuevo contexto, utilizaremos la funci\u00f3n wolfSSL_CTX_new como sigue: /* Create and initialize WOLFSSL_CTX */ if ((ctx = wolfSSL_CTX_new(wolfTLSv1_2_server_method())) == NULL) { fprintf(stderr, \"ERROR: failed to create WOLFSSL_CTX\\n\"); return -1; } El argumento proporcionado incluye informaci\u00f3n sobre la versi\u00f3n de protocolo a utilizar. Actualmente, WolfSSL soporta SSL 3.0, TLS 1.1, TLS 1.2, DTLS 1.0 y DTLS 1.2. En este caso, para la parte cliente, las funciones a utilizar como argumento ser\u00edan: wolfSSLv3_server_method(); // SSLv3 wolfTLSv1_server_method(); // TLSv1 wolfTLSv1_1_server_method(); // TLSv1.1 wolfTLSv1_2_server_method(); // TLSv1.2 wolfDTLSv1_server_method(); // DTLS wolfDTLSv1_2_server_method(); // DTLS 1.2 En segundo lugar, es necesario cargar nuestra CA (Autoridad Certificadora) en el contexto, para que cualquier cliente pueda verificar, en el momento de su conexi\u00f3n, la identidad del sevidor. Para ello, usamos la funci\u00f3n wolfSSL_CTX_use_certificate_file de la siguiente manera: /* Load server certificates into WOLFSSL_CTX */ if (wolfSSL_CTX_use_certificate_file(ctx, CERT_FILE, SSL_FILETYPE_PEM) != SSL_SUCCESS) { fprintf(stderr, \"ERROR: failed to load %s, please check the file.\\n\", CERT_FILE); return -1; } Del mismo modo, el servidor deber\u00e1 incluir su clave privada en formato PEM: /* Load server key into WOLFSSL_CTX */ if (wolfSSL_CTX_use_PrivateKey_file(ctx, KEY_FILE, SSL_FILETYPE_PEM) != SSL_SUCCESS) { fprintf(stderr, \"ERROR: failed to load %s, please check the file.\\n\", KEY_FILE); return -1; } A continuaci\u00f3n, observa como el c\u00f3digo de escucha y aceptaci\u00f3n de conexiones entrantes no difier de cualquier c\u00f3digo que hayas desarrollado previamente para aceptar conexiones entrantes TCP ( bind , + listen + accept ). Justo tras la conexi\u00f3n ( accept ), resulta necesario crear un nuevo objeto SSL, as\u00ed como asociar el descriptor de socket con la nueva sesi\u00f3n (conexi\u00f3n) TLS: /* Create a WOLFSSL object */ if ((ssl = wolfSSL_new(ctx)) == NULL) { fprintf(stderr, \"ERROR: failed to create WOLFSSL object\\n\"); return -1; } /* Attach wolfSSL to the socket */ wolfSSL_set_fd(ssl, connd); /* Establish TLS connection */ ret = wolfSSL_accept(ssl); if (ret != SSL_SUCCESS) { fprintf(stderr, \"wolfSSL_accept error = %d\\n\", wolfSSL_get_error(ssl, ret)); return -1; } A partir de este punto, podemos enviar y recibir datos a trav\u00e9s del socket (y por tanto de la conexi\u00f3n TLS) de forma muy similar a como lo hacemos con el enfoque cl\u00e1sico. As\u00ed, para recibir datos: if (wolfSSL_read(ssl, buff, sizeof(buff)-1) == -1) { fprintf(stderr, \"ERROR: failed to read\\n\"); return -1; } Y para enviar datos de vuelta: /* Reply back to the client */ if (wolfSSL_write(ssl, buff, len) != len) { fprintf(stderr, \"ERROR: failed to write\\n\"); return -1; } Por \u00faltimo, finalizaremos la conexi\u00f3n con la invocaci\u00f3n de la funci\u00f3n wolfSSL_free(ssl) . Note El cliente proporcionado sigue una estrategia de implementaci\u00f3n similar. Compara ambos c\u00f3digos (cliente y servidor) y aseg\u00farate de entender las diferencias entre ellos. Tarea entregable Compila y ejecuta el sistema cliente/servidor TLS y obt\u00e9n capturas de tr\u00e1fico tanto de las fases de establecimiento de conexi\u00f3n como de las fases de transferencia de datos. En base a lo aprendido en las clases de teor\u00eda y la documentaci\u00f3n adicional sobre TLS y wolfSSL, redacta un documento con aquellas observaciones que consideres relevantes. Cliente/servidor DTLS. Ejemplo b\u00e1sico en host El desarrollo de un sistema b\u00e1sico cliente/servidor con soporte DTLS utilizando WolfSSL es muy similar al visto anteriormente para TLS. Como detalle adicional, la inicializaci\u00f3n de la infraestructura debe realizarse indicando el soporte para DTLS en sus versiones 1.0 o 1.2: wolfDTLSv1_client_method(); // DTLS 1.0 wolfDTLSv1_2_client_method(); // DTLS 1.2 El resto del c\u00f3digo sigue una filosof\u00eda similar a TLS, adaptado, obviamente, a las caracter\u00edsticas de UDP (tipo de socket, ausencia de conexi\u00f3n, etc.), por lo que se deja como ejercicio su an\u00e1lisis y ejecuci\u00f3n. Tarea entregable Analiza, compila y ejecuta los c\u00f3digos correspondientes al sistema cliente/servidor DTLS. Realiza capturas de tr\u00e1fico y comp\u00e1ralas, paquete a paquete, con las generadas para un patr\u00f3n de tr\u00e1fico similar en el caso de TLS. Incide en sus similitudes y diferencias, tanto a nivel de handshake como de transferencia de datos. Observa, en este \u00faltimo caso, la aparici\u00f3n de nuevos campos de encabezado en los env\u00edos de datos DTLS. \u00bfCu\u00e1l/cu\u00e1les son esos campos y por qu\u00e9 aparecen? Realiza una comparativa del tr\u00e1fico total generado en ambos casos para exactamente la misma cantidad de datos transferidos. TLS en el ESP32. El componente ESP-TLS ESP-IDF proporciona un componente (ESP-TLS) que ofrece una interfaz (API) simplificada para acceder a funcionalidad b\u00e1sica TLS. A\u00fan as\u00ed, ofrece una funcionalidad suficientemente amplia como para implementar casos de uso comunes en entornos IoT. La API de ESP-TLS es sencilla,y se basa en el uso de cuatro funciones b\u00e1sicas: Establecimiento de conexi\u00f3n TLS ( esp_tls_conn_new() ) Prototipo: esp_tls_t *esp_tls_conn_new(const char *hostname, int hostlen, int port, constesp_tls_cfg_t *cfg) Descripci\u00f3n: Crea una nueva conexi\u00f3n TLS/SSL bloqueante, estableciendo dicha conexi\u00f3n contra un servidor establecido. Par\u00e1metros: hostname : Identificaci\u00f3n del host. hostlen : Longitud del par\u00e1metro hostname . port : Puerto de conexi\u00f3n con el host. cfg : Configuraci\u00f3n de la conexi\u00f3n TLS. Valor de retorno: Puntero a esp_tls_t (manejador de la conexi\u00f3n). Devuelve NULL si se produce un error en la conexi\u00f3n. Destrucci\u00f3n de conexi\u00f3n TLS ( esp_tls_conn_delete() ) void esp_tls_conn_delete(esp_tls_t *tls) Descripci\u00f3n: Cierra la conexi\u00f3n TLS/SSL. Par\u00e1metros: tls : Manejador de la conexi\u00f3n. Escritura de datos ( esp_tls_conn_read() ) static ssize_t esp_tls_conn_write(esp_tls_t *tls, const void *data, size_t datalen) Descripci\u00f3n: Escribe en la conexi\u00f3n TLS/SSL indicada el contenido del buffer data . Par\u00e1metros: tls : Manejador de la conexi\u00f3n. data : Buffer de env\u00edo. datalen : Longitud del buffer de env\u00edo (o n\u00famero m\u00e1ximo de bytes a escribir). Valor de retorno: >=0 : \u00e9xito en el env\u00edo. N\u00famero de bytes efectivamente enviados. <0 : error en el env\u00edo. Lectura de datos ( esp_tls_conn_read() ) static ssize_t esp_tls_conn_read(esp_tls_t *tls, void *data, size_t datalen) Descripci\u00f3n: Lee desde la conexi\u00f3n TLS/SSL indicada hacia el buffer data . Par\u00e1metros: tls : Manejador de la conexi\u00f3n. data : Buffer de recepci\u00f3n. datalen : Longitud del buffer de recepci\u00f3n (o n\u00famero m\u00e1ximo de bytes a leer). Valor de retorno: >0 : \u00e9xito en la recepci\u00f3n. N\u00famero de bytes efectivamente le\u00eddos. =0 : error en la recepci\u00f3n. La conexi\u00f3n se cerr\u00f3. <0 : error en la recepci\u00f3n. Estructura b\u00e1sica de un cliente TCP usando ESP-IDF Un cliente TCP implementado sobre ESP-IDF para dar soporte TLS, requiere ciertas modificaciones con respecto a la versi\u00f3n sin TLS. De hecho, el uso de ESP-IDF simplifica el c\u00f3digo del cliente (puedes compararlo con tus clientes TCP desarrollados en sesiones anteriores). La estructura b\u00e1sica resultar\u00eda: /// Includes anteriores. #include \"esp_tls.h\" // Puede tomarse desde menuconfig. #define HOST_IP_ADDR DIRECCION_DE_HOST #define PORT PUERTO static const char *payload = \"Hola, mundo via TLS\"; // ... static void tls_client_task( void *pvParameters ) { // ... // Configuraci\u00f3n de ESP-TLS (por defecto). esp_tls_cfg_t cfg = { }; // Creaci\u00f3n de conexi\u00f3n. struct esp_tls *tls = esp_tls_conn_new( HOST_IP_ADDR, longitud, PORT, &cfg); // Chequeo de errores. // ... // Env\u00edo de datos. ret = esp_tls_conn_write(tls, payload, strlen(payload)); // Chequeo de errores. // ... // Lectura de datos ret = esp_tls_conn_read(tls, (char *)rx_buffer, 128); // Chequeo de errores. // ... // Destrucci\u00f3n de la conexi\u00f3n esp_tls_conn_delete( tls ); } void app_main( void ) { // ... } Observa como, efectivamente, el c\u00f3digo del cliente se simplifica en gran medida con respecto a tu cliente TCP original. Toma el c\u00f3digo del proyecto que utilizaste para desarrollar tu cliente TCP original y, siguiendo las anteriores directivas, adapta la \u00fanica tarea a crear (por ejemplo, puede recibir el nombre tls_client_task ) para que realice un env\u00edo y recepci\u00f3n de datos (una cadena) al servidor TLS que probaste en el host . Puedes valerte para ello de la base del ejemplo examples/protocols/https_request , obviamente adaptando la totalidad de su c\u00f3digo para que se comporte como un simple cliente echo . Note Compila y ejecuta el cliente TLS en el ESP32, y consigue que interact\u00fae con el servidor TLS que probaste anteriormente en el host . Comprueba que, efectivamente, los datos se transfieren cifrados entre ambos extremos, y que el intercambio de paquetes es similar al que observaste entre cliente y servidor en el host . Tarea entregable Adapta tu sistema cliente/servidor TCP desarrollado en la anterior pr\u00e1ctica para que se ejecute sobre el binomio host /ESP32 utlizando TLS. Entrega el c\u00f3digo generado junto con una captura de tr\u00e1fico que demuestre su correcto funcionamiento.","title":"Pr\u00e1ctica 3"},{"location":"RPI-II/P3/#practica-3-seguridad-tls-y-dtls","text":"","title":"Pr\u00e1ctica 3. Seguridad (TLS y DTLS)"},{"location":"RPI-II/P3/#objetivos","text":"Observar el comportamiento de TLS y DTLS para el intercambio cifrado de mensajes. Conocer las diferencias b\u00e1sicas entre TLS y DTLS. Conocer una API b\u00e1sica de programaci\u00f3n de sistemas cliente/servidor usando TLS y DTLS (WolfSSL). Conocer una API b\u00e1sica de programaci\u00f3n de sistemas cliente/servidor en ESP-IDF (ESP-TLS).","title":"Objetivos"},{"location":"RPI-II/P3/#contenido-del-paquete-proporcionado-y-setup-basico","text":"El paquete proporcionado (puedes descargarlo aqu\u00ed ) incluye ejemplos de sistemas cliente/servidor programados utilizando TLS y DTLS mediante el uso de la biblioteca WolfSSL. Estos c\u00f3digos est\u00e1n dise\u00f1ados para ejecutarse exclusivamente en un sistema Linux, y requieren la instalaci\u00f3n de los paquetes de desarrollo WolfSSL. Para realizar la instalaci\u00f3n, ejecuta en tu m\u00e1quina virtual (esta l\u00ednea podr\u00eda cambiar si usas otra distribuci\u00f3n de Linux, en cuyo caso deber\u00e1s buscar los paquetes equivalentes): sudo apt-get install libwolfssl-dev libwolfssl24 Una vez hecho esto, prueba a realizar la compilaci\u00f3n tanto del ejemplo TLS como DTLS utilizando la orden make en el directorio correspondiente. Si todo ha ido bien, puedes continuar con el an\u00e1lisis de los c\u00f3digos en la siguiente secci\u00f3n.","title":"Contenido del paquete proporcionado y setup b\u00e1sico"},{"location":"RPI-II/P3/#clienteservidor-tls-ejemplo-basico-en-host","text":"","title":"Cliente/servidor TLS. Ejemplo b\u00e1sico en host"},{"location":"RPI-II/P3/#servidor-tls","text":"Analizaremos en primer lugar el c\u00f3digo b\u00e1sico del servidor TLS. Para ello, observa el contenido del fchero tls/server-tls.c .","title":"Servidor TLS"},{"location":"RPI-II/P3/#cabeceras-y-constantes","text":"El uso de WolfSSL requiere la inclusi\u00f3n de dos cabeceras b\u00e1sicas: #include <wolfssl/options.h> #include <wolfssl/ssl.h> Adem\u00e1s, ya que ser\u00e1n necesarios en el desarrollo, definiremos las rutas al certificado (clave p\u00fablica) del servidor y su clave privada: #define CERT_FILE \"../certs/server-cert.pem\" #define KEY_FILE \"../certs/server-key.pem\" Observa adem\u00e1s que el puerto de escucha del servidor ser\u00e1 el 11111 .","title":"Cabeceras y constantes"},{"location":"RPI-II/P3/#objetos-basicos-wolfssl-contexto-y-objeto-ssl","text":"Definiremos dos objetos b\u00e1sicos que se utilizar\u00e1n de forma recurrente en el c\u00f3digo: WOLFSSL_CTX* ctx; WOLFSSL* ssl; El contexto ( ctx ) incluye valores globales para cada conexi\u00f3n SSL, incluyendo informaci\u00f3n sobre certificados. Es posible utilizar un mismo contexto para m\u00faltiples conexiones, siempre que compartan caracter\u00edsticas. Para crear un nuevo contexto, utilizaremos la funci\u00f3n wolfSSL_CTX_new como sigue: /* Create and initialize WOLFSSL_CTX */ if ((ctx = wolfSSL_CTX_new(wolfTLSv1_2_server_method())) == NULL) { fprintf(stderr, \"ERROR: failed to create WOLFSSL_CTX\\n\"); return -1; } El argumento proporcionado incluye informaci\u00f3n sobre la versi\u00f3n de protocolo a utilizar. Actualmente, WolfSSL soporta SSL 3.0, TLS 1.1, TLS 1.2, DTLS 1.0 y DTLS 1.2. En este caso, para la parte cliente, las funciones a utilizar como argumento ser\u00edan: wolfSSLv3_server_method(); // SSLv3 wolfTLSv1_server_method(); // TLSv1 wolfTLSv1_1_server_method(); // TLSv1.1 wolfTLSv1_2_server_method(); // TLSv1.2 wolfDTLSv1_server_method(); // DTLS wolfDTLSv1_2_server_method(); // DTLS 1.2 En segundo lugar, es necesario cargar nuestra CA (Autoridad Certificadora) en el contexto, para que cualquier cliente pueda verificar, en el momento de su conexi\u00f3n, la identidad del sevidor. Para ello, usamos la funci\u00f3n wolfSSL_CTX_use_certificate_file de la siguiente manera: /* Load server certificates into WOLFSSL_CTX */ if (wolfSSL_CTX_use_certificate_file(ctx, CERT_FILE, SSL_FILETYPE_PEM) != SSL_SUCCESS) { fprintf(stderr, \"ERROR: failed to load %s, please check the file.\\n\", CERT_FILE); return -1; } Del mismo modo, el servidor deber\u00e1 incluir su clave privada en formato PEM: /* Load server key into WOLFSSL_CTX */ if (wolfSSL_CTX_use_PrivateKey_file(ctx, KEY_FILE, SSL_FILETYPE_PEM) != SSL_SUCCESS) { fprintf(stderr, \"ERROR: failed to load %s, please check the file.\\n\", KEY_FILE); return -1; } A continuaci\u00f3n, observa como el c\u00f3digo de escucha y aceptaci\u00f3n de conexiones entrantes no difier de cualquier c\u00f3digo que hayas desarrollado previamente para aceptar conexiones entrantes TCP ( bind , + listen + accept ). Justo tras la conexi\u00f3n ( accept ), resulta necesario crear un nuevo objeto SSL, as\u00ed como asociar el descriptor de socket con la nueva sesi\u00f3n (conexi\u00f3n) TLS: /* Create a WOLFSSL object */ if ((ssl = wolfSSL_new(ctx)) == NULL) { fprintf(stderr, \"ERROR: failed to create WOLFSSL object\\n\"); return -1; } /* Attach wolfSSL to the socket */ wolfSSL_set_fd(ssl, connd); /* Establish TLS connection */ ret = wolfSSL_accept(ssl); if (ret != SSL_SUCCESS) { fprintf(stderr, \"wolfSSL_accept error = %d\\n\", wolfSSL_get_error(ssl, ret)); return -1; } A partir de este punto, podemos enviar y recibir datos a trav\u00e9s del socket (y por tanto de la conexi\u00f3n TLS) de forma muy similar a como lo hacemos con el enfoque cl\u00e1sico. As\u00ed, para recibir datos: if (wolfSSL_read(ssl, buff, sizeof(buff)-1) == -1) { fprintf(stderr, \"ERROR: failed to read\\n\"); return -1; } Y para enviar datos de vuelta: /* Reply back to the client */ if (wolfSSL_write(ssl, buff, len) != len) { fprintf(stderr, \"ERROR: failed to write\\n\"); return -1; } Por \u00faltimo, finalizaremos la conexi\u00f3n con la invocaci\u00f3n de la funci\u00f3n wolfSSL_free(ssl) . Note El cliente proporcionado sigue una estrategia de implementaci\u00f3n similar. Compara ambos c\u00f3digos (cliente y servidor) y aseg\u00farate de entender las diferencias entre ellos. Tarea entregable Compila y ejecuta el sistema cliente/servidor TLS y obt\u00e9n capturas de tr\u00e1fico tanto de las fases de establecimiento de conexi\u00f3n como de las fases de transferencia de datos. En base a lo aprendido en las clases de teor\u00eda y la documentaci\u00f3n adicional sobre TLS y wolfSSL, redacta un documento con aquellas observaciones que consideres relevantes.","title":"Objetos b\u00e1sicos WolfSSL. Contexto y objeto SSL"},{"location":"RPI-II/P3/#clienteservidor-dtls-ejemplo-basico-en-host","text":"El desarrollo de un sistema b\u00e1sico cliente/servidor con soporte DTLS utilizando WolfSSL es muy similar al visto anteriormente para TLS. Como detalle adicional, la inicializaci\u00f3n de la infraestructura debe realizarse indicando el soporte para DTLS en sus versiones 1.0 o 1.2: wolfDTLSv1_client_method(); // DTLS 1.0 wolfDTLSv1_2_client_method(); // DTLS 1.2 El resto del c\u00f3digo sigue una filosof\u00eda similar a TLS, adaptado, obviamente, a las caracter\u00edsticas de UDP (tipo de socket, ausencia de conexi\u00f3n, etc.), por lo que se deja como ejercicio su an\u00e1lisis y ejecuci\u00f3n. Tarea entregable Analiza, compila y ejecuta los c\u00f3digos correspondientes al sistema cliente/servidor DTLS. Realiza capturas de tr\u00e1fico y comp\u00e1ralas, paquete a paquete, con las generadas para un patr\u00f3n de tr\u00e1fico similar en el caso de TLS. Incide en sus similitudes y diferencias, tanto a nivel de handshake como de transferencia de datos. Observa, en este \u00faltimo caso, la aparici\u00f3n de nuevos campos de encabezado en los env\u00edos de datos DTLS. \u00bfCu\u00e1l/cu\u00e1les son esos campos y por qu\u00e9 aparecen? Realiza una comparativa del tr\u00e1fico total generado en ambos casos para exactamente la misma cantidad de datos transferidos.","title":"Cliente/servidor DTLS. Ejemplo b\u00e1sico en host"},{"location":"RPI-II/P3/#tls-en-el-esp32-el-componente-esp-tls","text":"ESP-IDF proporciona un componente (ESP-TLS) que ofrece una interfaz (API) simplificada para acceder a funcionalidad b\u00e1sica TLS. A\u00fan as\u00ed, ofrece una funcionalidad suficientemente amplia como para implementar casos de uso comunes en entornos IoT. La API de ESP-TLS es sencilla,y se basa en el uso de cuatro funciones b\u00e1sicas:","title":"TLS en el ESP32. El componente ESP-TLS"},{"location":"RPI-II/P3/#establecimiento-de-conexion-tls-esp_tls_conn_new","text":"Prototipo: esp_tls_t *esp_tls_conn_new(const char *hostname, int hostlen, int port, constesp_tls_cfg_t *cfg) Descripci\u00f3n: Crea una nueva conexi\u00f3n TLS/SSL bloqueante, estableciendo dicha conexi\u00f3n contra un servidor establecido. Par\u00e1metros: hostname : Identificaci\u00f3n del host. hostlen : Longitud del par\u00e1metro hostname . port : Puerto de conexi\u00f3n con el host. cfg : Configuraci\u00f3n de la conexi\u00f3n TLS. Valor de retorno: Puntero a esp_tls_t (manejador de la conexi\u00f3n). Devuelve NULL si se produce un error en la conexi\u00f3n.","title":"Establecimiento de conexi\u00f3n TLS (esp_tls_conn_new())"},{"location":"RPI-II/P3/#destruccion-de-conexion-tls-esp_tls_conn_delete","text":"void esp_tls_conn_delete(esp_tls_t *tls) Descripci\u00f3n: Cierra la conexi\u00f3n TLS/SSL. Par\u00e1metros: tls : Manejador de la conexi\u00f3n.","title":"Destrucci\u00f3n de conexi\u00f3n TLS (esp_tls_conn_delete())"},{"location":"RPI-II/P3/#escritura-de-datos-esp_tls_conn_read","text":"static ssize_t esp_tls_conn_write(esp_tls_t *tls, const void *data, size_t datalen) Descripci\u00f3n: Escribe en la conexi\u00f3n TLS/SSL indicada el contenido del buffer data . Par\u00e1metros: tls : Manejador de la conexi\u00f3n. data : Buffer de env\u00edo. datalen : Longitud del buffer de env\u00edo (o n\u00famero m\u00e1ximo de bytes a escribir). Valor de retorno: >=0 : \u00e9xito en el env\u00edo. N\u00famero de bytes efectivamente enviados. <0 : error en el env\u00edo.","title":"Escritura de datos (esp_tls_conn_read())"},{"location":"RPI-II/P3/#lectura-de-datos-esp_tls_conn_read","text":"static ssize_t esp_tls_conn_read(esp_tls_t *tls, void *data, size_t datalen) Descripci\u00f3n: Lee desde la conexi\u00f3n TLS/SSL indicada hacia el buffer data . Par\u00e1metros: tls : Manejador de la conexi\u00f3n. data : Buffer de recepci\u00f3n. datalen : Longitud del buffer de recepci\u00f3n (o n\u00famero m\u00e1ximo de bytes a leer). Valor de retorno: >0 : \u00e9xito en la recepci\u00f3n. N\u00famero de bytes efectivamente le\u00eddos. =0 : error en la recepci\u00f3n. La conexi\u00f3n se cerr\u00f3. <0 : error en la recepci\u00f3n.","title":"Lectura de datos (esp_tls_conn_read())"},{"location":"RPI-II/P3/#estructura-basica-de-un-cliente-tcp-usando-esp-idf","text":"Un cliente TCP implementado sobre ESP-IDF para dar soporte TLS, requiere ciertas modificaciones con respecto a la versi\u00f3n sin TLS. De hecho, el uso de ESP-IDF simplifica el c\u00f3digo del cliente (puedes compararlo con tus clientes TCP desarrollados en sesiones anteriores). La estructura b\u00e1sica resultar\u00eda: /// Includes anteriores. #include \"esp_tls.h\" // Puede tomarse desde menuconfig. #define HOST_IP_ADDR DIRECCION_DE_HOST #define PORT PUERTO static const char *payload = \"Hola, mundo via TLS\"; // ... static void tls_client_task( void *pvParameters ) { // ... // Configuraci\u00f3n de ESP-TLS (por defecto). esp_tls_cfg_t cfg = { }; // Creaci\u00f3n de conexi\u00f3n. struct esp_tls *tls = esp_tls_conn_new( HOST_IP_ADDR, longitud, PORT, &cfg); // Chequeo de errores. // ... // Env\u00edo de datos. ret = esp_tls_conn_write(tls, payload, strlen(payload)); // Chequeo de errores. // ... // Lectura de datos ret = esp_tls_conn_read(tls, (char *)rx_buffer, 128); // Chequeo de errores. // ... // Destrucci\u00f3n de la conexi\u00f3n esp_tls_conn_delete( tls ); } void app_main( void ) { // ... } Observa como, efectivamente, el c\u00f3digo del cliente se simplifica en gran medida con respecto a tu cliente TCP original. Toma el c\u00f3digo del proyecto que utilizaste para desarrollar tu cliente TCP original y, siguiendo las anteriores directivas, adapta la \u00fanica tarea a crear (por ejemplo, puede recibir el nombre tls_client_task ) para que realice un env\u00edo y recepci\u00f3n de datos (una cadena) al servidor TLS que probaste en el host . Puedes valerte para ello de la base del ejemplo examples/protocols/https_request , obviamente adaptando la totalidad de su c\u00f3digo para que se comporte como un simple cliente echo . Note Compila y ejecuta el cliente TLS en el ESP32, y consigue que interact\u00fae con el servidor TLS que probaste anteriormente en el host . Comprueba que, efectivamente, los datos se transfieren cifrados entre ambos extremos, y que el intercambio de paquetes es similar al que observaste entre cliente y servidor en el host . Tarea entregable Adapta tu sistema cliente/servidor TCP desarrollado en la anterior pr\u00e1ctica para que se ejecute sobre el binomio host /ESP32 utlizando TLS. Entrega el c\u00f3digo generado junto con una captura de tr\u00e1fico que demuestre su correcto funcionamiento.","title":"Estructura b\u00e1sica de un cliente TCP usando ESP-IDF"},{"location":"RPI-II/P4/","text":"Pr\u00e1ctica 4. Protocolos b\u00e1sicos. HTTP y Websocket","title":"Pr\u00e1ctica 4"},{"location":"RPI-II/P4/#practica-4-protocolos-basicos-http-y-websocket","text":"","title":"Pr\u00e1ctica 4. Protocolos b\u00e1sicos. HTTP y Websocket"},{"location":"RPI-II/P5/","text":"Pr\u00e1ctica 5. Representaci\u00f3n de la informaci\u00f3n. CBOR","title":"Pr\u00e1ctica 5"},{"location":"RPI-II/P5/#practica-5-representacion-de-la-informacion-cbor","text":"","title":"Pr\u00e1ctica 5. Representaci\u00f3n de la informaci\u00f3n. CBOR"},{"location":"RPI-II/P6/","text":"Pr\u00e1ctica 6. El protocolo MQTT","title":"Pr\u00e1ctica 6"},{"location":"RPI-II/P6/#practica-6-el-protocolo-mqtt","text":"","title":"Pr\u00e1ctica 6. El protocolo MQTT"},{"location":"RPI-II/P7/","text":"Pr\u00e1ctica 7. El protocolo CoAP","title":"Pr\u00e1ctica 7"},{"location":"RPI-II/P7/#practica-7-el-protocolo-coap","text":"","title":"Pr\u00e1ctica 7. El protocolo CoAP"},{"location":"RPI-II/P8/","text":"Pr\u00e1ctica 8. El protocolo LWM2M","title":"Pr\u00e1ctica 8"},{"location":"RPI-II/P8/#practica-8-el-protocolo-lwm2m","text":"","title":"Pr\u00e1ctica 8. El protocolo LWM2M"},{"location":"RPI-II/P9/","text":"Pr\u00e1ctica 9. Node-RED","title":"Pr\u00e1ctica 9"},{"location":"RPI-II/P9/#practica-9-node-red","text":"","title":"Pr\u00e1ctica 9. Node-RED"}]}