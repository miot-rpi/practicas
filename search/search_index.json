{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Redes, Protocolos e Interfaces Calendario RPI-I Pr\u00e1ctica D\u00eda T\u00edtulo 1 05/10 Introducci\u00f3n al entorno de desarrollo 12/10 FESTIVO 2 19/10 WiFi. Conceptos b\u00e1sicos 3 26/10 WiFi. Conceptos avanzados (WiFi Mesh, provisionamiento y ahorro de energ\u00eda) 02/11 FESTIVO 09/11 FESTIVO 4 16/11 Bluetooth Low Energy 5 23/11 BLE Mesh 6 30/11 6LowPAN (Simulaci\u00f3n) 07/12 FESTIVO 7 14/12 6LowPAN (SensorTag) 8 21/12 LoRA Calendario RPI-II Pr\u00e1ctica D\u00eda T\u00edtulo 1 01/10 Sockets TCP/UDP (Linux) 2 08/10 Sockets TCP/UDP (ESP32) 3 15/10 TLS y DTLS 4 22/10 Websockets 5 29/11 Interfaces REST. Representaci\u00f3n de la informaci\u00f3n. CBOR 6 05/11 MQTT (I) 6 12/11 MQTT (II) 7 19/11 CoAP 8 26/11 LWM2M (I) 8 03/12 LWM2M (II) 9 10/12 Node-RED 10 17/12 Entornos Cloud / Frameworks IoT","title":"Calendario"},{"location":"#redes-protocolos-e-interfaces","text":"","title":"Redes, Protocolos e Interfaces"},{"location":"#calendario-rpi-i","text":"Pr\u00e1ctica D\u00eda T\u00edtulo 1 05/10 Introducci\u00f3n al entorno de desarrollo 12/10 FESTIVO 2 19/10 WiFi. Conceptos b\u00e1sicos 3 26/10 WiFi. Conceptos avanzados (WiFi Mesh, provisionamiento y ahorro de energ\u00eda) 02/11 FESTIVO 09/11 FESTIVO 4 16/11 Bluetooth Low Energy 5 23/11 BLE Mesh 6 30/11 6LowPAN (Simulaci\u00f3n) 07/12 FESTIVO 7 14/12 6LowPAN (SensorTag) 8 21/12 LoRA","title":"Calendario RPI-I"},{"location":"#calendario-rpi-ii","text":"Pr\u00e1ctica D\u00eda T\u00edtulo 1 01/10 Sockets TCP/UDP (Linux) 2 08/10 Sockets TCP/UDP (ESP32) 3 15/10 TLS y DTLS 4 22/10 Websockets 5 29/11 Interfaces REST. Representaci\u00f3n de la informaci\u00f3n. CBOR 6 05/11 MQTT (I) 6 12/11 MQTT (II) 7 19/11 CoAP 8 26/11 LWM2M (I) 8 03/12 LWM2M (II) 9 10/12 Node-RED 10 17/12 Entornos Cloud / Frameworks IoT","title":"Calendario RPI-II"},{"location":"RPI-I/P1/","text":"Pr\u00e1ctica 1. Introducci\u00f3n al entorno de desarrollo ESP-IDF Objetivos Conocer dos entornos b\u00e1sicos de desarrollo para el ESP32: uno basado en l\u00ednea de comandos, y otro en la herramienta PlatformIO Ser capaz de compilar, flashear y monitorizar proyectos sencillos basados en ESP-IDF Entender el funcionamiento b\u00e1sico de una aplicaci\u00f3n ESP-IDF que haga uso de las capacidades WiFi del ESP32 Personalizar variables de configuraci\u00f3n de proyectos ESP-IDF Responder a eventos b\u00e1sicos de red en ESP-IDF Introducci\u00f3n ESP-IDF ( Espressif IoT Development Framework ) es el entorno de desarrollo oficial de Espressif para los SoCs ESP32 y ESP32-S. Este entorno de desarrollo y conjunto de herramientas permite desarrollar firmwares eficientes para dichas placas utilizando las interfaces de comunicaci\u00f3n WiFi y Bluetooth, as\u00ed como gestionar m\u00faltiples caracter\u00edsticas de los SoCs que iremos desgranando en futuras pr\u00e1cticas. ESP-IDF utiliza como base FreeRTOS para la construcci\u00f3n del firmware , aunque a\u00f1ade multitud de componentes para ofrecer un soporte de mayor nivel para la interacci\u00f3n con protocolos de comunicaci\u00f3n de bajo y alto nivel, la mayor\u00eda de ellos enfocados al \u00e1mbito de comunicaci\u00f3n en Internet de las Cosas. La presente pr\u00e1ctica pretende ser una introducci\u00f3n b\u00e1sica a la puesta en marcha del entorno de desarrollo ESP-IDF sobre un sistema operativo Linux, ofreciendo dos alternativas b\u00e1sicas: l\u00ednea de comandos y un plugin espec\u00edfico para VSCode (PlatformIO). Adem\u00e1s, veremos de forma superficial la estructura b\u00e1sica de un programa sencillo desarrollado usando ESP-IDF, as\u00ed como ejemplos b\u00e1sicos para la puesta en marcha de la interfaz WiFi sobre una placa ESP32. Recuerda La presente pr\u00e1ctica no tiene tarea entregable asociada m\u00e1s all\u00e1 de una memoria justificativa del trabajo realizado. Por tanto, recuerda apuntar y reportar los pasos y tareas realizadas durante su desarrollo para plasmarlas en una breve memoria entregable final. Flujo de trabajo. Entorno basado en l\u00ednea de comandos Instalaci\u00f3n de prerequisitos ESP-IDF requiere ciertos paquetes software instalados en el sistema para poder desarrollar los c\u00f3digos y descargarlos sobre el ESP32. Se muestran a continuaci\u00f3n los requisitos y modo de instalaci\u00f3n para m\u00e1quinas Ubuntu/Debian (como la m\u00e1quina virtual del curso), aunque la documentaci\u00f3n de ESP-IDF incluye instrucciones para otras distribuciones y sistemas operativos, incluyendo Windows y MacOS. En tu m\u00e1quina virtual, instala los paquetes necesarios utilizando (como superusuario): sudo apt-get install git wget flex bison gperf python python3-pip python-setuptools cmake ninja-build ccache libffi-dev libssl-dev dfu-util Adem\u00e1s, es necesario, en todo caso, que el usuario que est\u00e9s utilizando pertenezca al grupo dialout (puedes editar el fichero /etc/group a\u00f1adiendo a tu usuario a la l\u00ednea que indica el grupo correspondiente, e iniciando de nuevo tu sesi\u00f3n). Instala y configura Python 3 para su uso por defecto en tu distribuci\u00f3n: sudo apt-get install python3 python3-pip python3-setuptools sudo update-alternatives --install /usr/bin/python python /usr/bin/python3 10 Obtenci\u00f3n de ESP-IDF Utilizaremos las versiones de ESP-IDF a obtener directamente desde el repositorio Github oficial (concretamente, en su versi\u00f3n 4.1). Para ello, ejecuta desde tu directorio de inicio: mkdir -p ~/esp cd ~/esp git clone --recursive https://github.com/espressif/esp-idf.git cd esp-idf git fetch git checkout release/v4.1 git pull git submodule update --init --recursive Instalaci\u00f3n de herramientas adicionales Desde el directorio esp-idf , ejecuta el script install.sh para instalar las herramientas ( toolchain ) espec\u00edficas para tu versi\u00f3n: sh install.sh Preparaci\u00f3n del entorno Tras el inicio de cada sesi\u00f3n, deber\u00e1s establecer valores correctos para ciertas variables de entorno. Afortunadamente, se proporciona un script ( export.sh ) que te permitir\u00e1 establecerlas de forma autom\u00e1tica: . export.sh Puedes a\u00f1adir esta l\u00ednea en cualquier fichero de inicio de sesi\u00f3n para no tener que ejecutar el comando cada vez. En cualquier caso, en este punto deber\u00edas tener acceso a un programa llamado idf.py , a trav\u00e9s del cual gestionaremos el flujo de trabajo. Compru\u00e9balo y observa si la version de IDF con la que est\u00e1s trabajando es efectivamente la 4.1 (el n\u00famero de subversi\u00f3n podr\u00eda variar en tu salida): $ idf.py --version ESP-IDF v4.1-332-g7b7c64107 Preparaci\u00f3n del proyecto En esta primera parte, nos basaremos en un ejemplo sencillo de c\u00f3digo desarrollado en base a ESP-IDF. No es el objetivo de esta pr\u00e1ctica analizar en detalle los la estructura de dicho c\u00f3digo (al menos de momento), sino utilizarlo para ilustrar el flujo de trabajo t\u00edpico en un proyecto ESP-IDF. Recuerda Tras la ejecuci\u00f3n del script export.sh , tendr\u00e1s definida una variable de entorno llamada IDF_PATH . Consulta su valor y comprueba que apunta, efectivamente, al directorio de instalaci\u00f3n de IDF. La utilizaremos a partir de ahora para referirnos a \u00e9l. Para empezar, toma el ejemplo hello_world proporcionado como parte de la instalaci\u00f3n b\u00e1sica de IDF, y c\u00f3pialo en cualquier directorio del sistema de ficheros: cp -R $IDF_PATH/examples/get-started/hello_world $HOME/ cd $HOME/hello_world Compilaci\u00f3n El proceso de compilaci\u00f3n b\u00e1sico utiliza el script idf.py : idf.py build Si todo ha ido bien, en el directorio build se habr\u00e1n generado los objetos y binarios listos para ser flasheados en el ESP32. Flasheado El proceso de flasheado b\u00e1sico utiliza el script idf.py : idf.py -p PUERTO flash En este punto, el ESP32 debe estar conectado utilizando el cable microUSB, y si est\u00e1s trabajando en una m\u00e1quina virtual, debe haberse hecho visible a la misma (por ejemplo, en VirtualBox, a trav\u00e9s del men\u00fa Dispositivos->USB->Silicon Labs USB to UART Bridge Controller ). En todo caso, la salida del comando dmesg tras la conexi\u00f3n del dispositivo te proporcionar\u00e1 informaci\u00f3n sobre el PUERTO que debes utilizar en el proceso de flasheado y montorizaci\u00f3n posterior. Monitorizaci\u00f3n Si todo ha ido bien, el proceso de monitorizaci\u00f3n nos permitir\u00e1 observar la salida del programa que tenemos ejecutando en la placa. Para ello, de nuevo, usamos el script idf.py : idf.py -p PUERTO monitor Nota Comprueba que, efectivamente, puedes realizar el proceso de compilaci\u00f3n, flasheado y monitorizaci\u00f3n del programa sobre la placa ESP32. Recuerda que el bot\u00f3n EN , justo al lado del conector microUSB, forzar\u00e1 un reseteo de la misma. Flujo de trabajo. Entorno basado en PlatformIO El anterior flujo de trabajo puede tambi\u00e9n desarrollarse desde otros entornos de desarrollo. En nuestro caso, se muestran a continuaci\u00f3n los pasos principales para la integraci\u00f3n de ESP-IDF con VSCode, utilizando la plataforma PlatformIO . Las m\u00e1quinas virtuales proporcionadas en el curso ya tienen instalada la \u00faltima versi\u00f3n de PlatformIO y ESP-IDF, por lo que se refiere al lector a la documentaci\u00f3n oficial de PlatformIO para llevar a cabo dicha instalaci\u00f3n en otros sistemas operativos. Configuraci\u00f3n de un proyecto La forma m\u00e1s sencilla de crear un nuevo proyecto consiste en pulsar el bot\u00f3n PlatformIO Home situado en la parte inferior de la pantalla: A continuaci\u00f3n, clica en New Project y selecciona como placa de desarrollo ESP DevkitC o Espressif ESP32 Dev Module . Selecciona ESP-IDF como framework de desarrollo para el proyecto: Adici\u00f3n de ficheros a un proyecto Crea un nuevo fichero main.c (si no existe) en el directorio src de tu proyecto, o modifica el que ya existe utilizando, por ejemplo, el siguiente c\u00f3digo: #include <string.h> #include \"freertos/FreeRTOS.h\" #include \"freertos/task.h\" #include \"esp_system.h\" #include \"esp_wifi.h\" #include \"esp_event.h\" #include \"esp_log.h\" #include \"nvs_flash.h\" #include \"lwip/err.h\" #include \"lwip/sys.h\" #define EXAMPLE_ESP_WIFI_SSID \"mywifissid\" #define EXAMPLE_ESP_WIFI_PASS \"mywifipass\" #define EXAMPLE_MAX_STA_CONN (3) static const char *TAG = \"wifi softAP\"; static void wifi_event_handler(void* arg, esp_event_base_t event_base, int32_t event_id, void* event_data) { if (event_id == WIFI_EVENT_AP_STACONNECTED) { wifi_event_ap_staconnected_t* event = (wifi_event_ap_staconnected_t*) event_data; ESP_LOGI(TAG, \"station \"MACSTR\" join, AID=%d\", MAC2STR(event->mac), event->aid); } else if (event_id == WIFI_EVENT_AP_STADISCONNECTED) { wifi_event_ap_stadisconnected_t* event = (wifi_event_ap_stadisconnected_t*) event_data; ESP_LOGI(TAG, \"station \"MACSTR\" leave, AID=%d\", MAC2STR(event->mac), event->aid); } } void wifi_init_softap() { tcpip_adapter_init(); ESP_ERROR_CHECK(esp_event_loop_create_default()); wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT(); ESP_ERROR_CHECK(esp_wifi_init(&cfg)); ESP_ERROR_CHECK(esp_event_handler_register(WIFI_EVENT, ESP_EVENT_ANY_ID, &wifi_event_handler, NULL)); wifi_config_t wifi_config = { .ap = { .ssid = EXAMPLE_ESP_WIFI_SSID, .ssid_len = strlen(EXAMPLE_ESP_WIFI_SSID), .password = EXAMPLE_ESP_WIFI_PASS, .max_connection = EXAMPLE_MAX_STA_CONN, .authmode = WIFI_AUTH_WPA_WPA2_PSK }, }; if (strlen(EXAMPLE_ESP_WIFI_PASS) == 0) { wifi_config.ap.authmode = WIFI_AUTH_OPEN; } ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_AP)); ESP_ERROR_CHECK(esp_wifi_set_config(ESP_IF_WIFI_AP, &wifi_config)); ESP_ERROR_CHECK(esp_wifi_start()); ESP_LOGI(TAG, \"wifi_init_softap finished. SSID:%s password:%s\", EXAMPLE_ESP_WIFI_SSID, EXAMPLE_ESP_WIFI_PASS); } void app_main() { //Initialize NVS esp_err_t ret = nvs_flash_init(); if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) { ESP_ERROR_CHECK(nvs_flash_erase()); ret = nvs_flash_init(); } ESP_ERROR_CHECK(ret); ESP_LOGI(TAG, \"ESP_WIFI_MODE_AP\"); wifi_init_softap(); } De momento no analizaremos el funcionamiento del c\u00f3digo (lo haremos m\u00e1s adelante) pero b\u00e1sicamente establece un Punto de Acceso inal\u00e1mbrico abierto a conexiones autenticadas v\u00eda WPA2. Compilaci\u00f3n del proyecto Para compilar del proyecto, despliega la paleta de comandos (men\u00fa View -> Command Palette ) y ejecuta la orden PlatformIO: Build desde ella. Tambi\u00e9n puedes presionar el bot\u00f3n Build (con forma de check ) en la barra inferior de PlatformIO: Si todo ha ido bien, deber\u00edas ver un mensaje final similar al siguiente en la terminal del sistema: Flasheado del proyecto Para llevar a cabo el proceso de subida ( upload ) del proyecto a la placa, podemos utilizar la orden PlatformIO: Upload a trav\u00e9s de la paleta de comandos, o bien presionar el bot\u00f3n correspondiente en la barra inferior (con un s\u00edmbolo de flecha a izquierda): Monitorizaci\u00f3n del proyecto Por \u00faltimo, podemos monitorizar el proyecto utilizando la orden PlatformIO: Monitor de la paleta de comandos o a trav\u00e9s de la barra inferior, usando el bot\u00f3n con un enchufe como s\u00edmbolo: An\u00e1lisis de un proyecto sencillo ( Hola, mundo ) en ESP-IDF Nota Las siguientes tareas pueden realizarse desde l\u00ednea de comandos o utilizando PlatformIO. Para familiarizarse con en entorno de bajo nivel, sin embargo, se sugiere el uso de l\u00ednea de comandos. Observa la estructura general del directorio hello_world que compilaste anteriormente. Espec\u00edficamente, nos interesar\u00e1 inspeccionar la estructura b\u00e1sica de un programa principal para ESP-IDF, en este caso hello_world_main.c . #include <stdio.h> #include \"sdkconfig.h\" #include \"freertos/FreeRTOS.h\" #include \"freertos/task.h\" #include \"esp_system.h\" #include \"esp_spi_flash.h\" void app_main(void) { printf(\"Hello world!\\n\"); /* Print chip information */ esp_chip_info_t chip_info; esp_chip_info(&chip_info); printf(\"This is %s chip with %d CPU cores, WiFi%s%s, \", CONFIG_IDF_TARGET, chip_info.cores, (chip_info.features & CHIP_FEATURE_BT) ? \"/BT\" : \"\", (chip_info.features & CHIP_FEATURE_BLE) ? \"/BLE\" : \"\"); printf(\"silicon revision %d, \", chip_info.revision); printf(\"%dMB %s flash\\n\", spi_flash_get_chip_size() / (1024 * 1024), (chip_info.features & CHIP_FEATURE_EMB_FLASH) ? \"embedded\" : \"external\"); printf(\"Minimum free heap size: %d bytes\\n\", esp_get_minimum_free_heap_size()); for (int i = 10; i >= 0; i--) { printf(\"Restarting in %d seconds...\\n\", i); vTaskDelay(1000 / portTICK_PERIOD_MS); } printf(\"Restarting now.\\n\"); fflush(stdout); esp_restart(); } A alto nivel, la funci\u00f3n app_main es el punto de entrada a todo programa desarrollado usando ESP-IDF. De modo m\u00e1s espec\u00edfico, tras la carga del sistema , la llamada tarea principal ( main task ) ejecuta el c\u00f3digo proporcionado por el usuario e implementado en la funci\u00f3n app_main . Tanto el tama\u00f1o de pila asignado como la prioridad de esta tarea puede ser configuradas por el desarrollador a trav\u00e9s del sistema de configuraci\u00f3n de ESP-IDF (lo veremos m\u00e1s adelante). Normalmente, esta funci\u00f3n se utiliza para llevar a cabo tareas iniciales de configuraci\u00f3n o para crear y lanzar a ejecuci\u00f3n otras tareas. De cualquier modo (como es el caso), se puede implementar cualquier funcionalidad dentro de la funci\u00f3n app_main . En este ejemplo, se muestra en primer lugar informaci\u00f3n gen\u00e9rica sobre el SoC que est\u00e1 ejecutando el firmware : /* Print chip information */ esp_chip_info_t chip_info; esp_chip_info(&chip_info); printf(\"This is %s chip with %d CPU cores, WiFi%s%s, \", CONFIG_IDF_TARGET, chip_info.cores, (chip_info.features & CHIP_FEATURE_BT) ? \"/BT\" : \"\", (chip_info.features & CHIP_FEATURE_BLE) ? \"/BLE\" : \"\"); printf(\"silicon revision %d, \", chip_info.revision); printf(\"%dMB %s flash\\n\", spi_flash_get_chip_size() / (1024 * 1024), (chip_info.features & CHIP_FEATURE_EMB_FLASH) ? \"embedded\" : \"external\"); printf(\"Minimum free heap size: %d bytes\\n\", esp_get_minimum_free_heap_size()); A continuaci\u00f3n, dentro de un bucle sencillo, el sistema muestra un mensaje y difiere la ejecuci\u00f3n de la tarea durante un per\u00edodo determinado de tiempo utilizando la funci\u00f3n vTaskDelay de FreeRTOS. Esta funci\u00f3n recibe el n\u00famero de ticks de reloj que se desea utilizar, por lo que el tiempo real que la tarea diferir\u00e1 su ejecuci\u00f3n depende de la duraci\u00f3n de dicho tick . Por ello, la constante portTIC_PERIOD_MS puede utilizarse para calcular dicho tiempo: for (int i = 10; i >= 0; i--) { printf(\"Restarting in %d seconds...\\n\", i); vTaskDelay(1000 / portTICK_PERIOD_MS); } Finalmente, la tarea reinicia el sistema tras la finalizaci\u00f3n de la tarea principal: printf(\"Restarting now.\\n\"); fflush(stdout); esp_restart(); Tarea Modifica el per\u00edodo de suspensi\u00f3n de la tarea para que sea mayor o menor, y comprueba que efectivamente esto modifica el comportamiento del firmware cargado. Modifica el programa para que se muestre tambi\u00e9n por pantalla si el SoC tiene capacidades WiFi y si incluye memoria FLASH (para ello, puedes consultar la siguiente p\u00e1gina ). Creaci\u00f3n de tareas El anterior proyecto puede replantearse para que no sea la tarea principal la que ejecute la l\u00f3gica del programa. Para ello, es necesario introducir brevemente la API b\u00e1sica para gesti\u00f3n (en nuestro caso, creaci\u00f3n) de tareas. Ver\u00e1s muchos m\u00e1s detalles sobre esta API en la asignatura ANIOT, por lo que no veremos aqu\u00ed m\u00e1s detalles de los estrictamente necesarios. La funci\u00f3n xTaskCreate (incluida en task.h ) permite la creaci\u00f3n de nuevas tareas: BaseType_t xTaskCreate( TaskFunction_t pvTaskCode, const char * const pcName, configSTACK_DEPTH_TYPE usStackDepth, void *pvParameters, UBaseType_t uxPriority, TaskHandle_t *pxCreatedTask ); Concretamente, crea una nueva tarea y la a\u00f1ade a la lista de tareas listas para ejecuci\u00f3n, recibiendo como par\u00e1metros: pvTaskCode : Puntero a la funci\u00f3n de entrada para la tarea. Las tareas suelen implementarse como un bucle infinito, y no deber\u00eda, en su cuerpo, retornar o simplemente finalizar abruptamente. En cambio, una tarea puede ser destruida externamente a trav\u00e9s de su manejador (\u00faltimo par\u00e1metro en la creaci\u00f3n), o internamente (desde el propio c\u00f3digo de la tarea), tal y como se muestra en el siguiente ejemplo extra\u00eddo directamente desde la documentaci\u00f3n de FreeRTOS: void vATaskFunction( void *pvParameters ) { for( ;; ) { -- Task application code here. -- } /* Tasks must not attempt to return from their implementing function or otherwise exit. In newer FreeRTOS port attempting to do so will result in an configASSERT() being called if it is defined. If it is necessary for a task to exit then have the task call vTaskDelete( NULL ) to ensure its exit is clean. */ vTaskDelete( NULL ); } pcName : Nombre (en forma de cadena) descriptivo de la tarea a ejecutar, t\u00edpicamente usado en tiempo de depuraci\u00f3n. usStackDepth : N\u00famero de palabras a alojar para utilizar como pila para la tarea. pvParameters : Par\u00e1metros a proporcionar a la funci\u00f3n de entrada para la tarea. uxPriority : Prioridad asignada a la tarea. pxCreatedTask : Manejador opcional para la tarea. As\u00ed, la funcionalidad del programa Hola, mundo que hemos analizado anteriormente, podr\u00eda reestrcturarse en base a una \u00fanica tarea: void hello_task(void *pvParameter) { printf(\"Hello world!\\n\"); for (int i = 10; i >= 0; i--) { printf(\"Restarting in %d seconds...\\n\", i); vTaskDelay(1000 / portTICK_RATE_MS); } printf(\"Restarting now.\\n\"); fflush(stdout); esp_restart(); } Que podr\u00eda ser creada desde la tarea principal: void app_main() { nvs_flash_init(); xTaskCreate( &hello_task, \"hello_task\", 2048, NULL, 5, NULL ); } Tarea Implementa una modificaci\u00f3n del programa hello_world que implemente y planifique dos tareas independientes con distinta funcionalidad (en este caso, es suficiente con mostrar por pantalla alg\u00fan mensaje) y distintos tiempos de suspensi\u00f3n. Comprueba que, efectivamente, ambas tareas se ejecutan concurrentemente. Personalizaci\u00f3n del proyecto ESP-IDF utiliza la biblioteca kconfiglib para proporcionar un sistema de configuracion de proyectos en tiempo de compilaci\u00f3n sencillo y extensible. Para ilustrar su funcionamiento, utilizaremos el ejemplo blink que puedes encontrar en la distribuci\u00f3n de ESP-IDF que has clonado anteriormente (copia el ejemplo en cualquier punto de tu jerarqu\u00eda de directorios antes de comenzar). Para configurar un proyecto ESP-IDF, simplemente utiliza la siguiente orden: idf.py menuconfig La ejecuci\u00f3n de la orden anterior te permitir\u00e1 navegar por un conjunto de opciones de car\u00e1cter general, que te permitir\u00e1n configurar las caracter\u00edsticas espec\u00edficas del proyecto a compilar (por ejemplo, seleccionando los componentes que deseas habilitar en la construcci\u00f3n del mismo). Tarea Navega por las opciones que aparecen en los men\u00fas de configuraci\u00f3n para familiarizarte con ellos. Los utilizar\u00e1s en futuras pr\u00e1cticas. En el proyecto blink , observa que una de las opciones del men\u00fa de navegaci\u00f3n, llamada Example configuration , incluye una opci\u00f3n llamada Blink GPIO number . M\u00e1s all\u00e1 de su funcionalidad (define el n\u00famero de pin GPIO a activar/desactivar para iluminar un LED), es de inter\u00e9s para nosotros el hecho de que esta opci\u00f3n de configuraci\u00f3n definir\u00e1 en tiempo de compilaci\u00f3n el valor de una constante (en este caso CONFIG_BLINK_GPIO ) que podemos utilizar directamente en cualquier fichero de nuestro proyecto. Nota Observa el uso que da el c\u00f3digo del proyecto blink a la constante CONFIG_BLINK_GPIO . Esta opci\u00f3n de configuraci\u00f3n no forma parte de las opciones por defecto de ESP-IDF, sino que ha sido a\u00f1adida por los desarrolladores del proyecto blink . Observa y estudia el formato y contenido del fichero main/Kconfig.projbuild que se proporciona como parte del fichero. En \u00e9l, se definen las caracter\u00edsticas (nombre, rango, valor por defecto y descripcion) de la opci\u00f3n de configuraci\u00f3n a definir. Tarea Modifica el proyecto hello_world para que defina dos opciones de configuraci\u00f3n que permitir\u00e1n definir el tiempo de espera de cada una de las dos tareas que hayas definido en tu anterior soluci\u00f3n. Haz uso de ellas en tu c\u00f3digo y comprueba que efectivamente su modificaci\u00f3n a trav\u00e9s del sistema de men\u00fas permite una personalizaci\u00f3n del comportamiento de tus c\u00f3digos. Gesti\u00f3n de redes WiFi. Ejemplo 1. Escaneado de redes WiFi A modo de ejemplo, y en preparaci\u00f3n para los c\u00f3digos con los que trabajaremos en futuras pr\u00e1cticas, vamos a analizar a continuaci\u00f3n un ejemplo concreto de firmware cuya tarea es el escaneado de redes inal\u00e1mbricas al alcance del ESP32, y su reporte a trav\u00e9s del puerto serie del mismo. Para cada red escaneada, se reportar\u00e1n sus caracter\u00edsticas principales. Tarea Compila, flashea y monitoriza el ejemplo scan situado en el directorio examples/wifi/scan . Recuerda copiarlo antes a cualquier otro directorio de tu home . Antes de compilarlo, modifica el n\u00famero m\u00e1ximo de redes a escanear a trav\u00e9s del men\u00fa de configuraci\u00f3n del ejemplo para ampliarlo a 20. Crea un punto de acceso WiFi con tu tel\u00e9fono m\u00f3vil y observa que, efectivamente, es escaneado por el ejemplo. Observa su funcionamiento. Realmente, el firmware simplemente escanea un subconjunto de las redes disponibles, reportando algunas de sus caracter\u00edsticas (por ejemplo, SSID, modo de autenticaci\u00f3n o canal primario). Tarea Analiza el c\u00f3digo de la funci\u00f3n wifi_scan (tarea principal). Espec\u00edficamente, c\u00e9ntrate en las l\u00edneas que permiten activar y configurar el escaneado de redes. Intenta entender el funcionamiento general del programa, consultando y apuntando el cometido de cada l\u00ednea, con especial inter\u00e9s a aquellas funciones con prefijo esp_wifi_* . Anota en la memoria entregable el cometido de cada una de ellas, consultando la documentaci\u00f3n oficial . Gesti\u00f3n de redes WiFi. Ejemplo 2. Gesti\u00f3n de eventos de red El segundo ejemplo consiste en la creaci\u00f3n de un firmware para conexi\u00f3n del ESP32 a un punto de acceso existente. Este ejemplo nos permitir\u00e1 observar, a grandes rasgos, el sistema de gesti\u00f3n de eventos en FreeRTOS/ESP-IDF, que estudiar\u00e1s en m\u00e1s detalle en ANIOT y que permite gestionar, entre otros, las respuestas a eventos de red, como por ejemplo la obtenci\u00f3n de direcci\u00f3n IP o la conexi\u00f3n exitosa a un punto de acceso. Tarea Compila, flashea y monitoriza el ejemplo station situado en el directorio examples/wifi/getting_started . Recuerda copiarlo antes a cualquier otro directorio de tu home . Antes de compilarlo, modifica el SSID de la red al que conectar\u00e1, as\u00ed como la contrase\u00f1a elegida (puedes usar el mismo punto de acceso que creaste anteriormente como objetivo de tu conexi\u00f3n) a trav\u00e9s del sistema de men\u00fas de configuraci\u00f3n. Observa su funcionamiento. El firmware simplemente inicializa el dispositivo en modo station (en contraposici\u00f3n al modo Access Point , que veremos en la pr\u00f3xima sesi\u00f3n), realizando una conexi\u00f3n al punto de acceso preconfigurado a trav\u00e9s del men\u00fa de configuraci\u00f3n. Analiza el c\u00f3digo de la funci\u00f3n wifi_init_sta . Esta funci\u00f3n, que implementa la tarea principal, se divide b\u00e1sicamente en dos partes: Gesti\u00f3n de eventos . Observa el mecanismo mediante el cual se registra y se asocia la recepci\u00f3n de un evento a la ejecuci\u00f3n de un manejador o funci\u00f3n determinada. Pregunta \u00bfQu\u00e9 eventos se asocian a la ejecuci\u00f3n de qu\u00e9 funci\u00f3n en el firmware que est\u00e1s estudiando? Configuraci\u00f3n de la conexi\u00f3n a un punto de acceso . La configuraci\u00f3n de la conexi\u00f3n se realiza a trav\u00e9s de los campos correspondientes de una estructura de tipo wifi_config_t . Observa los campos b\u00e1sicos que necesita, c\u00f3mo fuerza el uso de WPA2 y c\u00f3mo recoge los datos de conexi\u00f3n (SSID y contrase\u00f1a) a trav\u00e9s del sistema de configuraci\u00f3n. Observa tambi\u00e9n c\u00f3mo, una vez realizadas dichas personalizaciones, inicializa el sistema de comunicaci\u00f3n inal\u00e1mbrica a trav\u00e9s de esp_wifi_start() . Consulta la documentaci\u00f3n relativa a dichas funciones y anota en tu memoria entregable aquellos aspectos que consideres m\u00e1s relevantes. Tarea Modifica el firmware para que el handler de tratamiento de la obtenci\u00f3n de una direcci\u00f3n IP sea independiente del tratamiento del resto de eventos del sistema WiFi que ya se est\u00e1n considerando. Comprueba que, efectivamente sigue observ\u00e1ndose la salida asociada a dicho evento, aun cuando ambas funciones sean independientes. Entrega o a\u00f1ade a la memoria el c\u00f3digo modificado.","title":"Pr\u00e1ctica 1"},{"location":"RPI-I/P1/#practica-1-introduccion-al-entorno-de-desarrollo-esp-idf","text":"","title":"Pr\u00e1ctica 1. Introducci\u00f3n al entorno de desarrollo ESP-IDF"},{"location":"RPI-I/P1/#objetivos","text":"Conocer dos entornos b\u00e1sicos de desarrollo para el ESP32: uno basado en l\u00ednea de comandos, y otro en la herramienta PlatformIO Ser capaz de compilar, flashear y monitorizar proyectos sencillos basados en ESP-IDF Entender el funcionamiento b\u00e1sico de una aplicaci\u00f3n ESP-IDF que haga uso de las capacidades WiFi del ESP32 Personalizar variables de configuraci\u00f3n de proyectos ESP-IDF Responder a eventos b\u00e1sicos de red en ESP-IDF","title":"Objetivos"},{"location":"RPI-I/P1/#introduccion","text":"ESP-IDF ( Espressif IoT Development Framework ) es el entorno de desarrollo oficial de Espressif para los SoCs ESP32 y ESP32-S. Este entorno de desarrollo y conjunto de herramientas permite desarrollar firmwares eficientes para dichas placas utilizando las interfaces de comunicaci\u00f3n WiFi y Bluetooth, as\u00ed como gestionar m\u00faltiples caracter\u00edsticas de los SoCs que iremos desgranando en futuras pr\u00e1cticas. ESP-IDF utiliza como base FreeRTOS para la construcci\u00f3n del firmware , aunque a\u00f1ade multitud de componentes para ofrecer un soporte de mayor nivel para la interacci\u00f3n con protocolos de comunicaci\u00f3n de bajo y alto nivel, la mayor\u00eda de ellos enfocados al \u00e1mbito de comunicaci\u00f3n en Internet de las Cosas. La presente pr\u00e1ctica pretende ser una introducci\u00f3n b\u00e1sica a la puesta en marcha del entorno de desarrollo ESP-IDF sobre un sistema operativo Linux, ofreciendo dos alternativas b\u00e1sicas: l\u00ednea de comandos y un plugin espec\u00edfico para VSCode (PlatformIO). Adem\u00e1s, veremos de forma superficial la estructura b\u00e1sica de un programa sencillo desarrollado usando ESP-IDF, as\u00ed como ejemplos b\u00e1sicos para la puesta en marcha de la interfaz WiFi sobre una placa ESP32. Recuerda La presente pr\u00e1ctica no tiene tarea entregable asociada m\u00e1s all\u00e1 de una memoria justificativa del trabajo realizado. Por tanto, recuerda apuntar y reportar los pasos y tareas realizadas durante su desarrollo para plasmarlas en una breve memoria entregable final.","title":"Introducci\u00f3n"},{"location":"RPI-I/P1/#flujo-de-trabajo-entorno-basado-en-linea-de-comandos","text":"","title":"Flujo de trabajo. Entorno basado en l\u00ednea de comandos"},{"location":"RPI-I/P1/#instalacion-de-prerequisitos","text":"ESP-IDF requiere ciertos paquetes software instalados en el sistema para poder desarrollar los c\u00f3digos y descargarlos sobre el ESP32. Se muestran a continuaci\u00f3n los requisitos y modo de instalaci\u00f3n para m\u00e1quinas Ubuntu/Debian (como la m\u00e1quina virtual del curso), aunque la documentaci\u00f3n de ESP-IDF incluye instrucciones para otras distribuciones y sistemas operativos, incluyendo Windows y MacOS. En tu m\u00e1quina virtual, instala los paquetes necesarios utilizando (como superusuario): sudo apt-get install git wget flex bison gperf python python3-pip python-setuptools cmake ninja-build ccache libffi-dev libssl-dev dfu-util Adem\u00e1s, es necesario, en todo caso, que el usuario que est\u00e9s utilizando pertenezca al grupo dialout (puedes editar el fichero /etc/group a\u00f1adiendo a tu usuario a la l\u00ednea que indica el grupo correspondiente, e iniciando de nuevo tu sesi\u00f3n). Instala y configura Python 3 para su uso por defecto en tu distribuci\u00f3n: sudo apt-get install python3 python3-pip python3-setuptools sudo update-alternatives --install /usr/bin/python python /usr/bin/python3 10","title":"Instalaci\u00f3n de prerequisitos"},{"location":"RPI-I/P1/#obtencion-de-esp-idf","text":"Utilizaremos las versiones de ESP-IDF a obtener directamente desde el repositorio Github oficial (concretamente, en su versi\u00f3n 4.1). Para ello, ejecuta desde tu directorio de inicio: mkdir -p ~/esp cd ~/esp git clone --recursive https://github.com/espressif/esp-idf.git cd esp-idf git fetch git checkout release/v4.1 git pull git submodule update --init --recursive","title":"Obtenci\u00f3n de ESP-IDF"},{"location":"RPI-I/P1/#instalacion-de-herramientas-adicionales","text":"Desde el directorio esp-idf , ejecuta el script install.sh para instalar las herramientas ( toolchain ) espec\u00edficas para tu versi\u00f3n: sh install.sh","title":"Instalaci\u00f3n de herramientas adicionales"},{"location":"RPI-I/P1/#preparacion-del-entorno","text":"Tras el inicio de cada sesi\u00f3n, deber\u00e1s establecer valores correctos para ciertas variables de entorno. Afortunadamente, se proporciona un script ( export.sh ) que te permitir\u00e1 establecerlas de forma autom\u00e1tica: . export.sh Puedes a\u00f1adir esta l\u00ednea en cualquier fichero de inicio de sesi\u00f3n para no tener que ejecutar el comando cada vez. En cualquier caso, en este punto deber\u00edas tener acceso a un programa llamado idf.py , a trav\u00e9s del cual gestionaremos el flujo de trabajo. Compru\u00e9balo y observa si la version de IDF con la que est\u00e1s trabajando es efectivamente la 4.1 (el n\u00famero de subversi\u00f3n podr\u00eda variar en tu salida): $ idf.py --version ESP-IDF v4.1-332-g7b7c64107","title":"Preparaci\u00f3n del entorno"},{"location":"RPI-I/P1/#preparacion-del-proyecto","text":"En esta primera parte, nos basaremos en un ejemplo sencillo de c\u00f3digo desarrollado en base a ESP-IDF. No es el objetivo de esta pr\u00e1ctica analizar en detalle los la estructura de dicho c\u00f3digo (al menos de momento), sino utilizarlo para ilustrar el flujo de trabajo t\u00edpico en un proyecto ESP-IDF. Recuerda Tras la ejecuci\u00f3n del script export.sh , tendr\u00e1s definida una variable de entorno llamada IDF_PATH . Consulta su valor y comprueba que apunta, efectivamente, al directorio de instalaci\u00f3n de IDF. La utilizaremos a partir de ahora para referirnos a \u00e9l. Para empezar, toma el ejemplo hello_world proporcionado como parte de la instalaci\u00f3n b\u00e1sica de IDF, y c\u00f3pialo en cualquier directorio del sistema de ficheros: cp -R $IDF_PATH/examples/get-started/hello_world $HOME/ cd $HOME/hello_world","title":"Preparaci\u00f3n del proyecto"},{"location":"RPI-I/P1/#compilacion","text":"El proceso de compilaci\u00f3n b\u00e1sico utiliza el script idf.py : idf.py build Si todo ha ido bien, en el directorio build se habr\u00e1n generado los objetos y binarios listos para ser flasheados en el ESP32.","title":"Compilaci\u00f3n"},{"location":"RPI-I/P1/#flasheado","text":"El proceso de flasheado b\u00e1sico utiliza el script idf.py : idf.py -p PUERTO flash En este punto, el ESP32 debe estar conectado utilizando el cable microUSB, y si est\u00e1s trabajando en una m\u00e1quina virtual, debe haberse hecho visible a la misma (por ejemplo, en VirtualBox, a trav\u00e9s del men\u00fa Dispositivos->USB->Silicon Labs USB to UART Bridge Controller ). En todo caso, la salida del comando dmesg tras la conexi\u00f3n del dispositivo te proporcionar\u00e1 informaci\u00f3n sobre el PUERTO que debes utilizar en el proceso de flasheado y montorizaci\u00f3n posterior.","title":"Flasheado"},{"location":"RPI-I/P1/#monitorizacion","text":"Si todo ha ido bien, el proceso de monitorizaci\u00f3n nos permitir\u00e1 observar la salida del programa que tenemos ejecutando en la placa. Para ello, de nuevo, usamos el script idf.py : idf.py -p PUERTO monitor Nota Comprueba que, efectivamente, puedes realizar el proceso de compilaci\u00f3n, flasheado y monitorizaci\u00f3n del programa sobre la placa ESP32. Recuerda que el bot\u00f3n EN , justo al lado del conector microUSB, forzar\u00e1 un reseteo de la misma.","title":"Monitorizaci\u00f3n"},{"location":"RPI-I/P1/#flujo-de-trabajo-entorno-basado-en-platformio","text":"El anterior flujo de trabajo puede tambi\u00e9n desarrollarse desde otros entornos de desarrollo. En nuestro caso, se muestran a continuaci\u00f3n los pasos principales para la integraci\u00f3n de ESP-IDF con VSCode, utilizando la plataforma PlatformIO . Las m\u00e1quinas virtuales proporcionadas en el curso ya tienen instalada la \u00faltima versi\u00f3n de PlatformIO y ESP-IDF, por lo que se refiere al lector a la documentaci\u00f3n oficial de PlatformIO para llevar a cabo dicha instalaci\u00f3n en otros sistemas operativos.","title":"Flujo de trabajo. Entorno basado en PlatformIO"},{"location":"RPI-I/P1/#configuracion-de-un-proyecto","text":"La forma m\u00e1s sencilla de crear un nuevo proyecto consiste en pulsar el bot\u00f3n PlatformIO Home situado en la parte inferior de la pantalla: A continuaci\u00f3n, clica en New Project y selecciona como placa de desarrollo ESP DevkitC o Espressif ESP32 Dev Module . Selecciona ESP-IDF como framework de desarrollo para el proyecto:","title":"Configuraci\u00f3n de un proyecto"},{"location":"RPI-I/P1/#adicion-de-ficheros-a-un-proyecto","text":"Crea un nuevo fichero main.c (si no existe) en el directorio src de tu proyecto, o modifica el que ya existe utilizando, por ejemplo, el siguiente c\u00f3digo: #include <string.h> #include \"freertos/FreeRTOS.h\" #include \"freertos/task.h\" #include \"esp_system.h\" #include \"esp_wifi.h\" #include \"esp_event.h\" #include \"esp_log.h\" #include \"nvs_flash.h\" #include \"lwip/err.h\" #include \"lwip/sys.h\" #define EXAMPLE_ESP_WIFI_SSID \"mywifissid\" #define EXAMPLE_ESP_WIFI_PASS \"mywifipass\" #define EXAMPLE_MAX_STA_CONN (3) static const char *TAG = \"wifi softAP\"; static void wifi_event_handler(void* arg, esp_event_base_t event_base, int32_t event_id, void* event_data) { if (event_id == WIFI_EVENT_AP_STACONNECTED) { wifi_event_ap_staconnected_t* event = (wifi_event_ap_staconnected_t*) event_data; ESP_LOGI(TAG, \"station \"MACSTR\" join, AID=%d\", MAC2STR(event->mac), event->aid); } else if (event_id == WIFI_EVENT_AP_STADISCONNECTED) { wifi_event_ap_stadisconnected_t* event = (wifi_event_ap_stadisconnected_t*) event_data; ESP_LOGI(TAG, \"station \"MACSTR\" leave, AID=%d\", MAC2STR(event->mac), event->aid); } } void wifi_init_softap() { tcpip_adapter_init(); ESP_ERROR_CHECK(esp_event_loop_create_default()); wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT(); ESP_ERROR_CHECK(esp_wifi_init(&cfg)); ESP_ERROR_CHECK(esp_event_handler_register(WIFI_EVENT, ESP_EVENT_ANY_ID, &wifi_event_handler, NULL)); wifi_config_t wifi_config = { .ap = { .ssid = EXAMPLE_ESP_WIFI_SSID, .ssid_len = strlen(EXAMPLE_ESP_WIFI_SSID), .password = EXAMPLE_ESP_WIFI_PASS, .max_connection = EXAMPLE_MAX_STA_CONN, .authmode = WIFI_AUTH_WPA_WPA2_PSK }, }; if (strlen(EXAMPLE_ESP_WIFI_PASS) == 0) { wifi_config.ap.authmode = WIFI_AUTH_OPEN; } ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_AP)); ESP_ERROR_CHECK(esp_wifi_set_config(ESP_IF_WIFI_AP, &wifi_config)); ESP_ERROR_CHECK(esp_wifi_start()); ESP_LOGI(TAG, \"wifi_init_softap finished. SSID:%s password:%s\", EXAMPLE_ESP_WIFI_SSID, EXAMPLE_ESP_WIFI_PASS); } void app_main() { //Initialize NVS esp_err_t ret = nvs_flash_init(); if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) { ESP_ERROR_CHECK(nvs_flash_erase()); ret = nvs_flash_init(); } ESP_ERROR_CHECK(ret); ESP_LOGI(TAG, \"ESP_WIFI_MODE_AP\"); wifi_init_softap(); } De momento no analizaremos el funcionamiento del c\u00f3digo (lo haremos m\u00e1s adelante) pero b\u00e1sicamente establece un Punto de Acceso inal\u00e1mbrico abierto a conexiones autenticadas v\u00eda WPA2.","title":"Adici\u00f3n de ficheros a un proyecto"},{"location":"RPI-I/P1/#compilacion-del-proyecto","text":"Para compilar del proyecto, despliega la paleta de comandos (men\u00fa View -> Command Palette ) y ejecuta la orden PlatformIO: Build desde ella. Tambi\u00e9n puedes presionar el bot\u00f3n Build (con forma de check ) en la barra inferior de PlatformIO: Si todo ha ido bien, deber\u00edas ver un mensaje final similar al siguiente en la terminal del sistema:","title":"Compilaci\u00f3n del proyecto"},{"location":"RPI-I/P1/#flasheado-del-proyecto","text":"Para llevar a cabo el proceso de subida ( upload ) del proyecto a la placa, podemos utilizar la orden PlatformIO: Upload a trav\u00e9s de la paleta de comandos, o bien presionar el bot\u00f3n correspondiente en la barra inferior (con un s\u00edmbolo de flecha a izquierda):","title":"Flasheado del proyecto"},{"location":"RPI-I/P1/#monitorizacion-del-proyecto","text":"Por \u00faltimo, podemos monitorizar el proyecto utilizando la orden PlatformIO: Monitor de la paleta de comandos o a trav\u00e9s de la barra inferior, usando el bot\u00f3n con un enchufe como s\u00edmbolo:","title":"Monitorizaci\u00f3n del proyecto"},{"location":"RPI-I/P1/#analisis-de-un-proyecto-sencillo-hola-mundo-en-esp-idf","text":"Nota Las siguientes tareas pueden realizarse desde l\u00ednea de comandos o utilizando PlatformIO. Para familiarizarse con en entorno de bajo nivel, sin embargo, se sugiere el uso de l\u00ednea de comandos. Observa la estructura general del directorio hello_world que compilaste anteriormente. Espec\u00edficamente, nos interesar\u00e1 inspeccionar la estructura b\u00e1sica de un programa principal para ESP-IDF, en este caso hello_world_main.c . #include <stdio.h> #include \"sdkconfig.h\" #include \"freertos/FreeRTOS.h\" #include \"freertos/task.h\" #include \"esp_system.h\" #include \"esp_spi_flash.h\" void app_main(void) { printf(\"Hello world!\\n\"); /* Print chip information */ esp_chip_info_t chip_info; esp_chip_info(&chip_info); printf(\"This is %s chip with %d CPU cores, WiFi%s%s, \", CONFIG_IDF_TARGET, chip_info.cores, (chip_info.features & CHIP_FEATURE_BT) ? \"/BT\" : \"\", (chip_info.features & CHIP_FEATURE_BLE) ? \"/BLE\" : \"\"); printf(\"silicon revision %d, \", chip_info.revision); printf(\"%dMB %s flash\\n\", spi_flash_get_chip_size() / (1024 * 1024), (chip_info.features & CHIP_FEATURE_EMB_FLASH) ? \"embedded\" : \"external\"); printf(\"Minimum free heap size: %d bytes\\n\", esp_get_minimum_free_heap_size()); for (int i = 10; i >= 0; i--) { printf(\"Restarting in %d seconds...\\n\", i); vTaskDelay(1000 / portTICK_PERIOD_MS); } printf(\"Restarting now.\\n\"); fflush(stdout); esp_restart(); } A alto nivel, la funci\u00f3n app_main es el punto de entrada a todo programa desarrollado usando ESP-IDF. De modo m\u00e1s espec\u00edfico, tras la carga del sistema , la llamada tarea principal ( main task ) ejecuta el c\u00f3digo proporcionado por el usuario e implementado en la funci\u00f3n app_main . Tanto el tama\u00f1o de pila asignado como la prioridad de esta tarea puede ser configuradas por el desarrollador a trav\u00e9s del sistema de configuraci\u00f3n de ESP-IDF (lo veremos m\u00e1s adelante). Normalmente, esta funci\u00f3n se utiliza para llevar a cabo tareas iniciales de configuraci\u00f3n o para crear y lanzar a ejecuci\u00f3n otras tareas. De cualquier modo (como es el caso), se puede implementar cualquier funcionalidad dentro de la funci\u00f3n app_main . En este ejemplo, se muestra en primer lugar informaci\u00f3n gen\u00e9rica sobre el SoC que est\u00e1 ejecutando el firmware : /* Print chip information */ esp_chip_info_t chip_info; esp_chip_info(&chip_info); printf(\"This is %s chip with %d CPU cores, WiFi%s%s, \", CONFIG_IDF_TARGET, chip_info.cores, (chip_info.features & CHIP_FEATURE_BT) ? \"/BT\" : \"\", (chip_info.features & CHIP_FEATURE_BLE) ? \"/BLE\" : \"\"); printf(\"silicon revision %d, \", chip_info.revision); printf(\"%dMB %s flash\\n\", spi_flash_get_chip_size() / (1024 * 1024), (chip_info.features & CHIP_FEATURE_EMB_FLASH) ? \"embedded\" : \"external\"); printf(\"Minimum free heap size: %d bytes\\n\", esp_get_minimum_free_heap_size()); A continuaci\u00f3n, dentro de un bucle sencillo, el sistema muestra un mensaje y difiere la ejecuci\u00f3n de la tarea durante un per\u00edodo determinado de tiempo utilizando la funci\u00f3n vTaskDelay de FreeRTOS. Esta funci\u00f3n recibe el n\u00famero de ticks de reloj que se desea utilizar, por lo que el tiempo real que la tarea diferir\u00e1 su ejecuci\u00f3n depende de la duraci\u00f3n de dicho tick . Por ello, la constante portTIC_PERIOD_MS puede utilizarse para calcular dicho tiempo: for (int i = 10; i >= 0; i--) { printf(\"Restarting in %d seconds...\\n\", i); vTaskDelay(1000 / portTICK_PERIOD_MS); } Finalmente, la tarea reinicia el sistema tras la finalizaci\u00f3n de la tarea principal: printf(\"Restarting now.\\n\"); fflush(stdout); esp_restart(); Tarea Modifica el per\u00edodo de suspensi\u00f3n de la tarea para que sea mayor o menor, y comprueba que efectivamente esto modifica el comportamiento del firmware cargado. Modifica el programa para que se muestre tambi\u00e9n por pantalla si el SoC tiene capacidades WiFi y si incluye memoria FLASH (para ello, puedes consultar la siguiente p\u00e1gina ).","title":"An\u00e1lisis de un proyecto sencillo (Hola, mundo) en ESP-IDF"},{"location":"RPI-I/P1/#creacion-de-tareas","text":"El anterior proyecto puede replantearse para que no sea la tarea principal la que ejecute la l\u00f3gica del programa. Para ello, es necesario introducir brevemente la API b\u00e1sica para gesti\u00f3n (en nuestro caso, creaci\u00f3n) de tareas. Ver\u00e1s muchos m\u00e1s detalles sobre esta API en la asignatura ANIOT, por lo que no veremos aqu\u00ed m\u00e1s detalles de los estrictamente necesarios. La funci\u00f3n xTaskCreate (incluida en task.h ) permite la creaci\u00f3n de nuevas tareas: BaseType_t xTaskCreate( TaskFunction_t pvTaskCode, const char * const pcName, configSTACK_DEPTH_TYPE usStackDepth, void *pvParameters, UBaseType_t uxPriority, TaskHandle_t *pxCreatedTask ); Concretamente, crea una nueva tarea y la a\u00f1ade a la lista de tareas listas para ejecuci\u00f3n, recibiendo como par\u00e1metros: pvTaskCode : Puntero a la funci\u00f3n de entrada para la tarea. Las tareas suelen implementarse como un bucle infinito, y no deber\u00eda, en su cuerpo, retornar o simplemente finalizar abruptamente. En cambio, una tarea puede ser destruida externamente a trav\u00e9s de su manejador (\u00faltimo par\u00e1metro en la creaci\u00f3n), o internamente (desde el propio c\u00f3digo de la tarea), tal y como se muestra en el siguiente ejemplo extra\u00eddo directamente desde la documentaci\u00f3n de FreeRTOS: void vATaskFunction( void *pvParameters ) { for( ;; ) { -- Task application code here. -- } /* Tasks must not attempt to return from their implementing function or otherwise exit. In newer FreeRTOS port attempting to do so will result in an configASSERT() being called if it is defined. If it is necessary for a task to exit then have the task call vTaskDelete( NULL ) to ensure its exit is clean. */ vTaskDelete( NULL ); } pcName : Nombre (en forma de cadena) descriptivo de la tarea a ejecutar, t\u00edpicamente usado en tiempo de depuraci\u00f3n. usStackDepth : N\u00famero de palabras a alojar para utilizar como pila para la tarea. pvParameters : Par\u00e1metros a proporcionar a la funci\u00f3n de entrada para la tarea. uxPriority : Prioridad asignada a la tarea. pxCreatedTask : Manejador opcional para la tarea. As\u00ed, la funcionalidad del programa Hola, mundo que hemos analizado anteriormente, podr\u00eda reestrcturarse en base a una \u00fanica tarea: void hello_task(void *pvParameter) { printf(\"Hello world!\\n\"); for (int i = 10; i >= 0; i--) { printf(\"Restarting in %d seconds...\\n\", i); vTaskDelay(1000 / portTICK_RATE_MS); } printf(\"Restarting now.\\n\"); fflush(stdout); esp_restart(); } Que podr\u00eda ser creada desde la tarea principal: void app_main() { nvs_flash_init(); xTaskCreate( &hello_task, \"hello_task\", 2048, NULL, 5, NULL ); } Tarea Implementa una modificaci\u00f3n del programa hello_world que implemente y planifique dos tareas independientes con distinta funcionalidad (en este caso, es suficiente con mostrar por pantalla alg\u00fan mensaje) y distintos tiempos de suspensi\u00f3n. Comprueba que, efectivamente, ambas tareas se ejecutan concurrentemente.","title":"Creaci\u00f3n de tareas"},{"location":"RPI-I/P1/#personalizacion-del-proyecto","text":"ESP-IDF utiliza la biblioteca kconfiglib para proporcionar un sistema de configuracion de proyectos en tiempo de compilaci\u00f3n sencillo y extensible. Para ilustrar su funcionamiento, utilizaremos el ejemplo blink que puedes encontrar en la distribuci\u00f3n de ESP-IDF que has clonado anteriormente (copia el ejemplo en cualquier punto de tu jerarqu\u00eda de directorios antes de comenzar). Para configurar un proyecto ESP-IDF, simplemente utiliza la siguiente orden: idf.py menuconfig La ejecuci\u00f3n de la orden anterior te permitir\u00e1 navegar por un conjunto de opciones de car\u00e1cter general, que te permitir\u00e1n configurar las caracter\u00edsticas espec\u00edficas del proyecto a compilar (por ejemplo, seleccionando los componentes que deseas habilitar en la construcci\u00f3n del mismo). Tarea Navega por las opciones que aparecen en los men\u00fas de configuraci\u00f3n para familiarizarte con ellos. Los utilizar\u00e1s en futuras pr\u00e1cticas. En el proyecto blink , observa que una de las opciones del men\u00fa de navegaci\u00f3n, llamada Example configuration , incluye una opci\u00f3n llamada Blink GPIO number . M\u00e1s all\u00e1 de su funcionalidad (define el n\u00famero de pin GPIO a activar/desactivar para iluminar un LED), es de inter\u00e9s para nosotros el hecho de que esta opci\u00f3n de configuraci\u00f3n definir\u00e1 en tiempo de compilaci\u00f3n el valor de una constante (en este caso CONFIG_BLINK_GPIO ) que podemos utilizar directamente en cualquier fichero de nuestro proyecto. Nota Observa el uso que da el c\u00f3digo del proyecto blink a la constante CONFIG_BLINK_GPIO . Esta opci\u00f3n de configuraci\u00f3n no forma parte de las opciones por defecto de ESP-IDF, sino que ha sido a\u00f1adida por los desarrolladores del proyecto blink . Observa y estudia el formato y contenido del fichero main/Kconfig.projbuild que se proporciona como parte del fichero. En \u00e9l, se definen las caracter\u00edsticas (nombre, rango, valor por defecto y descripcion) de la opci\u00f3n de configuraci\u00f3n a definir. Tarea Modifica el proyecto hello_world para que defina dos opciones de configuraci\u00f3n que permitir\u00e1n definir el tiempo de espera de cada una de las dos tareas que hayas definido en tu anterior soluci\u00f3n. Haz uso de ellas en tu c\u00f3digo y comprueba que efectivamente su modificaci\u00f3n a trav\u00e9s del sistema de men\u00fas permite una personalizaci\u00f3n del comportamiento de tus c\u00f3digos.","title":"Personalizaci\u00f3n del proyecto"},{"location":"RPI-I/P1/#gestion-de-redes-wifi-ejemplo-1-escaneado-de-redes-wifi","text":"A modo de ejemplo, y en preparaci\u00f3n para los c\u00f3digos con los que trabajaremos en futuras pr\u00e1cticas, vamos a analizar a continuaci\u00f3n un ejemplo concreto de firmware cuya tarea es el escaneado de redes inal\u00e1mbricas al alcance del ESP32, y su reporte a trav\u00e9s del puerto serie del mismo. Para cada red escaneada, se reportar\u00e1n sus caracter\u00edsticas principales. Tarea Compila, flashea y monitoriza el ejemplo scan situado en el directorio examples/wifi/scan . Recuerda copiarlo antes a cualquier otro directorio de tu home . Antes de compilarlo, modifica el n\u00famero m\u00e1ximo de redes a escanear a trav\u00e9s del men\u00fa de configuraci\u00f3n del ejemplo para ampliarlo a 20. Crea un punto de acceso WiFi con tu tel\u00e9fono m\u00f3vil y observa que, efectivamente, es escaneado por el ejemplo. Observa su funcionamiento. Realmente, el firmware simplemente escanea un subconjunto de las redes disponibles, reportando algunas de sus caracter\u00edsticas (por ejemplo, SSID, modo de autenticaci\u00f3n o canal primario). Tarea Analiza el c\u00f3digo de la funci\u00f3n wifi_scan (tarea principal). Espec\u00edficamente, c\u00e9ntrate en las l\u00edneas que permiten activar y configurar el escaneado de redes. Intenta entender el funcionamiento general del programa, consultando y apuntando el cometido de cada l\u00ednea, con especial inter\u00e9s a aquellas funciones con prefijo esp_wifi_* . Anota en la memoria entregable el cometido de cada una de ellas, consultando la documentaci\u00f3n oficial .","title":"Gesti\u00f3n de redes WiFi. Ejemplo 1. Escaneado de redes WiFi"},{"location":"RPI-I/P1/#gestion-de-redes-wifi-ejemplo-2-gestion-de-eventos-de-red","text":"El segundo ejemplo consiste en la creaci\u00f3n de un firmware para conexi\u00f3n del ESP32 a un punto de acceso existente. Este ejemplo nos permitir\u00e1 observar, a grandes rasgos, el sistema de gesti\u00f3n de eventos en FreeRTOS/ESP-IDF, que estudiar\u00e1s en m\u00e1s detalle en ANIOT y que permite gestionar, entre otros, las respuestas a eventos de red, como por ejemplo la obtenci\u00f3n de direcci\u00f3n IP o la conexi\u00f3n exitosa a un punto de acceso. Tarea Compila, flashea y monitoriza el ejemplo station situado en el directorio examples/wifi/getting_started . Recuerda copiarlo antes a cualquier otro directorio de tu home . Antes de compilarlo, modifica el SSID de la red al que conectar\u00e1, as\u00ed como la contrase\u00f1a elegida (puedes usar el mismo punto de acceso que creaste anteriormente como objetivo de tu conexi\u00f3n) a trav\u00e9s del sistema de men\u00fas de configuraci\u00f3n. Observa su funcionamiento. El firmware simplemente inicializa el dispositivo en modo station (en contraposici\u00f3n al modo Access Point , que veremos en la pr\u00f3xima sesi\u00f3n), realizando una conexi\u00f3n al punto de acceso preconfigurado a trav\u00e9s del men\u00fa de configuraci\u00f3n. Analiza el c\u00f3digo de la funci\u00f3n wifi_init_sta . Esta funci\u00f3n, que implementa la tarea principal, se divide b\u00e1sicamente en dos partes: Gesti\u00f3n de eventos . Observa el mecanismo mediante el cual se registra y se asocia la recepci\u00f3n de un evento a la ejecuci\u00f3n de un manejador o funci\u00f3n determinada. Pregunta \u00bfQu\u00e9 eventos se asocian a la ejecuci\u00f3n de qu\u00e9 funci\u00f3n en el firmware que est\u00e1s estudiando? Configuraci\u00f3n de la conexi\u00f3n a un punto de acceso . La configuraci\u00f3n de la conexi\u00f3n se realiza a trav\u00e9s de los campos correspondientes de una estructura de tipo wifi_config_t . Observa los campos b\u00e1sicos que necesita, c\u00f3mo fuerza el uso de WPA2 y c\u00f3mo recoge los datos de conexi\u00f3n (SSID y contrase\u00f1a) a trav\u00e9s del sistema de configuraci\u00f3n. Observa tambi\u00e9n c\u00f3mo, una vez realizadas dichas personalizaciones, inicializa el sistema de comunicaci\u00f3n inal\u00e1mbrica a trav\u00e9s de esp_wifi_start() . Consulta la documentaci\u00f3n relativa a dichas funciones y anota en tu memoria entregable aquellos aspectos que consideres m\u00e1s relevantes. Tarea Modifica el firmware para que el handler de tratamiento de la obtenci\u00f3n de una direcci\u00f3n IP sea independiente del tratamiento del resto de eventos del sistema WiFi que ya se est\u00e1n considerando. Comprueba que, efectivamente sigue observ\u00e1ndose la salida asociada a dicho evento, aun cuando ambas funciones sean independientes. Entrega o a\u00f1ade a la memoria el c\u00f3digo modificado.","title":"Gesti\u00f3n de redes WiFi. Ejemplo 2. Gesti\u00f3n de eventos de red"},{"location":"RPI-I/P2/","text":"Pr\u00e1ctica 2. Soporte WiFi en el ESP32 Objetivos Conocer el flujo de trabajo del driver WiFi en ESP-IDF. Analizar las diferencias entre un firmware desarrollado para trabajar en modo station y en modo AP . Desarrollar un firmware combinado para que funcione en modo AP y station de forma simult\u00e1nea. Conocer los mecanismos de escaneado de redes en ESP-IDF. Conectar a redes v\u00eda WPA2 Enterprise desde el ESP32 ( eduroam ). Introducci\u00f3n Las bibliotecas y componentes de soporte WiFi en ESP-IDF proporcionan soporte para configurar y monitorizar la conexi\u00f3n 802.11 sobre placas ESP32. Este soporte incluye configuraciones para: Modo station (modo cliente WiFi, o STA ). En este caso, el ESP32 conecta con un punto de acceso preconfigurado. Modo AP (tambi\u00e9n denominado softAP o modo Punto de Acceso ). En este caso, son las estaciones las que conectan al ESP32. Modo combinado AP-STA, donde el ESP32 es act\u00faa de forma concurrente como Punto de Acceso y cliente WiFi conectado a otro punto de acceso. Varios modos de seguridad tanto en modo cliente como en modo AP (WPA, WPA2, WEP, etc.) Escaneado de puntos de acceso (activo y pasivo). Provisionamiento de claves y modo WPS. Modo promiscuo para monitorizaci\u00f3n de paquetes IEEE 802.11. En la presente pr\u00e1ctica, a trav\u00e9s de ejemplos b\u00e1sicos, estudiaremos las caracter\u00edsticas principales soportadas por el driver WiFi sobre el ESP32. Todas estas caracter\u00edsticas pueden ser utilizadas a posteriori para el desarrollo de c\u00f3digos y proyectos m\u00e1s complejos con m\u00ednimas modificaciones. Modelo de programaci\u00f3n del driver WiFi en ESP-IDF El modelo de programaci\u00f3n del driver WiFi en ESP-IDF sigue un modelo de programaci\u00f3n sencillo que se puede resumir en la siguiente imagen: Puede considerarse que el driver WiFi es una caja negra que desconoce cualquier detalle de la aplicaci\u00f3n a mayor nivel, por ejemplo de la pila TCP/IP, las tareas de aplicaci\u00f3n, los eventos, etc. El c\u00f3digo de las tareas de aplicaci\u00f3n generalmente invoca a la API WiFi para inicializar el dispositivo inal\u00e1mbrico y tratar eventos espec\u00edficos cuando resulta necesario. El driver WiFi recibe invocaciones a su API, las procesa y emite eventos a la aplicaci\u00f3n. El tratamiento de eventos WiFi se basa en la biblioteca de eventos esp_event ; los eventos se env\u00edan por parte del driver a bucle de tratamiento de eventos por defecto . La aplicaci\u00f3n procesa estos eventos en funciones callback registradas previamente a trav\u00e9s de la funci\u00f3n esp_event_handler_register() . Alg\u00fan tipo de eventos es tambi\u00e9n procesado por el componente esp_netif para proporcionar reacciones por defecto ante su recepci\u00f3n; un ejemplo claro sucede de forma transparente cuando un dispositivo se conecta a un AP, momento en el cual esp_netif arranca un cliente DHCP para obtener una direcci\u00f3n IP sin intervenci\u00f3n del c\u00f3digo de usuario (aunque este comportamiento por defecto puede ser personalizado para, por ejemplo, asignar una direcci\u00f3n IP est\u00e1ticamente). Nota Toda la API mencionada a continuaci\u00f3n se encuentra descrita en profundidad en este enlace . Se aconseja disponer de esta informaci\u00f3n durante el proceso de desarrollo y tambi\u00e9n en el propio desarrollo de la pr\u00e1ctica. Eventos WiFi Se listan a continuaci\u00f3n algunos de los ejemplos m\u00e1s utilizados en la gesti\u00f3n de conexiones WiFi, que utilizaremos en los ejemplos posteriores. WIFI_EVENT_SCAN_DONE Este evento se env\u00eda autom\u00e1ticamente en la invocaci\u00f3n de esp_wifi_scan_start() , en los siguientes escenarios: El escaneado de redes se completa, es decir, se ha encontrado el punto de acceso (AP) objetivo. El escaneado de redes finaliza tras la invocaci\u00f3n de esp_wifi_scan_stop() . Se invoca al inicio de un nuevo escaneo (mediante la rutina esp_wifi_scan_start() ) antes de finalizar un escaneado previo. Este nuevo escaneado se superpondr\u00e1 al anterior y se emitir\u00e1 el evento. El evento no se emite cuando el escaneado se fuerza mediante la invocaci\u00f3n a esp_wifi_connect() . Ante la recepci\u00f3n de este evento, no se lanza ning\u00fan proceso espec\u00edfico como respuesta. La aplicaci\u00f3n necesitar\u00e1 invocar normalmente a esp_wifi_scan_get_ap_num() y a esp_wifi_scan_get_ap_records() para recoger la lista de APs escaneados y liberar los recursos (memoria) que se aloja en el proceso de escaneado. WIFI_EVENT_STA_START Este evento se env\u00eda cuando, tras la invocaci\u00f3n a esp_wifi_start() , \u00e9sta devuelve ESP_OK . Tras la recepci\u00f3n de este evento, se inicializa la interfaz de red, por lo que normalmente, tras la recepci\u00f3n de este evento se est\u00e1 listo para invocar a esp_wifi_connect() para comenzar el proceso de conexi\u00f3n con un punto de acceso (AP). WIFI_EVENT_STA_STOP Este evento se env\u00eda cuando, tras la invocaci\u00f3n a esp_wifi_stop() , \u00e9sta devuelve ESP_OK . Tras la recepci\u00f3n de este evento, se libera la direcci\u00f3n IP, se detiene el cliente DHCP y se liberan las conexiones TCP/UDP existentes. Normalmente no se trata desde el punto de vista de la aplicaci\u00f3n. WIFI_EVENT_STA_CONNECTED Este evento se env\u00eda cuando, tras la invocaci\u00f3n a esp_wifi_connect() , \u00e9sta devuelve ESP_OK . Tras la recepci\u00f3n de este evento, arranca un cliente DHCP para la obtenci\u00f3n de una direcci\u00f3n IP. A continuaci\u00f3n, si todo ha ido bien, el driver WiFi est\u00e1 listo para enviar y recibir datos. Dicho instante es el adecuado para comenzar con la l\u00f3gica de la aplicaci\u00f3n, siempre que \u00e9sta no dependa de la correcta obtenci\u00f3n de una direcci\u00f3n IP. Si este es el caso, ser\u00e1 necesario esperar a la obtenci\u00f3n de la misma esperando al evento WIFI_EVENT_STA_GOT_IP . WIFI_EVENT_STA_DISCONNECTED Este evento se genera en los siguientes escenarios: Cuando se invoca a las funciones esp_wifi_disconnect() , esp_wifi_stop() , esp_wifi_deinit() o esp_wifi_restart() y la estaci\u00f3n est\u00e1 conectada al punto de acceso. Cuando se invoca a esp_wifi_connect() , pero el driver WiFi no consigue configurar una conexi\u00f3n con el AP debido a cualquier raz\u00f3n (por ejemplo, el escaneo no puede encontrar el AP objetivo, el proceso de autenticaci\u00f3n no tiene \u00e9xito, etc. Si hay m\u00e1s de un AP con el mismo SSID, el evento se emite s\u00f3lo cuando el dispositivo no puede conectar a ninguno de los APs encontrados. Cuando la conexi\u00f3n WiFi se interrumpe, por ejemplo porque el dispositivo pierde N beacons emitidos por el AP, el AP expulsa al dispositivo, el modo de autenticaci\u00f3n cambia, etc. Resulta com\u00fan que la rutina de tratamiento del evento trate de invocar de nuevo a la funci\u00f3n esp_wifi_connect() para reintentar la conexi\u00f3n. WIFI_EVENT_STA_GOT_IP Este evento se emite cuando el cliente DHCP obtiene una direcci\u00f3n IPv4 desde un servidor DHCP, o cuando se modifica su direcci\u00f3n IPv4. El evento significa que todo est\u00e1 listo y que la aplicaci\u00f3n puede continuar con sus tareas (por ejemplo, creaci\u00f3n de sockets, inicializaci\u00f3n de protocolos, etc.) La direcci\u00f3n IPv4 podr\u00eda modificarse por alguna de las siguientes razones: El cliente DHCP no puede renovar la direcci\u00f3n IPv4 tras su expiraci\u00f3n (los servidores DHCP suelen conceder direcciones IP durante un tiempo limitado). El cliente DHCP se asocia a otra direcci\u00f3n. Se modifica la direcci\u00f3n IPv4 asignada est\u00e1ticamente (no v\u00eda DHCP). Normalmente, cuando la IP cambia, todos los sockets asociados a ella quedar\u00e1n en un estado no utilizable. As\u00ed, la recepci\u00f3n de este evento se suele aprovechar para cerrar y a continuaci\u00f3n recrear todos los sockets abiertos. WIFI_EVENT_STA_LOST_IP Evento emitido cuando una direcci\u00f3n IPv4 se convierte en una direcci\u00f3n inv\u00e1lida. El evento no se emite inmediatamente tras la desconexi\u00f3n WiFi, sino que inicializa un temporizador de tipo address lost . Si se obtiene una IP antes de su expiraci\u00f3n, el evento no se emite. En otro caso, se emite justo en el instante de expirci\u00f3n del temporizador. Normalmente, las aplicaciones no deben tratar este evento (suele usarse en tareas de depuraci\u00f3n). WIFI_EVENT_AP_START Emitido en el inicio de un AP (punto de acceso). WIFI_EVENT_AP_STACONNECTED Cuando un dispositivo ( station ) se conecta a un AP, \u00e9ste emite el event WIFI_EVENT_AP_STACONNECTED . Es posible ignorarlo, o aprovecharlo para obtener informaci\u00f3n sobre la estaci\u00f3n conectada, por ejemplo. WIFI_EVENT_AP_STADISCONNECTED Este evento se genera en los siguientes escenarios: La aplicaci\u00f3n invoca a esp_wifi_disconnect() o esp_wifi_deauth_sta() para desconectarla manualmente del punto de acceso. El driver WiFi expulsa al dispositivo ( station ), por ejemplo en una situaci\u00f3n en la que el AP no ha recibido paquetes en los \u00faltimos minutos. Cuando ocurre este evento, la aplicaci\u00f3n necesitar\u00eda (idealmente) tomar las medidas necesarias asociadas al mismo, por ejemplo, cerrar los sockets abiertos. Modo Station La siguiente figura describe, a grandes rasgos, algunos de los escenarios principales que pueden darse en modo station : Se analizan a continuaci\u00f3n las fases principales en este tipo de firmware (no todas tienen que estar necesariamente presentes en cualquier escenario). Fase 1: inicializaci\u00f3n WiFi La tarea principal invoca a esp_netif_init() para crear la pila IP y realizar las tareas de inicializaci\u00f3n pertinentes. La tarea principal invoca a esp_event_loop_create() para crear e inicializar el sistema de eventos. La tarea principal invoca a esp_netif_create_default_wifi_sta() para crear la interfaz de red que asocia el dispositivo con la pila TCP/IP. La tarea principal invoca a esp_wifi_init() para crear la tarea que manejar\u00e1 la conexi\u00f3n WiFi e inicializa el driver WiFi. Por \u00faltimo, se invoca (si as\u00ed se desea, aunque es lo m\u00e1s com\u00fan) a la API para la creaci\u00f3n de la tarea o tareas de aplicaci\u00f3n. Esta secuencia es la recomendada para la inicializaci\u00f3n del sistema de comunicaci\u00f3n WiFi, pero no es estrictamente obligatorio seguirla en dicho orden o en su totalidad. Por ejemplo, se podr\u00eda crear directamente una tarea de aplicaci\u00f3n (paso 5) y realizar la configuraci\u00f3n en su cuerpo, o se puede diferir su creaci\u00f3n hasta la obtenci\u00f3n de una direcci\u00f3n IP. Fase 2: configuraci\u00f3n WiFi Una vez inicializado el driver WiFi, comienza su configuraci\u00f3n. En este escenario, el modo debe fijarse a station a trav\u00e9s de una invocaci\u00f3n a esp_wifi_set_mode(WIFI_MODE_STA) . Es posible invocar a continuaci\u00f3n a otras rutinas de tipo esp_wifi_set_xxx() para configurar par\u00e1metros adicionales (pa\u00eds, ancho de banda, modo de protocolo, ...). Para m\u00e1s informaci\u00f3n sobre los modos de operaci\u00f3n ( station , AP o modo combinado station/AP , consulta el siguiente enlace ). Generalmente, es necesario configurar el driver WiFi antes de establecer una conexi\u00f3n, pero no es obligatorio: es posible reconfigurarlo en cualquier momento, siempre que el driver est\u00e9 correctamente incializado. En cualquier caso, si la configuraci\u00f3n no tiene que modificarse tras la conexi\u00f3n, es mejor realizarla en este punto, porque algunos de los par\u00e1metros que pueden variar forzar\u00e1n una reconexi\u00f3n WiFi, aspecto que es mejor evitar. La rutina esp_wifi_set_config() permite configurar los aspectos b\u00e1sicos de la conexi\u00f3n WiFi. Por ejemplo, el c\u00f3digo: wifi_config_t wifi_config = { .sta = { .ssid = EXAMPLE_ESP_WIFI_SSID, .password = EXAMPLE_ESP_WIFI_PASS, .threshold.authmode = WIFI_AUTH_WPA2_PSK, .pmf_cfg = { .capable = true, .required = false }, }, }; ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA) ); ESP_ERROR_CHECK(esp_wifi_set_config(ESP_IF_WIFI_STA, &wifi_config) ); Realiza una configuraci\u00f3n b\u00e1sica WiFi proporcionando SSID, contrase\u00f1a y modo de autenticaci\u00f3n antes de configurar la conexi\u00f3n. Fase 3: inicio WiFi Invocaci\u00f3n a esp_wifi_start() para iniciar el driver WiFi. El driver WiFi envia un evento WIFI_EVENT_STA_START , que ser\u00e1 tratado por la tarea de gesti\u00f3n de eventos por defecto para realizar las tareas necesarias e invocar\u00e1 a la runtina de tratamiento del evento a nivel de aplicaci\u00f3n. La aplicaci\u00f3n deber\u00e1 tratar el evento WIFI_EVENT_STA_START , invocando (se recomienda) a esp_wifi_connect() . Fase 4: conexi\u00f3n WiFi Una vez invocada esp_wifi_connect() , el dirver WiFi comienza un proceso interno de escaneado/conexi\u00f3n. Si dicho proceso tiene \u00e9xito, se genera un evento WIFI_EVENT_STA_CONNECTED . Autom\u00e1ticamente se invoca al cliente DHCP y comienza el proceso de obtenci\u00f3n de direcci\u00f3n IP. Generalmente, la aplicaci\u00f3n no suele responder a este evento, pero podr\u00eda por ejemplo imprimirse un mensaje por pantalla a modo de depuraci\u00f3n. En el segundo paso, la conexi\u00f3n podr\u00eda fallar, por ejemplo, si la contrase\u00f1a proporcionada es incorrecta. En dicho caso, se env\u00eda un evento de tipo WIFI_EVENT_STA_DISCONNECTED y se proporcionar\u00e1 la causa del error. En el paso 6 se trata este aspecto. Fase 5: obtenci\u00f3n de IP Una vez inicializado el cliente DHCP (paso 4.2) comienza la fase de obtenci\u00f3n de IP. Si se recibe con \u00e9xito una IP desde el servidor DHCP, se emite un evento de tipo IP_EVENT_STA_GOT_IP) . La aplicaci\u00f3n trar\u00e1 este evento de forma acorde. Realmente, en este punto puede comenzar la l\u00f3gica de red de la aplicaci\u00f3n, incluyendo, por ejemplo, la creaci\u00f3n de sockets TCP/UDP. Es imprescindible la recepci\u00f3n de una direcci\u00f3n IP antes de la inicializaci\u00f3n de sockets. Fase 6: desconexi\u00f3n WiFi Cuando finaliza de forma abrupta una conexi\u00f3n WiFi, por ejemplo al apagar el punto de acceso (AP), si la calidad de recepci\u00f3n (RSSI) es baja, etc. se emite un evento WIFI_EVENT_STA_DISCONNECTED . La tarea de aplicaci\u00f3n deber\u00eda tratar este evento para, t\u00edpicamente, reintentar la conexi\u00f3n a trav\u00e9s de una invocaci\u00f3n a esp_wifi_reconnect() . Fase 7: cambio de IP Cuando la direcci\u00f3n IP asignada a un dispositivo cambia, se emite un evento de tipo IP_EVENT_STA_GOT_IP . Por defecto, y de forma autom\u00e1tica, se activa el campo ip_change de la estructura de tipo ip_event_got_ip_t que acompa\u00f1a al evento. La aplicaci\u00f3n deber\u00eda tomar las medidas necesarias (por ejemplo, recreaci\u00f3n de sockets) para mantenerse en un estado consistente. Fase 8: terminaci\u00f3n WiFi Invocaci\u00f3n a esp_wifi_disconnect() para desconectar la conexi\u00f3n en marcha. Invocaci\u00f3n a esp_wifi_stop() para parar el driver WiFi. Invocaci\u00f3n a esp_wifi_deinit() para descargar el driver WiFi. An\u00e1lisis de un ejemplo ( wifi/getting_started/station ) Tarea Analiza el ejemplo station , comp\u00edlalo y flashealo. Estudia el tratamiento de eventos que realiza, y c\u00f3mo estos son emitidos para casos reales. Para ello, conecta tu ESP32 con un punto de acceso existente, otro inexistente, apaga el punto de acceso mientras la IP est\u00e1 concedida, y analiza los eventos generados y su respuesta. Si no existe respuesta a alguno de ellos, a\u00f1\u00e1dela. Documenta las observaciones que consideres de inter\u00e9s y las posibles modificaciones realizadas en tu memoria. Modo Punto de Acceso La siguiente figura describe, a grandes rasgos, algunos de los escenarios principales que pueden darse en modo AP (access point) : El flujo de trabajo es muy similar al del modo station , con la diferencia b\u00e1sica del tipo de configuraci\u00f3n WiFi a realizar ( WIFI_MODE_AP ) y obviamente los par\u00e1metros de configuraci\u00f3n. Observa el siguiente ejemplo de configuraci\u00f3n: wifi_config_t wifi_config = { .ap = { .ssid = EXAMPLE_ESP_WIFI_SSID, .ssid_len = strlen(EXAMPLE_ESP_WIFI_SSID), .channel = EXAMPLE_ESP_WIFI_CHANNEL, .password = EXAMPLE_ESP_WIFI_PASS, .max_connection = EXAMPLE_MAX_STA_CONN, .authmode = WIFI_AUTH_WPA_WPA2_PSK }, }; if (strlen(EXAMPLE_ESP_WIFI_PASS) == 0) { wifi_config.ap.authmode = WIFI_AUTH_OPEN; } ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_AP)); ESP_ERROR_CHECK(esp_wifi_set_config(ESP_IF_WIFI_AP, &wifi_config)); Para m\u00e1s informaci\u00f3n sobre los par\u00e1metros de configuraci\u00f3n de un punto de acceso, consulta este enlace . An\u00e1lisis de un ejemplo ( wifi/getting_started/softAP ) Tarea Analiza el ejemplo softAP , comp\u00edlalo y flashealo. Estudia el tratamiento de eventos que realiza, y c\u00f3mo estos son emitidos para casos reales. Para ello, conecta distintos clientes ( stations ), bien sean ESP32 o cualquier otro dispositivo, y analiza los eventos generados y su respuesta. Si no existe respuesta a alguno de ellos, a\u00f1\u00e1dela. Documenta las observaciones que consideres de inter\u00e9s y las posibles modificaciones realizadas en tu memoria. Modo combinado Station/Punto de Acceso ESP-IDF soporta un modo mixto de conexi\u00f3n, en el que el ESP32 es a la vez un punto de acceso (AP) y una estaci\u00f3n ( station ). Este modo se configura utilizando el par\u00e1metro ESP_MODE_APSTA en la invocaci\u00f3n a la rutina esp_wifi_set_mode() . Adem\u00e1s, obviamente el firmware combinado requerir\u00e1 la creaci\u00f3n de dos estructuras de tipo wifi_config_t , una con los datos asociados al punto de acceso (campo .ap ) y otra con los campos asociados a la station (campo .sta ). A continuaci\u00f3n, ser\u00e1 necesario invocar a la rutina de configuraci\u00f3n ( esp_wifi_set_config ) con cada una de dichas estructuras (por \u00faltimo, tambi\u00e9n es necesario invocar a la inicializaci\u00f3n de netif tanto en modo station -- esp_netif_create_default_wifi_sta() -- como en modo AP -- esp_netif_create_default_wifi_ap() ). Ejercicio: desarrollo de un nodo mixto station/AP Tarea Modifica el ejemplo station para que el ESP32 se comporte a la vez como estaci\u00f3n y como punto de acceso. A\u00f1ade las opciones de configuraci\u00f3n necesarias para que todos los par\u00e1metros se puedan modificar v\u00eda menuconfig . Comprueba que el ESP32 efectivamente se conecta al punto de acceso y que a la vez es posible conectar otro dispositivo al mismo (por ejemplo, tu tel\u00e9fono m\u00f3vil). Adjunta en la entrega tanto el c\u00f3digo como evidencias de su correcto funcionamiento. Escaneado de redes WiFi Modos de escaneado de redes WiFi El modo de escaneo de redes WiFi (es decir, la invocaci\u00f3n de la rutina esp_wifi_scan_start() ) s\u00f3lo est\u00e1 soportada en la actualidad en modo station o station+AP . En este modo, se da soporte a distintos tipos de escaneado de redes, v\u00e9ase: Escaneado activo: El escaneado se desarrolla mediante el env\u00edo de paquetes probe y esperando respuesta, de forma activa. Escaneado pasivo: El escaneado se desarrolla simplemente escuchando en cada canal y esperando el env\u00edo por parte de los APs de paquetes de balizamiento ( beacons ). El modo activo o pasivo puede configurarse desde la aplicaci\u00f3n, mediante el campo scan_type de la estrcutura wifi_scan_config_t (lo ver\u00e1s en el siguiente ejemplo). Escaneado en primer plano: : Se utiliza cuando no hay conexi\u00f3n WiFi activa en el momento del escaneado. No es, por tanto, directamente configurable. Escaneado en segundo plano: Se utiliza cuando hay conexi\u00f3n WiFi activa en el momento del escaneado. No es, por tanto, directamente configurable. Escaneado de todos los canales: Escanea SSIDs en todos los canales. La forma de activarlo es mediante el valor 0 en el campo correspondiente de wifi_scan_config_t . Escaneado de canal espec\u00edfico: Escanea \u00fanicamente en un canal. As\u00ed, existen 8 modos distintos de escaneado de red WiFi, resultantes de la combinaci\u00f3n de los anteriores modos, llamados: All-Channel Background Active Scan. All-Channel Background Passive Scan. All-Channel Foreground Active Scan. All-Channel Foreground Passive Scan. Specific-Channel Background Active Scan. Specific-Channel Background Passive Scan. Specific-Channel Foreground Active Scan. Specific-Channel Foreground Passive Scan. Configuraci\u00f3n de escaneado de redes WiFi Para configurar una sesi\u00f3n de escaneado, se utilizan los campos correspondientes de la estructura de tipo wifi_scan_config_t , proporcionada a la rutina esp_wifi_scan_start() , que es la encargada de iniciar la sesi\u00f3n. Los campos de dicha estructura son: ssid : Si SSID no es NULL, s\u00f3lo se escanea en b\u00fasqueda de este ssid . channel : Si es 0, se realiza un escaneado de todos los canales. En caso contrario, s\u00f3lo se escanea el canal especificado. show_hidden : Si es 0, se ignoran los AP con SSID oculto. En caso contrario se consideran SSIDs normales, y por tanto se muestran. scan_type : Si tma el valor WIFI_SCAN_TYPE_ACTIVE realiza un escaneado activo. En cualquier otro caso, el escaneado es pasivo. scan_time : Especifica el tiempo de escaneado por canal. Escaneado de todos los canales en primer plano. Ejemplo de flujo El siguiente escenario describe un escaneado b\u00e1sico sobre todos los canales en primer plano (recuerda que \u00fanicamente puede ocurrir en modo station si todav\u00eda no hay conexi\u00f3n a un AP). Fase 1: Configuraci\u00f3n del escaneado Se invoca a la rutina esp_wifi_set_country() para establecer el pa\u00eds donde se est\u00e1 desarrollando el escaneado (opcional). Se invoca a esp_wifi_scan_start() para configurar el escaneado. Para ello, se utilizan los par\u00e1metros por defecto o se configuran tal y como se ha especificado en la secci\u00f3n anterior. En este caso, el tipo de escaneado exige fijar el SSID y canal a 0. Fase 2: Fase de escaneado El driver WiFi cambia al canal 1 y emite (en caso de escaneado activo) en modo broadcast un paquete de tipo probe request . En caso de escaneado pasivo, seguir\u00e1 escuchando en el canal 1 durante un tiempo determinado a la espera de beacons . En cualquier caso, el valor por defecto de espera es de 120 milisengundos. El driver cambia al canal 2 y repite el proceso. El proceso se repite para N canales, donde N viene configurado seg\u00fan el pa\u00eds en el que se lleva a cabo el an\u00e1lisis. Fase 3: Fase de an\u00e1lisis de resultados Cuando todos los canales se han escaneado, se emite un evento de tipo WIFI_EVENT_SCAN_DONE . La aplicaci\u00f3n, a trav\u00e9s del callback correspondiente, recibe y procesa los resultados. Se invoca a esp_wifi_scan_get_ap_num() para obtener el n\u00famero de APs que se han encontrado. A continuaci\u00f3n, aloja suficientes entradas e invoca a esp_wifi_scan_get_ap_records() para obtener la informaci\u00f3n de cada AP. An\u00e1lisis de un ejemplo ( wifi/scan ) Analiza el ejemplo de escaneado, e intenta observar el flujo de trabajo detallado anteriormente. Tarea Compila, flashea y ejecuta el ejemplo de escaneado. Observa si los resultados son los esperados en el laboratorio o en un entorno dom\u00e9stico. Modifica el c\u00f3digo para conseguir distintos tipos de escaneado, asegur\u00e1ndote, por ejemplo, de que si fijas un canal espec\u00edfico en el que tu punto de acceso est\u00e1 trabajando, \u00e9ste es detectado corretamente. Estudia y modifica los tiempos de espera en el escaneado y observa su efecto en el tiempo total de escaneado. Documenta las modificaciones realizadas y las observaciones que consideres de inter\u00e9s. Conexi\u00f3n a una red WPA2 Enterprise ( eduroam ) Las \u00faltimas versiones de ESP-IDF permiten la conexi\u00f3n a redes con autenticaci\u00f3n RADIUS, como por ejemplo eduroam . Aunque los detalles de configuraci\u00f3n y desarrollo de un ejemplo concreto van m\u00e1s all\u00e1 del objetivo de la pr\u00e1ctica, es deseable realizar una prueba de conexi\u00f3n a eduroam en el laboratorio, ya que nos resultar\u00e1 de utilidad de cara a futuras pr\u00e1cticas. Como preparaci\u00f3n, debemos utilizar la \u00faltima versi\u00f3n de ESP-IDF, disponible en Github, en lugar de la versi\u00f3n 4.1 que has utilizado hasta ahora. Para ello, en un directorio independiente del que has utilizado hasta ahora instala la \u00faltima versi\u00f3n de ESP-IDF siguiendo las mismas instrucciones que en la instalaci\u00f3n incial, pero clonando la rama master del repositorio, es decir, ejecutando la siguiente instrucci\u00f3n exclusivamente: git clone --recursive https://github.com/espressif/esp-idf.git En lugar de las cadena de ordenes que usaste en la primera pr\u00e1ctica: ## NO EJECUTAR ESTAS ORDENES EN LA NUEVA INSTALACI\u00d3N git clone --recursive https://github.com/espressif/esp-idf.git cd esp-idf git fetch git checkout release/v4.1 git pull git submodule update --init --recursive En cualquier caso, tras la ejecuci\u00f3n anterior, deber\u00e1s instalar las dependencias de nuevo y a continuaci\u00f3n exportar las variables de entorno correctas: sh install.sh . export.sh Conexi\u00f3n a eduroam ( wifi/wpa2_enterprise ) Para conectar a eduroam nuestro ESP32, necesitaremos seguir los siguientes pasos: Descarga el certificado de la CA de la UCM desde este enlace . Copia el fichero descargado, con nombre eduroam.crt al directorio main , y as\u00edgnale el nombre wpa2_ca.pem . Configura el proyecto a trav\u00e9s de idf.py menuconfig con los siguientes par\u00e1metros: SSID: eduroam Validate server: activo EAP method: TTLS Phase2 method for TTLS: PAP EAP ID: anonymous@ucm.es EAP USERNAME: tuusuario@ucm.es EAP PASSWORD: (tu contrase\u00f1a UCM) Tarea Configura, compila y ejecuta el ejemplo de autenticaci\u00f3n y adjunta una captura de pantalla que demuestre la correcta conexi\u00f3n a eduroam .","title":"Pr\u00e1ctica 2"},{"location":"RPI-I/P2/#practica-2-soporte-wifi-en-el-esp32","text":"","title":"Pr\u00e1ctica 2. Soporte WiFi en el ESP32"},{"location":"RPI-I/P2/#objetivos","text":"Conocer el flujo de trabajo del driver WiFi en ESP-IDF. Analizar las diferencias entre un firmware desarrollado para trabajar en modo station y en modo AP . Desarrollar un firmware combinado para que funcione en modo AP y station de forma simult\u00e1nea. Conocer los mecanismos de escaneado de redes en ESP-IDF. Conectar a redes v\u00eda WPA2 Enterprise desde el ESP32 ( eduroam ).","title":"Objetivos"},{"location":"RPI-I/P2/#introduccion","text":"Las bibliotecas y componentes de soporte WiFi en ESP-IDF proporcionan soporte para configurar y monitorizar la conexi\u00f3n 802.11 sobre placas ESP32. Este soporte incluye configuraciones para: Modo station (modo cliente WiFi, o STA ). En este caso, el ESP32 conecta con un punto de acceso preconfigurado. Modo AP (tambi\u00e9n denominado softAP o modo Punto de Acceso ). En este caso, son las estaciones las que conectan al ESP32. Modo combinado AP-STA, donde el ESP32 es act\u00faa de forma concurrente como Punto de Acceso y cliente WiFi conectado a otro punto de acceso. Varios modos de seguridad tanto en modo cliente como en modo AP (WPA, WPA2, WEP, etc.) Escaneado de puntos de acceso (activo y pasivo). Provisionamiento de claves y modo WPS. Modo promiscuo para monitorizaci\u00f3n de paquetes IEEE 802.11. En la presente pr\u00e1ctica, a trav\u00e9s de ejemplos b\u00e1sicos, estudiaremos las caracter\u00edsticas principales soportadas por el driver WiFi sobre el ESP32. Todas estas caracter\u00edsticas pueden ser utilizadas a posteriori para el desarrollo de c\u00f3digos y proyectos m\u00e1s complejos con m\u00ednimas modificaciones.","title":"Introducci\u00f3n"},{"location":"RPI-I/P2/#modelo-de-programacion-del-driver-wifi-en-esp-idf","text":"El modelo de programaci\u00f3n del driver WiFi en ESP-IDF sigue un modelo de programaci\u00f3n sencillo que se puede resumir en la siguiente imagen: Puede considerarse que el driver WiFi es una caja negra que desconoce cualquier detalle de la aplicaci\u00f3n a mayor nivel, por ejemplo de la pila TCP/IP, las tareas de aplicaci\u00f3n, los eventos, etc. El c\u00f3digo de las tareas de aplicaci\u00f3n generalmente invoca a la API WiFi para inicializar el dispositivo inal\u00e1mbrico y tratar eventos espec\u00edficos cuando resulta necesario. El driver WiFi recibe invocaciones a su API, las procesa y emite eventos a la aplicaci\u00f3n. El tratamiento de eventos WiFi se basa en la biblioteca de eventos esp_event ; los eventos se env\u00edan por parte del driver a bucle de tratamiento de eventos por defecto . La aplicaci\u00f3n procesa estos eventos en funciones callback registradas previamente a trav\u00e9s de la funci\u00f3n esp_event_handler_register() . Alg\u00fan tipo de eventos es tambi\u00e9n procesado por el componente esp_netif para proporcionar reacciones por defecto ante su recepci\u00f3n; un ejemplo claro sucede de forma transparente cuando un dispositivo se conecta a un AP, momento en el cual esp_netif arranca un cliente DHCP para obtener una direcci\u00f3n IP sin intervenci\u00f3n del c\u00f3digo de usuario (aunque este comportamiento por defecto puede ser personalizado para, por ejemplo, asignar una direcci\u00f3n IP est\u00e1ticamente). Nota Toda la API mencionada a continuaci\u00f3n se encuentra descrita en profundidad en este enlace . Se aconseja disponer de esta informaci\u00f3n durante el proceso de desarrollo y tambi\u00e9n en el propio desarrollo de la pr\u00e1ctica.","title":"Modelo de programaci\u00f3n del driver WiFi en ESP-IDF"},{"location":"RPI-I/P2/#eventos-wifi","text":"Se listan a continuaci\u00f3n algunos de los ejemplos m\u00e1s utilizados en la gesti\u00f3n de conexiones WiFi, que utilizaremos en los ejemplos posteriores. WIFI_EVENT_SCAN_DONE Este evento se env\u00eda autom\u00e1ticamente en la invocaci\u00f3n de esp_wifi_scan_start() , en los siguientes escenarios: El escaneado de redes se completa, es decir, se ha encontrado el punto de acceso (AP) objetivo. El escaneado de redes finaliza tras la invocaci\u00f3n de esp_wifi_scan_stop() . Se invoca al inicio de un nuevo escaneo (mediante la rutina esp_wifi_scan_start() ) antes de finalizar un escaneado previo. Este nuevo escaneado se superpondr\u00e1 al anterior y se emitir\u00e1 el evento. El evento no se emite cuando el escaneado se fuerza mediante la invocaci\u00f3n a esp_wifi_connect() . Ante la recepci\u00f3n de este evento, no se lanza ning\u00fan proceso espec\u00edfico como respuesta. La aplicaci\u00f3n necesitar\u00e1 invocar normalmente a esp_wifi_scan_get_ap_num() y a esp_wifi_scan_get_ap_records() para recoger la lista de APs escaneados y liberar los recursos (memoria) que se aloja en el proceso de escaneado. WIFI_EVENT_STA_START Este evento se env\u00eda cuando, tras la invocaci\u00f3n a esp_wifi_start() , \u00e9sta devuelve ESP_OK . Tras la recepci\u00f3n de este evento, se inicializa la interfaz de red, por lo que normalmente, tras la recepci\u00f3n de este evento se est\u00e1 listo para invocar a esp_wifi_connect() para comenzar el proceso de conexi\u00f3n con un punto de acceso (AP). WIFI_EVENT_STA_STOP Este evento se env\u00eda cuando, tras la invocaci\u00f3n a esp_wifi_stop() , \u00e9sta devuelve ESP_OK . Tras la recepci\u00f3n de este evento, se libera la direcci\u00f3n IP, se detiene el cliente DHCP y se liberan las conexiones TCP/UDP existentes. Normalmente no se trata desde el punto de vista de la aplicaci\u00f3n. WIFI_EVENT_STA_CONNECTED Este evento se env\u00eda cuando, tras la invocaci\u00f3n a esp_wifi_connect() , \u00e9sta devuelve ESP_OK . Tras la recepci\u00f3n de este evento, arranca un cliente DHCP para la obtenci\u00f3n de una direcci\u00f3n IP. A continuaci\u00f3n, si todo ha ido bien, el driver WiFi est\u00e1 listo para enviar y recibir datos. Dicho instante es el adecuado para comenzar con la l\u00f3gica de la aplicaci\u00f3n, siempre que \u00e9sta no dependa de la correcta obtenci\u00f3n de una direcci\u00f3n IP. Si este es el caso, ser\u00e1 necesario esperar a la obtenci\u00f3n de la misma esperando al evento WIFI_EVENT_STA_GOT_IP . WIFI_EVENT_STA_DISCONNECTED Este evento se genera en los siguientes escenarios: Cuando se invoca a las funciones esp_wifi_disconnect() , esp_wifi_stop() , esp_wifi_deinit() o esp_wifi_restart() y la estaci\u00f3n est\u00e1 conectada al punto de acceso. Cuando se invoca a esp_wifi_connect() , pero el driver WiFi no consigue configurar una conexi\u00f3n con el AP debido a cualquier raz\u00f3n (por ejemplo, el escaneo no puede encontrar el AP objetivo, el proceso de autenticaci\u00f3n no tiene \u00e9xito, etc. Si hay m\u00e1s de un AP con el mismo SSID, el evento se emite s\u00f3lo cuando el dispositivo no puede conectar a ninguno de los APs encontrados. Cuando la conexi\u00f3n WiFi se interrumpe, por ejemplo porque el dispositivo pierde N beacons emitidos por el AP, el AP expulsa al dispositivo, el modo de autenticaci\u00f3n cambia, etc. Resulta com\u00fan que la rutina de tratamiento del evento trate de invocar de nuevo a la funci\u00f3n esp_wifi_connect() para reintentar la conexi\u00f3n. WIFI_EVENT_STA_GOT_IP Este evento se emite cuando el cliente DHCP obtiene una direcci\u00f3n IPv4 desde un servidor DHCP, o cuando se modifica su direcci\u00f3n IPv4. El evento significa que todo est\u00e1 listo y que la aplicaci\u00f3n puede continuar con sus tareas (por ejemplo, creaci\u00f3n de sockets, inicializaci\u00f3n de protocolos, etc.) La direcci\u00f3n IPv4 podr\u00eda modificarse por alguna de las siguientes razones: El cliente DHCP no puede renovar la direcci\u00f3n IPv4 tras su expiraci\u00f3n (los servidores DHCP suelen conceder direcciones IP durante un tiempo limitado). El cliente DHCP se asocia a otra direcci\u00f3n. Se modifica la direcci\u00f3n IPv4 asignada est\u00e1ticamente (no v\u00eda DHCP). Normalmente, cuando la IP cambia, todos los sockets asociados a ella quedar\u00e1n en un estado no utilizable. As\u00ed, la recepci\u00f3n de este evento se suele aprovechar para cerrar y a continuaci\u00f3n recrear todos los sockets abiertos. WIFI_EVENT_STA_LOST_IP Evento emitido cuando una direcci\u00f3n IPv4 se convierte en una direcci\u00f3n inv\u00e1lida. El evento no se emite inmediatamente tras la desconexi\u00f3n WiFi, sino que inicializa un temporizador de tipo address lost . Si se obtiene una IP antes de su expiraci\u00f3n, el evento no se emite. En otro caso, se emite justo en el instante de expirci\u00f3n del temporizador. Normalmente, las aplicaciones no deben tratar este evento (suele usarse en tareas de depuraci\u00f3n). WIFI_EVENT_AP_START Emitido en el inicio de un AP (punto de acceso). WIFI_EVENT_AP_STACONNECTED Cuando un dispositivo ( station ) se conecta a un AP, \u00e9ste emite el event WIFI_EVENT_AP_STACONNECTED . Es posible ignorarlo, o aprovecharlo para obtener informaci\u00f3n sobre la estaci\u00f3n conectada, por ejemplo. WIFI_EVENT_AP_STADISCONNECTED Este evento se genera en los siguientes escenarios: La aplicaci\u00f3n invoca a esp_wifi_disconnect() o esp_wifi_deauth_sta() para desconectarla manualmente del punto de acceso. El driver WiFi expulsa al dispositivo ( station ), por ejemplo en una situaci\u00f3n en la que el AP no ha recibido paquetes en los \u00faltimos minutos. Cuando ocurre este evento, la aplicaci\u00f3n necesitar\u00eda (idealmente) tomar las medidas necesarias asociadas al mismo, por ejemplo, cerrar los sockets abiertos.","title":"Eventos WiFi"},{"location":"RPI-I/P2/#modo-station","text":"La siguiente figura describe, a grandes rasgos, algunos de los escenarios principales que pueden darse en modo station : Se analizan a continuaci\u00f3n las fases principales en este tipo de firmware (no todas tienen que estar necesariamente presentes en cualquier escenario). Fase 1: inicializaci\u00f3n WiFi La tarea principal invoca a esp_netif_init() para crear la pila IP y realizar las tareas de inicializaci\u00f3n pertinentes. La tarea principal invoca a esp_event_loop_create() para crear e inicializar el sistema de eventos. La tarea principal invoca a esp_netif_create_default_wifi_sta() para crear la interfaz de red que asocia el dispositivo con la pila TCP/IP. La tarea principal invoca a esp_wifi_init() para crear la tarea que manejar\u00e1 la conexi\u00f3n WiFi e inicializa el driver WiFi. Por \u00faltimo, se invoca (si as\u00ed se desea, aunque es lo m\u00e1s com\u00fan) a la API para la creaci\u00f3n de la tarea o tareas de aplicaci\u00f3n. Esta secuencia es la recomendada para la inicializaci\u00f3n del sistema de comunicaci\u00f3n WiFi, pero no es estrictamente obligatorio seguirla en dicho orden o en su totalidad. Por ejemplo, se podr\u00eda crear directamente una tarea de aplicaci\u00f3n (paso 5) y realizar la configuraci\u00f3n en su cuerpo, o se puede diferir su creaci\u00f3n hasta la obtenci\u00f3n de una direcci\u00f3n IP. Fase 2: configuraci\u00f3n WiFi Una vez inicializado el driver WiFi, comienza su configuraci\u00f3n. En este escenario, el modo debe fijarse a station a trav\u00e9s de una invocaci\u00f3n a esp_wifi_set_mode(WIFI_MODE_STA) . Es posible invocar a continuaci\u00f3n a otras rutinas de tipo esp_wifi_set_xxx() para configurar par\u00e1metros adicionales (pa\u00eds, ancho de banda, modo de protocolo, ...). Para m\u00e1s informaci\u00f3n sobre los modos de operaci\u00f3n ( station , AP o modo combinado station/AP , consulta el siguiente enlace ). Generalmente, es necesario configurar el driver WiFi antes de establecer una conexi\u00f3n, pero no es obligatorio: es posible reconfigurarlo en cualquier momento, siempre que el driver est\u00e9 correctamente incializado. En cualquier caso, si la configuraci\u00f3n no tiene que modificarse tras la conexi\u00f3n, es mejor realizarla en este punto, porque algunos de los par\u00e1metros que pueden variar forzar\u00e1n una reconexi\u00f3n WiFi, aspecto que es mejor evitar. La rutina esp_wifi_set_config() permite configurar los aspectos b\u00e1sicos de la conexi\u00f3n WiFi. Por ejemplo, el c\u00f3digo: wifi_config_t wifi_config = { .sta = { .ssid = EXAMPLE_ESP_WIFI_SSID, .password = EXAMPLE_ESP_WIFI_PASS, .threshold.authmode = WIFI_AUTH_WPA2_PSK, .pmf_cfg = { .capable = true, .required = false }, }, }; ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA) ); ESP_ERROR_CHECK(esp_wifi_set_config(ESP_IF_WIFI_STA, &wifi_config) ); Realiza una configuraci\u00f3n b\u00e1sica WiFi proporcionando SSID, contrase\u00f1a y modo de autenticaci\u00f3n antes de configurar la conexi\u00f3n. Fase 3: inicio WiFi Invocaci\u00f3n a esp_wifi_start() para iniciar el driver WiFi. El driver WiFi envia un evento WIFI_EVENT_STA_START , que ser\u00e1 tratado por la tarea de gesti\u00f3n de eventos por defecto para realizar las tareas necesarias e invocar\u00e1 a la runtina de tratamiento del evento a nivel de aplicaci\u00f3n. La aplicaci\u00f3n deber\u00e1 tratar el evento WIFI_EVENT_STA_START , invocando (se recomienda) a esp_wifi_connect() . Fase 4: conexi\u00f3n WiFi Una vez invocada esp_wifi_connect() , el dirver WiFi comienza un proceso interno de escaneado/conexi\u00f3n. Si dicho proceso tiene \u00e9xito, se genera un evento WIFI_EVENT_STA_CONNECTED . Autom\u00e1ticamente se invoca al cliente DHCP y comienza el proceso de obtenci\u00f3n de direcci\u00f3n IP. Generalmente, la aplicaci\u00f3n no suele responder a este evento, pero podr\u00eda por ejemplo imprimirse un mensaje por pantalla a modo de depuraci\u00f3n. En el segundo paso, la conexi\u00f3n podr\u00eda fallar, por ejemplo, si la contrase\u00f1a proporcionada es incorrecta. En dicho caso, se env\u00eda un evento de tipo WIFI_EVENT_STA_DISCONNECTED y se proporcionar\u00e1 la causa del error. En el paso 6 se trata este aspecto. Fase 5: obtenci\u00f3n de IP Una vez inicializado el cliente DHCP (paso 4.2) comienza la fase de obtenci\u00f3n de IP. Si se recibe con \u00e9xito una IP desde el servidor DHCP, se emite un evento de tipo IP_EVENT_STA_GOT_IP) . La aplicaci\u00f3n trar\u00e1 este evento de forma acorde. Realmente, en este punto puede comenzar la l\u00f3gica de red de la aplicaci\u00f3n, incluyendo, por ejemplo, la creaci\u00f3n de sockets TCP/UDP. Es imprescindible la recepci\u00f3n de una direcci\u00f3n IP antes de la inicializaci\u00f3n de sockets. Fase 6: desconexi\u00f3n WiFi Cuando finaliza de forma abrupta una conexi\u00f3n WiFi, por ejemplo al apagar el punto de acceso (AP), si la calidad de recepci\u00f3n (RSSI) es baja, etc. se emite un evento WIFI_EVENT_STA_DISCONNECTED . La tarea de aplicaci\u00f3n deber\u00eda tratar este evento para, t\u00edpicamente, reintentar la conexi\u00f3n a trav\u00e9s de una invocaci\u00f3n a esp_wifi_reconnect() . Fase 7: cambio de IP Cuando la direcci\u00f3n IP asignada a un dispositivo cambia, se emite un evento de tipo IP_EVENT_STA_GOT_IP . Por defecto, y de forma autom\u00e1tica, se activa el campo ip_change de la estructura de tipo ip_event_got_ip_t que acompa\u00f1a al evento. La aplicaci\u00f3n deber\u00eda tomar las medidas necesarias (por ejemplo, recreaci\u00f3n de sockets) para mantenerse en un estado consistente. Fase 8: terminaci\u00f3n WiFi Invocaci\u00f3n a esp_wifi_disconnect() para desconectar la conexi\u00f3n en marcha. Invocaci\u00f3n a esp_wifi_stop() para parar el driver WiFi. Invocaci\u00f3n a esp_wifi_deinit() para descargar el driver WiFi.","title":"Modo Station"},{"location":"RPI-I/P2/#analisis-de-un-ejemplo-wifigetting_startedstation","text":"Tarea Analiza el ejemplo station , comp\u00edlalo y flashealo. Estudia el tratamiento de eventos que realiza, y c\u00f3mo estos son emitidos para casos reales. Para ello, conecta tu ESP32 con un punto de acceso existente, otro inexistente, apaga el punto de acceso mientras la IP est\u00e1 concedida, y analiza los eventos generados y su respuesta. Si no existe respuesta a alguno de ellos, a\u00f1\u00e1dela. Documenta las observaciones que consideres de inter\u00e9s y las posibles modificaciones realizadas en tu memoria.","title":"An\u00e1lisis de un ejemplo (wifi/getting_started/station)"},{"location":"RPI-I/P2/#modo-punto-de-acceso","text":"La siguiente figura describe, a grandes rasgos, algunos de los escenarios principales que pueden darse en modo AP (access point) : El flujo de trabajo es muy similar al del modo station , con la diferencia b\u00e1sica del tipo de configuraci\u00f3n WiFi a realizar ( WIFI_MODE_AP ) y obviamente los par\u00e1metros de configuraci\u00f3n. Observa el siguiente ejemplo de configuraci\u00f3n: wifi_config_t wifi_config = { .ap = { .ssid = EXAMPLE_ESP_WIFI_SSID, .ssid_len = strlen(EXAMPLE_ESP_WIFI_SSID), .channel = EXAMPLE_ESP_WIFI_CHANNEL, .password = EXAMPLE_ESP_WIFI_PASS, .max_connection = EXAMPLE_MAX_STA_CONN, .authmode = WIFI_AUTH_WPA_WPA2_PSK }, }; if (strlen(EXAMPLE_ESP_WIFI_PASS) == 0) { wifi_config.ap.authmode = WIFI_AUTH_OPEN; } ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_AP)); ESP_ERROR_CHECK(esp_wifi_set_config(ESP_IF_WIFI_AP, &wifi_config)); Para m\u00e1s informaci\u00f3n sobre los par\u00e1metros de configuraci\u00f3n de un punto de acceso, consulta este enlace .","title":"Modo Punto de Acceso"},{"location":"RPI-I/P2/#analisis-de-un-ejemplo-wifigetting_startedsoftap","text":"Tarea Analiza el ejemplo softAP , comp\u00edlalo y flashealo. Estudia el tratamiento de eventos que realiza, y c\u00f3mo estos son emitidos para casos reales. Para ello, conecta distintos clientes ( stations ), bien sean ESP32 o cualquier otro dispositivo, y analiza los eventos generados y su respuesta. Si no existe respuesta a alguno de ellos, a\u00f1\u00e1dela. Documenta las observaciones que consideres de inter\u00e9s y las posibles modificaciones realizadas en tu memoria.","title":"An\u00e1lisis de un ejemplo (wifi/getting_started/softAP)"},{"location":"RPI-I/P2/#modo-combinado-stationpunto-de-acceso","text":"ESP-IDF soporta un modo mixto de conexi\u00f3n, en el que el ESP32 es a la vez un punto de acceso (AP) y una estaci\u00f3n ( station ). Este modo se configura utilizando el par\u00e1metro ESP_MODE_APSTA en la invocaci\u00f3n a la rutina esp_wifi_set_mode() . Adem\u00e1s, obviamente el firmware combinado requerir\u00e1 la creaci\u00f3n de dos estructuras de tipo wifi_config_t , una con los datos asociados al punto de acceso (campo .ap ) y otra con los campos asociados a la station (campo .sta ). A continuaci\u00f3n, ser\u00e1 necesario invocar a la rutina de configuraci\u00f3n ( esp_wifi_set_config ) con cada una de dichas estructuras (por \u00faltimo, tambi\u00e9n es necesario invocar a la inicializaci\u00f3n de netif tanto en modo station -- esp_netif_create_default_wifi_sta() -- como en modo AP -- esp_netif_create_default_wifi_ap() ).","title":"Modo combinado Station/Punto de Acceso"},{"location":"RPI-I/P2/#ejercicio-desarrollo-de-un-nodo-mixto-stationap","text":"Tarea Modifica el ejemplo station para que el ESP32 se comporte a la vez como estaci\u00f3n y como punto de acceso. A\u00f1ade las opciones de configuraci\u00f3n necesarias para que todos los par\u00e1metros se puedan modificar v\u00eda menuconfig . Comprueba que el ESP32 efectivamente se conecta al punto de acceso y que a la vez es posible conectar otro dispositivo al mismo (por ejemplo, tu tel\u00e9fono m\u00f3vil). Adjunta en la entrega tanto el c\u00f3digo como evidencias de su correcto funcionamiento.","title":"Ejercicio: desarrollo de un nodo mixto station/AP"},{"location":"RPI-I/P2/#escaneado-de-redes-wifi","text":"","title":"Escaneado de redes WiFi"},{"location":"RPI-I/P2/#modos-de-escaneado-de-redes-wifi","text":"El modo de escaneo de redes WiFi (es decir, la invocaci\u00f3n de la rutina esp_wifi_scan_start() ) s\u00f3lo est\u00e1 soportada en la actualidad en modo station o station+AP . En este modo, se da soporte a distintos tipos de escaneado de redes, v\u00e9ase: Escaneado activo: El escaneado se desarrolla mediante el env\u00edo de paquetes probe y esperando respuesta, de forma activa. Escaneado pasivo: El escaneado se desarrolla simplemente escuchando en cada canal y esperando el env\u00edo por parte de los APs de paquetes de balizamiento ( beacons ). El modo activo o pasivo puede configurarse desde la aplicaci\u00f3n, mediante el campo scan_type de la estrcutura wifi_scan_config_t (lo ver\u00e1s en el siguiente ejemplo). Escaneado en primer plano: : Se utiliza cuando no hay conexi\u00f3n WiFi activa en el momento del escaneado. No es, por tanto, directamente configurable. Escaneado en segundo plano: Se utiliza cuando hay conexi\u00f3n WiFi activa en el momento del escaneado. No es, por tanto, directamente configurable. Escaneado de todos los canales: Escanea SSIDs en todos los canales. La forma de activarlo es mediante el valor 0 en el campo correspondiente de wifi_scan_config_t . Escaneado de canal espec\u00edfico: Escanea \u00fanicamente en un canal. As\u00ed, existen 8 modos distintos de escaneado de red WiFi, resultantes de la combinaci\u00f3n de los anteriores modos, llamados: All-Channel Background Active Scan. All-Channel Background Passive Scan. All-Channel Foreground Active Scan. All-Channel Foreground Passive Scan. Specific-Channel Background Active Scan. Specific-Channel Background Passive Scan. Specific-Channel Foreground Active Scan. Specific-Channel Foreground Passive Scan.","title":"Modos de escaneado de redes WiFi"},{"location":"RPI-I/P2/#configuracion-de-escaneado-de-redes-wifi","text":"Para configurar una sesi\u00f3n de escaneado, se utilizan los campos correspondientes de la estructura de tipo wifi_scan_config_t , proporcionada a la rutina esp_wifi_scan_start() , que es la encargada de iniciar la sesi\u00f3n. Los campos de dicha estructura son: ssid : Si SSID no es NULL, s\u00f3lo se escanea en b\u00fasqueda de este ssid . channel : Si es 0, se realiza un escaneado de todos los canales. En caso contrario, s\u00f3lo se escanea el canal especificado. show_hidden : Si es 0, se ignoran los AP con SSID oculto. En caso contrario se consideran SSIDs normales, y por tanto se muestran. scan_type : Si tma el valor WIFI_SCAN_TYPE_ACTIVE realiza un escaneado activo. En cualquier otro caso, el escaneado es pasivo. scan_time : Especifica el tiempo de escaneado por canal.","title":"Configuraci\u00f3n de escaneado de redes WiFi"},{"location":"RPI-I/P2/#escaneado-de-todos-los-canales-en-primer-plano-ejemplo-de-flujo","text":"El siguiente escenario describe un escaneado b\u00e1sico sobre todos los canales en primer plano (recuerda que \u00fanicamente puede ocurrir en modo station si todav\u00eda no hay conexi\u00f3n a un AP). Fase 1: Configuraci\u00f3n del escaneado Se invoca a la rutina esp_wifi_set_country() para establecer el pa\u00eds donde se est\u00e1 desarrollando el escaneado (opcional). Se invoca a esp_wifi_scan_start() para configurar el escaneado. Para ello, se utilizan los par\u00e1metros por defecto o se configuran tal y como se ha especificado en la secci\u00f3n anterior. En este caso, el tipo de escaneado exige fijar el SSID y canal a 0. Fase 2: Fase de escaneado El driver WiFi cambia al canal 1 y emite (en caso de escaneado activo) en modo broadcast un paquete de tipo probe request . En caso de escaneado pasivo, seguir\u00e1 escuchando en el canal 1 durante un tiempo determinado a la espera de beacons . En cualquier caso, el valor por defecto de espera es de 120 milisengundos. El driver cambia al canal 2 y repite el proceso. El proceso se repite para N canales, donde N viene configurado seg\u00fan el pa\u00eds en el que se lleva a cabo el an\u00e1lisis. Fase 3: Fase de an\u00e1lisis de resultados Cuando todos los canales se han escaneado, se emite un evento de tipo WIFI_EVENT_SCAN_DONE . La aplicaci\u00f3n, a trav\u00e9s del callback correspondiente, recibe y procesa los resultados. Se invoca a esp_wifi_scan_get_ap_num() para obtener el n\u00famero de APs que se han encontrado. A continuaci\u00f3n, aloja suficientes entradas e invoca a esp_wifi_scan_get_ap_records() para obtener la informaci\u00f3n de cada AP.","title":"Escaneado de todos los canales en primer plano. Ejemplo de flujo"},{"location":"RPI-I/P2/#analisis-de-un-ejemplo-wifiscan","text":"Analiza el ejemplo de escaneado, e intenta observar el flujo de trabajo detallado anteriormente. Tarea Compila, flashea y ejecuta el ejemplo de escaneado. Observa si los resultados son los esperados en el laboratorio o en un entorno dom\u00e9stico. Modifica el c\u00f3digo para conseguir distintos tipos de escaneado, asegur\u00e1ndote, por ejemplo, de que si fijas un canal espec\u00edfico en el que tu punto de acceso est\u00e1 trabajando, \u00e9ste es detectado corretamente. Estudia y modifica los tiempos de espera en el escaneado y observa su efecto en el tiempo total de escaneado. Documenta las modificaciones realizadas y las observaciones que consideres de inter\u00e9s.","title":"An\u00e1lisis de un ejemplo (wifi/scan)"},{"location":"RPI-I/P2/#conexion-a-una-red-wpa2-enterprise-eduroam","text":"Las \u00faltimas versiones de ESP-IDF permiten la conexi\u00f3n a redes con autenticaci\u00f3n RADIUS, como por ejemplo eduroam . Aunque los detalles de configuraci\u00f3n y desarrollo de un ejemplo concreto van m\u00e1s all\u00e1 del objetivo de la pr\u00e1ctica, es deseable realizar una prueba de conexi\u00f3n a eduroam en el laboratorio, ya que nos resultar\u00e1 de utilidad de cara a futuras pr\u00e1cticas. Como preparaci\u00f3n, debemos utilizar la \u00faltima versi\u00f3n de ESP-IDF, disponible en Github, en lugar de la versi\u00f3n 4.1 que has utilizado hasta ahora. Para ello, en un directorio independiente del que has utilizado hasta ahora instala la \u00faltima versi\u00f3n de ESP-IDF siguiendo las mismas instrucciones que en la instalaci\u00f3n incial, pero clonando la rama master del repositorio, es decir, ejecutando la siguiente instrucci\u00f3n exclusivamente: git clone --recursive https://github.com/espressif/esp-idf.git En lugar de las cadena de ordenes que usaste en la primera pr\u00e1ctica: ## NO EJECUTAR ESTAS ORDENES EN LA NUEVA INSTALACI\u00d3N git clone --recursive https://github.com/espressif/esp-idf.git cd esp-idf git fetch git checkout release/v4.1 git pull git submodule update --init --recursive En cualquier caso, tras la ejecuci\u00f3n anterior, deber\u00e1s instalar las dependencias de nuevo y a continuaci\u00f3n exportar las variables de entorno correctas: sh install.sh . export.sh","title":"Conexi\u00f3n a una red WPA2 Enterprise (eduroam)"},{"location":"RPI-I/P2/#conexion-a-eduroam-wifiwpa2_enterprise","text":"Para conectar a eduroam nuestro ESP32, necesitaremos seguir los siguientes pasos: Descarga el certificado de la CA de la UCM desde este enlace . Copia el fichero descargado, con nombre eduroam.crt al directorio main , y as\u00edgnale el nombre wpa2_ca.pem . Configura el proyecto a trav\u00e9s de idf.py menuconfig con los siguientes par\u00e1metros: SSID: eduroam Validate server: activo EAP method: TTLS Phase2 method for TTLS: PAP EAP ID: anonymous@ucm.es EAP USERNAME: tuusuario@ucm.es EAP PASSWORD: (tu contrase\u00f1a UCM) Tarea Configura, compila y ejecuta el ejemplo de autenticaci\u00f3n y adjunta una captura de pantalla que demuestre la correcta conexi\u00f3n a eduroam .","title":"Conexi\u00f3n a eduroam (wifi/wpa2_enterprise)"},{"location":"RPI-I/P3/","text":"Pr\u00e1ctica 3. WiFi. Conceptos avanzados (WiFi Mesh, provisionamiento y ahorro de energ\u00eda) Objetivos La presente pr\u00e1ctica se divide en tres partes principales, que abordan tres temas avanzados relacionados con la conectividad WiFi en ESP-IDF y en el ESP32. Los objetivos en cada punto son: WiFi MESH Revisar los conceptos b\u00e1sicos para la construcci\u00f3n de una red MESH WiFi autogestionada. Presentar la API b\u00e1sica para la creaci\u00f3n de aplicaciones basadas en la pila ESP-MESH. Observar en funcionamiento una red ESP-MESH, as\u00ed como sus capacidades de autoconfiguraci\u00f3n. Provisionamiento Entender y experimentar con distintos modos de provisionamiento de credenciales WiFi, v\u00eda BLE y v\u00eda softAP . Comprobar el intercambio de claves en claro realizando provisionamientos desde l\u00ednea de comandos, as\u00ed como observar la utilidad (y necesidad) del env\u00edo cifrado de credenciales. Ahorro de energ\u00eda Entender los tres modos de funcionamiento del ESP32 a nivel de ahorro energ\u00e9tico en conexiones WiFi. Observar la desviaci\u00f3n en latencia de recepci\u00f3n de paquetes en funci\u00f3n del modo aplicado. Parte 1. WiFi Mesh (ESP MESH) El stack ESP-MESH est\u00e1 construido por encima del driver WiFi (es decir, obviamente hace uso de sus servicios), y en algunos casos tambi\u00e9n haciendo uso de servicios de la pila IP ( lwIP ), por ejemplo en el nodo ra\u00edz, que es el \u00fanico con comunicaci\u00f3n IP contra un router de borde. El siguiente diagrama muestra la situaci\u00f3n de la pila Mesh en ESP-IDF: Como cualquier otro componente ESP-IDF, ESP-MESH se comunica con las aplicaciones a trav\u00e9s de eventos propios: El tipo mesh_event_id_t define todos los posibles eventos que pueden surgir en las distintas fases del ciclo de vida de una red (por ejemplo, para un nodo determinado, conexi\u00f3n o desconexi\u00f3n de su nodo padre, o de uno de sus nodos hijo). Antes de utilizar los eventos ESP-MESH para gestionar u observar el funcionamiento de la red, es necesario registrarlos v\u00eda esp_event_handler_register() . Algunos usos t\u00edpicos de los eventos incluyen, por ejemplo, la situaci\u00f3n de conexi\u00f3n de un nodo padre ( MESH_EVENT_PARENT_CONNECTED ) o de un hijo ( MESH_EVENT_CHILD_CONNECTED ), indicando, respectivamente, que un nodo puede comenzar a emitir hacia arriba en el grafo, o hacia abajo. Del mismo modo, en un nodo ra\u00edz, la recepci\u00f3n de los eventos IP_EVENT_STA_GOT_IP y IP_EVENT_STA_LOST_IP se pueden aprovechar para indicar que dicho nodo ra\u00edz puede o no enviar datos a la red IP externa. Eventos MESH_EVENT_STARTED : mesh iniciada. MESH_EVENT_STOPPED : mesh finalizada. MESH_EVENT_CHANNEL_SWITCH : cambio de canal. MESH_EVENT_CHILD_CONNECTED : un hijo ha conectado a la interfaz softAP . MESH_EVENT_CHILD_DISCONNECTED : un hijo ha desconectado de la interfaz softAP . MESH_EVENT_ROUTING_TABLE_ADD : se han a\u00f1adido nuevas entradas a la tabla de enrutamiento a\u00f1adiendo nuevos hijos. MESH_EVENT_ROUTING_TABLE_REMOVE : se ha eliminado entradas de la tabla de enrutamiento eliminado hijos que han abandonado la red. MESH_EVENT_PARENT_CONNECTED : un padre se ha conectado a la interfaz station . MESH_EVENT_PARENT_DISCONNECTED : un padre se ha desconectado de la interfaz station . MESH_EVENT_NO_PARENT_FOUND : no se ha encontrado un padre. MESH_EVENT_LAYER_CHANGE : el nodo ha cambiado de nivel en la red. MESH_EVENT_TODS_STATE : indica que el nodo ra\u00edz es capaz de acceder a la red IP externa. MESH_EVENT_VOTE_STARTED : el proceso de voto de un nuevo nodo ra\u00edz ha comenzado. MESH_EVENT_VOTE_STOPPED : el proceo de voto de un nuevo nodo ra\u00edz ha finalizado. MESH_EVENT_ROOT_ADDRESS : se ha obtenido la direcci\u00f3n del nodo ra\u00edz. MESH_EVENT_ROOT_SWITCH_REQ : un nodo ra\u00edz candidato ya elegido solicita un cambio de nodo ra\u00edz. MESH_EVENT_ROOT_SWITCH_ACK : respuesta a la anterior petici\u00f3n por parte del nodo ra\u00edz actual. MESH_EVENT_NETWORK_STATE : la actual red tiene un nodo ra\u00edz. MESH_EVENT_STOP_RECONNECTION : el nodo ra\u00edz detiene el proceso de reconexi\u00f3n al router y los dem\u00e1s nodos detienen los procesos de conexi\u00f3n a sus nodos padre. MESH_EVENT_FIND_NETWORK : si el canal solicitado es 0, la pila escanear\u00e1 todos los canales para encontrar una red mesh a la que conectar, devolviendo el canal en el que lo ha conseguido. Uso de la pila IP El c\u00f3digo de una aplicaci\u00f3n que haga uso de ESP-MESH puede acceder directamente a la pila MESH sin pasar por la pila IP. De hecho, la pila IP s\u00f3lo es estrictamente necesaria por parte del nodo ra\u00edz, al ser el \u00fanico que puede recibir o transmitir datos desde o hacia la red IP externa. Sin embargo, como cualquier nodo de la topolog\u00eda puede potencialmente convertirse en nodo ra\u00edz (ya que su selecci\u00f3n es autom\u00e1tica), todos los nodos deber\u00e1n inicializar la pila IP. Por tanto, todos los nodos incializan la pila IP v\u00eda tcpip_adapter_init() . Adem\u00e1s, todos los nodos deber\u00e1n detener el servidor DHCP en la interfaz softAP , y el cliente DHCP en la interfaz station : /* tcpip initialization */ tcpip_adapter_init(); /* * for mesh * stop DHCP server on softAP interface by default * stop DHCP client on station interface by default */ ESP_ERROR_CHECK(tcpip_adapter_dhcps_stop(TCPIP_ADAPTER_IF_AP)); ESP_ERROR_CHECK(tcpip_adapter_dhcpc_stop(TCPIP_ADAPTER_IF_STA)); Sin embargo, en el caso de un nodo que se convierte en ra\u00edz, es imprescindible arrancar el cliente DHCP como respuesta al evento corresondiente para as\u00ed obtener direcci\u00f3n IP desde el router que da salida hacia la red externa. Estructura b\u00e1sica de una aplicaci\u00f3n ESP-MESH El siguiente c\u00f3digo muestra la estructura b\u00e1sica de inicializaci\u00f3n de pilas IP y WiFi necesarias para comenzar con la configuraci\u00f3n de la red MESH: tcpip_adapter_init(); /* * for mesh * stop DHCP server on softAP interface by default * stop DHCP client on station interface by default */ ESP_ERROR_CHECK(tcpip_adapter_dhcps_stop(TCPIP_ADAPTER_IF_AP)); ESP_ERROR_CHECK(tcpip_adapter_dhcpc_stop(TCPIP_ADAPTER_IF_STA)); /* event initialization */ ESP_ERROR_CHECK(esp_event_loop_create_default()); /* Wi-Fi initialization */ wifi_init_config_t config = WIFI_INIT_CONFIG_DEFAULT(); ESP_ERROR_CHECK(esp_wifi_init(&config)); /* register IP events handler */ ESP_ERROR_CHECK(esp_event_handler_register(IP_EVENT, IP_EVENT_STA_GOT_IP, &ip_event_handler, NULL)); ESP_ERROR_CHECK(esp_wifi_set_storage(WIFI_STORAGE_FLASH)); ESP_ERROR_CHECK(esp_wifi_start()); Tras esta inicializaci\u00f3n, comienza la fase de configuraci\u00f3n e inicializaci\u00f3n de la malla, que proceder\u00e1 en tres pasos principales: Inicializaci\u00f3n de la malla Configuraci\u00f3n de la red ESP-MESH Arranque de la red Paso 1. Inicializaci\u00f3n de la malla La inicializaci\u00f3n de la malla y registro de eventos propios es sencilla: /* mesh initialization */ ESP_ERROR_CHECK(esp_mesh_init()); /* register mesh events handler */ ESP_ERROR_CHECK(esp_event_handler_register(MESH_EVENT, ESP_EVENT_ANY_ID, &mesh_event_handler, NULL)); Paso 2. Configuraci\u00f3n de la red ESP-MESH La configuraci\u00f3n de ESP-MESH se realiza a trav\u00e9s de la funci\u00f3n esp_mesh_set_config() , que recibe una estructura de tipo mesh_cfg_t con la configuraci\u00f3n de la red: Par\u00e1metro Descripci\u00f3n Channel Canal (entre 1 y 14) Mesh ID Identificaci\u00f3n de la red MESH (6 bytes) Router SSID y contrase\u00f1a de conexi\u00f3n al router de salida Mesh AP Configuraci\u00f3n espec\u00edfica del AP generado por cada nodo Un ejemplo de configuraci\u00f3n podr\u00eda ser: /* Mesh ID */ static const uint8_t MESH_ID = { 0x77, 0x77, 0x77, 0x77, 0x77, 0x77 }; /* Enable the Mesh IE encryption by default */ mesh_cfg_t cfg = MESH_INIT_CONFIG_DEFAULT(); /* mesh ID */ memcpy((uint8_t *) &cfg.mesh_id, MESH_ID, 6); /* channel (must match the router's channel) */ cfg.channel = CONFIG_MESH_CHANNEL; /* router */ cfg.router.ssid_len = strlen(CONFIG_MESH_ROUTER_SSID); memcpy((uint8_t *) &cfg.router.ssid, CONFIG_MESH_ROUTER_SSID, cfg.router.ssid_len); memcpy((uint8_t *) &cfg.router.password, CONFIG_MESH_ROUTER_PASSWD, strlen(CONFIG_MESH_ROUTER_PASSWD)); /* mesh softAP */ cfg.mesh_ap.max_connection = CONFIG_MESH_AP_CONNECTIONS; memcpy((uint8_t *) &cfg.mesh_ap.password, CONFIG_MESH_AP_PASSWD, strlen(CONFIG_MESH_AP_PASSWD)); ESP_ERROR_CHECK(esp_mesh_set_config(&cfg)); Paso 3. Arranque de la red El arranque de la red MESH es sencillo: /* mesh start */ ESP_ERROR_CHECK(esp_mesh_start()); Tras el arranque, la aplicaci\u00f3n deber\u00eda comprobar los eventos para determinar si la conexi\u00f3n a la red ha sido exitosa. En dicho caso, tras la conexi\u00f3n, la aplicaci\u00f3n puede comenzar a transmitir paquetes a trav\u00e9s de la red MESH utilizando las rutinas esp_mesh_send() y esp_mesh_recv() . Ejercicio en clase. Despliegue conjunto de una red WiFi Mesh La forma m\u00e1s conveniente de observar el comportamiento de una red WiFi Mesh es desplegar una infraestructura con suficiente n\u00famero de nodos pertenecientes a una misma red. Desafortunadamente, para ello es necesario disponer de dichos nodos en un espacio cercano. En la presente pr\u00e1ctica, desplegaremos una red WiFi Mesh en el laboratorio, utilizando vuestro o vuestros ESP32 como elementos de la red. Para ello, configuraremos, compilaremos y ejecutaremos el ejemplo examples/mesh/internal_communication . Antes de proceder, configuraremos el proyecto para: Conectar al punto de acceso com\u00fan del laboratorio ( Router SSID y Router password ). Configurar la red ESP-MESH para utilizar WPA2_PSK y seleccionar como contrase\u00f1a password . Aumentar el n\u00famero de conexiones al AP a 10. De momento, no realizaremos ning\u00fan cambio en el c\u00f3digo del ejemplo. Compila y ejecuta tu c\u00f3digo. En la direcci\u00f3n del enlace dispones de una primera pesta\u00f1a en la que deber\u00e1s completar cierta informaci\u00f3n que observar\u00e1s en la salida de monitorizaci\u00f3n una vez arranques el ESP32, en la celda correspondiente a tu puesto. Esta informaci\u00f3n, en principio, incluye: Tu nombre. Direcciones MAC de las interfaces STA y SoftAP (lo observar\u00e1s en los primeros mensajes de salida). Capa de la topolog\u00eda en la que se encuentra tu nodo (lo observar\u00e1s en formato [L:XX] en los env\u00edos y recepciones de datos). En caso de haber sido elegido nodo ra\u00edz, anotar tambi\u00e9n esta circunstancia y la IP asignada por el router (observa la respuesta al evento correspondiente). Adem\u00e1s, anota la ID de la red Mesh que se ha utilizado para conectar. Antes de rellenar la informaci\u00f3n, espera que el profesor te indique que la topolog\u00eda ha convergido, y que por tanto no habr\u00e1 ning\u00fan cambio m\u00e1s en ella (siempre que ningun nodo deje de formar parte de la misma). Ejercicio entregable Captura el estado de la red cuando todos tus compa\u00f1eros hayan llegado al punto de convergencia, e intenta determinar, en forma de grafo, la topolog\u00eda de la misma. A continuaci\u00f3n, apagaremos el nodo ra\u00edz y esperaremos a la vuelta a la convergencia de la red. Ejercicio entregable Captura de nuevo el estado de la red cuando todos tus compa\u00f1eros hayan llegado al punto de convergencia, e intenta determinar, en forma de grafo, la topolog\u00eda de la misma. Como \u00faltimo ejercicio, vamos a crear nuevas redes Mesh en funci\u00f3n del puesto que tengas asignado. Observa los colores asignados a cada grupo de puestos en la siguiente hoja . Ejercicio en clase. Despliegue conjunto de una red WiFi Mesh de menores dimensiones Modifica tu c\u00f3digo para que el canal de escucha y el identificador de red coincidan con el indicado. Puedes configurar el canal a trav\u00e9s del men\u00fa de configuracion del ejemplo ( channel ) y el identificador modificando la variable correspondiente en el fichero mesh_main.c . Una vez hecho esto, reconstruid la informaci\u00f3n de las tablas para reflejar las nuevas topolog\u00edas. Pod\u00e9is hacer pruebas posteriores apagando el nodo ra\u00edz y observando la convergencia de la red. Ejercicio entregable Captura de nuevo el estado de la red cuando todos tus compa\u00f1eros hayan llegado al punto de convergencia, e intenta determinar, en forma de grafo, la topolog\u00eda de la misma. El estudio detallado del c\u00f3digo para el despliegue de la red queda como ejercicio para el alumno. Observa el tratamiento de eventos y la fase de configuraci\u00f3n de la red. Intenta entender el funcionamiento del c\u00f3digo (env\u00edos y recepciones, destinatarios de los mismos, etc.). Parte 2.Provisionamiento WiFi ESP-IDF proporciona un componente espec\u00edfico que ofrece un servicio de provisionamiento WiFi. Entendemos por provisionamiento WiFi el mecanismo o mecanismos mediante los cuales es posible proporcionar, de forma externa y segura, el conjunto de credenciales de conexi\u00f3n a una red WiFi a un dispositivo no conectado. El component de provisionamiento WiFi en ESP-IDF permite proporcionar dichas credenciales a trav\u00e9s de dos v\u00edas: Bluetooth Low Energy (modo BLE ) o a trav\u00e9s de un mecanismo de punto de acceso WiFi temporal (modo SoftAP ). ESP-IDF proporciona una serie de APIs (con prototipos wifi_prov_mgr_* ) para implementar de forma sencilla ambos modos de provisionamiento. Inicializaci\u00f3n del servicio de provisionamiento La rutina wifi_prov_mgr_init() se utiliza para configurar e inicializar el componente de provisionamiento, y debe invocarse antes de cualquier otra invocaci\u00f3n a rutinas de tipo wifi_prov_mgr* . Adem\u00e1s, es necesario destacar que el componente de provisionamiento conf\u00eda en las funcionalidades de otros componentes (b\u00e1sicamente NVS, TCP/IP, Event loop y mDNS), por lo que \u00e9stos deben inicializarse antes del propio componente. Para finalizar el componente de provisionamiento, es suficiente con invocar a la rutina wifi_prov_mgr_deinit() . Un ejemplo de inicializaci\u00f3n resultar\u00eda en: wifi_prov_mgr_config_t config = { .scheme = wifi_prov_scheme_ble, .scheme_event_handler = WIFI_PROV_SCHEME_BLE_EVENT_HANDLER_FREE_BTDM }; ESP_ERR_CHECK( wifi_prov_mgr_init(config) ); La estructura de configuraci\u00f3n de tipo wifi_prov_mgr_config_t dispone de campos que permiten especificar el comportamiento del componente; espec\u00edficamente, el campo scheme especifica el esquema (o tipo) de provisionamiento. Disponemos de tres opciones: wifi_prov_scheme_softap : transporta la informaci\u00f3n de provisionamiento v\u00eda WiFi (creando un punto de acceso temporal) y un servidor HTTP para recibir los comandos e informaci\u00f3n de provisionamiento. wifi_prov_scheme_ble : transporta la informaci\u00f3n de provisionamiento v\u00eda Bluetooth Low Energy (BLE) y un servidor GATT para recibir los comandos e informaci\u00f3n de provisionamiento. wifi_prov_scheme_console : transporta la informaci\u00f3n v\u00eda puerto serie y Comprobaci\u00f3n del estado de provisionamiento Es posible comprobar el estado de provisionamiento de un dispositivo mediante una invocaci\u00f3n a wifi_prov_mgr_is_provisioned() , que chequea si las credenciales de conexi\u00f3n WiFi est\u00e1n almacenadas en la memoria no vol\u00e1til (NVS). Aunque existen distintos m\u00e9todos para eliminar la informaci\u00f3n de provisionamento almacenada en la NVS, utilizaremos el mecanismo proporcionado por idf.py para eliminar su contenido. Para ello, ejecutaremos: idf.py erase_flash Par\u00e1metros de inicializaci\u00f3n del servicio de provisionamiento WiFi Al inicializar el componente de provisionamiento, es necesario especificar un nombre de servicio y una clave. Esto se traduce en: SSID y contrase\u00f1a para el modo SoftAP (es decir, cuando el esquema de provisionamiento se ha configurado como wifi_prov_scheme_softap ). Nombre del dispositivo BLE para el modo BLE (es decir, cuando el esquema de provisionamiento se ha configurado como wifi_prov_scheme_ble ). Adem\u00e1s, internamente el componente utiliza el mecanismo de comunicaci\u00f3n protocomm , que permite dos niveles de seguridad en la comunicaci\u00f3n de credenciales de provisionamiento: Nivel 1 de seguridad, que consiste en un handshake previo entre ambos extremos, con intercambio de claves y utilizaci\u00f3n de una prueba de posesi\u00f3n (PoP, proof of possession ), y utilizando encriptaci\u00f3n AES para el intercambio de mensajes. Nivel 0 de seguridad, que consiste en un intercambio de credenciales utilizando texto plano y sin PoP . As\u00ed, un ejemplo de inicializaci\u00f3n del servicio de provisionamiento podr\u00eda resultar en el siguiente c\u00f3digo: const char *service_name = \"my_device\"; const char *service_key = \"password\"; wifi_prov_security_t security = WIFI_PROV_SECURITY_1; const char *pop = \"abcd1234\"; ESP_ERR_CHECK( wifi_prov_mgr_start_provisioning(security, pop, service_name, service_key) ); El servicio de provisionamiento finalizar\u00e1 autom\u00e1ticamente al conectar a un AP con \u00e9xito (es decir, al obtener IP desde el mismo). En cualquier caso, puede tambi\u00e9n detenerse de forma manual en cualquier momento a trav\u00e9s de la invocaci\u00f3n a wifi_prov_mgr_stop_provisioning() . Espera a la finalizaci\u00f3n del proceso de provisionamiento T\u00edpicamente, las aplicaciones de usuario en el ESP32 deber\u00e1n esperar a que el proceso de provisionamiento finalice antes de proceder. En ese momento, y antes de proceder, liberar\u00e1n los recursos que se alojaron para el proceso de provisionamiento, y comenzar\u00e1n con su l\u00f3gica habitual. Existen dos mecanismos para conseguir este efecto: En primer lugar, la soluci\u00f3n m\u00e1s simple consiste en utilizar una invocaci\u00f3n bloqueante a la rutina wifi_prov_mgr_wait() : // Inicializaci\u00f3n del servicio de provisionamiento ESP_ERR_CHECK( wifi_prov_mgr_start_provisioning(security, pop, service_name, service_key) ); // Espera a la compleci\u00f3n del provisionamiento wifi_prov_mgr_wait(); // Liberaci\u00f3n de recursos wifi_prov_mgr_deinit(); // A partir de aqu\u00ed, comenzar\u00eda la l\u00f3gica habitual de la aplicaci\u00f3n // ... El segundo mecanismo estar\u00eda basado en eventos (es decir, ser\u00eda no bloqueante ), interceptando y trabajando sobre eventos de tipo WIFI_PROV_EVENT e invocando a wifi_prov_mgr_deinit() cuando el identificador de evento sea WIFI_PROV_END : static void event_handler(void* arg, esp_event_base_t event_base, int event_id, void* event_data) { if (event_base == WIFI_PROV_EVENT && event_id == WIFI_PROV_END) { /* Liberar recursos una vez el proceso de provisionamiento ha finalizado */ wifi_prov_mgr_deinit(); } } Herramientas de provisionamiento para dispositivos m\u00f3viles Existen aplicaciones preparadas por Espressif para llevar a cabo el proceso de provisionamiento sobre ESP32. Estas aplicaciones est\u00e1n disponibles tanto para dispositivos Android como IOS, en las versiones con transporte BLE o SoftAP: Android: Provisionamiento BLE . Provisionamiento SoftAP . IOS: Provisionamiento BLE . Provisionamiento SoftAP . Tarea entregable Utilizando las aplicaciones correspondientes a tu dispositivo m\u00f3vil, tanto para el uso de BLE como de SoftAP, provisiona tu ESP32 utilizando las credenciales que correspondan a tu red WiFi. Entrega una breve descripci\u00f3n del proceso desarrollado, as\u00ed como capturas de pantalla correspondientes a la salida del ESP32 que evidencien que el proceso de provisionamiento se ha realizado correctamente. Recuerda, antes de cada repetici\u00f3n del experimento, utilizar la orden idf.py erase_flash para eliminar informaci\u00f3n de provisionamiento de sesiones anteriores. Comprueba el funcionamiento de los distintos niveles de seguridad. Estas aplicaciones funcionan mediante una comunicaci\u00f3n muy sencilla con el ESP32 no provisionado, cuyos mecanismos dependen del transporte utilizado; en el caso de BLE, se crea una tabla GATT con distintas caracter\u00edsticas que ser\u00e1n utilizadas para escribir (enviar) datos en el dispositivo. Veremos qu\u00e9 es una tabla GATT en pr\u00f3ximas pr\u00e1cticas, por lo que retornaremos a este punto. En el caso de softAP , se crean una serie de endpoints (URIs HTTP) que permiten, de forma sencilla, leer y escribir aquellos datos que deseamos comunicar al otro extremo de la comunicaci\u00f3n. La siguiente tabla resume los endpoints creados por las versiones est\u00e1ndar del protocolo de provisionamiento (pueden ser modificados o adaptados en funci\u00f3n de la informaci\u00f3n adicional que deseemos intercambiar): Endpoint (BLE + Servidor GATT) URI (SoftAP + HTTP) Establecimiento de sesi\u00f3n prov-session http://IP:80/prov-session Escaneo de redes disponibles prov-scan http://IP:80/prov-scan Configuraci\u00f3n de provisionamiento prov-config http://IP:80/prov-config Versi\u00f3n del protocolo proto-ver http://IP:80/proto-ver Los detalles de este tipo de protocolo de provisionamiento quedan como ejercicio adicional al alumno, y van m\u00e1s all\u00e1 del objetivo de la pr\u00e1ctica. Sin embargo, s\u00ed es conveniente disponer de alg\u00fan mecanismo que permita observarlos, y determinar, por ejemplo para el caso de SoftAP, si el intercambio de credenciales se realiza como texto plano (en claro) o cifrado, lo cu\u00e1l podr\u00eda suponer serios problemas de seguridad para el usuario de un dispositivo m\u00f3vil, ya que se expondr\u00edan las credenciales de conexi\u00f3n a la red WiFi. Para estudiar este hecho, utilizaremos una herramienta de l\u00ednea de \u00f3rdenes proporcionada junto a ESP-IDF, llamada esp_prov.py , situada en el directorio tools/esp_prov de la instalaci\u00f3n. Nota Antes de utilizar el programa, debes instalar las dependencias respectivas utilizando las \u00f3rdenes (desde el propio directorio tools/esp_prov ): pip install -r requirements.txt pip install -r requirements_linux_extra.txt Su uso es sencillo, y puede consultarse ejecutando python esp_prov.py -h . B\u00e1sicamente, una sesi\u00f3n de provisionamiento utilizando softAP sobre un dispositivo a la espera con IP 192.168.4.1 , sin capa de seguridad (cifrado) y proporcionando la SSID y clave SSID_EJEMPLO/CLAVE_EJEMPLO resultar\u00eda: python esp_prov.py --transport softap --service_name \"192.168.4.1:80\" --sec_ver 0 --ssid SSID_EJEMPLO --passphrase CLAVE_EJEMPLO Ten en cuenta que, para emitir el anterior comando, debes pertenecer a la misma red que el dispositivo a provisionar, es decir, haber conectado al SSID de provisionamiento que se proporciona. Tarea entregable Realiza el proceso de provisionamiento desde l\u00ednea de comandos utilizando las anteriores indicaciones, y muestra capturas de tr\u00e1fico v\u00eda Wireshark donde se evidencie la entrega en claro (en modo texto, sin cifrar) de las credenciales de red entre el provisionador y el dispositivo, y el uso de los endpoints/URIs anteriormente mencionados. A continuaci\u00f3n, pasa a un modo seguro (opci\u00f3n --sec_ver 1 ) y observa c\u00f3mo las claves se intercambian cifradas. Parte 3. Modos de ahorro de consumo WiFi En la versi\u00f3n actual de ESP-IDF, el framework soporta distintos modos de ahorro de energ\u00eda, con soporte tanto a nivel de dispositivo ( station ) como de punto de acceso ( AP ). Todos estos modos se basan en las caracter\u00edsticas de ahorro de consumo contempladas en el est\u00e1ndar 802.11 (concretamente en el modo Modem-sleep ). El modo Modem-sleep trabaja exclusivamente cuando un dispositivo est\u00e1 configurado como station , y se encuentra conectado a un AP. Si el modo Modem-sleep est\u00e1 activo, el dispositivo var\u00eda su estado entre activo y sleep peri\u00f3dicamente. En el modo sleep , tres de los principales componentes del subsistema de comunicacion inal\u00e1mbrica (PHY, BB y RF) se desconectan para reducir el consumo energ\u00e9tico. Pese a permanecer desconectados, la estaci\u00f3n sigue conectada al AP en todo momento. El modo Modem-sleep soporta dos submodos de ahorro de consumo: m\u00ednimo y m\u00e1ximo . En el modo m\u00ednimo , la estaci\u00f3n se despierta cada DTIM para recibir un beacon. Debido a que los mensajes de difusi\u00f3n ( broadcast ) se transmiten tras cada DTIM, en este caso no se perder\u00e1n y ser\u00e1n recibidos por las estaciones. Sin embargo, el ahorro energ\u00e9tico puede ser reducido si el DTIM es breve (adem\u00e1s, DTIM est\u00e1 determinado por el AP, por lo que la estaci\u00f3n no tiene control sobre este par\u00e1metro). En el modo m\u00e1ximo , la estaci\u00f3n se despierta tras cada intervalo de escucha para recibir un beacon. Este intervalo de escucha no tiene que coincidir con el valor de DTIM , y de hecho suele fijarse a un valor mayor para conseguir mayor ahorro de consumo. Los datos de broadcast podr\u00edan perderse usando este modo si la estaci\u00f3n est\u00e1 en estado de reposo mientras expira el temporizador DTIM . El valor del intervalo de escucha puede configurarse mediante una invocaci\u00f3n a esp_wifi_set_config() antes de conectar al AP. Para activar el modo m\u00ednimo , es neceario invocar a la rutina esp_wifi_set_ps(WIFI_PS_MIN_MODEM) ; para activar el modo m\u00e1ximo , es neceario invocar a la rutina esp_wifi_set_ps(WIFI_PS_MAX_MODEM) , ambos tras la infocaci\u00f3n de esp_wifi_init() . Los modos de ahorro se activar\u00e1n al conectar al AP, y se desactivar\u00e1n al desconectar. Es posible desactivar los modos de ahorro mediante una invocaci\u00f3n a esp_wifi_set_ps(WIFI_PS_NONE) . Obviamente, esto aumentar\u00e1 el consumo, pero reducir\u00e1 la latencia en la recepci\u00f3n de mensajes. Con el modo de ahorro activado, la recepci\u00f3n de los mensajes se retrasar\u00e1 tanto como el per\u00edodo DTIM (en modo m\u00ednimo ahorro) o el per\u00edodo de escucha (modo m\u00e1ximo ahorro). El modo por defecto es WIFI_PS_MIN_MODEM . En modo punto de acceso, ESP-IDF no soporta todos los modos de ahorro dictados en la especificaci\u00f3n WiFi. Concretamente, un AP programado v\u00eda ESP-IDF s\u00f3lo cachear\u00e1 (almacenar\u00e1 temporalmente) los paquetes de tipo unicast para las estaciones conectadas a dicho AP, pero no paquetes multicast para dichas estacioens. As\u00ed, con el modo de ahorro activo, las estaciones podr\u00edan perder paquetes multicast . El ejemplo examples/wifi/power_save ilustra mediante un c\u00f3digo sencillo la configuraci\u00f3n de una estaci\u00f3n en los dos modos de ahorro energ\u00e9tico. Estos modos pueden configurarse a trav\u00e9s del men\u00fa de configuraci\u00f3n; adem\u00e1s, se ofrece una opci\u00f3n para modificar el tiempo de escucha en el caso del modo de ahorro m\u00e1ximo . Tarea entregable Compila, flashea y ejecuta el c\u00f3digo de ejemplo utilizando los tres modos disponibles (sin ahorro, con ahorro m\u00ednimo y con ahorro m\u00e1ximo). En el caso del ahorro m\u00e1ximo, var\u00eda el tiempo de escucha para que tome distintos valores. En todos los casos, conecta tu ESP32 a un punto de acceso y, desde un port\u00e1til conectado al mismo AP, ejecuta una serie de pings hacia la estaci\u00f3n. Para cada modo, representa gr\u00e1ficamente el tiempo de respuesta de la estaci\u00f3n en una gr\u00e1fica para cada petici\u00f3n ping , relacionando su comportamiento con los tiempos DTIM y de escucha.","title":"Pr\u00e1ctica 3"},{"location":"RPI-I/P3/#practica-3-wifi-conceptos-avanzados-wifi-mesh-provisionamiento-y-ahorro-de-energia","text":"","title":"Pr\u00e1ctica 3. WiFi. Conceptos avanzados (WiFi Mesh, provisionamiento y ahorro de energ\u00eda)"},{"location":"RPI-I/P3/#objetivos","text":"La presente pr\u00e1ctica se divide en tres partes principales, que abordan tres temas avanzados relacionados con la conectividad WiFi en ESP-IDF y en el ESP32. Los objetivos en cada punto son: WiFi MESH Revisar los conceptos b\u00e1sicos para la construcci\u00f3n de una red MESH WiFi autogestionada. Presentar la API b\u00e1sica para la creaci\u00f3n de aplicaciones basadas en la pila ESP-MESH. Observar en funcionamiento una red ESP-MESH, as\u00ed como sus capacidades de autoconfiguraci\u00f3n. Provisionamiento Entender y experimentar con distintos modos de provisionamiento de credenciales WiFi, v\u00eda BLE y v\u00eda softAP . Comprobar el intercambio de claves en claro realizando provisionamientos desde l\u00ednea de comandos, as\u00ed como observar la utilidad (y necesidad) del env\u00edo cifrado de credenciales. Ahorro de energ\u00eda Entender los tres modos de funcionamiento del ESP32 a nivel de ahorro energ\u00e9tico en conexiones WiFi. Observar la desviaci\u00f3n en latencia de recepci\u00f3n de paquetes en funci\u00f3n del modo aplicado.","title":"Objetivos"},{"location":"RPI-I/P3/#parte-1-wifi-mesh-esp-mesh","text":"El stack ESP-MESH est\u00e1 construido por encima del driver WiFi (es decir, obviamente hace uso de sus servicios), y en algunos casos tambi\u00e9n haciendo uso de servicios de la pila IP ( lwIP ), por ejemplo en el nodo ra\u00edz, que es el \u00fanico con comunicaci\u00f3n IP contra un router de borde. El siguiente diagrama muestra la situaci\u00f3n de la pila Mesh en ESP-IDF: Como cualquier otro componente ESP-IDF, ESP-MESH se comunica con las aplicaciones a trav\u00e9s de eventos propios: El tipo mesh_event_id_t define todos los posibles eventos que pueden surgir en las distintas fases del ciclo de vida de una red (por ejemplo, para un nodo determinado, conexi\u00f3n o desconexi\u00f3n de su nodo padre, o de uno de sus nodos hijo). Antes de utilizar los eventos ESP-MESH para gestionar u observar el funcionamiento de la red, es necesario registrarlos v\u00eda esp_event_handler_register() . Algunos usos t\u00edpicos de los eventos incluyen, por ejemplo, la situaci\u00f3n de conexi\u00f3n de un nodo padre ( MESH_EVENT_PARENT_CONNECTED ) o de un hijo ( MESH_EVENT_CHILD_CONNECTED ), indicando, respectivamente, que un nodo puede comenzar a emitir hacia arriba en el grafo, o hacia abajo. Del mismo modo, en un nodo ra\u00edz, la recepci\u00f3n de los eventos IP_EVENT_STA_GOT_IP y IP_EVENT_STA_LOST_IP se pueden aprovechar para indicar que dicho nodo ra\u00edz puede o no enviar datos a la red IP externa.","title":"Parte 1. WiFi Mesh (ESP MESH)"},{"location":"RPI-I/P3/#eventos","text":"MESH_EVENT_STARTED : mesh iniciada. MESH_EVENT_STOPPED : mesh finalizada. MESH_EVENT_CHANNEL_SWITCH : cambio de canal. MESH_EVENT_CHILD_CONNECTED : un hijo ha conectado a la interfaz softAP . MESH_EVENT_CHILD_DISCONNECTED : un hijo ha desconectado de la interfaz softAP . MESH_EVENT_ROUTING_TABLE_ADD : se han a\u00f1adido nuevas entradas a la tabla de enrutamiento a\u00f1adiendo nuevos hijos. MESH_EVENT_ROUTING_TABLE_REMOVE : se ha eliminado entradas de la tabla de enrutamiento eliminado hijos que han abandonado la red. MESH_EVENT_PARENT_CONNECTED : un padre se ha conectado a la interfaz station . MESH_EVENT_PARENT_DISCONNECTED : un padre se ha desconectado de la interfaz station . MESH_EVENT_NO_PARENT_FOUND : no se ha encontrado un padre. MESH_EVENT_LAYER_CHANGE : el nodo ha cambiado de nivel en la red. MESH_EVENT_TODS_STATE : indica que el nodo ra\u00edz es capaz de acceder a la red IP externa. MESH_EVENT_VOTE_STARTED : el proceso de voto de un nuevo nodo ra\u00edz ha comenzado. MESH_EVENT_VOTE_STOPPED : el proceo de voto de un nuevo nodo ra\u00edz ha finalizado. MESH_EVENT_ROOT_ADDRESS : se ha obtenido la direcci\u00f3n del nodo ra\u00edz. MESH_EVENT_ROOT_SWITCH_REQ : un nodo ra\u00edz candidato ya elegido solicita un cambio de nodo ra\u00edz. MESH_EVENT_ROOT_SWITCH_ACK : respuesta a la anterior petici\u00f3n por parte del nodo ra\u00edz actual. MESH_EVENT_NETWORK_STATE : la actual red tiene un nodo ra\u00edz. MESH_EVENT_STOP_RECONNECTION : el nodo ra\u00edz detiene el proceso de reconexi\u00f3n al router y los dem\u00e1s nodos detienen los procesos de conexi\u00f3n a sus nodos padre. MESH_EVENT_FIND_NETWORK : si el canal solicitado es 0, la pila escanear\u00e1 todos los canales para encontrar una red mesh a la que conectar, devolviendo el canal en el que lo ha conseguido.","title":"Eventos"},{"location":"RPI-I/P3/#uso-de-la-pila-ip","text":"El c\u00f3digo de una aplicaci\u00f3n que haga uso de ESP-MESH puede acceder directamente a la pila MESH sin pasar por la pila IP. De hecho, la pila IP s\u00f3lo es estrictamente necesaria por parte del nodo ra\u00edz, al ser el \u00fanico que puede recibir o transmitir datos desde o hacia la red IP externa. Sin embargo, como cualquier nodo de la topolog\u00eda puede potencialmente convertirse en nodo ra\u00edz (ya que su selecci\u00f3n es autom\u00e1tica), todos los nodos deber\u00e1n inicializar la pila IP. Por tanto, todos los nodos incializan la pila IP v\u00eda tcpip_adapter_init() . Adem\u00e1s, todos los nodos deber\u00e1n detener el servidor DHCP en la interfaz softAP , y el cliente DHCP en la interfaz station : /* tcpip initialization */ tcpip_adapter_init(); /* * for mesh * stop DHCP server on softAP interface by default * stop DHCP client on station interface by default */ ESP_ERROR_CHECK(tcpip_adapter_dhcps_stop(TCPIP_ADAPTER_IF_AP)); ESP_ERROR_CHECK(tcpip_adapter_dhcpc_stop(TCPIP_ADAPTER_IF_STA)); Sin embargo, en el caso de un nodo que se convierte en ra\u00edz, es imprescindible arrancar el cliente DHCP como respuesta al evento corresondiente para as\u00ed obtener direcci\u00f3n IP desde el router que da salida hacia la red externa.","title":"Uso de la pila IP"},{"location":"RPI-I/P3/#estructura-basica-de-una-aplicacion-esp-mesh","text":"El siguiente c\u00f3digo muestra la estructura b\u00e1sica de inicializaci\u00f3n de pilas IP y WiFi necesarias para comenzar con la configuraci\u00f3n de la red MESH: tcpip_adapter_init(); /* * for mesh * stop DHCP server on softAP interface by default * stop DHCP client on station interface by default */ ESP_ERROR_CHECK(tcpip_adapter_dhcps_stop(TCPIP_ADAPTER_IF_AP)); ESP_ERROR_CHECK(tcpip_adapter_dhcpc_stop(TCPIP_ADAPTER_IF_STA)); /* event initialization */ ESP_ERROR_CHECK(esp_event_loop_create_default()); /* Wi-Fi initialization */ wifi_init_config_t config = WIFI_INIT_CONFIG_DEFAULT(); ESP_ERROR_CHECK(esp_wifi_init(&config)); /* register IP events handler */ ESP_ERROR_CHECK(esp_event_handler_register(IP_EVENT, IP_EVENT_STA_GOT_IP, &ip_event_handler, NULL)); ESP_ERROR_CHECK(esp_wifi_set_storage(WIFI_STORAGE_FLASH)); ESP_ERROR_CHECK(esp_wifi_start()); Tras esta inicializaci\u00f3n, comienza la fase de configuraci\u00f3n e inicializaci\u00f3n de la malla, que proceder\u00e1 en tres pasos principales: Inicializaci\u00f3n de la malla Configuraci\u00f3n de la red ESP-MESH Arranque de la red","title":"Estructura b\u00e1sica de una aplicaci\u00f3n ESP-MESH"},{"location":"RPI-I/P3/#paso-1-inicializacion-de-la-malla","text":"La inicializaci\u00f3n de la malla y registro de eventos propios es sencilla: /* mesh initialization */ ESP_ERROR_CHECK(esp_mesh_init()); /* register mesh events handler */ ESP_ERROR_CHECK(esp_event_handler_register(MESH_EVENT, ESP_EVENT_ANY_ID, &mesh_event_handler, NULL));","title":"Paso 1. Inicializaci\u00f3n de la malla"},{"location":"RPI-I/P3/#paso-2-configuracion-de-la-red-esp-mesh","text":"La configuraci\u00f3n de ESP-MESH se realiza a trav\u00e9s de la funci\u00f3n esp_mesh_set_config() , que recibe una estructura de tipo mesh_cfg_t con la configuraci\u00f3n de la red: Par\u00e1metro Descripci\u00f3n Channel Canal (entre 1 y 14) Mesh ID Identificaci\u00f3n de la red MESH (6 bytes) Router SSID y contrase\u00f1a de conexi\u00f3n al router de salida Mesh AP Configuraci\u00f3n espec\u00edfica del AP generado por cada nodo Un ejemplo de configuraci\u00f3n podr\u00eda ser: /* Mesh ID */ static const uint8_t MESH_ID = { 0x77, 0x77, 0x77, 0x77, 0x77, 0x77 }; /* Enable the Mesh IE encryption by default */ mesh_cfg_t cfg = MESH_INIT_CONFIG_DEFAULT(); /* mesh ID */ memcpy((uint8_t *) &cfg.mesh_id, MESH_ID, 6); /* channel (must match the router's channel) */ cfg.channel = CONFIG_MESH_CHANNEL; /* router */ cfg.router.ssid_len = strlen(CONFIG_MESH_ROUTER_SSID); memcpy((uint8_t *) &cfg.router.ssid, CONFIG_MESH_ROUTER_SSID, cfg.router.ssid_len); memcpy((uint8_t *) &cfg.router.password, CONFIG_MESH_ROUTER_PASSWD, strlen(CONFIG_MESH_ROUTER_PASSWD)); /* mesh softAP */ cfg.mesh_ap.max_connection = CONFIG_MESH_AP_CONNECTIONS; memcpy((uint8_t *) &cfg.mesh_ap.password, CONFIG_MESH_AP_PASSWD, strlen(CONFIG_MESH_AP_PASSWD)); ESP_ERROR_CHECK(esp_mesh_set_config(&cfg));","title":"Paso 2. Configuraci\u00f3n de la red ESP-MESH"},{"location":"RPI-I/P3/#paso-3-arranque-de-la-red","text":"El arranque de la red MESH es sencillo: /* mesh start */ ESP_ERROR_CHECK(esp_mesh_start()); Tras el arranque, la aplicaci\u00f3n deber\u00eda comprobar los eventos para determinar si la conexi\u00f3n a la red ha sido exitosa. En dicho caso, tras la conexi\u00f3n, la aplicaci\u00f3n puede comenzar a transmitir paquetes a trav\u00e9s de la red MESH utilizando las rutinas esp_mesh_send() y esp_mesh_recv() .","title":"Paso 3. Arranque de la red"},{"location":"RPI-I/P3/#ejercicio-en-clase-despliegue-conjunto-de-una-red-wifi-mesh","text":"La forma m\u00e1s conveniente de observar el comportamiento de una red WiFi Mesh es desplegar una infraestructura con suficiente n\u00famero de nodos pertenecientes a una misma red. Desafortunadamente, para ello es necesario disponer de dichos nodos en un espacio cercano. En la presente pr\u00e1ctica, desplegaremos una red WiFi Mesh en el laboratorio, utilizando vuestro o vuestros ESP32 como elementos de la red. Para ello, configuraremos, compilaremos y ejecutaremos el ejemplo examples/mesh/internal_communication . Antes de proceder, configuraremos el proyecto para: Conectar al punto de acceso com\u00fan del laboratorio ( Router SSID y Router password ). Configurar la red ESP-MESH para utilizar WPA2_PSK y seleccionar como contrase\u00f1a password . Aumentar el n\u00famero de conexiones al AP a 10. De momento, no realizaremos ning\u00fan cambio en el c\u00f3digo del ejemplo. Compila y ejecuta tu c\u00f3digo. En la direcci\u00f3n del enlace dispones de una primera pesta\u00f1a en la que deber\u00e1s completar cierta informaci\u00f3n que observar\u00e1s en la salida de monitorizaci\u00f3n una vez arranques el ESP32, en la celda correspondiente a tu puesto. Esta informaci\u00f3n, en principio, incluye: Tu nombre. Direcciones MAC de las interfaces STA y SoftAP (lo observar\u00e1s en los primeros mensajes de salida). Capa de la topolog\u00eda en la que se encuentra tu nodo (lo observar\u00e1s en formato [L:XX] en los env\u00edos y recepciones de datos). En caso de haber sido elegido nodo ra\u00edz, anotar tambi\u00e9n esta circunstancia y la IP asignada por el router (observa la respuesta al evento correspondiente). Adem\u00e1s, anota la ID de la red Mesh que se ha utilizado para conectar. Antes de rellenar la informaci\u00f3n, espera que el profesor te indique que la topolog\u00eda ha convergido, y que por tanto no habr\u00e1 ning\u00fan cambio m\u00e1s en ella (siempre que ningun nodo deje de formar parte de la misma). Ejercicio entregable Captura el estado de la red cuando todos tus compa\u00f1eros hayan llegado al punto de convergencia, e intenta determinar, en forma de grafo, la topolog\u00eda de la misma. A continuaci\u00f3n, apagaremos el nodo ra\u00edz y esperaremos a la vuelta a la convergencia de la red. Ejercicio entregable Captura de nuevo el estado de la red cuando todos tus compa\u00f1eros hayan llegado al punto de convergencia, e intenta determinar, en forma de grafo, la topolog\u00eda de la misma. Como \u00faltimo ejercicio, vamos a crear nuevas redes Mesh en funci\u00f3n del puesto que tengas asignado. Observa los colores asignados a cada grupo de puestos en la siguiente hoja .","title":"Ejercicio en clase. Despliegue conjunto de una red WiFi Mesh"},{"location":"RPI-I/P3/#ejercicio-en-clase-despliegue-conjunto-de-una-red-wifi-mesh-de-menores-dimensiones","text":"Modifica tu c\u00f3digo para que el canal de escucha y el identificador de red coincidan con el indicado. Puedes configurar el canal a trav\u00e9s del men\u00fa de configuracion del ejemplo ( channel ) y el identificador modificando la variable correspondiente en el fichero mesh_main.c . Una vez hecho esto, reconstruid la informaci\u00f3n de las tablas para reflejar las nuevas topolog\u00edas. Pod\u00e9is hacer pruebas posteriores apagando el nodo ra\u00edz y observando la convergencia de la red. Ejercicio entregable Captura de nuevo el estado de la red cuando todos tus compa\u00f1eros hayan llegado al punto de convergencia, e intenta determinar, en forma de grafo, la topolog\u00eda de la misma. El estudio detallado del c\u00f3digo para el despliegue de la red queda como ejercicio para el alumno. Observa el tratamiento de eventos y la fase de configuraci\u00f3n de la red. Intenta entender el funcionamiento del c\u00f3digo (env\u00edos y recepciones, destinatarios de los mismos, etc.).","title":"Ejercicio en clase. Despliegue conjunto de una red WiFi Mesh de menores dimensiones"},{"location":"RPI-I/P3/#parte-2provisionamiento-wifi","text":"ESP-IDF proporciona un componente espec\u00edfico que ofrece un servicio de provisionamiento WiFi. Entendemos por provisionamiento WiFi el mecanismo o mecanismos mediante los cuales es posible proporcionar, de forma externa y segura, el conjunto de credenciales de conexi\u00f3n a una red WiFi a un dispositivo no conectado. El component de provisionamiento WiFi en ESP-IDF permite proporcionar dichas credenciales a trav\u00e9s de dos v\u00edas: Bluetooth Low Energy (modo BLE ) o a trav\u00e9s de un mecanismo de punto de acceso WiFi temporal (modo SoftAP ). ESP-IDF proporciona una serie de APIs (con prototipos wifi_prov_mgr_* ) para implementar de forma sencilla ambos modos de provisionamiento.","title":"Parte 2.Provisionamiento WiFi"},{"location":"RPI-I/P3/#inicializacion-del-servicio-de-provisionamiento","text":"La rutina wifi_prov_mgr_init() se utiliza para configurar e inicializar el componente de provisionamiento, y debe invocarse antes de cualquier otra invocaci\u00f3n a rutinas de tipo wifi_prov_mgr* . Adem\u00e1s, es necesario destacar que el componente de provisionamiento conf\u00eda en las funcionalidades de otros componentes (b\u00e1sicamente NVS, TCP/IP, Event loop y mDNS), por lo que \u00e9stos deben inicializarse antes del propio componente. Para finalizar el componente de provisionamiento, es suficiente con invocar a la rutina wifi_prov_mgr_deinit() . Un ejemplo de inicializaci\u00f3n resultar\u00eda en: wifi_prov_mgr_config_t config = { .scheme = wifi_prov_scheme_ble, .scheme_event_handler = WIFI_PROV_SCHEME_BLE_EVENT_HANDLER_FREE_BTDM }; ESP_ERR_CHECK( wifi_prov_mgr_init(config) ); La estructura de configuraci\u00f3n de tipo wifi_prov_mgr_config_t dispone de campos que permiten especificar el comportamiento del componente; espec\u00edficamente, el campo scheme especifica el esquema (o tipo) de provisionamiento. Disponemos de tres opciones: wifi_prov_scheme_softap : transporta la informaci\u00f3n de provisionamiento v\u00eda WiFi (creando un punto de acceso temporal) y un servidor HTTP para recibir los comandos e informaci\u00f3n de provisionamiento. wifi_prov_scheme_ble : transporta la informaci\u00f3n de provisionamiento v\u00eda Bluetooth Low Energy (BLE) y un servidor GATT para recibir los comandos e informaci\u00f3n de provisionamiento. wifi_prov_scheme_console : transporta la informaci\u00f3n v\u00eda puerto serie y","title":"Inicializaci\u00f3n del servicio de provisionamiento"},{"location":"RPI-I/P3/#comprobacion-del-estado-de-provisionamiento","text":"Es posible comprobar el estado de provisionamiento de un dispositivo mediante una invocaci\u00f3n a wifi_prov_mgr_is_provisioned() , que chequea si las credenciales de conexi\u00f3n WiFi est\u00e1n almacenadas en la memoria no vol\u00e1til (NVS). Aunque existen distintos m\u00e9todos para eliminar la informaci\u00f3n de provisionamento almacenada en la NVS, utilizaremos el mecanismo proporcionado por idf.py para eliminar su contenido. Para ello, ejecutaremos: idf.py erase_flash","title":"Comprobaci\u00f3n del estado de provisionamiento"},{"location":"RPI-I/P3/#parametros-de-inicializacion-del-servicio-de-provisionamiento-wifi","text":"Al inicializar el componente de provisionamiento, es necesario especificar un nombre de servicio y una clave. Esto se traduce en: SSID y contrase\u00f1a para el modo SoftAP (es decir, cuando el esquema de provisionamiento se ha configurado como wifi_prov_scheme_softap ). Nombre del dispositivo BLE para el modo BLE (es decir, cuando el esquema de provisionamiento se ha configurado como wifi_prov_scheme_ble ). Adem\u00e1s, internamente el componente utiliza el mecanismo de comunicaci\u00f3n protocomm , que permite dos niveles de seguridad en la comunicaci\u00f3n de credenciales de provisionamiento: Nivel 1 de seguridad, que consiste en un handshake previo entre ambos extremos, con intercambio de claves y utilizaci\u00f3n de una prueba de posesi\u00f3n (PoP, proof of possession ), y utilizando encriptaci\u00f3n AES para el intercambio de mensajes. Nivel 0 de seguridad, que consiste en un intercambio de credenciales utilizando texto plano y sin PoP . As\u00ed, un ejemplo de inicializaci\u00f3n del servicio de provisionamiento podr\u00eda resultar en el siguiente c\u00f3digo: const char *service_name = \"my_device\"; const char *service_key = \"password\"; wifi_prov_security_t security = WIFI_PROV_SECURITY_1; const char *pop = \"abcd1234\"; ESP_ERR_CHECK( wifi_prov_mgr_start_provisioning(security, pop, service_name, service_key) ); El servicio de provisionamiento finalizar\u00e1 autom\u00e1ticamente al conectar a un AP con \u00e9xito (es decir, al obtener IP desde el mismo). En cualquier caso, puede tambi\u00e9n detenerse de forma manual en cualquier momento a trav\u00e9s de la invocaci\u00f3n a wifi_prov_mgr_stop_provisioning() .","title":"Par\u00e1metros de inicializaci\u00f3n del servicio de provisionamiento WiFi"},{"location":"RPI-I/P3/#espera-a-la-finalizacion-del-proceso-de-provisionamiento","text":"T\u00edpicamente, las aplicaciones de usuario en el ESP32 deber\u00e1n esperar a que el proceso de provisionamiento finalice antes de proceder. En ese momento, y antes de proceder, liberar\u00e1n los recursos que se alojaron para el proceso de provisionamiento, y comenzar\u00e1n con su l\u00f3gica habitual. Existen dos mecanismos para conseguir este efecto: En primer lugar, la soluci\u00f3n m\u00e1s simple consiste en utilizar una invocaci\u00f3n bloqueante a la rutina wifi_prov_mgr_wait() : // Inicializaci\u00f3n del servicio de provisionamiento ESP_ERR_CHECK( wifi_prov_mgr_start_provisioning(security, pop, service_name, service_key) ); // Espera a la compleci\u00f3n del provisionamiento wifi_prov_mgr_wait(); // Liberaci\u00f3n de recursos wifi_prov_mgr_deinit(); // A partir de aqu\u00ed, comenzar\u00eda la l\u00f3gica habitual de la aplicaci\u00f3n // ... El segundo mecanismo estar\u00eda basado en eventos (es decir, ser\u00eda no bloqueante ), interceptando y trabajando sobre eventos de tipo WIFI_PROV_EVENT e invocando a wifi_prov_mgr_deinit() cuando el identificador de evento sea WIFI_PROV_END : static void event_handler(void* arg, esp_event_base_t event_base, int event_id, void* event_data) { if (event_base == WIFI_PROV_EVENT && event_id == WIFI_PROV_END) { /* Liberar recursos una vez el proceso de provisionamiento ha finalizado */ wifi_prov_mgr_deinit(); } }","title":"Espera a la finalizaci\u00f3n del proceso de provisionamiento"},{"location":"RPI-I/P3/#herramientas-de-provisionamiento-para-dispositivos-moviles","text":"Existen aplicaciones preparadas por Espressif para llevar a cabo el proceso de provisionamiento sobre ESP32. Estas aplicaciones est\u00e1n disponibles tanto para dispositivos Android como IOS, en las versiones con transporte BLE o SoftAP: Android: Provisionamiento BLE . Provisionamiento SoftAP . IOS: Provisionamiento BLE . Provisionamiento SoftAP . Tarea entregable Utilizando las aplicaciones correspondientes a tu dispositivo m\u00f3vil, tanto para el uso de BLE como de SoftAP, provisiona tu ESP32 utilizando las credenciales que correspondan a tu red WiFi. Entrega una breve descripci\u00f3n del proceso desarrollado, as\u00ed como capturas de pantalla correspondientes a la salida del ESP32 que evidencien que el proceso de provisionamiento se ha realizado correctamente. Recuerda, antes de cada repetici\u00f3n del experimento, utilizar la orden idf.py erase_flash para eliminar informaci\u00f3n de provisionamiento de sesiones anteriores. Comprueba el funcionamiento de los distintos niveles de seguridad. Estas aplicaciones funcionan mediante una comunicaci\u00f3n muy sencilla con el ESP32 no provisionado, cuyos mecanismos dependen del transporte utilizado; en el caso de BLE, se crea una tabla GATT con distintas caracter\u00edsticas que ser\u00e1n utilizadas para escribir (enviar) datos en el dispositivo. Veremos qu\u00e9 es una tabla GATT en pr\u00f3ximas pr\u00e1cticas, por lo que retornaremos a este punto. En el caso de softAP , se crean una serie de endpoints (URIs HTTP) que permiten, de forma sencilla, leer y escribir aquellos datos que deseamos comunicar al otro extremo de la comunicaci\u00f3n. La siguiente tabla resume los endpoints creados por las versiones est\u00e1ndar del protocolo de provisionamiento (pueden ser modificados o adaptados en funci\u00f3n de la informaci\u00f3n adicional que deseemos intercambiar): Endpoint (BLE + Servidor GATT) URI (SoftAP + HTTP) Establecimiento de sesi\u00f3n prov-session http://IP:80/prov-session Escaneo de redes disponibles prov-scan http://IP:80/prov-scan Configuraci\u00f3n de provisionamiento prov-config http://IP:80/prov-config Versi\u00f3n del protocolo proto-ver http://IP:80/proto-ver Los detalles de este tipo de protocolo de provisionamiento quedan como ejercicio adicional al alumno, y van m\u00e1s all\u00e1 del objetivo de la pr\u00e1ctica. Sin embargo, s\u00ed es conveniente disponer de alg\u00fan mecanismo que permita observarlos, y determinar, por ejemplo para el caso de SoftAP, si el intercambio de credenciales se realiza como texto plano (en claro) o cifrado, lo cu\u00e1l podr\u00eda suponer serios problemas de seguridad para el usuario de un dispositivo m\u00f3vil, ya que se expondr\u00edan las credenciales de conexi\u00f3n a la red WiFi. Para estudiar este hecho, utilizaremos una herramienta de l\u00ednea de \u00f3rdenes proporcionada junto a ESP-IDF, llamada esp_prov.py , situada en el directorio tools/esp_prov de la instalaci\u00f3n. Nota Antes de utilizar el programa, debes instalar las dependencias respectivas utilizando las \u00f3rdenes (desde el propio directorio tools/esp_prov ): pip install -r requirements.txt pip install -r requirements_linux_extra.txt Su uso es sencillo, y puede consultarse ejecutando python esp_prov.py -h . B\u00e1sicamente, una sesi\u00f3n de provisionamiento utilizando softAP sobre un dispositivo a la espera con IP 192.168.4.1 , sin capa de seguridad (cifrado) y proporcionando la SSID y clave SSID_EJEMPLO/CLAVE_EJEMPLO resultar\u00eda: python esp_prov.py --transport softap --service_name \"192.168.4.1:80\" --sec_ver 0 --ssid SSID_EJEMPLO --passphrase CLAVE_EJEMPLO Ten en cuenta que, para emitir el anterior comando, debes pertenecer a la misma red que el dispositivo a provisionar, es decir, haber conectado al SSID de provisionamiento que se proporciona. Tarea entregable Realiza el proceso de provisionamiento desde l\u00ednea de comandos utilizando las anteriores indicaciones, y muestra capturas de tr\u00e1fico v\u00eda Wireshark donde se evidencie la entrega en claro (en modo texto, sin cifrar) de las credenciales de red entre el provisionador y el dispositivo, y el uso de los endpoints/URIs anteriormente mencionados. A continuaci\u00f3n, pasa a un modo seguro (opci\u00f3n --sec_ver 1 ) y observa c\u00f3mo las claves se intercambian cifradas.","title":"Herramientas de provisionamiento para dispositivos m\u00f3viles"},{"location":"RPI-I/P3/#parte-3-modos-de-ahorro-de-consumo-wifi","text":"En la versi\u00f3n actual de ESP-IDF, el framework soporta distintos modos de ahorro de energ\u00eda, con soporte tanto a nivel de dispositivo ( station ) como de punto de acceso ( AP ). Todos estos modos se basan en las caracter\u00edsticas de ahorro de consumo contempladas en el est\u00e1ndar 802.11 (concretamente en el modo Modem-sleep ). El modo Modem-sleep trabaja exclusivamente cuando un dispositivo est\u00e1 configurado como station , y se encuentra conectado a un AP. Si el modo Modem-sleep est\u00e1 activo, el dispositivo var\u00eda su estado entre activo y sleep peri\u00f3dicamente. En el modo sleep , tres de los principales componentes del subsistema de comunicacion inal\u00e1mbrica (PHY, BB y RF) se desconectan para reducir el consumo energ\u00e9tico. Pese a permanecer desconectados, la estaci\u00f3n sigue conectada al AP en todo momento. El modo Modem-sleep soporta dos submodos de ahorro de consumo: m\u00ednimo y m\u00e1ximo . En el modo m\u00ednimo , la estaci\u00f3n se despierta cada DTIM para recibir un beacon. Debido a que los mensajes de difusi\u00f3n ( broadcast ) se transmiten tras cada DTIM, en este caso no se perder\u00e1n y ser\u00e1n recibidos por las estaciones. Sin embargo, el ahorro energ\u00e9tico puede ser reducido si el DTIM es breve (adem\u00e1s, DTIM est\u00e1 determinado por el AP, por lo que la estaci\u00f3n no tiene control sobre este par\u00e1metro). En el modo m\u00e1ximo , la estaci\u00f3n se despierta tras cada intervalo de escucha para recibir un beacon. Este intervalo de escucha no tiene que coincidir con el valor de DTIM , y de hecho suele fijarse a un valor mayor para conseguir mayor ahorro de consumo. Los datos de broadcast podr\u00edan perderse usando este modo si la estaci\u00f3n est\u00e1 en estado de reposo mientras expira el temporizador DTIM . El valor del intervalo de escucha puede configurarse mediante una invocaci\u00f3n a esp_wifi_set_config() antes de conectar al AP. Para activar el modo m\u00ednimo , es neceario invocar a la rutina esp_wifi_set_ps(WIFI_PS_MIN_MODEM) ; para activar el modo m\u00e1ximo , es neceario invocar a la rutina esp_wifi_set_ps(WIFI_PS_MAX_MODEM) , ambos tras la infocaci\u00f3n de esp_wifi_init() . Los modos de ahorro se activar\u00e1n al conectar al AP, y se desactivar\u00e1n al desconectar. Es posible desactivar los modos de ahorro mediante una invocaci\u00f3n a esp_wifi_set_ps(WIFI_PS_NONE) . Obviamente, esto aumentar\u00e1 el consumo, pero reducir\u00e1 la latencia en la recepci\u00f3n de mensajes. Con el modo de ahorro activado, la recepci\u00f3n de los mensajes se retrasar\u00e1 tanto como el per\u00edodo DTIM (en modo m\u00ednimo ahorro) o el per\u00edodo de escucha (modo m\u00e1ximo ahorro). El modo por defecto es WIFI_PS_MIN_MODEM . En modo punto de acceso, ESP-IDF no soporta todos los modos de ahorro dictados en la especificaci\u00f3n WiFi. Concretamente, un AP programado v\u00eda ESP-IDF s\u00f3lo cachear\u00e1 (almacenar\u00e1 temporalmente) los paquetes de tipo unicast para las estaciones conectadas a dicho AP, pero no paquetes multicast para dichas estacioens. As\u00ed, con el modo de ahorro activo, las estaciones podr\u00edan perder paquetes multicast . El ejemplo examples/wifi/power_save ilustra mediante un c\u00f3digo sencillo la configuraci\u00f3n de una estaci\u00f3n en los dos modos de ahorro energ\u00e9tico. Estos modos pueden configurarse a trav\u00e9s del men\u00fa de configuraci\u00f3n; adem\u00e1s, se ofrece una opci\u00f3n para modificar el tiempo de escucha en el caso del modo de ahorro m\u00e1ximo . Tarea entregable Compila, flashea y ejecuta el c\u00f3digo de ejemplo utilizando los tres modos disponibles (sin ahorro, con ahorro m\u00ednimo y con ahorro m\u00e1ximo). En el caso del ahorro m\u00e1ximo, var\u00eda el tiempo de escucha para que tome distintos valores. En todos los casos, conecta tu ESP32 a un punto de acceso y, desde un port\u00e1til conectado al mismo AP, ejecuta una serie de pings hacia la estaci\u00f3n. Para cada modo, representa gr\u00e1ficamente el tiempo de respuesta de la estaci\u00f3n en una gr\u00e1fica para cada petici\u00f3n ping , relacionando su comportamiento con los tiempos DTIM y de escucha.","title":"Parte 3. Modos de ahorro de consumo WiFi"},{"location":"RPI-I/P4/","text":"Pr\u00e1ctica 4. Bluetooth Low Energy (BLE)","title":"Pr\u00e1ctica 4"},{"location":"RPI-I/P5/","text":"Pr\u00e1ctica 4. Bluetooth Mesh","title":"Pr\u00e1ctica 5"},{"location":"RPI-I/P5/#practica-4-bluetooth-mesh","text":"","title":"Pr\u00e1ctica 4. Bluetooth Mesh"},{"location":"RPI-I/P6/","text":"Pr\u00e1ctica 6. 6LowPAN (simulaci\u00f3n en Cooja)","title":"Pr\u00e1ctica 6"},{"location":"RPI-I/P6/#practica-6-6lowpan-simulacion-en-cooja","text":"","title":"Pr\u00e1ctica 6. 6LowPAN (simulaci\u00f3n en Cooja)"},{"location":"RPI-I/P7/","text":"Pr\u00e1ctica 6. 6LowPAN (SensorTag)","title":"Pr\u00e1ctica 7"},{"location":"RPI-I/P7/#practica-6-6lowpan-sensortag","text":"","title":"Pr\u00e1ctica 6. 6LowPAN (SensorTag)"},{"location":"RPI-I/P8/","text":"Pr\u00e1ctica 8. LoRA","title":"Pr\u00e1ctica 8"},{"location":"RPI-I/P8/#practica-8-lora","text":"","title":"Pr\u00e1ctica 8. LoRA"},{"location":"RPI-II/P1/","text":"Pr\u00e1ctica 1. Programaci\u00f3n con sockets en Python Objetivos Familiarizarse con la API de sockets en Python. Desarrollar esquemas b\u00e1sicos de sistemas cliente/servidor TCP y UDP utilizando Python. Ser capaces de analizar el tr\u00e1fico generado en una conexi\u00f3n TCP y UDP a trav\u00e9s de Wireshark. Dise\u00f1ar un protocolo de capa de aplicaci\u00f3n para simular una aplicaci\u00f3n cliente/servidor utilizando TCP y UDP. Observar la diferencia en tr\u00e1fico generado para una misma aplicaci\u00f3n utilizando TCP y UDP. Implementar servidores multi-hilo en Python. Introducci\u00f3n La historia de los sockets se remonta al origen de ARPANET, en 1971, y su posterior estandarizaci\u00f3n en forma de API dentro del sistema operativo Berkeley Software Distribution (BSD) , liberado en 1983, bajo el nombre de sockets de Berkeley . Con la popularizaci\u00f3n de Internet en los a\u00f1os 90, y de la mano de la World Wide Web , la programaci\u00f3n de red sufri\u00f3 tambi\u00e9n una notable evoluci\u00f3n. Los servidores web y los navegadores no fueron (ni son) las \u00fanicas aplicaciones basadas en sockets . De hecho, los sistemas cliente/servidor son a d\u00eda de hoy ubicuos e incluyen, por supuesto, a todos los protocolos de alto nivel que dan soporte a Internet de las Cosas. De hecho, a d\u00eda de hoy, aunque los potocolos de alto nivel (capa de aplicaci\u00f3n) han evolucionado hasta niveles de sofisticaci\u00f3n no considerados en sus inicios, la API de bajo nivel sobre la que se basan se mantiene inalterada. El tipo m\u00e1s com\u00fan de aplicaciones basadas en sockets se basa en el paradigma cliente/servidor, donde una de las partes act\u00faa como servidor , esperando pasivamente conexiones desde un conjunto de uno o m\u00e1s clientes . A continuaci\u00f3n, veremos c\u00f3mo desarrollar este tipo de paradigma desde Python, utilizando sockets Berkeley . Existen tambi\u00e9n los llamados Unix domain sockets , que permiten la comunicaci\u00f3n directa entre procesos en el mismo host , aunque quedan fuera de nuestro inter\u00e9s en el \u00e1mbito de IoT. La API de sockets en Python El m\u00f3dulo socket de Python proporciona una interfaz completa para trabajar con la API de sockets de Berkeley . En la presente pr\u00e1ctica, trabajaremos exclusivamente con esta API para desarrollar aplicaciones cliente/servidor utilizando los protocolos TCP y UDP. Las funciones y m\u00e9todos principales de la API de sockets son: socket() - bind() - listen() - accept() - connect() - connect_ex() - send() - recv() - close() - Python prorpociona una API consistente y completa mapeada directamente a las anteriores llamadas al sistema, t\u00edpicamente escritas en lenguaje C. Como parte de su biblioteca est\u00e1ndar, Python tambi\u00e9n proporciona clases que facilitan el trabajo con las funciones de bajo nivel. Aunque no lo cubriremos, el m\u00f3dulo socketserver proporciona una forma sencilla de crear servidores de red. Existen tambi\u00e9n numerosos m\u00f3dulos disponibles para implementar protocolos de alto nivel (por ejemplo HTTP o SMTP), v\u00e9ase . Sockets TCP En Python, los sockets TCP se crean en Python utilizando socket.socket() , especificando el tipo de socket como socket.SOCK_STREAM . El protocolo de control de transmisi\u00f3n (TCP) se caracteriza por dos rasgos principales: Es confiable : se implementan mecanismos de detecci\u00f3n de p\u00e9rdidas en la red y reenv\u00edo de paquetes perdidos. Garantiza una entrega de paquetes en orden : los datos se entregan a las capas superiores (aplicaciones) en el mismo orden en el que fueron enviados. En contra, los sockets UDP se crean a trav\u00e9s de socket.SOCK_DGRAM , y no son confiables ni garantizan la entrega de paquetes en orden. Por tanto, es el desarrollador de aplicaciones quien, en caso de as\u00ed desearlo en el dise\u00f1o de la aplicaci\u00f3n, debe implementar estos mecanismos de forma espec\u00edfica. En el siguiente diagrama se muestra la secuencia t\u00edpica de invocaciones a la API de sockets para TCP: En la figura, la columna de la izquierda representa al servidor, mientras que la columna de la derecha representa al cliente en la conexi\u00f3n TCP. Observa las invocaciones necesarias para configurar un socket a la escucha de conexiones entrantes: socket() bind() listen() accept() En este extremo, un socket escucha ( listen ) potenciales conexiones entrantes desde clientes. Cuando un cliente solicita conectar, el servidor acepta ( accept ) la conexi\u00f3n, complet\u00e1ndola. El cliente invoca a connect() para establecer una conexi\u00f3n con el servidor e inicia el proceso de conexi\u00f3n a tres v\u00edas ( three-way connection ). Una vez establecida la conexi\u00f3n, los datos se intercambian entre cliente y servidor a trav\u00e9s de invocaciones a send() y recv() . Finalmente, el socket se destruye (esto es, la conexi\u00f3n entre ambos extremos se cierra) a trav\u00e9s de una invocaci\u00f3n a close() en cada extremo. Cliente/servidor echo TCP Veamos un ejemplo sencillo para crear un par cliente-servidor. En este caso, el servidor simplemente responder\u00e1 con la misma cadena que reciba desde el cliente. Servidor echo #!/usr/bin/env python3 #### servidor_echo.py import socket HOST = '127.0.0.1' # Interfaz est\u00e1ndar de loopback (localhost) PORT = 65432 # Puerto de escucha (los puertos mayores a 1023 son no privilegiados) with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: s.bind((HOST, PORT)) s.listen() conn, addr = s.accept() with conn: print('Conectado ', addr) while True: data = conn.recv(1024) if not data: break conn.sendall(data) Nota De momento, no importa si no entiendes todas las l\u00edneas en el anterior c\u00f3digo. Simplemente se trata de un punto de partida para desarrollar un servidor sencillo. Sin embargo, es conveniente que copies el c\u00f3digo en un fichero de texto (por ejemplo, llamado servidor_echo.py ) para que podeamos probarlo. Veamos l\u00ednea a l\u00ednea las partes m\u00e1s importantes del anterior c\u00f3digo. socket.socket() crea un objeto socket . Observa que, al crearse a trav\u00e9s de una construcci\u00f3n with , no es necesario invocar expl\u00edcitamente a s.close() , aunque debes tener en cuenta que el objeto es destruido al finalizar la construcci\u00f3n: with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: pass # Es posible usar el socket win invocar a s.close(). Los argumentos que se proporcionan a socket() especifican la familia de direcciones ( AF_INET ) y tipo de socket ( SOCK_STREAM ). AF_INET es la familia de direcciones de Internet para IPv4. SOCK_STREAM es el tipo de socket que permite la creaci\u00f3n de conexiones TCP. bind() se utiliza para asociar el socket a una interfaz de red y n\u00famero de puerto espec\u00edficos: HOST = '127.0.0.1' # Interfaz est\u00e1ndar de loopback (localhost) PORT = 65432 # Puerto de escucha (los puertos mayores a 1023 son no privilegiados) # ... s.bind((HOST, PORT)) Los valores proporcionados a bind() dependen de la familia de direcciones seleccionada para el socket . En este ejemplo, al utilizar AF_INET , espera una tupla con \u00fanicamente dos valores (host, puerto) . Para determinar el host , es posible utilizar un nombre de host , una direcci\u00f3n IP o una cadena vac\u00eda. Si utilizamos una direcci\u00f3n IP, \u00e9sta debe ser especificarse mediante una cadena que contenga una direcci\u00f3n IPv4 bien formada. La direcci\u00f3n 127.0.0.1 es la direcci\u00f3n IPv4 est\u00e1ndar para la interfaz de loopback , por lo que \u00fanicamente procesos que est\u00e9n ejecut\u00e1ndose en el propio host podr\u00e1n comunicar con el servidor. Si proporcionamos una cadena vac\u00eda, el servidro aceptar\u00e1 conexiones entrantes a trav\u00e9s de todas las interfaces IPv4 disponibles en el sistema. El n\u00famero de puerto ( port ) se especifica con un valor entero entre 1 y 65535, y espcifica el puerto (en este caso, TCP) a trav\u00e9s del cual el servidor aceptar\u00e1 conexiones desde los clientes. La mayor\u00eda de sistemas requieren permisos de superusuario para escuchar a trav\u00e9s de los puertos ( well-known ), es decir, con valor inferior a 1024. Continuando con el ejemplo, listen() posibilita que un servidor pueda, en el futuro, aceptar ( accept() ) conexiones entrantes. En otras palabras, pone a la escucha al socket : s.listen() conn, addr = s.accept() La invocaci\u00f3n a accept() bloquea el proceso y espera a una conexi\u00f3n entrante. Cuando un cliente conecta, devuelve un objeto socket que representa la conexi\u00f3n, as\u00ed como una tupla ( addr ) que contiene la direcci\u00f3n del cliente. Concretamente, esta tupla contiene los valores (host, port) que almacenan la direcci\u00f3n IPv4 y puerto del cliente que solicita la conexi\u00f3n. Observa que, en el ejemplo, conn es el objeto socket que usaremos para comunicar con el cliente: conn, addr = s.accept() with conn: print('Conectado ', addr) while True: data = conn.recv(1024) if not data: break conn.sendall(data) Tras obtener el objeto devuelto por accept() , dise\u00f1amos el servidor como un bucle infinito que invoca repetidamente a llamadas bloqueantes a conn.recv() . As\u00ed, leemos los datos enviados por el cliente y los reenviamos sin modificaci\u00f3n utilizando conn.sendall() . Si conn.recv() devuelve un objeto de tipo bytes vac\u00edo ( b'' ) significa que el cliente cerr\u00f3 la conexi\u00f3n, en cuyo caso el bucle termina, destruy\u00e9ndose el socket al salir de la sentencia with . Cliente echo Veamos a continuaci\u00f3n la estructura general del cliente (puedes usar, por ejemplo, cliente_echo.py como nombre para el fichero): #!/usr/bin/env python3 ### cliente_echo.py import socket HOST = '127.0.0.1' # IP del servidor PORT = 65432 # Puerto de escucha del servidor with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: s.connect((HOST, PORT)) s.sendall(b'Hola, mundo') data = s.recv(1024) print('Recibido ', repr(data)) En comparaci\u00f3n con el servidor, la estructura del cliente es m\u00e1s simple; simplemente crea un nuevo objeto socket , conecta con el servidor e invoca a s.sendall() para enviar el mensaje. Finalmente, espera la recepci\u00f3n de la respuesta utilizando s.recv() y la imprime por pantalla. Ejecuci\u00f3n del cliente y servidor echo A continuaci\u00f3n, ejecutaremos cliente y servidor para observar el estado de las conexiones durante su ciclo de vida. Ejecuta en una terminal el servidor: $ python3 ./servidor-echo.py Como ves, la terminal se bloquea (de hecho, el servidor permanece en estado bloqueado) en la invocaci\u00f3n: conn, addr = s.accept() Realmente, el servidor est\u00e1 esperando a que haya conexiones entrantes por parte de un cliente. Abre otra terminal y ejecuta el cliente: $ python3 cliente-echo.py Recibido 'Hola, mundo' En la ventana del servidor, deber\u00edas ver algo similar a: $ python3 ./servidor-echo.py Conectado ('127.0.0.1, 61234') En esta salida, el servidor ha mostrado por pantalla la tupla devuelta por s.accept() , que incluye la direcci\u00f3n IP y el n\u00famero de puerto TCP. Dicho n\u00famero de puerto (en el ejemplo anterior, 61234) es seleccionado aleatoriamente por el sistema operativo y puede variar en tu ejecuci\u00f3n. Herramientas para observar el estado del socket Podemos utilizar la herramienta netstat para observar el estado actual de los sockets en cualquier sistema operativo (macOS, Linux e incluso Windows). Por ejemplo, esta ser\u00eda la salida de netstat en Linux tras ejecutar el servidor: netstat -an | grep 65432 Conexiones activas de Internet (servidores y establecidos) Proto Recib Enviad Direcci\u00f3n local Direcci\u00f3n remota Estado tcp 0 0 127.0.0.1:65432 0.0.0.0:* ESCUCHAR Observa que hemos filtrado la salida de la orden netcat seg\u00fan el n\u00famero de puerto utilizado. Observa el valor de las columnas Proto, Direcci\u00f3n local y Estado . Nota Otra forma de observar el estado de las conexiones es a trav\u00e9s de la orden lsof -i -n . Ejec\u00fatala y observa su salida. Capturas de tr\u00e1fico v\u00eda Wireshark Wireshark es una herramienta de c\u00f3digo abierto ampliamente utilizada para analizar protocolos de comunicaci\u00f3n de red en cualquiera de las capas de la pila TCP/IP (como tambi\u00e9n en otros protocolos). Wireshark implementa un amplio abanico de filtros para definir criterios de b\u00fasqueda en las capturas de tr\u00e1fico, aunque de momento, en nuestro caso, no ser\u00e1 necesario utilizar filtros espec\u00edficos. Para arrancar Wireshark en la m\u00e1quina virtual proporcionada (o en cualquier instalaci\u00f3n b\u00e1sica Linux), teclea en tu terminal: $ sudo wireshark Tras el arranque, podemos comenzar una nueva captura de tr\u00e1fico a trav\u00e9s del men\u00fa Capture , opci\u00f3n Start . La pantalla de selecci\u00f3n de interfaz nos permitir\u00e1 definir en qu\u00e9 interfaz de red se realizar\u00e1 la captura. En nuestro caso, ya que vamos a comunicar dos procesos en la misma m\u00e1quina, elegiremos la interfaz de Loopback (lo) y comenzaremos la captura. Tarea Arranca Wireshark y prepara una captura sobre la interfaz de loopback . Ejecuta el servidor echo TCP y el cliente correspondiente, y analiza el tr\u00e1fico generado. Especialmente, f\u00edjate en el proceso de establecimiento de conexi\u00f3n en tres v\u00edas, paquetes de Acknowledge tras el env\u00edo de cada mensaje y, en general, en cualquier otro aspecto que consideres de inter\u00e9s. Sockets UDP La creaci\u00f3n y gesti\u00f3n de sockets UDP en Python resulta todav\u00eda m\u00e1s sencilla. Observa el siguiente c\u00f3digo, que crea un servidor UDP utilizando la API de sockets Python: import socket udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) udp_socket.bind((\"localhost\", 5005)) data = udp_socket.recv(512) print(data) Primero, importamos la biblioteca socket de recepci\u00f3n, igual que en el caso de TCP. Obviamente, en este caso el tipo de socket pasa a ser socket.DOCK_DGRAM , para indicar que deseamos utilizar UDP en la comunicaci\u00f3n. El programa espera a la recepci\u00f3n de un paquete utilizando el m\u00e9todo bloqueante recv , cuyo \u00fanico par\u00e1metro indica el n\u00famero m\u00e1ximo de bytes que deseamos recibir. Cuando un paquete llega al socket, el metodo recv devolver\u00e1 un array de bytes, que ser\u00e1 almacenado en la variable que deseemos. El env\u00edo de datos a trav\u00e9s de un socket UDP es tambi\u00e9n sencillo: import socket udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) udp_socket.bind((\"localhost\", 0)) data = b\"Hola, mundo!\" udp_socket.sendto(data,(\"localhost\", 5005)) Observa que, en este caso, asociamos ( bind ) el socket a un puerto especificado como 0. Este valor especial indica al sistema operativo que elija para la transimisi\u00f3n un puerto origen aleatorio de entre los disponibles en el sistema. A continuaci\u00f3n, creamos los datos a enviar y los enviamos utilizando el m\u00e9todo sendto() . Este m\u00e9todo tomados argumentos: datos a enviar, y precisamente la direcci\u00f3n de env\u00edo. Los datos enviados a trav\u00e9s del socket deben formar parte de un array de bytes (por ello, la cadena a enviar viene precedida por el car\u00e1cter b ). Tarea Comprueba que, efectivamente, los c\u00f3digos de env\u00edo y recepci\u00f3n a trav\u00e9s de UDP funcionan como se espera. Nota Desde la versi\u00f3n 3 de Python, las cadenas se codifican utilizando Unicode. Al contrario que ASCII, conde cada caracter tiene una representaci\u00f3n en byte directa, Unicode utiliza enteros par representar cada caracter, que deben ser codificados para obtener una representaci\u00f3n en forma de byte. Uno de esos esquemas de codificaci\u00f3n es UTF-8. Por ejemplo, el siguiente c\u00f3digo muestra c\u00f3mo codificar una cadena Unicode en una representaci\u00f3n de bytes: cadena= \"Hola\" data = cadena.encode(\"UTF-8\") print(data, type(data)) lo cual genera b\"Hola\" <class 'bytes'> que puede ya ser enviado directamente por red. Hasta este punto, los programas UDP han sido totalmente unidireccionales en el env\u00edo/recepci\u00f3n de datos, pero obviamente, un socket UDP es un canal de comunicaci\u00f3n bidireccional. Tarea Implementa una funcionalidad similar al servidor echo que vimos para TCP, pero utilizando en este caso UDP. Realiza una captura de tr\u00e1fico en Wireshark similar a la realizada en el caso de TCP, y observa las principales diferencias entre ellas a nivel de tr\u00e1fico generado. Env\u00edo de datos binarios a trav\u00e9s de sockets Hasta este punto, hemos visto \u00fanicamente c\u00f3mo enviar cadenas de texto a trav\u00e9s de sockets TCP o UDP, pero es muy probable que sea necesario (o conveniente), en ocasiones, enviar datos directamente en formato binario (por ejemplo, valores num\u00e9ricos en punto flotante o enteros). Utilizando el m\u00f3dulo struct de Python podemos especificar qu\u00e9 tipo o tipos de datos se almacenan en una secuencia de bytes y c\u00f3mo decodificarlos. Tambi\u00e9n es posible especificar en qu\u00e9 lugar de la secuencia se alojan dichos datos, permitiendo el empaquetado de m\u00faltiples datos de distintos tipos de forma sencilla, y su posterior decodificaci\u00f3n en el otro extremo de la comunicaci\u00f3n. Nota Para todos los detalles del m\u00f3dulo struct , consulta la p\u00e1gina oficial de documentaci\u00f3n . El m\u00f3dulo struct proporciona dos m\u00e9todos de inter\u00e9s: pack y unpack . La siguiente sentencia: struct.pack(\">iii\", 1, 2, 3) utiliza el m\u00e9todo pack para realizar un empaquetado de datos. Concretamente, observa como el m\u00e9todo recibe dos par\u00e1metros: En primer lugar, el par\u00e1metro de formato \">iii\" . Define como debe codificarse cada valor en la secuencia de bytes. El primer car\u00e1cter indica el endianness utilizado, en este caso big endian (utilizar\u00edamos \">\" para big endian , \"<\" para little endian y \"=\" para network (big) endian). En segundo lugar, los valores a empaquetar. Observa que el formato, adem\u00e1s, incluye el n\u00famero y tipo de los datos a empaquetar (en este caso, tres valores detipo entero). Para otros tipos de datos, consulta la documentaci\u00f3n del m\u00f3dulo. Desempaquetar los datos enviados en el extremo opuesto es intuitivo: a, b, c = struct.unpack( \">iii\" ) A continuaci\u00f3n, mostramos un ejemplo de sistema cliente/servidor TCP que hace uso del m\u00f3dulo struct para realizar el env\u00edo de dos datos enteros y uno flotante entre un cliente y un servidor. # Cliente import binascii import socket import struct import sys # Socket TCP sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_address = ('localhost', 10001) sock.connect(server_address) packed_data = struct.pack(\"=iif\", 1, 4, 2.7) try: # Envio de datos print('Enviando \"%s\"' % binascii.hexlify(packed_data)) sock.sendall(packed_data) finally: print('Cerrando socket') sock.close() # Servidor import binascii import socket import struct import sys # Socket TCP sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_address = ('localhost', 10001) sock.bind(server_address) sock.listen(1) while True: print('Esperando conexiones entrantes') connection, client_address = sock.accept() try: data = connection.recv(1024) print('Recibido \"%s\"' % binascii.hexlify(data)) unpacked_data = struct.unpack(\"=iif\", data) print('Desempaquetado:', unpacked_data) finally: connection.close() Tarea Ejecuta el anterior sistema cliente servidor y analiza el tr\u00e1fico generado, en busca de los datos binarios empaquetados. Experimenta con otros tipos de datos y endianess y observa las diferencias. Tarea entregable Tarea entregable Se pide dise\u00f1ar un sistema cliente/servidor programado en Python, que simule el env\u00edo de un conjunto de datos sensorizados desde un cliente hacia un servidor. El protocolo a utilizar (formato de datos enviado por la red a nivel de aplicaci\u00f3n) debe ser propuesto por el propio alumno y descrito previamente al desarrollo. Se valorar\u00e1 el uso de m\u00faltiples tipos de datos tanto en el env\u00edo de datos sensorizados como de posibles respuestas por parte del servidor. Se desarrollar\u00e1 una versi\u00f3n utilizando TCP y otra equivalente usando UDP. El cliente enviar\u00e1 los datos de forma peri\u00f3dica y se \u00e9stos generar\u00e1n de modo aleatorio. A modo de entrega, se solicitan los c\u00f3digos desarrollados, as\u00ed como un an\u00e1lisis del tr\u00e1fico generado, considerando la sobrecarga (en bytes reales enviados) introducida por cada protocolo de capa de transporte. Ejemplo de sistema cliente/servidor multi-hilo Los ejemplos anteriormente descritos, aunque funcionales, adolecen en su dise\u00f1o de una caracter\u00edstica esencial: el servidor deja de atender peticiones entrantes mientras trata cada nuevo env\u00edo por parte del cliente. Los siguientes ejemplos muestran implementaciones sencillas con soporte multi-hilo para un sistema cliente/servidor escrito en Python. # Servidor TCP concurrente import socket, threading class ClientThread(threading.Thread): def __init__(self,clientAddress,clientsocket): threading.Thread.__init__(self) self.csocket = clientsocket print (\"Nueva conexion anyadida: \", clientAddress) def run(self): print (\"Conexion desde: \", clientAddress) #self.csocket.send(bytes(\"Hi, This is from Server..\",'utf-8')) msg = '' while True: data = self.csocket.recv(2048) msg = data.decode() if msg=='bye': break print (\"Desde el cliente\", msg) self.csocket.send(bytes(msg,'UTF-8')) print (\"Cliente \", clientAddress , \" desconectado...\") LOCALHOST = \"127.0.0.1\" PORT = 8080 server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) server.bind((LOCALHOST, PORT)) print(\"Servidor arrancado...\") print(\"Esperando petici\u00f3n de clientes...\") server.listen(1) while True: clientsock, clientAddress = server.accept() newthread = ClientThread(clientAddress, clientsock) newthread.start() # Cliente TCP. El env\u00edo de la cadena bye indica petici\u00f3n de desconexi\u00f3n. import socket SERVER = \"127.0.0.1\" PORT = 8080 client = socket.socket(socket.AF_INET, socket.SOCK_STREAM) client.connect((SERVER, PORT)) client.sendall(bytes(\"Hola, soy un cliente!!\",'UTF-8')) while True: in_data = client.recv(1024) print(\"Desde el servidor :\" ,in_data.decode()) out_data = input() client.sendall(bytes(out_data,'UTF-8')) if out_data=='end': break client.close() Tarea Estudia el c\u00f3digo del servidor concurrente y observa c\u00f3mo gestiona la creaci\u00f3n de hilos para atender cada petici\u00f3n entrante. Conecta simult\u00e1neamente m\u00faltiples clientes y observa el estado de los sockets mediante las herramientas correspondientes. Tarea entregable opcional Tarea entregable opcional Modifica tu primer entregable para considerar una implementaci\u00f3n multihilo del servidor TCP, siguiendo las directrices de los c\u00f3digos de ejemplo anteriormente proporcionados. Tarea entregable opcional Tarea entregable opcional Modifica el protocolo de env\u00edo para que tu aplicaci\u00f3n cliente/servidor UDP garantice en la medida de lo posible la recepci\u00f3n de los paquetes enviados desde el cliente, as\u00ed como su recepci\u00f3n en orden. Vuelve a analizar el tr\u00e1fico necesario en este caso comparado con una comunicaci\u00f3n b\u00e1sica basada en TCP (donde s\u00ed se garantizan, a nivel de transporte, dichas caracter\u00edsticas).","title":"Pr\u00e1ctica 1"},{"location":"RPI-II/P1/#practica-1-programacion-con-sockets-en-python","text":"","title":"Pr\u00e1ctica 1. Programaci\u00f3n con sockets en Python"},{"location":"RPI-II/P1/#objetivos","text":"Familiarizarse con la API de sockets en Python. Desarrollar esquemas b\u00e1sicos de sistemas cliente/servidor TCP y UDP utilizando Python. Ser capaces de analizar el tr\u00e1fico generado en una conexi\u00f3n TCP y UDP a trav\u00e9s de Wireshark. Dise\u00f1ar un protocolo de capa de aplicaci\u00f3n para simular una aplicaci\u00f3n cliente/servidor utilizando TCP y UDP. Observar la diferencia en tr\u00e1fico generado para una misma aplicaci\u00f3n utilizando TCP y UDP. Implementar servidores multi-hilo en Python.","title":"Objetivos"},{"location":"RPI-II/P1/#introduccion","text":"La historia de los sockets se remonta al origen de ARPANET, en 1971, y su posterior estandarizaci\u00f3n en forma de API dentro del sistema operativo Berkeley Software Distribution (BSD) , liberado en 1983, bajo el nombre de sockets de Berkeley . Con la popularizaci\u00f3n de Internet en los a\u00f1os 90, y de la mano de la World Wide Web , la programaci\u00f3n de red sufri\u00f3 tambi\u00e9n una notable evoluci\u00f3n. Los servidores web y los navegadores no fueron (ni son) las \u00fanicas aplicaciones basadas en sockets . De hecho, los sistemas cliente/servidor son a d\u00eda de hoy ubicuos e incluyen, por supuesto, a todos los protocolos de alto nivel que dan soporte a Internet de las Cosas. De hecho, a d\u00eda de hoy, aunque los potocolos de alto nivel (capa de aplicaci\u00f3n) han evolucionado hasta niveles de sofisticaci\u00f3n no considerados en sus inicios, la API de bajo nivel sobre la que se basan se mantiene inalterada. El tipo m\u00e1s com\u00fan de aplicaciones basadas en sockets se basa en el paradigma cliente/servidor, donde una de las partes act\u00faa como servidor , esperando pasivamente conexiones desde un conjunto de uno o m\u00e1s clientes . A continuaci\u00f3n, veremos c\u00f3mo desarrollar este tipo de paradigma desde Python, utilizando sockets Berkeley . Existen tambi\u00e9n los llamados Unix domain sockets , que permiten la comunicaci\u00f3n directa entre procesos en el mismo host , aunque quedan fuera de nuestro inter\u00e9s en el \u00e1mbito de IoT.","title":"Introducci\u00f3n"},{"location":"RPI-II/P1/#la-api-de-sockets-en-python","text":"El m\u00f3dulo socket de Python proporciona una interfaz completa para trabajar con la API de sockets de Berkeley . En la presente pr\u00e1ctica, trabajaremos exclusivamente con esta API para desarrollar aplicaciones cliente/servidor utilizando los protocolos TCP y UDP. Las funciones y m\u00e9todos principales de la API de sockets son: socket() - bind() - listen() - accept() - connect() - connect_ex() - send() - recv() - close() - Python prorpociona una API consistente y completa mapeada directamente a las anteriores llamadas al sistema, t\u00edpicamente escritas en lenguaje C. Como parte de su biblioteca est\u00e1ndar, Python tambi\u00e9n proporciona clases que facilitan el trabajo con las funciones de bajo nivel. Aunque no lo cubriremos, el m\u00f3dulo socketserver proporciona una forma sencilla de crear servidores de red. Existen tambi\u00e9n numerosos m\u00f3dulos disponibles para implementar protocolos de alto nivel (por ejemplo HTTP o SMTP), v\u00e9ase .","title":"La API de sockets en Python"},{"location":"RPI-II/P1/#sockets-tcp","text":"En Python, los sockets TCP se crean en Python utilizando socket.socket() , especificando el tipo de socket como socket.SOCK_STREAM . El protocolo de control de transmisi\u00f3n (TCP) se caracteriza por dos rasgos principales: Es confiable : se implementan mecanismos de detecci\u00f3n de p\u00e9rdidas en la red y reenv\u00edo de paquetes perdidos. Garantiza una entrega de paquetes en orden : los datos se entregan a las capas superiores (aplicaciones) en el mismo orden en el que fueron enviados. En contra, los sockets UDP se crean a trav\u00e9s de socket.SOCK_DGRAM , y no son confiables ni garantizan la entrega de paquetes en orden. Por tanto, es el desarrollador de aplicaciones quien, en caso de as\u00ed desearlo en el dise\u00f1o de la aplicaci\u00f3n, debe implementar estos mecanismos de forma espec\u00edfica. En el siguiente diagrama se muestra la secuencia t\u00edpica de invocaciones a la API de sockets para TCP: En la figura, la columna de la izquierda representa al servidor, mientras que la columna de la derecha representa al cliente en la conexi\u00f3n TCP. Observa las invocaciones necesarias para configurar un socket a la escucha de conexiones entrantes: socket() bind() listen() accept() En este extremo, un socket escucha ( listen ) potenciales conexiones entrantes desde clientes. Cuando un cliente solicita conectar, el servidor acepta ( accept ) la conexi\u00f3n, complet\u00e1ndola. El cliente invoca a connect() para establecer una conexi\u00f3n con el servidor e inicia el proceso de conexi\u00f3n a tres v\u00edas ( three-way connection ). Una vez establecida la conexi\u00f3n, los datos se intercambian entre cliente y servidor a trav\u00e9s de invocaciones a send() y recv() . Finalmente, el socket se destruye (esto es, la conexi\u00f3n entre ambos extremos se cierra) a trav\u00e9s de una invocaci\u00f3n a close() en cada extremo.","title":"Sockets TCP"},{"location":"RPI-II/P1/#clienteservidor-echo-tcp","text":"Veamos un ejemplo sencillo para crear un par cliente-servidor. En este caso, el servidor simplemente responder\u00e1 con la misma cadena que reciba desde el cliente.","title":"Cliente/servidor echo TCP"},{"location":"RPI-II/P1/#servidor-echo","text":"#!/usr/bin/env python3 #### servidor_echo.py import socket HOST = '127.0.0.1' # Interfaz est\u00e1ndar de loopback (localhost) PORT = 65432 # Puerto de escucha (los puertos mayores a 1023 son no privilegiados) with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: s.bind((HOST, PORT)) s.listen() conn, addr = s.accept() with conn: print('Conectado ', addr) while True: data = conn.recv(1024) if not data: break conn.sendall(data) Nota De momento, no importa si no entiendes todas las l\u00edneas en el anterior c\u00f3digo. Simplemente se trata de un punto de partida para desarrollar un servidor sencillo. Sin embargo, es conveniente que copies el c\u00f3digo en un fichero de texto (por ejemplo, llamado servidor_echo.py ) para que podeamos probarlo. Veamos l\u00ednea a l\u00ednea las partes m\u00e1s importantes del anterior c\u00f3digo. socket.socket() crea un objeto socket . Observa que, al crearse a trav\u00e9s de una construcci\u00f3n with , no es necesario invocar expl\u00edcitamente a s.close() , aunque debes tener en cuenta que el objeto es destruido al finalizar la construcci\u00f3n: with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: pass # Es posible usar el socket win invocar a s.close(). Los argumentos que se proporcionan a socket() especifican la familia de direcciones ( AF_INET ) y tipo de socket ( SOCK_STREAM ). AF_INET es la familia de direcciones de Internet para IPv4. SOCK_STREAM es el tipo de socket que permite la creaci\u00f3n de conexiones TCP. bind() se utiliza para asociar el socket a una interfaz de red y n\u00famero de puerto espec\u00edficos: HOST = '127.0.0.1' # Interfaz est\u00e1ndar de loopback (localhost) PORT = 65432 # Puerto de escucha (los puertos mayores a 1023 son no privilegiados) # ... s.bind((HOST, PORT)) Los valores proporcionados a bind() dependen de la familia de direcciones seleccionada para el socket . En este ejemplo, al utilizar AF_INET , espera una tupla con \u00fanicamente dos valores (host, puerto) . Para determinar el host , es posible utilizar un nombre de host , una direcci\u00f3n IP o una cadena vac\u00eda. Si utilizamos una direcci\u00f3n IP, \u00e9sta debe ser especificarse mediante una cadena que contenga una direcci\u00f3n IPv4 bien formada. La direcci\u00f3n 127.0.0.1 es la direcci\u00f3n IPv4 est\u00e1ndar para la interfaz de loopback , por lo que \u00fanicamente procesos que est\u00e9n ejecut\u00e1ndose en el propio host podr\u00e1n comunicar con el servidor. Si proporcionamos una cadena vac\u00eda, el servidro aceptar\u00e1 conexiones entrantes a trav\u00e9s de todas las interfaces IPv4 disponibles en el sistema. El n\u00famero de puerto ( port ) se especifica con un valor entero entre 1 y 65535, y espcifica el puerto (en este caso, TCP) a trav\u00e9s del cual el servidor aceptar\u00e1 conexiones desde los clientes. La mayor\u00eda de sistemas requieren permisos de superusuario para escuchar a trav\u00e9s de los puertos ( well-known ), es decir, con valor inferior a 1024. Continuando con el ejemplo, listen() posibilita que un servidor pueda, en el futuro, aceptar ( accept() ) conexiones entrantes. En otras palabras, pone a la escucha al socket : s.listen() conn, addr = s.accept() La invocaci\u00f3n a accept() bloquea el proceso y espera a una conexi\u00f3n entrante. Cuando un cliente conecta, devuelve un objeto socket que representa la conexi\u00f3n, as\u00ed como una tupla ( addr ) que contiene la direcci\u00f3n del cliente. Concretamente, esta tupla contiene los valores (host, port) que almacenan la direcci\u00f3n IPv4 y puerto del cliente que solicita la conexi\u00f3n. Observa que, en el ejemplo, conn es el objeto socket que usaremos para comunicar con el cliente: conn, addr = s.accept() with conn: print('Conectado ', addr) while True: data = conn.recv(1024) if not data: break conn.sendall(data) Tras obtener el objeto devuelto por accept() , dise\u00f1amos el servidor como un bucle infinito que invoca repetidamente a llamadas bloqueantes a conn.recv() . As\u00ed, leemos los datos enviados por el cliente y los reenviamos sin modificaci\u00f3n utilizando conn.sendall() . Si conn.recv() devuelve un objeto de tipo bytes vac\u00edo ( b'' ) significa que el cliente cerr\u00f3 la conexi\u00f3n, en cuyo caso el bucle termina, destruy\u00e9ndose el socket al salir de la sentencia with .","title":"Servidor echo"},{"location":"RPI-II/P1/#cliente-echo","text":"Veamos a continuaci\u00f3n la estructura general del cliente (puedes usar, por ejemplo, cliente_echo.py como nombre para el fichero): #!/usr/bin/env python3 ### cliente_echo.py import socket HOST = '127.0.0.1' # IP del servidor PORT = 65432 # Puerto de escucha del servidor with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: s.connect((HOST, PORT)) s.sendall(b'Hola, mundo') data = s.recv(1024) print('Recibido ', repr(data)) En comparaci\u00f3n con el servidor, la estructura del cliente es m\u00e1s simple; simplemente crea un nuevo objeto socket , conecta con el servidor e invoca a s.sendall() para enviar el mensaje. Finalmente, espera la recepci\u00f3n de la respuesta utilizando s.recv() y la imprime por pantalla.","title":"Cliente echo"},{"location":"RPI-II/P1/#ejecucion-del-cliente-y-servidor-echo","text":"A continuaci\u00f3n, ejecutaremos cliente y servidor para observar el estado de las conexiones durante su ciclo de vida. Ejecuta en una terminal el servidor: $ python3 ./servidor-echo.py Como ves, la terminal se bloquea (de hecho, el servidor permanece en estado bloqueado) en la invocaci\u00f3n: conn, addr = s.accept() Realmente, el servidor est\u00e1 esperando a que haya conexiones entrantes por parte de un cliente. Abre otra terminal y ejecuta el cliente: $ python3 cliente-echo.py Recibido 'Hola, mundo' En la ventana del servidor, deber\u00edas ver algo similar a: $ python3 ./servidor-echo.py Conectado ('127.0.0.1, 61234') En esta salida, el servidor ha mostrado por pantalla la tupla devuelta por s.accept() , que incluye la direcci\u00f3n IP y el n\u00famero de puerto TCP. Dicho n\u00famero de puerto (en el ejemplo anterior, 61234) es seleccionado aleatoriamente por el sistema operativo y puede variar en tu ejecuci\u00f3n.","title":"Ejecuci\u00f3n del cliente y servidor echo"},{"location":"RPI-II/P1/#herramientas-para-observar-el-estado-del-socket","text":"Podemos utilizar la herramienta netstat para observar el estado actual de los sockets en cualquier sistema operativo (macOS, Linux e incluso Windows). Por ejemplo, esta ser\u00eda la salida de netstat en Linux tras ejecutar el servidor: netstat -an | grep 65432 Conexiones activas de Internet (servidores y establecidos) Proto Recib Enviad Direcci\u00f3n local Direcci\u00f3n remota Estado tcp 0 0 127.0.0.1:65432 0.0.0.0:* ESCUCHAR Observa que hemos filtrado la salida de la orden netcat seg\u00fan el n\u00famero de puerto utilizado. Observa el valor de las columnas Proto, Direcci\u00f3n local y Estado . Nota Otra forma de observar el estado de las conexiones es a trav\u00e9s de la orden lsof -i -n . Ejec\u00fatala y observa su salida.","title":"Herramientas para observar el estado del socket"},{"location":"RPI-II/P1/#capturas-de-trafico-via-wireshark","text":"Wireshark es una herramienta de c\u00f3digo abierto ampliamente utilizada para analizar protocolos de comunicaci\u00f3n de red en cualquiera de las capas de la pila TCP/IP (como tambi\u00e9n en otros protocolos). Wireshark implementa un amplio abanico de filtros para definir criterios de b\u00fasqueda en las capturas de tr\u00e1fico, aunque de momento, en nuestro caso, no ser\u00e1 necesario utilizar filtros espec\u00edficos. Para arrancar Wireshark en la m\u00e1quina virtual proporcionada (o en cualquier instalaci\u00f3n b\u00e1sica Linux), teclea en tu terminal: $ sudo wireshark Tras el arranque, podemos comenzar una nueva captura de tr\u00e1fico a trav\u00e9s del men\u00fa Capture , opci\u00f3n Start . La pantalla de selecci\u00f3n de interfaz nos permitir\u00e1 definir en qu\u00e9 interfaz de red se realizar\u00e1 la captura. En nuestro caso, ya que vamos a comunicar dos procesos en la misma m\u00e1quina, elegiremos la interfaz de Loopback (lo) y comenzaremos la captura. Tarea Arranca Wireshark y prepara una captura sobre la interfaz de loopback . Ejecuta el servidor echo TCP y el cliente correspondiente, y analiza el tr\u00e1fico generado. Especialmente, f\u00edjate en el proceso de establecimiento de conexi\u00f3n en tres v\u00edas, paquetes de Acknowledge tras el env\u00edo de cada mensaje y, en general, en cualquier otro aspecto que consideres de inter\u00e9s.","title":"Capturas de tr\u00e1fico v\u00eda Wireshark"},{"location":"RPI-II/P1/#sockets-udp","text":"La creaci\u00f3n y gesti\u00f3n de sockets UDP en Python resulta todav\u00eda m\u00e1s sencilla. Observa el siguiente c\u00f3digo, que crea un servidor UDP utilizando la API de sockets Python: import socket udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) udp_socket.bind((\"localhost\", 5005)) data = udp_socket.recv(512) print(data) Primero, importamos la biblioteca socket de recepci\u00f3n, igual que en el caso de TCP. Obviamente, en este caso el tipo de socket pasa a ser socket.DOCK_DGRAM , para indicar que deseamos utilizar UDP en la comunicaci\u00f3n. El programa espera a la recepci\u00f3n de un paquete utilizando el m\u00e9todo bloqueante recv , cuyo \u00fanico par\u00e1metro indica el n\u00famero m\u00e1ximo de bytes que deseamos recibir. Cuando un paquete llega al socket, el metodo recv devolver\u00e1 un array de bytes, que ser\u00e1 almacenado en la variable que deseemos. El env\u00edo de datos a trav\u00e9s de un socket UDP es tambi\u00e9n sencillo: import socket udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) udp_socket.bind((\"localhost\", 0)) data = b\"Hola, mundo!\" udp_socket.sendto(data,(\"localhost\", 5005)) Observa que, en este caso, asociamos ( bind ) el socket a un puerto especificado como 0. Este valor especial indica al sistema operativo que elija para la transimisi\u00f3n un puerto origen aleatorio de entre los disponibles en el sistema. A continuaci\u00f3n, creamos los datos a enviar y los enviamos utilizando el m\u00e9todo sendto() . Este m\u00e9todo tomados argumentos: datos a enviar, y precisamente la direcci\u00f3n de env\u00edo. Los datos enviados a trav\u00e9s del socket deben formar parte de un array de bytes (por ello, la cadena a enviar viene precedida por el car\u00e1cter b ). Tarea Comprueba que, efectivamente, los c\u00f3digos de env\u00edo y recepci\u00f3n a trav\u00e9s de UDP funcionan como se espera. Nota Desde la versi\u00f3n 3 de Python, las cadenas se codifican utilizando Unicode. Al contrario que ASCII, conde cada caracter tiene una representaci\u00f3n en byte directa, Unicode utiliza enteros par representar cada caracter, que deben ser codificados para obtener una representaci\u00f3n en forma de byte. Uno de esos esquemas de codificaci\u00f3n es UTF-8. Por ejemplo, el siguiente c\u00f3digo muestra c\u00f3mo codificar una cadena Unicode en una representaci\u00f3n de bytes: cadena= \"Hola\" data = cadena.encode(\"UTF-8\") print(data, type(data)) lo cual genera b\"Hola\" <class 'bytes'> que puede ya ser enviado directamente por red. Hasta este punto, los programas UDP han sido totalmente unidireccionales en el env\u00edo/recepci\u00f3n de datos, pero obviamente, un socket UDP es un canal de comunicaci\u00f3n bidireccional. Tarea Implementa una funcionalidad similar al servidor echo que vimos para TCP, pero utilizando en este caso UDP. Realiza una captura de tr\u00e1fico en Wireshark similar a la realizada en el caso de TCP, y observa las principales diferencias entre ellas a nivel de tr\u00e1fico generado.","title":"Sockets UDP"},{"location":"RPI-II/P1/#envio-de-datos-binarios-a-traves-de-sockets","text":"Hasta este punto, hemos visto \u00fanicamente c\u00f3mo enviar cadenas de texto a trav\u00e9s de sockets TCP o UDP, pero es muy probable que sea necesario (o conveniente), en ocasiones, enviar datos directamente en formato binario (por ejemplo, valores num\u00e9ricos en punto flotante o enteros). Utilizando el m\u00f3dulo struct de Python podemos especificar qu\u00e9 tipo o tipos de datos se almacenan en una secuencia de bytes y c\u00f3mo decodificarlos. Tambi\u00e9n es posible especificar en qu\u00e9 lugar de la secuencia se alojan dichos datos, permitiendo el empaquetado de m\u00faltiples datos de distintos tipos de forma sencilla, y su posterior decodificaci\u00f3n en el otro extremo de la comunicaci\u00f3n. Nota Para todos los detalles del m\u00f3dulo struct , consulta la p\u00e1gina oficial de documentaci\u00f3n . El m\u00f3dulo struct proporciona dos m\u00e9todos de inter\u00e9s: pack y unpack . La siguiente sentencia: struct.pack(\">iii\", 1, 2, 3) utiliza el m\u00e9todo pack para realizar un empaquetado de datos. Concretamente, observa como el m\u00e9todo recibe dos par\u00e1metros: En primer lugar, el par\u00e1metro de formato \">iii\" . Define como debe codificarse cada valor en la secuencia de bytes. El primer car\u00e1cter indica el endianness utilizado, en este caso big endian (utilizar\u00edamos \">\" para big endian , \"<\" para little endian y \"=\" para network (big) endian). En segundo lugar, los valores a empaquetar. Observa que el formato, adem\u00e1s, incluye el n\u00famero y tipo de los datos a empaquetar (en este caso, tres valores detipo entero). Para otros tipos de datos, consulta la documentaci\u00f3n del m\u00f3dulo. Desempaquetar los datos enviados en el extremo opuesto es intuitivo: a, b, c = struct.unpack( \">iii\" ) A continuaci\u00f3n, mostramos un ejemplo de sistema cliente/servidor TCP que hace uso del m\u00f3dulo struct para realizar el env\u00edo de dos datos enteros y uno flotante entre un cliente y un servidor. # Cliente import binascii import socket import struct import sys # Socket TCP sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_address = ('localhost', 10001) sock.connect(server_address) packed_data = struct.pack(\"=iif\", 1, 4, 2.7) try: # Envio de datos print('Enviando \"%s\"' % binascii.hexlify(packed_data)) sock.sendall(packed_data) finally: print('Cerrando socket') sock.close() # Servidor import binascii import socket import struct import sys # Socket TCP sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_address = ('localhost', 10001) sock.bind(server_address) sock.listen(1) while True: print('Esperando conexiones entrantes') connection, client_address = sock.accept() try: data = connection.recv(1024) print('Recibido \"%s\"' % binascii.hexlify(data)) unpacked_data = struct.unpack(\"=iif\", data) print('Desempaquetado:', unpacked_data) finally: connection.close() Tarea Ejecuta el anterior sistema cliente servidor y analiza el tr\u00e1fico generado, en busca de los datos binarios empaquetados. Experimenta con otros tipos de datos y endianess y observa las diferencias.","title":"Env\u00edo de datos binarios a trav\u00e9s de sockets"},{"location":"RPI-II/P1/#tarea-entregable","text":"Tarea entregable Se pide dise\u00f1ar un sistema cliente/servidor programado en Python, que simule el env\u00edo de un conjunto de datos sensorizados desde un cliente hacia un servidor. El protocolo a utilizar (formato de datos enviado por la red a nivel de aplicaci\u00f3n) debe ser propuesto por el propio alumno y descrito previamente al desarrollo. Se valorar\u00e1 el uso de m\u00faltiples tipos de datos tanto en el env\u00edo de datos sensorizados como de posibles respuestas por parte del servidor. Se desarrollar\u00e1 una versi\u00f3n utilizando TCP y otra equivalente usando UDP. El cliente enviar\u00e1 los datos de forma peri\u00f3dica y se \u00e9stos generar\u00e1n de modo aleatorio. A modo de entrega, se solicitan los c\u00f3digos desarrollados, as\u00ed como un an\u00e1lisis del tr\u00e1fico generado, considerando la sobrecarga (en bytes reales enviados) introducida por cada protocolo de capa de transporte.","title":"Tarea entregable"},{"location":"RPI-II/P1/#ejemplo-de-sistema-clienteservidor-multi-hilo","text":"Los ejemplos anteriormente descritos, aunque funcionales, adolecen en su dise\u00f1o de una caracter\u00edstica esencial: el servidor deja de atender peticiones entrantes mientras trata cada nuevo env\u00edo por parte del cliente. Los siguientes ejemplos muestran implementaciones sencillas con soporte multi-hilo para un sistema cliente/servidor escrito en Python. # Servidor TCP concurrente import socket, threading class ClientThread(threading.Thread): def __init__(self,clientAddress,clientsocket): threading.Thread.__init__(self) self.csocket = clientsocket print (\"Nueva conexion anyadida: \", clientAddress) def run(self): print (\"Conexion desde: \", clientAddress) #self.csocket.send(bytes(\"Hi, This is from Server..\",'utf-8')) msg = '' while True: data = self.csocket.recv(2048) msg = data.decode() if msg=='bye': break print (\"Desde el cliente\", msg) self.csocket.send(bytes(msg,'UTF-8')) print (\"Cliente \", clientAddress , \" desconectado...\") LOCALHOST = \"127.0.0.1\" PORT = 8080 server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) server.bind((LOCALHOST, PORT)) print(\"Servidor arrancado...\") print(\"Esperando petici\u00f3n de clientes...\") server.listen(1) while True: clientsock, clientAddress = server.accept() newthread = ClientThread(clientAddress, clientsock) newthread.start() # Cliente TCP. El env\u00edo de la cadena bye indica petici\u00f3n de desconexi\u00f3n. import socket SERVER = \"127.0.0.1\" PORT = 8080 client = socket.socket(socket.AF_INET, socket.SOCK_STREAM) client.connect((SERVER, PORT)) client.sendall(bytes(\"Hola, soy un cliente!!\",'UTF-8')) while True: in_data = client.recv(1024) print(\"Desde el servidor :\" ,in_data.decode()) out_data = input() client.sendall(bytes(out_data,'UTF-8')) if out_data=='end': break client.close() Tarea Estudia el c\u00f3digo del servidor concurrente y observa c\u00f3mo gestiona la creaci\u00f3n de hilos para atender cada petici\u00f3n entrante. Conecta simult\u00e1neamente m\u00faltiples clientes y observa el estado de los sockets mediante las herramientas correspondientes.","title":"Ejemplo de sistema cliente/servidor multi-hilo"},{"location":"RPI-II/P1/#tarea-entregable-opcional","text":"Tarea entregable opcional Modifica tu primer entregable para considerar una implementaci\u00f3n multihilo del servidor TCP, siguiendo las directrices de los c\u00f3digos de ejemplo anteriormente proporcionados.","title":"Tarea entregable opcional"},{"location":"RPI-II/P1/#tarea-entregable-opcional_1","text":"Tarea entregable opcional Modifica el protocolo de env\u00edo para que tu aplicaci\u00f3n cliente/servidor UDP garantice en la medida de lo posible la recepci\u00f3n de los paquetes enviados desde el cliente, as\u00ed como su recepci\u00f3n en orden. Vuelve a analizar el tr\u00e1fico necesario en este caso comparado con una comunicaci\u00f3n b\u00e1sica basada en TCP (donde s\u00ed se garantizan, a nivel de transporte, dichas caracter\u00edsticas).","title":"Tarea entregable opcional"},{"location":"RPI-II/P10/","text":"Pr\u00e1ctica 10. Frameworks IoT. Cloud","title":"Pr\u00e1ctica 10"},{"location":"RPI-II/P10/#practica-10-frameworks-iot-cloud","text":"","title":"Pr\u00e1ctica 10. Frameworks IoT. Cloud"},{"location":"RPI-II/P2/","text":"Pr\u00e1ctica 2. Sockets TCP y UDP en ESP-IDF Objetivos Familiarizarse con la API de sockets en C. Desarrollar esquemas b\u00e1sicos de sistemas cliente/servidor TCP y UDP utilizando C. Ser capaces de analizar el tr\u00e1fico generado en una conexi\u00f3n TCP y UDP a trav\u00e9s de Wireshark. Dise\u00f1ar un protocolo de capa de aplicaci\u00f3n para simular una aplicaci\u00f3n cliente/servidor utilizando TCP y UDP para interactuar entre un host y la placa ESP32 Introducci\u00f3n En la pr\u00e1ctica anterior, vimos c\u00f3mo desarrollar sistemas cliente/servidor sencillos utilizando Python, tanto en sus variantes TCP como UDP. El objetivo de la presente pr\u00e1ctica es estudiar y desarrollar componentes de red (clientes y servidores TCP y UDP) que puedan ejecutarse sobre el ESP32 haciendo uso de las facilidades propuestas por ESP-IDF. Adem\u00e1s, demostraremos que es posible hacer interactuar clientes y servidores ejecut\u00e1ndose indistintamente en la m\u00e1quina virtual (programados v\u00eda Python) y en la propia placa (utilizando la API de sockets de C). La API de sockets en C Funciones para ordenacion de bytes Como TCP/IP es un est\u00e1ndar universal, y permite comunicaciones entre cualquier plataforma y arquitectura, es necesario disponer de un m\u00e9todo de ordenaci\u00f3n de los bytes para que m\u00e1quinas big-endian y little-endian puedan comunicarse de forma transparente y correcta. Para ello, se suelen proporcionar rutinas de reordenaci\u00f3n de bytes. En plataformas donde los datos ya est\u00e1n correctamente ordenados, estas funciones no tienen ninguna funcionalidad especial, pero en cualquier caso, es necesario utilizarlas siempre para que la comunicaci\u00f3n entre pares sea correcta. Las funciones t\u00edpicas de reordenaci\u00f3n de datos son cuatro: htons , htonl , ntohs y ntohl . Su nombre explica correctamente su sem\u00e1ntica: host to network (short) host to network (long) , network to host (short) y network to host (long) , convirtiendo tipos de datos short y long desde el formato utilizado en transmisiones de red ( network ) a representaci\u00f3n en el host . As\u00ed, siempre que enviemos un dato binario por la red, deber\u00e1 ser transformado utilizando hton* y cuando lo recibamos y debamos procesarlo, utilizando ntoh* . Estructuras de datos Antes de estudiar la API de sockets b\u00e1sica, es necesario mostrar el cometido de un conjunto de estructuras de datos utilizadas comunmente en todas ellas. La m\u00e1s importante es sockaddr_in , que se define como sigue: struct sockaddr_in { short sin_family; u_short sin_port; struct in_addr sin_addr; char sin_zero[8]; }; La estructura in_addr utilizada en sockaddr_in se define como: struct in_addr { u_long s_addr; }; \u00c9sta consiste en un campo de tipo unsigned long int que contiene la direcci\u00f3n IP que se asociar\u00e1 con el socket. La estructura sockaddr_in contiene dos campos importantes: sin_family : que indica al socket qu\u00e9 familia de protocolos se utiliar\u00e1n (usaremos la constante AF_INET para IPv4). sin_port : que indica el puerto asociado al socket. API b\u00e1sica socket() Prototipo: int socket(int family, int type, int protocol); Descripci\u00f3n: Crea un endpoint de comunicaci\u00f3n y devuelve un descriptor de fichero para manejarlo. Par\u00e1metros: family : AF_INET (IPv4), AF_INET6 (IPv6). type : SOCK_DGRAM (UDP), SOCK_STREAM (TCP), SOCK_RAW . protocol : T\u00edpicamente 0 (no usado en sockets de Internet). Valor de retorno: Si tiene \u00e9xito, devuelve el descriptor de socket . Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de socket ( man socket ). bind() Prototipo: int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); Descripci\u00f3n: Asocia un socket a una direcci\u00f3n especificada por addr . Normalmente, es necesario asignar una direcci\u00f3n local v\u00eda esta funci\u00f3n antes de que un socket TCP pueda recibir conexiones. Par\u00e1metros: sockfd : descriptor de socket (devuelto por socket ). addr : direcci\u00f3n a asociar (v\u00e9ase estructura en secci\u00f3n anterior). addrlen : longitud (en bytes) de la anterior estructura. Valor de retorno: Si tiene \u00e9xito, devuelve 0. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de bind ( man bind ). listen() Prototipo: int listen(int sockfd, int backlog); Descripci\u00f3n: Marca el socket proporcionado como pasivo , esto es, un socket que podr\u00e1 ser utilizado para aceptar conexiones entrantes usando la llamada accept . Par\u00e1metros: sockfd : descriptor de socket (devuelto por socket ). backlog : longitud m\u00e1xima que podr\u00e1 tener la cola de conexiones pendientes para el socket . Si se sobrepasa, el cliente recibir\u00e1 un error en su intento de conexi\u00f3n. Valor de retorno: Si tiene \u00e9xito, devuelve 0. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de listen ( man listen ). accept() Prototipo: int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); Descripci\u00f3n: En sockets orientados a conexi\u00f3n, extrae la primera solicitud de conexi\u00f3n de la cola de conexiones pendientes para el socket proporcionado, crea un nuevo socket conectado y devuelve su descriptor. Par\u00e1metros: sockfd : descriptor de socket (devuelto por socket ). addr : es un puntero a una estructura de tipo sockaddr , cuyos campos ser\u00e1n rellenados con los datos de direcci\u00f3n del socket remoto. addrlen : tama\u00f1o de la estructura addr . Valor de retorno: Si tiene \u00e9xito, devuelve el descriptor de socket. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de accept ( man accept ). connect() Prototipo: int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); Descripci\u00f3n: Conecta el socket proporcionada a la direcci\u00f3n espec\u00edficada por addr . Si el socket es UDP, addr ser\u00e1 la direcci\u00f3n a la que se enviar\u00e1n los datagramas por defecto, y la \u00fanica desde la que se recibir\u00e1n datagramas. En caso de TCP, esta llamada inicia el proceso de conexi\u00f3n a la direcci\u00f3n especificada. Par\u00e1metros: sockfd : descriptor de socket (devuelto por socket ). addr : es un puntero a una estructura de tipo sockaddr , cuyos campos indican la direcci\u00f3n de conexi\u00f3n destino. addrlen : tama\u00f1o de la estructura addr . Valor de retorno: Si tiene \u00e9xito, devuelve el descriptor de socket. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de connect ( man connect ). send() Prototipo: ssize_t send(int sockfd, const void *buf, size_t len, int flags); Descripci\u00f3n: En un socket en estado conectado (con receptor conocido) transmite mensajes a un socket remoto. Par\u00e1metros: sockfd : descriptor de socket de env\u00edo. buf : buffer de env\u00edo donde se almacena el mensaje a enviar. len : n\u00famero de bytes a enviar. Valor de retorno: Si tiene \u00e9xito, devuelve el n\u00famero de bytes enviados. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de send ( man send ). recv() / recvfrom() Prototipos: ssize_t recv(int sockfd, void *buf, size_t len, int flags); ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen); Descripci\u00f3n: Reciben mensajes desde un socket , tanto en sockets orientados como no orientados a conexi\u00f3n. recvfrom , a diferencia de recv , recibe par\u00e1metrosd de salida adicionales que almacenan informaci\u00f3n sobre la direcci\u00f3n origen del mensaje. Par\u00e1metros: sockfd : descriptor de socket de recepci\u00f3n. buf : buffer de recepci\u00f3n donde se almacena el mensaje a recibir. len : n\u00famero de bytes a recibir. src_addr : direcci\u00f3n del extremo remoto del socket (origen de la comunicaci\u00f3n). addrlen : tama\u00f1o de la estructura src_addr . Valor de retorno: Si tiene \u00e9xito, devuelve el n\u00famero de bytes recibidos. Devuelve -1 si se produce un error. Detalles: consultad las p\u00e1ginas de manual de recv y recv_from ( man recv y man recv_from ). close() Prototipo: int close(int fd); Descripci\u00f3n: Cierra un socket. Par\u00e1metros: fd : descriptor de socket . Detalles: consultad la p\u00e1gina de manual de close ( man close ). Ejemplos Se proporcionan a continuaci\u00f3n ejemplos completos de uso de la API de sockets en C para el desarrollo de sistemas cliente/servidor sencillos. Para cada uno de ellos, comprueba que, efectivamente, el uso y secuencia de aplicaci\u00f3n de cada llamada sigue las directivas de la figura: Tarea Compila ( gcc ejemplo.c -o ejemplo.x ) y ejecuta ( ./ejemplo.x ) cada par de c\u00f3digos y comprueba su funcionamiento. Estudia con detenimiento el uso de cada rutina y como efectivamente siguen las directivas marcadas anteriormente. Ejemplo: un cliente TCP #include <arpa/inet.h> #include <stdio.h> #include <string.h> #include <sys/socket.h> #include <unistd.h> #include <netinet/in.h> int main() { const int server_port = 9000; struct sockaddr_in server_address; memset(&server_address, 0, sizeof(server_address)); server_address.sin_family = AF_INET; server_address.sin_addr.s_addr = inet_addr(\"127.0.0.1\"); server_address.sin_port = htons(server_port); int sock; if ((sock = socket(PF_INET, SOCK_STREAM, 0)) < 0) { printf(\"Error en socket\\n\"); return 1; } if (connect(sock, (struct sockaddr*)&server_address, sizeof(server_address)) < 0) { printf(\"Error en connect\\n\"); return 1; } const char* data_to_send = \"Hola, RPI!!\"; send(sock, data_to_send, strlen(data_to_send), 0); int n = 0; int len = 0, maxlen = 100; char buffer[maxlen]; char* pbuffer = buffer; while ((n = recv(sock, pbuffer, maxlen, 0)) > 0) { pbuffer += n; maxlen -= n; len += n; buffer[len] = '\\0'; printf(\"Recibido: '%s'\\n\", buffer); } close(sock); return 0; } Ejemplo: un servidor TCP #include <arpa/inet.h> #include <netinet/in.h> #include <stdbool.h> #include <stdio.h> #include <string.h> #include <unistd.h> int main(int argc, char *argv[]) { int SERVER_PORT = 9000; struct sockaddr_in server_address; memset(&server_address, 0, sizeof(server_address)); server_address.sin_family = AF_INET; server_address.sin_port = htons(SERVER_PORT); server_address.sin_addr.s_addr = htonl(INADDR_ANY); int listen_sock; if ((listen_sock = socket(PF_INET, SOCK_STREAM, 0)) < 0) { printf(\"Error en socket\\n\"); return 1; } if ((bind(listen_sock, (struct sockaddr *)&server_address, sizeof(server_address))) < 0) { printf(\"Error en bind\\n\"); return 1; } int wait_size = 16; if (listen(listen_sock, wait_size) < 0) { printf(\"Error en listen\\n\"); return 1; } struct sockaddr_in client_address; int client_address_len = 0; while (true) { int sock; if ((sock = accept(listen_sock, (struct sockaddr *)&client_address, &client_address_len)) < 0) { printf(\"Error en accept\\n\"); return 1; } int n = 0; int len = 0, maxlen = 100; char buffer[maxlen]; char *pbuffer = buffer; printf(\"Cliente conectado con IP: %s\\n\", inet_ntoa(client_address.sin_addr)); while ((n = recv(sock, pbuffer, maxlen, 0)) > 0) { pbuffer += n; maxlen -= n; len += n; printf(\"Recibido: '%s'\\n\", buffer); send(sock, buffer, len, 0); } close(sock); } close(listen_sock); return 0; } Tarea Reproduce el funcionamiento del anterior sistema cliente/servidor echo utilizando UDP. Construcci\u00f3n de mensajes Para enviar mensajes que encapsulen distintos tipos de datos en una sola invocaci\u00f3n, puedes definir un mensaje como el siguiente: typedef struct { int x; int y; } mensaje; Dando valor a cada campo y a continuaci\u00f3n envi\u00e1ndolo proporcionando la direcci\u00f3n de inicio de la estructura, del siguiente modo: mensaje.x = x; mensaje.y = y; send( socketfd, &mensaje, sizeof( mensaje ), 0 ); Tarea Modifica el cliente UDP para que encapsule y env\u00ede una estructura con distintos campos (por ejemplo, dos enteros), que sea recibida por un servidor Python siguiendo las directivas de la anterior pr\u00e1ctica. En este caso, no utilices campos de tipo flotante (veremos c\u00f3mo hacerlo m\u00e1s adelante). El objetivo del ejercicio es simplemente comprobar que la comunicaci\u00f3n entre un cliente programado en C y un servidor programado en Python es posible. No se pretende que desarrolles un sistema complejo. Sistemas cliente/servidor en el ESP32 La raz\u00f3n por la que hemos ejercitado el uso de la API de sockets desde C en Linux es que la implementaci\u00f3n de la pila TCP/IP en ESP-IDF (llamada Lightweight TCP/IP (lwIP) ) implementa al 100% dicha API. Por tanto, tanto la estructura b\u00e1sica de un firmware que implemente un cliente o servidor como la API utilizada permanece inalterada. En esta \u00faltima secci\u00f3n, se pide trabajar con dos ejemplos b\u00e1sicos de implementaci\u00f3n de sistemas cliente/servidor UDP y TCP sobre el ESP32, con el objetivo de estudiar su funcionalidad, comprobar su interoperabilidad y realizar modificaciones para adaptarlas a una hipot\u00e9tica aplicaci\u00f3n IoT. Cliente/servidor UDP en el ESP32 En esta parte, trabajar\u00e1s con dos ejemplos proporcionados dentro de la colecci\u00f3n de ejemplos de ESP-IDF. Por tanto, copia en tu espacio de trabajo (fuera del \u00e1rbol principal de ESP-IDF) los ejemplos: Servidor UDP : examples/protocols/sockets/udp_server/ Cliente UDP : examples/protocols/sockets/udp_client/ Estructura general Observa sus c\u00f3digos ( udp_server.c para el servidor, y udp_client.c para el cliente). Comprueba que, tanto la estructura b\u00e1sica de ambos componentes como las invocaciones a la API de sockets concuerdan con las que vimos para el sistema echo programado en C. Acerca de la tarea principal (funcion app_main ) observa que realiza una serie de llamadas a APIs de configuraci\u00f3n de algunos subsistemas de FreeRTOS, principalmente: // Inicializa la partici\u00f3n NVS (Non-volatile storage) por defecto. ESP_ERROR_CHECK(nvs_flash_init()); // Inicializa la infraestructura ESP-NETIF. ESP_ERROR_CHECK(esp_netif_init()); // Crea un bucle de eventos por defecto. ESP_ERROR_CHECK(esp_event_loop_create_default()); /* Esta funci\u00f3n configura WiFi o Ethernet, tal y como seleccionemos via menuconfig. */ ESP_ERROR_CHECK(example_connect()); xTaskCreate(udp_server_task, \"udp_server\", 4096, NULL, 5, NULL); example_connect() , funci\u00f3n que no forma parte de ESP-IDF, establece una conexi\u00f3n WiFi o Ethernet. La funci\u00f3n es bloqueante, y retorna cuando se ha conseguido establecer una conexi\u00f3n. Las caracter\u00edsticas de la conexi\u00f3n WiFi (SSID y contrase\u00f1a) se deben proporcionar a trav\u00e9s de menuconfig . El objetivo de ESP-NETIF es proporcionar una capa de abstracci\u00f3n por encima de la pila TCP/IP, de modo que pueda migrarse la pila sin que los c\u00f3digos del usuario cambien. Puedes consultar su documentaci\u00f3n en la p\u00e1gina oficial . Por \u00faltimo, se cerea una tarea que ejecutar\u00e1 la l\u00f3gica del servidor (lo mismo ocurre en el cliente). Observa que, en todo el c\u00f3digo, los mensajes de error se anotan utilizando la macro ESP_LOGE y los informativos con ESP_LOGI ; intenta seguir este convenio en tus c\u00f3digos. Despliegue. Opci\u00f3n 1 En este caso, desplegar\u00e1s el cliente en un ESP32 y el servidor en otro. Si no dispones de dos ESP32, puedes trabajar con un compa\u00f1ero. En cualquier caso, ambos ESP32 deben pertenecer a la misma red inal\u00e1mbrica, por lo que deber\u00e1n conectarse a un mismo punto de acceso (el profesor te proporcionar\u00e1 los datos, o simplemente puedes utilizar tu punto de acceso dom\u00e9stico). Configura los siguientes puntos de la infraestructura: Configura el SSID y contrase\u00f1a del punto de acceso v\u00eda menuconfig antes de compilar y flashear el c\u00f3digo tanto en el cliente como en el servidor. En el servidor, configura v\u00eda menuconfig el puerto sobre el que escuchar\u00e1. Arranca primero el nodo servidor y apunta la IP proporcionada por el punto de acceso; util\u00edzala en el cliente para configurar la IP destino de la comunicaci\u00f3n. No olvides configurar tambi\u00e9n el puerto destino de acuerdo al configurado en el servidor v\u00eda menuconfig . \u00can este punto, podr\u00e1s arrancar el cliente y deber\u00edas estar comunicando dos nodos ESP32 v\u00eda UDP. Despliegue. Opci\u00f3n 2 Si s\u00f3lo dispones de un nodo, o si simplemente quieres probar otra forma de comunicaci\u00f3n en la que uno de los equipos es un PC, puedes utilizar alguna de las herramientas del sistema: Nota Ten en cuenta que port\u00e1til (es decir, m\u00e1quina virtual) y ESP32 deben pertenecera la misma red. Para conseguirlo, para tu m\u00e1quina virtual y a\u00f1ade una nueva interfaz de red de tipo bridge conectada a la interfaz Wifi f\u00edsica de tu PC. As\u00ed, tendr\u00e1s una interfaz con IP en la misma red, otorgada directamente por tu punto de acceso. Para recibir un paquete UDP a trav\u00e9s de un puerto (es decir, emular un servidor UDP): nc -ul -p 3333 Para enviar un paquete UDP a una IP/puerto remotos (es decir, emular un cliente): nc -u IP_REMOTA 3333 En el directorio scripts dispones tambi\u00e9n de peque\u00f1os ejemplos de clientes y servidores UDP Python que puedes tambi\u00e9n utilizar. Cliente/servidor TCP en el ESP32 El despliegue de cliente y servidor TCP es equivalente al UDP. Para recibir un paquete TCP a trav\u00e9s de un puerto (es decir, emular un servidor TCP): nc -l IP -p 3333 Para enviar un paquete TCP a una IP/puerto remotos (es decir, emular un cliente): nc IP 3333 En el directorio scripts dispones tambi\u00e9n de peque\u00f1os ejemplos de clientes y servidores TCP Python que puedes tambi\u00e9n utilizar. Tarea Experimenta con los ejemplos proporcionados en ESP-IDF (cliente/servidor TCP y UDP) y consigue ejecutar todos los elementos en la placa. Si s\u00f3lo dispones de una placa, utiliza la m\u00e1quina virtual como cliente/servidor para comprobar el correcto funcionamiento de cada c\u00f3digo. Tarea entregable En este punto, deber\u00edas disponer de un conjunto de c\u00f3digos que implementan sistemas cliente/servidor tanto en un host (utilizando Python y/o C) como en la placa ESP32 (utilizando C y ESP-IDF), y deber\u00edas haber comprobado su correcto funcionamiento. Espec\u00edficamente, dispondr\u00e1s de: Sistema cliente/servidor desarrollado en la Pr\u00e1ctica 1, escrito en Python e implementando un protocolo b\u00e1sico de aplicacion (tipo de mensaje) propuesto por ti. C\u00f3digo b\u00e1sico en C para implementaci\u00f3n de un servidor/cliente echo programado en C, cuyos c\u00f3digos se proporcionan en este bolet\u00edn. C\u00f3digos b\u00e1sicos en C/ESP-IDF para implementar servidores/clientes echo sobre el ESP32. Como tarea entregable, se pide que adaptes tu entrega de la Pr\u00e1ctica 1 para que tanto cliente como servidor puedan funcionar en el host (bien usando tu implementaci\u00f3n Python, o bien utilizando una nueva implementaci\u00f3n en C) o en el ESP32. Se entregar\u00e1n los c\u00f3digos y una breve memoria con capturas de tr\u00e1fico que demuestren el correcto funcionamiento del sistema.","title":"Pr\u00e1ctica 2"},{"location":"RPI-II/P2/#practica-2-sockets-tcp-y-udp-en-esp-idf","text":"","title":"Pr\u00e1ctica 2. Sockets TCP y UDP en ESP-IDF"},{"location":"RPI-II/P2/#objetivos","text":"Familiarizarse con la API de sockets en C. Desarrollar esquemas b\u00e1sicos de sistemas cliente/servidor TCP y UDP utilizando C. Ser capaces de analizar el tr\u00e1fico generado en una conexi\u00f3n TCP y UDP a trav\u00e9s de Wireshark. Dise\u00f1ar un protocolo de capa de aplicaci\u00f3n para simular una aplicaci\u00f3n cliente/servidor utilizando TCP y UDP para interactuar entre un host y la placa ESP32","title":"Objetivos"},{"location":"RPI-II/P2/#introduccion","text":"En la pr\u00e1ctica anterior, vimos c\u00f3mo desarrollar sistemas cliente/servidor sencillos utilizando Python, tanto en sus variantes TCP como UDP. El objetivo de la presente pr\u00e1ctica es estudiar y desarrollar componentes de red (clientes y servidores TCP y UDP) que puedan ejecutarse sobre el ESP32 haciendo uso de las facilidades propuestas por ESP-IDF. Adem\u00e1s, demostraremos que es posible hacer interactuar clientes y servidores ejecut\u00e1ndose indistintamente en la m\u00e1quina virtual (programados v\u00eda Python) y en la propia placa (utilizando la API de sockets de C).","title":"Introducci\u00f3n"},{"location":"RPI-II/P2/#la-api-de-sockets-en-c","text":"","title":"La API de sockets en C"},{"location":"RPI-II/P2/#funciones-para-ordenacion-de-bytes","text":"Como TCP/IP es un est\u00e1ndar universal, y permite comunicaciones entre cualquier plataforma y arquitectura, es necesario disponer de un m\u00e9todo de ordenaci\u00f3n de los bytes para que m\u00e1quinas big-endian y little-endian puedan comunicarse de forma transparente y correcta. Para ello, se suelen proporcionar rutinas de reordenaci\u00f3n de bytes. En plataformas donde los datos ya est\u00e1n correctamente ordenados, estas funciones no tienen ninguna funcionalidad especial, pero en cualquier caso, es necesario utilizarlas siempre para que la comunicaci\u00f3n entre pares sea correcta. Las funciones t\u00edpicas de reordenaci\u00f3n de datos son cuatro: htons , htonl , ntohs y ntohl . Su nombre explica correctamente su sem\u00e1ntica: host to network (short) host to network (long) , network to host (short) y network to host (long) , convirtiendo tipos de datos short y long desde el formato utilizado en transmisiones de red ( network ) a representaci\u00f3n en el host . As\u00ed, siempre que enviemos un dato binario por la red, deber\u00e1 ser transformado utilizando hton* y cuando lo recibamos y debamos procesarlo, utilizando ntoh* .","title":"Funciones para ordenacion de bytes"},{"location":"RPI-II/P2/#estructuras-de-datos","text":"Antes de estudiar la API de sockets b\u00e1sica, es necesario mostrar el cometido de un conjunto de estructuras de datos utilizadas comunmente en todas ellas. La m\u00e1s importante es sockaddr_in , que se define como sigue: struct sockaddr_in { short sin_family; u_short sin_port; struct in_addr sin_addr; char sin_zero[8]; }; La estructura in_addr utilizada en sockaddr_in se define como: struct in_addr { u_long s_addr; }; \u00c9sta consiste en un campo de tipo unsigned long int que contiene la direcci\u00f3n IP que se asociar\u00e1 con el socket. La estructura sockaddr_in contiene dos campos importantes: sin_family : que indica al socket qu\u00e9 familia de protocolos se utiliar\u00e1n (usaremos la constante AF_INET para IPv4). sin_port : que indica el puerto asociado al socket.","title":"Estructuras de datos"},{"location":"RPI-II/P2/#api-basica","text":"","title":"API b\u00e1sica"},{"location":"RPI-II/P2/#socket","text":"Prototipo: int socket(int family, int type, int protocol); Descripci\u00f3n: Crea un endpoint de comunicaci\u00f3n y devuelve un descriptor de fichero para manejarlo. Par\u00e1metros: family : AF_INET (IPv4), AF_INET6 (IPv6). type : SOCK_DGRAM (UDP), SOCK_STREAM (TCP), SOCK_RAW . protocol : T\u00edpicamente 0 (no usado en sockets de Internet). Valor de retorno: Si tiene \u00e9xito, devuelve el descriptor de socket . Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de socket ( man socket ).","title":"socket()"},{"location":"RPI-II/P2/#bind","text":"Prototipo: int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); Descripci\u00f3n: Asocia un socket a una direcci\u00f3n especificada por addr . Normalmente, es necesario asignar una direcci\u00f3n local v\u00eda esta funci\u00f3n antes de que un socket TCP pueda recibir conexiones. Par\u00e1metros: sockfd : descriptor de socket (devuelto por socket ). addr : direcci\u00f3n a asociar (v\u00e9ase estructura en secci\u00f3n anterior). addrlen : longitud (en bytes) de la anterior estructura. Valor de retorno: Si tiene \u00e9xito, devuelve 0. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de bind ( man bind ).","title":"bind()"},{"location":"RPI-II/P2/#listen","text":"Prototipo: int listen(int sockfd, int backlog); Descripci\u00f3n: Marca el socket proporcionado como pasivo , esto es, un socket que podr\u00e1 ser utilizado para aceptar conexiones entrantes usando la llamada accept . Par\u00e1metros: sockfd : descriptor de socket (devuelto por socket ). backlog : longitud m\u00e1xima que podr\u00e1 tener la cola de conexiones pendientes para el socket . Si se sobrepasa, el cliente recibir\u00e1 un error en su intento de conexi\u00f3n. Valor de retorno: Si tiene \u00e9xito, devuelve 0. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de listen ( man listen ).","title":"listen()"},{"location":"RPI-II/P2/#accept","text":"Prototipo: int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); Descripci\u00f3n: En sockets orientados a conexi\u00f3n, extrae la primera solicitud de conexi\u00f3n de la cola de conexiones pendientes para el socket proporcionado, crea un nuevo socket conectado y devuelve su descriptor. Par\u00e1metros: sockfd : descriptor de socket (devuelto por socket ). addr : es un puntero a una estructura de tipo sockaddr , cuyos campos ser\u00e1n rellenados con los datos de direcci\u00f3n del socket remoto. addrlen : tama\u00f1o de la estructura addr . Valor de retorno: Si tiene \u00e9xito, devuelve el descriptor de socket. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de accept ( man accept ).","title":"accept()"},{"location":"RPI-II/P2/#connect","text":"Prototipo: int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); Descripci\u00f3n: Conecta el socket proporcionada a la direcci\u00f3n espec\u00edficada por addr . Si el socket es UDP, addr ser\u00e1 la direcci\u00f3n a la que se enviar\u00e1n los datagramas por defecto, y la \u00fanica desde la que se recibir\u00e1n datagramas. En caso de TCP, esta llamada inicia el proceso de conexi\u00f3n a la direcci\u00f3n especificada. Par\u00e1metros: sockfd : descriptor de socket (devuelto por socket ). addr : es un puntero a una estructura de tipo sockaddr , cuyos campos indican la direcci\u00f3n de conexi\u00f3n destino. addrlen : tama\u00f1o de la estructura addr . Valor de retorno: Si tiene \u00e9xito, devuelve el descriptor de socket. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de connect ( man connect ).","title":"connect()"},{"location":"RPI-II/P2/#send","text":"Prototipo: ssize_t send(int sockfd, const void *buf, size_t len, int flags); Descripci\u00f3n: En un socket en estado conectado (con receptor conocido) transmite mensajes a un socket remoto. Par\u00e1metros: sockfd : descriptor de socket de env\u00edo. buf : buffer de env\u00edo donde se almacena el mensaje a enviar. len : n\u00famero de bytes a enviar. Valor de retorno: Si tiene \u00e9xito, devuelve el n\u00famero de bytes enviados. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de send ( man send ).","title":"send()"},{"location":"RPI-II/P2/#recvrecvfrom","text":"Prototipos: ssize_t recv(int sockfd, void *buf, size_t len, int flags); ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen); Descripci\u00f3n: Reciben mensajes desde un socket , tanto en sockets orientados como no orientados a conexi\u00f3n. recvfrom , a diferencia de recv , recibe par\u00e1metrosd de salida adicionales que almacenan informaci\u00f3n sobre la direcci\u00f3n origen del mensaje. Par\u00e1metros: sockfd : descriptor de socket de recepci\u00f3n. buf : buffer de recepci\u00f3n donde se almacena el mensaje a recibir. len : n\u00famero de bytes a recibir. src_addr : direcci\u00f3n del extremo remoto del socket (origen de la comunicaci\u00f3n). addrlen : tama\u00f1o de la estructura src_addr . Valor de retorno: Si tiene \u00e9xito, devuelve el n\u00famero de bytes recibidos. Devuelve -1 si se produce un error. Detalles: consultad las p\u00e1ginas de manual de recv y recv_from ( man recv y man recv_from ).","title":"recv()/recvfrom()"},{"location":"RPI-II/P2/#close","text":"Prototipo: int close(int fd); Descripci\u00f3n: Cierra un socket. Par\u00e1metros: fd : descriptor de socket . Detalles: consultad la p\u00e1gina de manual de close ( man close ).","title":"close()"},{"location":"RPI-II/P2/#ejemplos","text":"Se proporcionan a continuaci\u00f3n ejemplos completos de uso de la API de sockets en C para el desarrollo de sistemas cliente/servidor sencillos. Para cada uno de ellos, comprueba que, efectivamente, el uso y secuencia de aplicaci\u00f3n de cada llamada sigue las directivas de la figura: Tarea Compila ( gcc ejemplo.c -o ejemplo.x ) y ejecuta ( ./ejemplo.x ) cada par de c\u00f3digos y comprueba su funcionamiento. Estudia con detenimiento el uso de cada rutina y como efectivamente siguen las directivas marcadas anteriormente.","title":"Ejemplos"},{"location":"RPI-II/P2/#ejemplo-un-cliente-tcp","text":"#include <arpa/inet.h> #include <stdio.h> #include <string.h> #include <sys/socket.h> #include <unistd.h> #include <netinet/in.h> int main() { const int server_port = 9000; struct sockaddr_in server_address; memset(&server_address, 0, sizeof(server_address)); server_address.sin_family = AF_INET; server_address.sin_addr.s_addr = inet_addr(\"127.0.0.1\"); server_address.sin_port = htons(server_port); int sock; if ((sock = socket(PF_INET, SOCK_STREAM, 0)) < 0) { printf(\"Error en socket\\n\"); return 1; } if (connect(sock, (struct sockaddr*)&server_address, sizeof(server_address)) < 0) { printf(\"Error en connect\\n\"); return 1; } const char* data_to_send = \"Hola, RPI!!\"; send(sock, data_to_send, strlen(data_to_send), 0); int n = 0; int len = 0, maxlen = 100; char buffer[maxlen]; char* pbuffer = buffer; while ((n = recv(sock, pbuffer, maxlen, 0)) > 0) { pbuffer += n; maxlen -= n; len += n; buffer[len] = '\\0'; printf(\"Recibido: '%s'\\n\", buffer); } close(sock); return 0; }","title":"Ejemplo: un cliente TCP"},{"location":"RPI-II/P2/#ejemplo-un-servidor-tcp","text":"#include <arpa/inet.h> #include <netinet/in.h> #include <stdbool.h> #include <stdio.h> #include <string.h> #include <unistd.h> int main(int argc, char *argv[]) { int SERVER_PORT = 9000; struct sockaddr_in server_address; memset(&server_address, 0, sizeof(server_address)); server_address.sin_family = AF_INET; server_address.sin_port = htons(SERVER_PORT); server_address.sin_addr.s_addr = htonl(INADDR_ANY); int listen_sock; if ((listen_sock = socket(PF_INET, SOCK_STREAM, 0)) < 0) { printf(\"Error en socket\\n\"); return 1; } if ((bind(listen_sock, (struct sockaddr *)&server_address, sizeof(server_address))) < 0) { printf(\"Error en bind\\n\"); return 1; } int wait_size = 16; if (listen(listen_sock, wait_size) < 0) { printf(\"Error en listen\\n\"); return 1; } struct sockaddr_in client_address; int client_address_len = 0; while (true) { int sock; if ((sock = accept(listen_sock, (struct sockaddr *)&client_address, &client_address_len)) < 0) { printf(\"Error en accept\\n\"); return 1; } int n = 0; int len = 0, maxlen = 100; char buffer[maxlen]; char *pbuffer = buffer; printf(\"Cliente conectado con IP: %s\\n\", inet_ntoa(client_address.sin_addr)); while ((n = recv(sock, pbuffer, maxlen, 0)) > 0) { pbuffer += n; maxlen -= n; len += n; printf(\"Recibido: '%s'\\n\", buffer); send(sock, buffer, len, 0); } close(sock); } close(listen_sock); return 0; } Tarea Reproduce el funcionamiento del anterior sistema cliente/servidor echo utilizando UDP.","title":"Ejemplo: un servidor TCP"},{"location":"RPI-II/P2/#construccion-de-mensajes","text":"Para enviar mensajes que encapsulen distintos tipos de datos en una sola invocaci\u00f3n, puedes definir un mensaje como el siguiente: typedef struct { int x; int y; } mensaje; Dando valor a cada campo y a continuaci\u00f3n envi\u00e1ndolo proporcionando la direcci\u00f3n de inicio de la estructura, del siguiente modo: mensaje.x = x; mensaje.y = y; send( socketfd, &mensaje, sizeof( mensaje ), 0 ); Tarea Modifica el cliente UDP para que encapsule y env\u00ede una estructura con distintos campos (por ejemplo, dos enteros), que sea recibida por un servidor Python siguiendo las directivas de la anterior pr\u00e1ctica. En este caso, no utilices campos de tipo flotante (veremos c\u00f3mo hacerlo m\u00e1s adelante). El objetivo del ejercicio es simplemente comprobar que la comunicaci\u00f3n entre un cliente programado en C y un servidor programado en Python es posible. No se pretende que desarrolles un sistema complejo.","title":"Construcci\u00f3n de mensajes"},{"location":"RPI-II/P2/#sistemas-clienteservidor-en-el-esp32","text":"La raz\u00f3n por la que hemos ejercitado el uso de la API de sockets desde C en Linux es que la implementaci\u00f3n de la pila TCP/IP en ESP-IDF (llamada Lightweight TCP/IP (lwIP) ) implementa al 100% dicha API. Por tanto, tanto la estructura b\u00e1sica de un firmware que implemente un cliente o servidor como la API utilizada permanece inalterada. En esta \u00faltima secci\u00f3n, se pide trabajar con dos ejemplos b\u00e1sicos de implementaci\u00f3n de sistemas cliente/servidor UDP y TCP sobre el ESP32, con el objetivo de estudiar su funcionalidad, comprobar su interoperabilidad y realizar modificaciones para adaptarlas a una hipot\u00e9tica aplicaci\u00f3n IoT.","title":"Sistemas cliente/servidor en el ESP32"},{"location":"RPI-II/P2/#clienteservidor-udp-en-el-esp32","text":"En esta parte, trabajar\u00e1s con dos ejemplos proporcionados dentro de la colecci\u00f3n de ejemplos de ESP-IDF. Por tanto, copia en tu espacio de trabajo (fuera del \u00e1rbol principal de ESP-IDF) los ejemplos: Servidor UDP : examples/protocols/sockets/udp_server/ Cliente UDP : examples/protocols/sockets/udp_client/","title":"Cliente/servidor UDP en el ESP32"},{"location":"RPI-II/P2/#estructura-general","text":"Observa sus c\u00f3digos ( udp_server.c para el servidor, y udp_client.c para el cliente). Comprueba que, tanto la estructura b\u00e1sica de ambos componentes como las invocaciones a la API de sockets concuerdan con las que vimos para el sistema echo programado en C. Acerca de la tarea principal (funcion app_main ) observa que realiza una serie de llamadas a APIs de configuraci\u00f3n de algunos subsistemas de FreeRTOS, principalmente: // Inicializa la partici\u00f3n NVS (Non-volatile storage) por defecto. ESP_ERROR_CHECK(nvs_flash_init()); // Inicializa la infraestructura ESP-NETIF. ESP_ERROR_CHECK(esp_netif_init()); // Crea un bucle de eventos por defecto. ESP_ERROR_CHECK(esp_event_loop_create_default()); /* Esta funci\u00f3n configura WiFi o Ethernet, tal y como seleccionemos via menuconfig. */ ESP_ERROR_CHECK(example_connect()); xTaskCreate(udp_server_task, \"udp_server\", 4096, NULL, 5, NULL); example_connect() , funci\u00f3n que no forma parte de ESP-IDF, establece una conexi\u00f3n WiFi o Ethernet. La funci\u00f3n es bloqueante, y retorna cuando se ha conseguido establecer una conexi\u00f3n. Las caracter\u00edsticas de la conexi\u00f3n WiFi (SSID y contrase\u00f1a) se deben proporcionar a trav\u00e9s de menuconfig . El objetivo de ESP-NETIF es proporcionar una capa de abstracci\u00f3n por encima de la pila TCP/IP, de modo que pueda migrarse la pila sin que los c\u00f3digos del usuario cambien. Puedes consultar su documentaci\u00f3n en la p\u00e1gina oficial . Por \u00faltimo, se cerea una tarea que ejecutar\u00e1 la l\u00f3gica del servidor (lo mismo ocurre en el cliente). Observa que, en todo el c\u00f3digo, los mensajes de error se anotan utilizando la macro ESP_LOGE y los informativos con ESP_LOGI ; intenta seguir este convenio en tus c\u00f3digos.","title":"Estructura general"},{"location":"RPI-II/P2/#despliegue-opcion-1","text":"En este caso, desplegar\u00e1s el cliente en un ESP32 y el servidor en otro. Si no dispones de dos ESP32, puedes trabajar con un compa\u00f1ero. En cualquier caso, ambos ESP32 deben pertenecer a la misma red inal\u00e1mbrica, por lo que deber\u00e1n conectarse a un mismo punto de acceso (el profesor te proporcionar\u00e1 los datos, o simplemente puedes utilizar tu punto de acceso dom\u00e9stico). Configura los siguientes puntos de la infraestructura: Configura el SSID y contrase\u00f1a del punto de acceso v\u00eda menuconfig antes de compilar y flashear el c\u00f3digo tanto en el cliente como en el servidor. En el servidor, configura v\u00eda menuconfig el puerto sobre el que escuchar\u00e1. Arranca primero el nodo servidor y apunta la IP proporcionada por el punto de acceso; util\u00edzala en el cliente para configurar la IP destino de la comunicaci\u00f3n. No olvides configurar tambi\u00e9n el puerto destino de acuerdo al configurado en el servidor v\u00eda menuconfig . \u00can este punto, podr\u00e1s arrancar el cliente y deber\u00edas estar comunicando dos nodos ESP32 v\u00eda UDP.","title":"Despliegue. Opci\u00f3n 1"},{"location":"RPI-II/P2/#despliegue-opcion-2","text":"Si s\u00f3lo dispones de un nodo, o si simplemente quieres probar otra forma de comunicaci\u00f3n en la que uno de los equipos es un PC, puedes utilizar alguna de las herramientas del sistema: Nota Ten en cuenta que port\u00e1til (es decir, m\u00e1quina virtual) y ESP32 deben pertenecera la misma red. Para conseguirlo, para tu m\u00e1quina virtual y a\u00f1ade una nueva interfaz de red de tipo bridge conectada a la interfaz Wifi f\u00edsica de tu PC. As\u00ed, tendr\u00e1s una interfaz con IP en la misma red, otorgada directamente por tu punto de acceso. Para recibir un paquete UDP a trav\u00e9s de un puerto (es decir, emular un servidor UDP): nc -ul -p 3333 Para enviar un paquete UDP a una IP/puerto remotos (es decir, emular un cliente): nc -u IP_REMOTA 3333 En el directorio scripts dispones tambi\u00e9n de peque\u00f1os ejemplos de clientes y servidores UDP Python que puedes tambi\u00e9n utilizar.","title":"Despliegue. Opci\u00f3n 2"},{"location":"RPI-II/P2/#clienteservidor-tcp-en-el-esp32","text":"El despliegue de cliente y servidor TCP es equivalente al UDP. Para recibir un paquete TCP a trav\u00e9s de un puerto (es decir, emular un servidor TCP): nc -l IP -p 3333 Para enviar un paquete TCP a una IP/puerto remotos (es decir, emular un cliente): nc IP 3333 En el directorio scripts dispones tambi\u00e9n de peque\u00f1os ejemplos de clientes y servidores TCP Python que puedes tambi\u00e9n utilizar. Tarea Experimenta con los ejemplos proporcionados en ESP-IDF (cliente/servidor TCP y UDP) y consigue ejecutar todos los elementos en la placa. Si s\u00f3lo dispones de una placa, utiliza la m\u00e1quina virtual como cliente/servidor para comprobar el correcto funcionamiento de cada c\u00f3digo. Tarea entregable En este punto, deber\u00edas disponer de un conjunto de c\u00f3digos que implementan sistemas cliente/servidor tanto en un host (utilizando Python y/o C) como en la placa ESP32 (utilizando C y ESP-IDF), y deber\u00edas haber comprobado su correcto funcionamiento. Espec\u00edficamente, dispondr\u00e1s de: Sistema cliente/servidor desarrollado en la Pr\u00e1ctica 1, escrito en Python e implementando un protocolo b\u00e1sico de aplicacion (tipo de mensaje) propuesto por ti. C\u00f3digo b\u00e1sico en C para implementaci\u00f3n de un servidor/cliente echo programado en C, cuyos c\u00f3digos se proporcionan en este bolet\u00edn. C\u00f3digos b\u00e1sicos en C/ESP-IDF para implementar servidores/clientes echo sobre el ESP32. Como tarea entregable, se pide que adaptes tu entrega de la Pr\u00e1ctica 1 para que tanto cliente como servidor puedan funcionar en el host (bien usando tu implementaci\u00f3n Python, o bien utilizando una nueva implementaci\u00f3n en C) o en el ESP32. Se entregar\u00e1n los c\u00f3digos y una breve memoria con capturas de tr\u00e1fico que demuestren el correcto funcionamiento del sistema.","title":"Cliente/servidor TCP en el ESP32"},{"location":"RPI-II/P3/","text":"Pr\u00e1ctica 3. Seguridad (TLS y DTLS) Objetivos Observar el comportamiento de TLS y DTLS para el intercambio cifrado de mensajes. Conocer las diferencias b\u00e1sicas entre TLS y DTLS. Conocer una API b\u00e1sica de programaci\u00f3n de sistemas cliente/servidor usando TLS y DTLS (WolfSSL). Conocer una API b\u00e1sica de programaci\u00f3n de sistemas cliente/servidor en ESP-IDF (ESP-TLS). Contenido del paquete proporcionado y setup b\u00e1sico El paquete proporcionado (puedes descargarlo aqu\u00ed ) incluye ejemplos de sistemas cliente/servidor programados utilizando TLS y DTLS mediante el uso de la biblioteca WolfSSL. Estos c\u00f3digos est\u00e1n dise\u00f1ados para ejecutarse exclusivamente en un sistema Linux, y requieren la instalaci\u00f3n de los paquetes de desarrollo WolfSSL. Para realizar la instalaci\u00f3n, ejecuta en tu m\u00e1quina virtual (esta l\u00ednea podr\u00eda cambiar si usas otra distribuci\u00f3n de Linux, en cuyo caso deber\u00e1s buscar los paquetes equivalentes): sudo apt-get install libwolfssl-dev libwolfssl24 Una vez hecho esto, prueba a realizar la compilaci\u00f3n tanto del ejemplo TLS como DTLS utilizando la orden make en el directorio correspondiente. Si todo ha ido bien, puedes continuar con el an\u00e1lisis de los c\u00f3digos en la siguiente secci\u00f3n. Cliente/servidor TLS. Ejemplo b\u00e1sico en host Servidor TLS Analizaremos en primer lugar el c\u00f3digo b\u00e1sico del servidor TLS. Para ello, observa el contenido del fchero tls/server-tls.c . Cabeceras y constantes El uso de WolfSSL requiere la inclusi\u00f3n de dos cabeceras b\u00e1sicas: #include <wolfssl/options.h> #include <wolfssl/ssl.h> Adem\u00e1s, ya que ser\u00e1n necesarios en el desarrollo, definiremos las rutas al certificado (clave p\u00fablica) del servidor y su clave privada: #define CERT_FILE \"../certs/server-cert.pem\" #define KEY_FILE \"../certs/server-key.pem\" Observa adem\u00e1s que el puerto de escucha del servidor ser\u00e1 el 11111 . Objetos b\u00e1sicos WolfSSL. Contexto y objeto SSL Definiremos dos objetos b\u00e1sicos que se utilizar\u00e1n de forma recurrente en el c\u00f3digo: WOLFSSL_CTX* ctx; WOLFSSL* ssl; El contexto ( ctx ) incluye valores globales para cada conexi\u00f3n SSL, incluyendo informaci\u00f3n sobre certificados. Es posible utilizar un mismo contexto para m\u00faltiples conexiones, siempre que compartan caracter\u00edsticas. Para crear un nuevo contexto, utilizaremos la funci\u00f3n wolfSSL_CTX_new como sigue: /* Create and initialize WOLFSSL_CTX */ if ((ctx = wolfSSL_CTX_new(wolfTLSv1_2_server_method())) == NULL) { fprintf(stderr, \"ERROR: failed to create WOLFSSL_CTX\\n\"); return -1; } El argumento proporcionado incluye informaci\u00f3n sobre la versi\u00f3n de protocolo a utilizar. Actualmente, WolfSSL soporta SSL 3.0, TLS 1.1, TLS 1.2, DTLS 1.0 y DTLS 1.2. En este caso, para la parte cliente, las funciones a utilizar como argumento ser\u00edan: wolfSSLv3_server_method(); // SSLv3 wolfTLSv1_server_method(); // TLSv1 wolfTLSv1_1_server_method(); // TLSv1.1 wolfTLSv1_2_server_method(); // TLSv1.2 wolfDTLSv1_server_method(); // DTLS wolfDTLSv1_2_server_method(); // DTLS 1.2 En segundo lugar, es necesario cargar nuestra CA (Autoridad Certificadora) en el contexto, para que cualquier cliente pueda verificar, en el momento de su conexi\u00f3n, la identidad del sevidor. Para ello, usamos la funci\u00f3n wolfSSL_CTX_use_certificate_file de la siguiente manera: /* Load server certificates into WOLFSSL_CTX */ if (wolfSSL_CTX_use_certificate_file(ctx, CERT_FILE, SSL_FILETYPE_PEM) != SSL_SUCCESS) { fprintf(stderr, \"ERROR: failed to load %s, please check the file.\\n\", CERT_FILE); return -1; } Del mismo modo, el servidor deber\u00e1 incluir su clave privada en formato PEM: /* Load server key into WOLFSSL_CTX */ if (wolfSSL_CTX_use_PrivateKey_file(ctx, KEY_FILE, SSL_FILETYPE_PEM) != SSL_SUCCESS) { fprintf(stderr, \"ERROR: failed to load %s, please check the file.\\n\", KEY_FILE); return -1; } A continuaci\u00f3n, observa como el c\u00f3digo de escucha y aceptaci\u00f3n de conexiones entrantes no difier de cualquier c\u00f3digo que hayas desarrollado previamente para aceptar conexiones entrantes TCP ( bind , + listen + accept ). Justo tras la conexi\u00f3n ( accept ), resulta necesario crear un nuevo objeto SSL, as\u00ed como asociar el descriptor de socket con la nueva sesi\u00f3n (conexi\u00f3n) TLS: /* Create a WOLFSSL object */ if ((ssl = wolfSSL_new(ctx)) == NULL) { fprintf(stderr, \"ERROR: failed to create WOLFSSL object\\n\"); return -1; } /* Attach wolfSSL to the socket */ wolfSSL_set_fd(ssl, connd); /* Establish TLS connection */ ret = wolfSSL_accept(ssl); if (ret != SSL_SUCCESS) { fprintf(stderr, \"wolfSSL_accept error = %d\\n\", wolfSSL_get_error(ssl, ret)); return -1; } A partir de este punto, podemos enviar y recibir datos a trav\u00e9s del socket (y por tanto de la conexi\u00f3n TLS) de forma muy similar a como lo hacemos con el enfoque cl\u00e1sico. As\u00ed, para recibir datos: if (wolfSSL_read(ssl, buff, sizeof(buff)-1) == -1) { fprintf(stderr, \"ERROR: failed to read\\n\"); return -1; } Y para enviar datos de vuelta: /* Reply back to the client */ if (wolfSSL_write(ssl, buff, len) != len) { fprintf(stderr, \"ERROR: failed to write\\n\"); return -1; } Por \u00faltimo, finalizaremos la conexi\u00f3n con la invocaci\u00f3n de la funci\u00f3n wolfSSL_free(ssl) . Note El cliente proporcionado sigue una estrategia de implementaci\u00f3n similar. Compara ambos c\u00f3digos (cliente y servidor) y aseg\u00farate de entender las diferencias entre ellos. Tarea entregable Compila y ejecuta el sistema cliente/servidor TLS y obt\u00e9n capturas de tr\u00e1fico tanto de las fases de establecimiento de conexi\u00f3n como de las fases de transferencia de datos. En base a lo aprendido en las clases de teor\u00eda y la documentaci\u00f3n adicional sobre TLS y wolfSSL, redacta un breve informe que resuma el proceso de handshake y transferencia de datos en TLS tomando como base los paquetes reales observados para esta conexi\u00f3n. Cliente/servidor DTLS. Ejemplo b\u00e1sico en host El desarrollo de un sistema b\u00e1sico cliente/servidor con soporte DTLS utilizando WolfSSL es muy similar al visto anteriormente para TLS. Como detalle adicional, la inicializaci\u00f3n de la infraestructura debe realizarse indicando el soporte para DTLS en sus versiones 1.0 o 1.2: wolfDTLSv1_client_method(); // DTLS 1.0 wolfDTLSv1_2_client_method(); // DTLS 1.2 El resto del c\u00f3digo sigue una filosof\u00eda similar a TLS, adaptado, obviamente, a las caracter\u00edsticas de UDP (tipo de socket, ausencia de conexi\u00f3n, etc.), por lo que se deja como ejercicio su an\u00e1lisis y ejecuci\u00f3n. Tarea entregable Analiza, compila y ejecuta los c\u00f3digos correspondientes al sistema cliente/servidor DTLS. Realiza capturas de tr\u00e1fico y comp\u00e1ralas, paquete a paquete, con las generadas para un patr\u00f3n de tr\u00e1fico similar en el caso de TLS. Incide en sus similitudes y diferencias, tanto a nivel de handshake como de transferencia de datos. Observa, en este \u00faltimo caso, la aparici\u00f3n de nuevos campos de encabezado en los env\u00edos de datos DTLS. \u00bfCu\u00e1l/cu\u00e1les son esos campos y por qu\u00e9 aparecen? Realiza una comparativa del tr\u00e1fico total generado en ambos casos para exactamente la misma cantidad de datos transferidos. TLS en el ESP32. El componente ESP-TLS ESP-IDF proporciona un componente (ESP-TLS) que ofrece una interfaz (API) simplificada para acceder a funcionalidad b\u00e1sica TLS. A\u00fan as\u00ed, ofrece una funcionalidad suficientemente amplia como para implementar casos de uso comunes en entornos IoT. La API de ESP-TLS es sencilla,y se basa en el uso de cuatro funciones b\u00e1sicas: Establecimiento de conexi\u00f3n TLS ( esp_tls_conn_new() ) Prototipo: esp_tls_t *esp_tls_conn_new(const char *hostname, int hostlen, int port, constesp_tls_cfg_t *cfg) Descripci\u00f3n: Crea una nueva conexi\u00f3n TLS/SSL bloqueante, estableciendo dicha conexi\u00f3n contra un servidor establecido. Par\u00e1metros: hostname : Identificaci\u00f3n del host. hostlen : Longitud del par\u00e1metro hostname . port : Puerto de conexi\u00f3n con el host. cfg : Configuraci\u00f3n de la conexi\u00f3n TLS. Valor de retorno: Puntero a esp_tls_t (manejador de la conexi\u00f3n). Devuelve NULL si se produce un error en la conexi\u00f3n. Destrucci\u00f3n de conexi\u00f3n TLS ( esp_tls_conn_delete() ) void esp_tls_conn_delete(esp_tls_t *tls) Descripci\u00f3n: Cierra la conexi\u00f3n TLS/SSL. Par\u00e1metros: tls : Manejador de la conexi\u00f3n. Escritura de datos ( esp_tls_conn_read() ) static ssize_t esp_tls_conn_write(esp_tls_t *tls, const void *data, size_t datalen) Descripci\u00f3n: Escribe en la conexi\u00f3n TLS/SSL indicada el contenido del buffer data . Par\u00e1metros: tls : Manejador de la conexi\u00f3n. data : Buffer de env\u00edo. datalen : Longitud del buffer de env\u00edo (o n\u00famero m\u00e1ximo de bytes a escribir). Valor de retorno: >=0 : \u00e9xito en el env\u00edo. N\u00famero de bytes efectivamente enviados. <0 : error en el env\u00edo. Lectura de datos ( esp_tls_conn_read() ) static ssize_t esp_tls_conn_read(esp_tls_t *tls, void *data, size_t datalen) Descripci\u00f3n: Lee desde la conexi\u00f3n TLS/SSL indicada hacia el buffer data . Par\u00e1metros: tls : Manejador de la conexi\u00f3n. data : Buffer de recepci\u00f3n. datalen : Longitud del buffer de recepci\u00f3n (o n\u00famero m\u00e1ximo de bytes a leer). Valor de retorno: >0 : \u00e9xito en la recepci\u00f3n. N\u00famero de bytes efectivamente le\u00eddos. =0 : error en la recepci\u00f3n. La conexi\u00f3n se cerr\u00f3. <0 : error en la recepci\u00f3n. Estructura b\u00e1sica de un cliente TCP usando ESP-IDF Un cliente TCP implementado sobre ESP-IDF para dar soporte TLS, requiere ciertas modificaciones con respecto a la versi\u00f3n sin TLS. De hecho, el uso de ESP-IDF simplifica el c\u00f3digo del cliente (puedes compararlo con tus clientes TCP desarrollados en sesiones anteriores). La estructura b\u00e1sica resultar\u00eda: /// Includes anteriores. #include \"esp_tls.h\" // Puede tomarse desde menuconfig. #define HOST_IP_ADDR DIRECCION_DE_HOST #define PORT PUERTO static const char *payload = \"Hola, mundo via TLS\"; // ... static void tls_client_task( void *pvParameters ) { // ... // Configuraci\u00f3n de ESP-TLS (vac\u00edo para opciones defecto). esp_tls_cfg_t cfg = { }; // Creaci\u00f3n de conexi\u00f3n. struct esp_tls *tls = esp_tls_conn_new( HOST_IP_ADDR, longitud, PORT, &cfg); // Chequeo de errores. // ... // Env\u00edo de datos. ret = esp_tls_conn_write(tls, payload, strlen(payload)); // Chequeo de errores. // ... // Lectura de datos ret = esp_tls_conn_read(tls, (char *)rx_buffer, 128); // Chequeo de errores. // ... // Destrucci\u00f3n de la conexi\u00f3n esp_tls_conn_delete( tls ); vTaskDelete( NULL ); } void app_main( void ) { // ... } Observa como, efectivamente, el c\u00f3digo del cliente se simplifica en gran medida con respecto a tu cliente TCP original. Toma el c\u00f3digo del proyecto que utilizaste para desarrollar tu cliente TCP original y, siguiendo las anteriores directivas, adapta la \u00fanica tarea a crear (por ejemplo, puede recibir el nombre tls_client_task ) para que realice un env\u00edo y recepci\u00f3n de datos (una cadena) al servidor TLS que probaste en el host . Puedes valerte para ello de la base del ejemplo examples/protocols/https_request , obviamente adaptando la totalidad de su c\u00f3digo para que se comporte como un simple cliente echo . Note Compila y ejecuta el cliente TLS en el ESP32, y consigue que interact\u00fae con el servidor TLS que probaste anteriormente en el host . Comprueba que, efectivamente, los datos se transfieren cifrados entre ambos extremos, y que el intercambio de paquetes es similar al que observaste entre cliente y servidor en el host . Tarea entregable Adapta tu sistema cliente/servidor TCP desarrollado en la anterior pr\u00e1ctica para que se ejecute sobre el binomio host /ESP32 utlizando TLS. Entrega el c\u00f3digo generado junto con una captura de tr\u00e1fico que demuestre su correcto funcionamiento.","title":"Pr\u00e1ctica 3"},{"location":"RPI-II/P3/#practica-3-seguridad-tls-y-dtls","text":"","title":"Pr\u00e1ctica 3. Seguridad (TLS y DTLS)"},{"location":"RPI-II/P3/#objetivos","text":"Observar el comportamiento de TLS y DTLS para el intercambio cifrado de mensajes. Conocer las diferencias b\u00e1sicas entre TLS y DTLS. Conocer una API b\u00e1sica de programaci\u00f3n de sistemas cliente/servidor usando TLS y DTLS (WolfSSL). Conocer una API b\u00e1sica de programaci\u00f3n de sistemas cliente/servidor en ESP-IDF (ESP-TLS).","title":"Objetivos"},{"location":"RPI-II/P3/#contenido-del-paquete-proporcionado-y-setup-basico","text":"El paquete proporcionado (puedes descargarlo aqu\u00ed ) incluye ejemplos de sistemas cliente/servidor programados utilizando TLS y DTLS mediante el uso de la biblioteca WolfSSL. Estos c\u00f3digos est\u00e1n dise\u00f1ados para ejecutarse exclusivamente en un sistema Linux, y requieren la instalaci\u00f3n de los paquetes de desarrollo WolfSSL. Para realizar la instalaci\u00f3n, ejecuta en tu m\u00e1quina virtual (esta l\u00ednea podr\u00eda cambiar si usas otra distribuci\u00f3n de Linux, en cuyo caso deber\u00e1s buscar los paquetes equivalentes): sudo apt-get install libwolfssl-dev libwolfssl24 Una vez hecho esto, prueba a realizar la compilaci\u00f3n tanto del ejemplo TLS como DTLS utilizando la orden make en el directorio correspondiente. Si todo ha ido bien, puedes continuar con el an\u00e1lisis de los c\u00f3digos en la siguiente secci\u00f3n.","title":"Contenido del paquete proporcionado y setup b\u00e1sico"},{"location":"RPI-II/P3/#clienteservidor-tls-ejemplo-basico-en-host","text":"","title":"Cliente/servidor TLS. Ejemplo b\u00e1sico en host"},{"location":"RPI-II/P3/#servidor-tls","text":"Analizaremos en primer lugar el c\u00f3digo b\u00e1sico del servidor TLS. Para ello, observa el contenido del fchero tls/server-tls.c .","title":"Servidor TLS"},{"location":"RPI-II/P3/#cabeceras-y-constantes","text":"El uso de WolfSSL requiere la inclusi\u00f3n de dos cabeceras b\u00e1sicas: #include <wolfssl/options.h> #include <wolfssl/ssl.h> Adem\u00e1s, ya que ser\u00e1n necesarios en el desarrollo, definiremos las rutas al certificado (clave p\u00fablica) del servidor y su clave privada: #define CERT_FILE \"../certs/server-cert.pem\" #define KEY_FILE \"../certs/server-key.pem\" Observa adem\u00e1s que el puerto de escucha del servidor ser\u00e1 el 11111 .","title":"Cabeceras y constantes"},{"location":"RPI-II/P3/#objetos-basicos-wolfssl-contexto-y-objeto-ssl","text":"Definiremos dos objetos b\u00e1sicos que se utilizar\u00e1n de forma recurrente en el c\u00f3digo: WOLFSSL_CTX* ctx; WOLFSSL* ssl; El contexto ( ctx ) incluye valores globales para cada conexi\u00f3n SSL, incluyendo informaci\u00f3n sobre certificados. Es posible utilizar un mismo contexto para m\u00faltiples conexiones, siempre que compartan caracter\u00edsticas. Para crear un nuevo contexto, utilizaremos la funci\u00f3n wolfSSL_CTX_new como sigue: /* Create and initialize WOLFSSL_CTX */ if ((ctx = wolfSSL_CTX_new(wolfTLSv1_2_server_method())) == NULL) { fprintf(stderr, \"ERROR: failed to create WOLFSSL_CTX\\n\"); return -1; } El argumento proporcionado incluye informaci\u00f3n sobre la versi\u00f3n de protocolo a utilizar. Actualmente, WolfSSL soporta SSL 3.0, TLS 1.1, TLS 1.2, DTLS 1.0 y DTLS 1.2. En este caso, para la parte cliente, las funciones a utilizar como argumento ser\u00edan: wolfSSLv3_server_method(); // SSLv3 wolfTLSv1_server_method(); // TLSv1 wolfTLSv1_1_server_method(); // TLSv1.1 wolfTLSv1_2_server_method(); // TLSv1.2 wolfDTLSv1_server_method(); // DTLS wolfDTLSv1_2_server_method(); // DTLS 1.2 En segundo lugar, es necesario cargar nuestra CA (Autoridad Certificadora) en el contexto, para que cualquier cliente pueda verificar, en el momento de su conexi\u00f3n, la identidad del sevidor. Para ello, usamos la funci\u00f3n wolfSSL_CTX_use_certificate_file de la siguiente manera: /* Load server certificates into WOLFSSL_CTX */ if (wolfSSL_CTX_use_certificate_file(ctx, CERT_FILE, SSL_FILETYPE_PEM) != SSL_SUCCESS) { fprintf(stderr, \"ERROR: failed to load %s, please check the file.\\n\", CERT_FILE); return -1; } Del mismo modo, el servidor deber\u00e1 incluir su clave privada en formato PEM: /* Load server key into WOLFSSL_CTX */ if (wolfSSL_CTX_use_PrivateKey_file(ctx, KEY_FILE, SSL_FILETYPE_PEM) != SSL_SUCCESS) { fprintf(stderr, \"ERROR: failed to load %s, please check the file.\\n\", KEY_FILE); return -1; } A continuaci\u00f3n, observa como el c\u00f3digo de escucha y aceptaci\u00f3n de conexiones entrantes no difier de cualquier c\u00f3digo que hayas desarrollado previamente para aceptar conexiones entrantes TCP ( bind , + listen + accept ). Justo tras la conexi\u00f3n ( accept ), resulta necesario crear un nuevo objeto SSL, as\u00ed como asociar el descriptor de socket con la nueva sesi\u00f3n (conexi\u00f3n) TLS: /* Create a WOLFSSL object */ if ((ssl = wolfSSL_new(ctx)) == NULL) { fprintf(stderr, \"ERROR: failed to create WOLFSSL object\\n\"); return -1; } /* Attach wolfSSL to the socket */ wolfSSL_set_fd(ssl, connd); /* Establish TLS connection */ ret = wolfSSL_accept(ssl); if (ret != SSL_SUCCESS) { fprintf(stderr, \"wolfSSL_accept error = %d\\n\", wolfSSL_get_error(ssl, ret)); return -1; } A partir de este punto, podemos enviar y recibir datos a trav\u00e9s del socket (y por tanto de la conexi\u00f3n TLS) de forma muy similar a como lo hacemos con el enfoque cl\u00e1sico. As\u00ed, para recibir datos: if (wolfSSL_read(ssl, buff, sizeof(buff)-1) == -1) { fprintf(stderr, \"ERROR: failed to read\\n\"); return -1; } Y para enviar datos de vuelta: /* Reply back to the client */ if (wolfSSL_write(ssl, buff, len) != len) { fprintf(stderr, \"ERROR: failed to write\\n\"); return -1; } Por \u00faltimo, finalizaremos la conexi\u00f3n con la invocaci\u00f3n de la funci\u00f3n wolfSSL_free(ssl) . Note El cliente proporcionado sigue una estrategia de implementaci\u00f3n similar. Compara ambos c\u00f3digos (cliente y servidor) y aseg\u00farate de entender las diferencias entre ellos. Tarea entregable Compila y ejecuta el sistema cliente/servidor TLS y obt\u00e9n capturas de tr\u00e1fico tanto de las fases de establecimiento de conexi\u00f3n como de las fases de transferencia de datos. En base a lo aprendido en las clases de teor\u00eda y la documentaci\u00f3n adicional sobre TLS y wolfSSL, redacta un breve informe que resuma el proceso de handshake y transferencia de datos en TLS tomando como base los paquetes reales observados para esta conexi\u00f3n.","title":"Objetos b\u00e1sicos WolfSSL. Contexto y objeto SSL"},{"location":"RPI-II/P3/#clienteservidor-dtls-ejemplo-basico-en-host","text":"El desarrollo de un sistema b\u00e1sico cliente/servidor con soporte DTLS utilizando WolfSSL es muy similar al visto anteriormente para TLS. Como detalle adicional, la inicializaci\u00f3n de la infraestructura debe realizarse indicando el soporte para DTLS en sus versiones 1.0 o 1.2: wolfDTLSv1_client_method(); // DTLS 1.0 wolfDTLSv1_2_client_method(); // DTLS 1.2 El resto del c\u00f3digo sigue una filosof\u00eda similar a TLS, adaptado, obviamente, a las caracter\u00edsticas de UDP (tipo de socket, ausencia de conexi\u00f3n, etc.), por lo que se deja como ejercicio su an\u00e1lisis y ejecuci\u00f3n. Tarea entregable Analiza, compila y ejecuta los c\u00f3digos correspondientes al sistema cliente/servidor DTLS. Realiza capturas de tr\u00e1fico y comp\u00e1ralas, paquete a paquete, con las generadas para un patr\u00f3n de tr\u00e1fico similar en el caso de TLS. Incide en sus similitudes y diferencias, tanto a nivel de handshake como de transferencia de datos. Observa, en este \u00faltimo caso, la aparici\u00f3n de nuevos campos de encabezado en los env\u00edos de datos DTLS. \u00bfCu\u00e1l/cu\u00e1les son esos campos y por qu\u00e9 aparecen? Realiza una comparativa del tr\u00e1fico total generado en ambos casos para exactamente la misma cantidad de datos transferidos.","title":"Cliente/servidor DTLS. Ejemplo b\u00e1sico en host"},{"location":"RPI-II/P3/#tls-en-el-esp32-el-componente-esp-tls","text":"ESP-IDF proporciona un componente (ESP-TLS) que ofrece una interfaz (API) simplificada para acceder a funcionalidad b\u00e1sica TLS. A\u00fan as\u00ed, ofrece una funcionalidad suficientemente amplia como para implementar casos de uso comunes en entornos IoT. La API de ESP-TLS es sencilla,y se basa en el uso de cuatro funciones b\u00e1sicas:","title":"TLS en el ESP32. El componente ESP-TLS"},{"location":"RPI-II/P3/#establecimiento-de-conexion-tls-esp_tls_conn_new","text":"Prototipo: esp_tls_t *esp_tls_conn_new(const char *hostname, int hostlen, int port, constesp_tls_cfg_t *cfg) Descripci\u00f3n: Crea una nueva conexi\u00f3n TLS/SSL bloqueante, estableciendo dicha conexi\u00f3n contra un servidor establecido. Par\u00e1metros: hostname : Identificaci\u00f3n del host. hostlen : Longitud del par\u00e1metro hostname . port : Puerto de conexi\u00f3n con el host. cfg : Configuraci\u00f3n de la conexi\u00f3n TLS. Valor de retorno: Puntero a esp_tls_t (manejador de la conexi\u00f3n). Devuelve NULL si se produce un error en la conexi\u00f3n.","title":"Establecimiento de conexi\u00f3n TLS (esp_tls_conn_new())"},{"location":"RPI-II/P3/#destruccion-de-conexion-tls-esp_tls_conn_delete","text":"void esp_tls_conn_delete(esp_tls_t *tls) Descripci\u00f3n: Cierra la conexi\u00f3n TLS/SSL. Par\u00e1metros: tls : Manejador de la conexi\u00f3n.","title":"Destrucci\u00f3n de conexi\u00f3n TLS (esp_tls_conn_delete())"},{"location":"RPI-II/P3/#escritura-de-datos-esp_tls_conn_read","text":"static ssize_t esp_tls_conn_write(esp_tls_t *tls, const void *data, size_t datalen) Descripci\u00f3n: Escribe en la conexi\u00f3n TLS/SSL indicada el contenido del buffer data . Par\u00e1metros: tls : Manejador de la conexi\u00f3n. data : Buffer de env\u00edo. datalen : Longitud del buffer de env\u00edo (o n\u00famero m\u00e1ximo de bytes a escribir). Valor de retorno: >=0 : \u00e9xito en el env\u00edo. N\u00famero de bytes efectivamente enviados. <0 : error en el env\u00edo.","title":"Escritura de datos (esp_tls_conn_read())"},{"location":"RPI-II/P3/#lectura-de-datos-esp_tls_conn_read","text":"static ssize_t esp_tls_conn_read(esp_tls_t *tls, void *data, size_t datalen) Descripci\u00f3n: Lee desde la conexi\u00f3n TLS/SSL indicada hacia el buffer data . Par\u00e1metros: tls : Manejador de la conexi\u00f3n. data : Buffer de recepci\u00f3n. datalen : Longitud del buffer de recepci\u00f3n (o n\u00famero m\u00e1ximo de bytes a leer). Valor de retorno: >0 : \u00e9xito en la recepci\u00f3n. N\u00famero de bytes efectivamente le\u00eddos. =0 : error en la recepci\u00f3n. La conexi\u00f3n se cerr\u00f3. <0 : error en la recepci\u00f3n.","title":"Lectura de datos (esp_tls_conn_read())"},{"location":"RPI-II/P3/#estructura-basica-de-un-cliente-tcp-usando-esp-idf","text":"Un cliente TCP implementado sobre ESP-IDF para dar soporte TLS, requiere ciertas modificaciones con respecto a la versi\u00f3n sin TLS. De hecho, el uso de ESP-IDF simplifica el c\u00f3digo del cliente (puedes compararlo con tus clientes TCP desarrollados en sesiones anteriores). La estructura b\u00e1sica resultar\u00eda: /// Includes anteriores. #include \"esp_tls.h\" // Puede tomarse desde menuconfig. #define HOST_IP_ADDR DIRECCION_DE_HOST #define PORT PUERTO static const char *payload = \"Hola, mundo via TLS\"; // ... static void tls_client_task( void *pvParameters ) { // ... // Configuraci\u00f3n de ESP-TLS (vac\u00edo para opciones defecto). esp_tls_cfg_t cfg = { }; // Creaci\u00f3n de conexi\u00f3n. struct esp_tls *tls = esp_tls_conn_new( HOST_IP_ADDR, longitud, PORT, &cfg); // Chequeo de errores. // ... // Env\u00edo de datos. ret = esp_tls_conn_write(tls, payload, strlen(payload)); // Chequeo de errores. // ... // Lectura de datos ret = esp_tls_conn_read(tls, (char *)rx_buffer, 128); // Chequeo de errores. // ... // Destrucci\u00f3n de la conexi\u00f3n esp_tls_conn_delete( tls ); vTaskDelete( NULL ); } void app_main( void ) { // ... } Observa como, efectivamente, el c\u00f3digo del cliente se simplifica en gran medida con respecto a tu cliente TCP original. Toma el c\u00f3digo del proyecto que utilizaste para desarrollar tu cliente TCP original y, siguiendo las anteriores directivas, adapta la \u00fanica tarea a crear (por ejemplo, puede recibir el nombre tls_client_task ) para que realice un env\u00edo y recepci\u00f3n de datos (una cadena) al servidor TLS que probaste en el host . Puedes valerte para ello de la base del ejemplo examples/protocols/https_request , obviamente adaptando la totalidad de su c\u00f3digo para que se comporte como un simple cliente echo . Note Compila y ejecuta el cliente TLS en el ESP32, y consigue que interact\u00fae con el servidor TLS que probaste anteriormente en el host . Comprueba que, efectivamente, los datos se transfieren cifrados entre ambos extremos, y que el intercambio de paquetes es similar al que observaste entre cliente y servidor en el host . Tarea entregable Adapta tu sistema cliente/servidor TCP desarrollado en la anterior pr\u00e1ctica para que se ejecute sobre el binomio host /ESP32 utlizando TLS. Entrega el c\u00f3digo generado junto con una captura de tr\u00e1fico que demuestre su correcto funcionamiento.","title":"Estructura b\u00e1sica de un cliente TCP usando ESP-IDF"},{"location":"RPI-II/P4/","text":"Pr\u00e1ctica 4. Protocolos b\u00e1sicos de capa de aplicaci\u00f3n. Websockets Objetivos Conocer el m\u00f3dulo Python websockets para desarrollar sistemas b\u00e1sicos cliente/servidor utilizando websockets . Estudar el intercambio de mensajes entre un cliente y un servidor websockets , tanto en la fase de handshake como de intercambio de datos. Conseguir interactuar con un servidor websockets utilizando un navegador web como cliente. Estudiar mecanismos de mantenimiento y publicaci\u00f3n de estado a clientes conectados, t\u00edpicos en un entorno IoT. Estudiar el componente websockets client en ESP-IDF, y desarrollar un firmware b\u00e1sico que interact\u00fae con un servidor Python. Introducir la gesti\u00f3n de objetos JSON en ESP-IDF. Los ficheros necesarios para completar la pr\u00e1ctica pueden descargarse aqu\u00ed . Ejemplo b\u00e1sico: sistema cliente/servidor usando Websockets en Python (\u00b4client1.py, server1.py`) En primer lugar, introducimos el uso del m\u00f3dulo Python websockets , que proporciona toda la funcionalidad necesaria para desarrollar sistemas cliente/servidor utilizando websockets . El m\u00f3dulo websockets proporciona la funcionalidad necesaria tanto a nivel de cliente como de servidor para implementar sistemas basados en dicho protocolo. Concretamente, las funciones de alto nivel que proporciona est\u00e1n basadas en una API de bajo nivel que implementa las dos fases principales del protocolo websockets : Handshake de apertura de comunicaci\u00f3n, en forma de peticiones HTTP upgrade . Transferencia de datos, y finalizaci\u00f3n de la comunicaci\u00f3n con un handshake de cierre de conexi\u00f3n. La primera fase est\u00e1 dise\u00f1ada para integrarse con software HTTP (cliente y servidor) existente, y proporciona una implementaci\u00f3n m\u00ednima para construir, parsear y validar peticiones y respuestas HTTP. La segunda fase implementa el n\u00facleo del protocolo websockets , y proporciona una implementaci\u00f3n completa basada en el m\u00f3dulo asyncio ) de Python. Para utilizar el m\u00f3dulo websockets de Python, primero lo instalaremos v\u00eda pip : pip install websockets Un ejemplo b\u00e1sico se puede basar en un cliente que env\u00eda una cadena a un servidor, y queda a la espera de recibir un mensaje de respuesta por parte de \u00e9ste, tal y como hemos visto en otras pr\u00e1cticas. Desarrollar la parte servidora para dicha aplicaci\u00f3n resulta sencillo. Observa el siguiente c\u00f3digo: #!/usr/bin/env python import asyncio import websockets async def hello(websocket, path): name = await websocket.recv() print(f\"< {name}\") greeting = f\"Hello {name}!\" await websocket.send(greeting) print(f\"> {greeting}\") start_server = websockets.serve(hello, \"localhost\", 8765) asyncio.get_event_loop().run_until_complete(start_server) asyncio.get_event_loop().run_forever() El paradigma de programaci\u00f3n utilizado en este ejemplo (basado en el m\u00f3dulo asyncio ) queda fuera del prop\u00f3sito de la pr\u00e1ctica (aunque se invita al alumno a estudiarlo, ya que aporta importantes ventajas a nivel de sencillez de desarrollo en aplicaciones de red). En cualquier caso, el anterior servidor ejecuta una (co)rutina manejadora hello para cada conexi\u00f3n websocket establecida; adem\u00e1s, se cierra dicha conexi\u00f3n cuando dicha (co)rutina finaliza. Concretamente, las funciones de inter\u00e9s en este caso son: await websockets.server.serve(ws_handler, host=None, port=None, # ... Crea, incializa y devuelve un objeto servidor Websocket asociado al host y puerto seleccionados. En un contexto de programaci\u00f3n as\u00edncrona (como el del ejemplo, el servidor finaliza autom\u00e1ticamente al salir de dicho contexto). Cuando un cliente conecta al host y puerto espec\u00edficados, se acepta la conexi\u00f3n, que es tratada por la (co)rutina ws_handler (en el ejemplo, hello ). Antes de delegar la conexi\u00f3n a la (co)rutina, se lleva a cabo el handshake de apertura websocket . await recv() Recibe el siguiente mensaje, devolviendo una cadena si el frame recibido es de texto, o un array de bytes si es binario. await send(message) Env\u00eda un mensaje. message puede er una cadena, o un array de bytes. En el primer caso, se env\u00eda un frame de texto; en el segundo caso, un frame binario. A continuaci\u00f3n se muestra un ejemplo de cliente websocket para interactuar con el anterior servidor: #!/usr/bin/env python import asyncio import websockets async def hello(): uri = \"ws://localhost:8765\" async with websockets.connect(uri) as websocket: name = input(\"What's your name? \") await websocket.send(name) print(f\"> {name}\") greeting = await websocket.recv() print(f\"< {greeting}\") asyncio.get_event_loop().run_until_complete(hello()) El c\u00f3digo en este caso es sencillo, ya que \u00fanicamente se basa en la planificaci\u00f3n (ejecuci\u00f3n) de una (co)rutina llamada hello , que establece una conexi\u00f3n con un servidor websocket v\u00eda connect , enviando y recibiendo un par de mensajes. await websockets.client.connect(uri, # ... Conecta con un servidor websocket en la URI determinada. La conexi\u00f3n se cierra al abandonar el contexto as\u00edncrono (es decir, la (co)rutina hello ). Tarea entregable Ejecuta el servidor en una terminal de tu m\u00e1quina virtual, y a continuaci\u00f3n el cliente en otra. Analiza el tr\u00e1fico intercambiado y responde a las siguientes preguntas: \u00bfEn qu\u00e9 protocolo de capa de transporte se basa la comunicaci\u00f3n v\u00eda Websockets? En la fase de handshake , \u00bfqu\u00e9 peticiones HTTP se intercambian? Analiza sus emisores y destinatarios, e investiga el cometido principal de cada uno de los campos de sus encabezados (f\u00edjate principalmente en el campo Upgrade y los campos espec\u00edficos para Websockets). En la fase de intercambio de datos, \u00bfqu\u00e9 opcode se especifica en el encabezado de cada paquete? \u00bfPor qu\u00e9? \u00bfSe env\u00edan los datos en claro o cifrados? \u00bfQu\u00e9 opcode se a\u00f1ade en los mensajes de cierre de conexi\u00f3n? Interactuando con un navegador web ( client_for_web.html , server_for_web.py ) Aunque fuera del inter\u00e9s de esta pr\u00e1ctica, es conveniente observar una de las ventajas de websockets : el env\u00edo as\u00edncrono bidireccional de informaci\u00f3n, y observarlo a trav\u00e9s de un navegador web convencional (la mayor\u00eda de navegadores modernos soportan websockets a trav\u00e9s de scripts Javascript ). En este caso, simplemente observa la interacci\u00f3n de un servidor websocket que env\u00eda mensajes que incluyen la hora actual separados un n\u00famero aleatorio de tiempo entre ellos: #!/usr/bin/env python # WS server that sends messages at random intervals import asyncio import datetime import random import websockets async def time(websocket, path): while True: now = datetime.datetime.utcnow().isoformat() + \"Z\" await websocket.send(now) await asyncio.sleep(random.random() * 3) start_server = websockets.serve(time, \"127.0.0.1\", 5678) asyncio.get_event_loop().run_until_complete(start_server) asyncio.get_event_loop().run_forever() Con un cliente (una p\u00e1gina HTML) que establece la conexi\u00f3n v\u00eda websockets , y muestra en la misma un elemento de texto con la marca de tiempo recibida tras la recepci\u00f3n de cada mensaje: <!DOCTYPE html> <html> <head> <title>WebSocket demo</title> </head> <body> <script> var ws = new WebSocket(\"ws://127.0.0.1:5678/\"), messages = document.createElement('ul'); ws.onmessage = function (event) { var messages = document.getElementsByTagName('ul')[0], message = document.createElement('li'), content = document.createTextNode(event.data); message.appendChild(content); messages.appendChild(message); }; document.body.appendChild(messages); </script> </body> </html> Tarea Ejecuta el servidor en tu m\u00e1quina virtual y, tras guardar el c\u00f3digo fuente del cliente en un fichero cliente.html , \u00e1brelo con un navegador. Observa como la p\u00e1gina se actualiza a medida que recibe mensajes a trav\u00e9s del socket. Si quieres, puedes observar el intercambio de mensajes. \u00bfQu\u00e9 ocurre si, en otra pesta\u00f1a, vuelves a abrir la p\u00e1gina cliente? Un ejemplo m\u00e1s complejo: sincronizaci\u00f3n entre m\u00faltiples clientes ( server2.py , client.html ) Un servidor websocket puede recibir eventos desde distintos clientes, procesarlos para, por ejemplo, mantener actualizado un estado a nivel de aplicaci\u00f3n, y sincronizar dicho estado entre todos los clientes conectados, envi\u00e1ndoles mensajes de forma as\u00edncrona a trav\u00e9s del socket bidireccional, a modo de \"notificaciones push \". A continuaci\u00f3n, se muestra el c\u00f3digo de un servidor que mantiene dos tipos de informaci\u00f3n de estado siempre actualizada: el valor de un contador ( STATE ), que puede ser modificado por los clientes conectados sumando o restando uno a su valor a trav\u00e9s de mensajes enviados por el socket ; y el n\u00famero de clientes conectados ( USERS ). #!/usr/bin/env python import asyncio import json import logging import websockets logging.basicConfig() STATE = {\"value\": 0} USERS = set() def state_event(): return json.dumps({\"type\": \"state\", **STATE}) def users_event(): return json.dumps({\"type\": \"users\", \"count\": len(USERS)}) async def notify_state(): if USERS: # asyncio.wait doesn't accept an empty list message = state_event() await asyncio.wait([user.send(message) for user in USERS]) async def notify_users(): if USERS: # asyncio.wait doesn't accept an empty list message = users_event() await asyncio.wait([user.send(message) for user in USERS]) async def register(websocket): USERS.add(websocket) await notify_users() async def unregister(websocket): USERS.remove(websocket) await notify_users() async def counter(websocket, path): # register(websocket) sends user_event() to websocket await register(websocket) try: await websocket.send(state_event()) async for message in websocket: data = json.loads(message) if data[\"action\"] == \"minus\": STATE[\"value\"] -= 1 await notify_state() elif data[\"action\"] == \"plus\": STATE[\"value\"] += 1 await notify_state() else: logging.error(\"unsupported event: {}\", data) finally: await unregister(websocket) start_server = websockets.serve(counter, \"localhost\", 6789) asyncio.get_event_loop().run_until_complete(start_server) asyncio.get_event_loop().run_forever() Observa el c\u00f3digo del servidor. El manejador counter procesa cada conexi\u00f3n entrante, registrando a su entrada a un nuevo cliente en el sistema ( register ) y desregistr\u00e1ndolo antes de finalizar ( unregister ). Ante cada registro o desregistro, se notifica a los usuarios este hecho, enviando a cada cliente un peque\u00f1o texto en formato JSON cuyo contenido es: {\"type\": \"users\", \"count\": usuarios} Es decir, un mensaje con dos campos (veremos JSON en la pr\u00f3xima pr\u00e1ctica): campo type , con valor fijo users , y campo count , con un valor entero que indica el n\u00famero de clientes conectados. A continuaci\u00f3n, para cada mensaje recibido a trav\u00e9s del socket, \u00e9ste se procesa, esperando tambi\u00e9n un fichero JSON con la acci\u00f3n que el cliente solicita (sumar o restar 1 al contador), por ejemplo: {\"action\": \"minus\"} o {\"action\": \"plus\"} En funci\u00f3n de la acci\u00f3n solicitada, el servidor actualiza el valor de STATE , y env\u00eda (rutina notify_state ) dicho valor actualizado a TODOS los clientes conectados mediante un peque\u00f1o mensaje de texto en formato JSON: {\"type\": \"state\", \"value\": VALOR} La parte cliente sigue la misma filosof\u00eda, utilizando de nuevo el navegador como plataforma para visualizar la interacci\u00f3n con el cliente. El c\u00f3digo HTML que puedes abrir en tu navegador es el siguiente: <!DOCTYPE html> <html> <head> <title>WebSocket demo</title> <style type=\"text/css\"> body { font-family: \"Courier New\", sans-serif; text-align: center; } .buttons { font-size: 4em; display: flex; justify-content: center; } .button, .value { line-height: 1; padding: 2rem; margin: 2rem; border: medium solid; min-height: 1em; min-width: 1em; } .button { cursor: pointer; user-select: none; } .minus { color: red; } .plus { color: green; } .value { min-width: 2em; } .state { font-size: 2em; } </style> </head> <body> <div class=\"buttons\"> <div class=\"minus button\">-</div> <div class=\"value\">?</div> <div class=\"plus button\">+</div> </div> <div class=\"state\"> <span class=\"users\">?</span> online </div> <script> var minus = document.querySelector('.minus'), plus = document.querySelector('.plus'), value = document.querySelector('.value'), users = document.querySelector('.users'), websocket = new WebSocket(\"ws://127.0.0.1:6789/\"); minus.onclick = function (event) { websocket.send(JSON.stringify({action: 'minus'})); } plus.onclick = function (event) { websocket.send(JSON.stringify({action: 'plus'})); } websocket.onmessage = function (event) { data = JSON.parse(event.data); switch (data.type) { case 'state': value.textContent = data.value; break; case 'users': users.textContent = ( data.count.toString() + \" user\" + (data.count == 1 ? \"\" : \"s\")); break; default: console.error( \"unsupported event\", data); } }; </script> </body> </html> Observa c\u00f3mo el script env\u00eda mensajes de suma o resta en formato JSON acorde al esperado por el servidor, y procesa los mensajes de entrada actualizando la informaci\u00f3n mostrada en pantalla recibida acerca del valor del contador actualizado y n\u00famero de usuarios. Tarea Ejecuta el servidor en tu m\u00e1quina virtual, y m\u00faltiples clientes en distintas ventanas/pesta\u00f1as del navegador (con ventanas lo ver\u00e1s mejor). Interact\u00faa desde un cliente aumentando o reduciendo el valor del contador, y observa c\u00f3mo dicho valor es actualizado (a trav\u00e9s del servidor) en el resto de clientes abiertos. Conecta y desconecta nuevos clientes y observa tambi\u00e9n como el campo correspondiente en la p\u00e1gina web se actualiza correctamente. Si quieres, puedes analizar el tr\u00e1fico Websockets generado v\u00eda Wireshark. Websockets en el ESP32 El soporte a nivel de cliente para el protocolo websockets est\u00e1 integrado en ESP-IDF a trav\u00e9sd el componente websocket client , cuya documentaci\u00f3n puede consultarse a trav\u00e9s de este enlace . El componente websocket client ofrece soporte para el protocolo websocket sobre TCP y tambi\u00e9n, opcionalmente, sobre TLS. Como todos los componentes en ESP-IDF, el componente websocket emite eventos que pueden ser tratados por parte de la aplicaci\u00f3n, entre los cuales destacan: WEBSOCKET_EVENT_CONNECTED : se emite una vez el cliente se ha conectado al servidor, sin intercambio de datos. WEBSOCKET_EVENT_DISCONNECTED : se emite en el instante de la desconexi\u00f3n entre cliente y servidor. WEBSOCKET_EVENT_DATA : se emite al recibir datos desde el servidor. Este \u00faltimo evento es de especial inter\u00e9s para nosotros, ya que accarrea la construcci\u00f3n de una estructura de tipo esp_websocket_event_data_t en la que se almacena el mensaje recibido desde el servidor (tanto en sus campos de control como de datos). Algunos campos de inter\u00e9s dentro de la estructura son: const char * data_ptr : puntero a los datos recibidos ( payload ). data_len : tama\u00f1o (en bytes) de los datos recibidos. op_code : c\u00f3digo de operaci\u00f3n asociado al mensaje recibido. La documentaci\u00f3n del componente ofrece informaci\u00f3n sobre campos adicionales, de menor inter\u00e9s para nosotros. Observemos el c\u00f3digo de una posible funci\u00f3n manejadora de eventos del componente websocket : static void websocket_event_handler(void *handler_args, esp_event_base_t base, int32_t event_id, void *event_data) { esp_websocket_event_data_t *data = (esp_websocket_event_data_t *)event_data; switch (event_id) { case WEBSOCKET_EVENT_CONNECTED: ESP_LOGI(TAG, \"WEBSOCKET_EVENT_CONNECTED\"); break; case WEBSOCKET_EVENT_DISCONNECTED: ESP_LOGI(TAG, \"WEBSOCKET_EVENT_DISCONNECTED\"); break; case WEBSOCKET_EVENT_DATA: ESP_LOGI(TAG, \"WEBSOCKET_EVENT_DATA\"); ESP_LOGI(TAG, \"Received opcode=%d\", data->op_code); if (data->op_code == 0x08 && data->data_len == 2) { ESP_LOGW(TAG, \"Received closed message with code=%d\", 256*data->data_ptr[0] + data->data_ptr[1]); } else { ESP_LOGW(TAG, \"Received=%.*s\", data->data_len, (char *)data->data_ptr); } ESP_LOGW(TAG, \"Total payload length=%d, data_len=%d, current payload offset=%d\\r\\n\", data->payload_len, data->data_len, data->payload_offset); xTimerReset(shutdown_signal_timer, portMAX_DELAY); break; case WEBSOCKET_EVENT_ERROR: ESP_LOGI(TAG, \"WEBSOCKET_EVENT_ERROR\"); break; } } Observa el c\u00f3digo. En funci\u00f3n del par\u00e1metro event_id , el manejador toma un camino de ejecuci\u00f3n u otro. Centr\u00e9monos en la recepci\u00f3n de un evento de tipo \u1e80EBSOCKET_EVENT_DATA ; a trav\u00e9s de los distintos campos de la estructura de informaci\u00f3n recibida ( event_data ), es posible: Obtener y mostrar el c\u00f3digo de la operaci\u00f3n ( op_code ). Mostrar el contenido del mensaje recibido ( data_ptr ). Mostrar el tama\u00f1o del mensaje recibido ( data_len y payload_len ). Preguntas \u00bfCu\u00e1l es la diferencia entre los campos data_len y payload_len ? \u00bfPor qu\u00e9 el programa realiza un tratamiento especial cuando op_code == 8 ? Dada la anterior funci\u00f3n manejadora, la inicializaci\u00f3n de un cliente websockets en el ESP32 es sencilla, y se resume en los siguientes pasos: Configuraci\u00f3n de URI (host + puerto) esp_websocket_client_config_t websocket_cfg = {}; websocket_cfg.uri = \"ws://localhost:123\"; esp_websocket_client_handle_t client = esp_websocket_client_init(&websocket_cfg); Asociaci\u00f3n de manejador a eventos Websocket esp_websocket_register_events(client, WEBSOCKET_EVENT_ANY, websocket_event_handler, (void *)client); Inicializaci\u00f3n del cliente esp_websocket_client_start(client); A partir de este punto, la interacci\u00f3n con el servidor se puede realizar en base a funciones de env\u00edo de texto o binario: int esp_websocket_client_send(esp_websocket_client_handle_tclient, const char *data, int len, TickType_t timeout) esp_websocket_client_send_bin(esp_websocket_client_handle_tclient, const char *data, int len, TickType_t timeout) No existen funciones de recepci\u00f3n, ya que \u00e9sta es impl\u00edcita y se notifica v\u00eda eventos. Ejemplo b\u00e1sico: cliente echo Veremos en primer lugar un ejemplo completo de cliente ejecutado sobre el ESP32. En este punto, configura, compila, flashea y monitoriza el ejemplo examples/protocols/websockets . El ejemplo simplemente conecta con un servidor echo Websockets en la nube (disponible en ws://websockets.org ). Dicho servidor simplemente espera, por parte de cada cliente, el env\u00edo a trav\u00e9s de la conexi\u00f3n de una cadena, respondiendo con la misma cadena en sentido contrario, siempre usando el mismo socket . Tarea Observa el c\u00f3digo del ejemplo y su ejecuci\u00f3n. Determina cu\u00e1l es el funcionamiento del ejemplo, y comprueba que los fragmentos de c\u00f3digo anteriores tienen su funci\u00f3n dentro del c\u00f3digo completo. \u00bfC\u00f3mo implementa el programa la espera limitada en tiempo si no se recibe ning\u00fan paquete tras cierto per\u00edodo? Ejercicio entregable: Comunicaci\u00f3n as\u00edncrona El objetivo del ejercicio entregable es conseguir que el ESP32 se comunique con el servidor Python que se prob\u00f3 en la secci\u00f3n anterior, y que implementaba comunicaci\u00f3n bidireccional para mantener y difundir el estado interno (contador y n\u00famero de clientes conectados) entre todos los clientes conectados. Para ello, se pide modificar el ejemplo de cliente echo para que: El cliente conecte con el servidor Python especificando su IP y puerto. El cliente sea cien por cien pasivo, es decir, no env\u00ede nunca mensajes al servidor. La funci\u00f3n de manejo de paquetes recibidos trate de forma especial el tipo de mensajes esperado por parte del servidor. Recuerda que se pueden recibir dos tipos de mensajes de texto: Mensajes de estado: {\"type\": \"users\", \"count\": usuarios} Mensajes de usuarios: {\"type\": \"state\", \"value\": VALOR} Observa que ambos mensajes, pese a ser recibidos como texto, corresponden con una representaci\u00f3n JSON de la informaci\u00f3n. Para tratarla desde ESP-IDF, puedes hacer uso del componente cJSON del framework . Por ejemplo, para tratar un mensaje de entrada de tipo \"state\", podr\u00edamos a\u00f1adir la siguiente secuencia de c\u00f3digo en nuestro manejador: #include \"cJSON.h\" // ... if( data->op_code == 1 ) { // Text frame only. cJSON *root = cJSON_Parse((char*)data->data_ptr); char *type = cJSON_GetObjectItem(root,\"type\")->valuestring; ESP_LOGI(TAG, \"type=%s\",type); int field = 0; if( strcmp( type, \"state\" ) == 0) { field = cJSON_GetObjectItem(root,\"value\")->valueint; ESP_LOGI(TAG, \"value=%d\",field); } } Tarea entregable Modifica el firmware de ejemplo websockets para que pueda comunicarse en modo lectura con el servidor Python que mantiene y publicita estado, cuyo c\u00f3digo se te proporciona. El programa ESP-IDF, al menos, mostar\u00e1 por pantalla un mensaje con los datos asociados cada vez que se reciban paquetes de tipo texto ( state o users ). Tambi\u00e9n mostrar\u00e1 un mensaje cada vez que el servidor env\u00ede un mensaje de tipo ping o pong (para ello, consulta el RFC que describe el protocolo para determinar el opcode asociado). Para comprobar el funcionamiento de la soluci\u00f3n, arranca el servidor y al menos dos clientes web. Cuando arranques el ESP32, ambos deber\u00e1n incrementar el n\u00famero de clientes reportado, en respuesta al mensaje enviado por el servidor. Cuando cualquiera de los clientes web incremente el valor del contador, el ESP32 recibir\u00e1 un mensaje con el valor actualizado, del mismo modo que cuando cierres uno de los navegadores web. Tarea opcional Modifica el c\u00f3digo para que el cliente, peri\u00f3dicamente, env\u00ede un mensaje de petici\u00f3n de suma o resta siguiendo las especificaciones y tipos de mensaje que se explicaron anteriormente.","title":"Pr\u00e1ctica 4"},{"location":"RPI-II/P4/#practica-4-protocolos-basicos-de-capa-de-aplicacion-websockets","text":"","title":"Pr\u00e1ctica 4. Protocolos b\u00e1sicos de capa de aplicaci\u00f3n. Websockets"},{"location":"RPI-II/P4/#objetivos","text":"Conocer el m\u00f3dulo Python websockets para desarrollar sistemas b\u00e1sicos cliente/servidor utilizando websockets . Estudar el intercambio de mensajes entre un cliente y un servidor websockets , tanto en la fase de handshake como de intercambio de datos. Conseguir interactuar con un servidor websockets utilizando un navegador web como cliente. Estudiar mecanismos de mantenimiento y publicaci\u00f3n de estado a clientes conectados, t\u00edpicos en un entorno IoT. Estudiar el componente websockets client en ESP-IDF, y desarrollar un firmware b\u00e1sico que interact\u00fae con un servidor Python. Introducir la gesti\u00f3n de objetos JSON en ESP-IDF. Los ficheros necesarios para completar la pr\u00e1ctica pueden descargarse aqu\u00ed .","title":"Objetivos"},{"location":"RPI-II/P4/#ejemplo-basico-sistema-clienteservidor-usando-websockets-en-python-client1py-server1py","text":"En primer lugar, introducimos el uso del m\u00f3dulo Python websockets , que proporciona toda la funcionalidad necesaria para desarrollar sistemas cliente/servidor utilizando websockets . El m\u00f3dulo websockets proporciona la funcionalidad necesaria tanto a nivel de cliente como de servidor para implementar sistemas basados en dicho protocolo. Concretamente, las funciones de alto nivel que proporciona est\u00e1n basadas en una API de bajo nivel que implementa las dos fases principales del protocolo websockets : Handshake de apertura de comunicaci\u00f3n, en forma de peticiones HTTP upgrade . Transferencia de datos, y finalizaci\u00f3n de la comunicaci\u00f3n con un handshake de cierre de conexi\u00f3n. La primera fase est\u00e1 dise\u00f1ada para integrarse con software HTTP (cliente y servidor) existente, y proporciona una implementaci\u00f3n m\u00ednima para construir, parsear y validar peticiones y respuestas HTTP. La segunda fase implementa el n\u00facleo del protocolo websockets , y proporciona una implementaci\u00f3n completa basada en el m\u00f3dulo asyncio ) de Python. Para utilizar el m\u00f3dulo websockets de Python, primero lo instalaremos v\u00eda pip : pip install websockets Un ejemplo b\u00e1sico se puede basar en un cliente que env\u00eda una cadena a un servidor, y queda a la espera de recibir un mensaje de respuesta por parte de \u00e9ste, tal y como hemos visto en otras pr\u00e1cticas. Desarrollar la parte servidora para dicha aplicaci\u00f3n resulta sencillo. Observa el siguiente c\u00f3digo: #!/usr/bin/env python import asyncio import websockets async def hello(websocket, path): name = await websocket.recv() print(f\"< {name}\") greeting = f\"Hello {name}!\" await websocket.send(greeting) print(f\"> {greeting}\") start_server = websockets.serve(hello, \"localhost\", 8765) asyncio.get_event_loop().run_until_complete(start_server) asyncio.get_event_loop().run_forever() El paradigma de programaci\u00f3n utilizado en este ejemplo (basado en el m\u00f3dulo asyncio ) queda fuera del prop\u00f3sito de la pr\u00e1ctica (aunque se invita al alumno a estudiarlo, ya que aporta importantes ventajas a nivel de sencillez de desarrollo en aplicaciones de red). En cualquier caso, el anterior servidor ejecuta una (co)rutina manejadora hello para cada conexi\u00f3n websocket establecida; adem\u00e1s, se cierra dicha conexi\u00f3n cuando dicha (co)rutina finaliza. Concretamente, las funciones de inter\u00e9s en este caso son: await websockets.server.serve(ws_handler, host=None, port=None, # ... Crea, incializa y devuelve un objeto servidor Websocket asociado al host y puerto seleccionados. En un contexto de programaci\u00f3n as\u00edncrona (como el del ejemplo, el servidor finaliza autom\u00e1ticamente al salir de dicho contexto). Cuando un cliente conecta al host y puerto espec\u00edficados, se acepta la conexi\u00f3n, que es tratada por la (co)rutina ws_handler (en el ejemplo, hello ). Antes de delegar la conexi\u00f3n a la (co)rutina, se lleva a cabo el handshake de apertura websocket . await recv() Recibe el siguiente mensaje, devolviendo una cadena si el frame recibido es de texto, o un array de bytes si es binario. await send(message) Env\u00eda un mensaje. message puede er una cadena, o un array de bytes. En el primer caso, se env\u00eda un frame de texto; en el segundo caso, un frame binario. A continuaci\u00f3n se muestra un ejemplo de cliente websocket para interactuar con el anterior servidor: #!/usr/bin/env python import asyncio import websockets async def hello(): uri = \"ws://localhost:8765\" async with websockets.connect(uri) as websocket: name = input(\"What's your name? \") await websocket.send(name) print(f\"> {name}\") greeting = await websocket.recv() print(f\"< {greeting}\") asyncio.get_event_loop().run_until_complete(hello()) El c\u00f3digo en este caso es sencillo, ya que \u00fanicamente se basa en la planificaci\u00f3n (ejecuci\u00f3n) de una (co)rutina llamada hello , que establece una conexi\u00f3n con un servidor websocket v\u00eda connect , enviando y recibiendo un par de mensajes. await websockets.client.connect(uri, # ... Conecta con un servidor websocket en la URI determinada. La conexi\u00f3n se cierra al abandonar el contexto as\u00edncrono (es decir, la (co)rutina hello ). Tarea entregable Ejecuta el servidor en una terminal de tu m\u00e1quina virtual, y a continuaci\u00f3n el cliente en otra. Analiza el tr\u00e1fico intercambiado y responde a las siguientes preguntas: \u00bfEn qu\u00e9 protocolo de capa de transporte se basa la comunicaci\u00f3n v\u00eda Websockets? En la fase de handshake , \u00bfqu\u00e9 peticiones HTTP se intercambian? Analiza sus emisores y destinatarios, e investiga el cometido principal de cada uno de los campos de sus encabezados (f\u00edjate principalmente en el campo Upgrade y los campos espec\u00edficos para Websockets). En la fase de intercambio de datos, \u00bfqu\u00e9 opcode se especifica en el encabezado de cada paquete? \u00bfPor qu\u00e9? \u00bfSe env\u00edan los datos en claro o cifrados? \u00bfQu\u00e9 opcode se a\u00f1ade en los mensajes de cierre de conexi\u00f3n?","title":"Ejemplo b\u00e1sico: sistema cliente/servidor usando Websockets en Python (\u00b4client1.py, server1.py`)"},{"location":"RPI-II/P4/#interactuando-con-un-navegador-web-client_for_webhtml-server_for_webpy","text":"Aunque fuera del inter\u00e9s de esta pr\u00e1ctica, es conveniente observar una de las ventajas de websockets : el env\u00edo as\u00edncrono bidireccional de informaci\u00f3n, y observarlo a trav\u00e9s de un navegador web convencional (la mayor\u00eda de navegadores modernos soportan websockets a trav\u00e9s de scripts Javascript ). En este caso, simplemente observa la interacci\u00f3n de un servidor websocket que env\u00eda mensajes que incluyen la hora actual separados un n\u00famero aleatorio de tiempo entre ellos: #!/usr/bin/env python # WS server that sends messages at random intervals import asyncio import datetime import random import websockets async def time(websocket, path): while True: now = datetime.datetime.utcnow().isoformat() + \"Z\" await websocket.send(now) await asyncio.sleep(random.random() * 3) start_server = websockets.serve(time, \"127.0.0.1\", 5678) asyncio.get_event_loop().run_until_complete(start_server) asyncio.get_event_loop().run_forever() Con un cliente (una p\u00e1gina HTML) que establece la conexi\u00f3n v\u00eda websockets , y muestra en la misma un elemento de texto con la marca de tiempo recibida tras la recepci\u00f3n de cada mensaje: <!DOCTYPE html> <html> <head> <title>WebSocket demo</title> </head> <body> <script> var ws = new WebSocket(\"ws://127.0.0.1:5678/\"), messages = document.createElement('ul'); ws.onmessage = function (event) { var messages = document.getElementsByTagName('ul')[0], message = document.createElement('li'), content = document.createTextNode(event.data); message.appendChild(content); messages.appendChild(message); }; document.body.appendChild(messages); </script> </body> </html> Tarea Ejecuta el servidor en tu m\u00e1quina virtual y, tras guardar el c\u00f3digo fuente del cliente en un fichero cliente.html , \u00e1brelo con un navegador. Observa como la p\u00e1gina se actualiza a medida que recibe mensajes a trav\u00e9s del socket. Si quieres, puedes observar el intercambio de mensajes. \u00bfQu\u00e9 ocurre si, en otra pesta\u00f1a, vuelves a abrir la p\u00e1gina cliente?","title":"Interactuando con un navegador web (client_for_web.html, server_for_web.py)"},{"location":"RPI-II/P4/#un-ejemplo-mas-complejo-sincronizacion-entre-multiples-clientes-server2py-clienthtml","text":"Un servidor websocket puede recibir eventos desde distintos clientes, procesarlos para, por ejemplo, mantener actualizado un estado a nivel de aplicaci\u00f3n, y sincronizar dicho estado entre todos los clientes conectados, envi\u00e1ndoles mensajes de forma as\u00edncrona a trav\u00e9s del socket bidireccional, a modo de \"notificaciones push \". A continuaci\u00f3n, se muestra el c\u00f3digo de un servidor que mantiene dos tipos de informaci\u00f3n de estado siempre actualizada: el valor de un contador ( STATE ), que puede ser modificado por los clientes conectados sumando o restando uno a su valor a trav\u00e9s de mensajes enviados por el socket ; y el n\u00famero de clientes conectados ( USERS ). #!/usr/bin/env python import asyncio import json import logging import websockets logging.basicConfig() STATE = {\"value\": 0} USERS = set() def state_event(): return json.dumps({\"type\": \"state\", **STATE}) def users_event(): return json.dumps({\"type\": \"users\", \"count\": len(USERS)}) async def notify_state(): if USERS: # asyncio.wait doesn't accept an empty list message = state_event() await asyncio.wait([user.send(message) for user in USERS]) async def notify_users(): if USERS: # asyncio.wait doesn't accept an empty list message = users_event() await asyncio.wait([user.send(message) for user in USERS]) async def register(websocket): USERS.add(websocket) await notify_users() async def unregister(websocket): USERS.remove(websocket) await notify_users() async def counter(websocket, path): # register(websocket) sends user_event() to websocket await register(websocket) try: await websocket.send(state_event()) async for message in websocket: data = json.loads(message) if data[\"action\"] == \"minus\": STATE[\"value\"] -= 1 await notify_state() elif data[\"action\"] == \"plus\": STATE[\"value\"] += 1 await notify_state() else: logging.error(\"unsupported event: {}\", data) finally: await unregister(websocket) start_server = websockets.serve(counter, \"localhost\", 6789) asyncio.get_event_loop().run_until_complete(start_server) asyncio.get_event_loop().run_forever() Observa el c\u00f3digo del servidor. El manejador counter procesa cada conexi\u00f3n entrante, registrando a su entrada a un nuevo cliente en el sistema ( register ) y desregistr\u00e1ndolo antes de finalizar ( unregister ). Ante cada registro o desregistro, se notifica a los usuarios este hecho, enviando a cada cliente un peque\u00f1o texto en formato JSON cuyo contenido es: {\"type\": \"users\", \"count\": usuarios} Es decir, un mensaje con dos campos (veremos JSON en la pr\u00f3xima pr\u00e1ctica): campo type , con valor fijo users , y campo count , con un valor entero que indica el n\u00famero de clientes conectados. A continuaci\u00f3n, para cada mensaje recibido a trav\u00e9s del socket, \u00e9ste se procesa, esperando tambi\u00e9n un fichero JSON con la acci\u00f3n que el cliente solicita (sumar o restar 1 al contador), por ejemplo: {\"action\": \"minus\"} o {\"action\": \"plus\"} En funci\u00f3n de la acci\u00f3n solicitada, el servidor actualiza el valor de STATE , y env\u00eda (rutina notify_state ) dicho valor actualizado a TODOS los clientes conectados mediante un peque\u00f1o mensaje de texto en formato JSON: {\"type\": \"state\", \"value\": VALOR} La parte cliente sigue la misma filosof\u00eda, utilizando de nuevo el navegador como plataforma para visualizar la interacci\u00f3n con el cliente. El c\u00f3digo HTML que puedes abrir en tu navegador es el siguiente: <!DOCTYPE html> <html> <head> <title>WebSocket demo</title> <style type=\"text/css\"> body { font-family: \"Courier New\", sans-serif; text-align: center; } .buttons { font-size: 4em; display: flex; justify-content: center; } .button, .value { line-height: 1; padding: 2rem; margin: 2rem; border: medium solid; min-height: 1em; min-width: 1em; } .button { cursor: pointer; user-select: none; } .minus { color: red; } .plus { color: green; } .value { min-width: 2em; } .state { font-size: 2em; } </style> </head> <body> <div class=\"buttons\"> <div class=\"minus button\">-</div> <div class=\"value\">?</div> <div class=\"plus button\">+</div> </div> <div class=\"state\"> <span class=\"users\">?</span> online </div> <script> var minus = document.querySelector('.minus'), plus = document.querySelector('.plus'), value = document.querySelector('.value'), users = document.querySelector('.users'), websocket = new WebSocket(\"ws://127.0.0.1:6789/\"); minus.onclick = function (event) { websocket.send(JSON.stringify({action: 'minus'})); } plus.onclick = function (event) { websocket.send(JSON.stringify({action: 'plus'})); } websocket.onmessage = function (event) { data = JSON.parse(event.data); switch (data.type) { case 'state': value.textContent = data.value; break; case 'users': users.textContent = ( data.count.toString() + \" user\" + (data.count == 1 ? \"\" : \"s\")); break; default: console.error( \"unsupported event\", data); } }; </script> </body> </html> Observa c\u00f3mo el script env\u00eda mensajes de suma o resta en formato JSON acorde al esperado por el servidor, y procesa los mensajes de entrada actualizando la informaci\u00f3n mostrada en pantalla recibida acerca del valor del contador actualizado y n\u00famero de usuarios. Tarea Ejecuta el servidor en tu m\u00e1quina virtual, y m\u00faltiples clientes en distintas ventanas/pesta\u00f1as del navegador (con ventanas lo ver\u00e1s mejor). Interact\u00faa desde un cliente aumentando o reduciendo el valor del contador, y observa c\u00f3mo dicho valor es actualizado (a trav\u00e9s del servidor) en el resto de clientes abiertos. Conecta y desconecta nuevos clientes y observa tambi\u00e9n como el campo correspondiente en la p\u00e1gina web se actualiza correctamente. Si quieres, puedes analizar el tr\u00e1fico Websockets generado v\u00eda Wireshark.","title":"Un ejemplo m\u00e1s complejo: sincronizaci\u00f3n entre m\u00faltiples clientes (server2.py, client.html)"},{"location":"RPI-II/P4/#websockets-en-el-esp32","text":"El soporte a nivel de cliente para el protocolo websockets est\u00e1 integrado en ESP-IDF a trav\u00e9sd el componente websocket client , cuya documentaci\u00f3n puede consultarse a trav\u00e9s de este enlace . El componente websocket client ofrece soporte para el protocolo websocket sobre TCP y tambi\u00e9n, opcionalmente, sobre TLS. Como todos los componentes en ESP-IDF, el componente websocket emite eventos que pueden ser tratados por parte de la aplicaci\u00f3n, entre los cuales destacan: WEBSOCKET_EVENT_CONNECTED : se emite una vez el cliente se ha conectado al servidor, sin intercambio de datos. WEBSOCKET_EVENT_DISCONNECTED : se emite en el instante de la desconexi\u00f3n entre cliente y servidor. WEBSOCKET_EVENT_DATA : se emite al recibir datos desde el servidor. Este \u00faltimo evento es de especial inter\u00e9s para nosotros, ya que accarrea la construcci\u00f3n de una estructura de tipo esp_websocket_event_data_t en la que se almacena el mensaje recibido desde el servidor (tanto en sus campos de control como de datos). Algunos campos de inter\u00e9s dentro de la estructura son: const char * data_ptr : puntero a los datos recibidos ( payload ). data_len : tama\u00f1o (en bytes) de los datos recibidos. op_code : c\u00f3digo de operaci\u00f3n asociado al mensaje recibido. La documentaci\u00f3n del componente ofrece informaci\u00f3n sobre campos adicionales, de menor inter\u00e9s para nosotros. Observemos el c\u00f3digo de una posible funci\u00f3n manejadora de eventos del componente websocket : static void websocket_event_handler(void *handler_args, esp_event_base_t base, int32_t event_id, void *event_data) { esp_websocket_event_data_t *data = (esp_websocket_event_data_t *)event_data; switch (event_id) { case WEBSOCKET_EVENT_CONNECTED: ESP_LOGI(TAG, \"WEBSOCKET_EVENT_CONNECTED\"); break; case WEBSOCKET_EVENT_DISCONNECTED: ESP_LOGI(TAG, \"WEBSOCKET_EVENT_DISCONNECTED\"); break; case WEBSOCKET_EVENT_DATA: ESP_LOGI(TAG, \"WEBSOCKET_EVENT_DATA\"); ESP_LOGI(TAG, \"Received opcode=%d\", data->op_code); if (data->op_code == 0x08 && data->data_len == 2) { ESP_LOGW(TAG, \"Received closed message with code=%d\", 256*data->data_ptr[0] + data->data_ptr[1]); } else { ESP_LOGW(TAG, \"Received=%.*s\", data->data_len, (char *)data->data_ptr); } ESP_LOGW(TAG, \"Total payload length=%d, data_len=%d, current payload offset=%d\\r\\n\", data->payload_len, data->data_len, data->payload_offset); xTimerReset(shutdown_signal_timer, portMAX_DELAY); break; case WEBSOCKET_EVENT_ERROR: ESP_LOGI(TAG, \"WEBSOCKET_EVENT_ERROR\"); break; } } Observa el c\u00f3digo. En funci\u00f3n del par\u00e1metro event_id , el manejador toma un camino de ejecuci\u00f3n u otro. Centr\u00e9monos en la recepci\u00f3n de un evento de tipo \u1e80EBSOCKET_EVENT_DATA ; a trav\u00e9s de los distintos campos de la estructura de informaci\u00f3n recibida ( event_data ), es posible: Obtener y mostrar el c\u00f3digo de la operaci\u00f3n ( op_code ). Mostrar el contenido del mensaje recibido ( data_ptr ). Mostrar el tama\u00f1o del mensaje recibido ( data_len y payload_len ). Preguntas \u00bfCu\u00e1l es la diferencia entre los campos data_len y payload_len ? \u00bfPor qu\u00e9 el programa realiza un tratamiento especial cuando op_code == 8 ? Dada la anterior funci\u00f3n manejadora, la inicializaci\u00f3n de un cliente websockets en el ESP32 es sencilla, y se resume en los siguientes pasos: Configuraci\u00f3n de URI (host + puerto) esp_websocket_client_config_t websocket_cfg = {}; websocket_cfg.uri = \"ws://localhost:123\"; esp_websocket_client_handle_t client = esp_websocket_client_init(&websocket_cfg); Asociaci\u00f3n de manejador a eventos Websocket esp_websocket_register_events(client, WEBSOCKET_EVENT_ANY, websocket_event_handler, (void *)client); Inicializaci\u00f3n del cliente esp_websocket_client_start(client); A partir de este punto, la interacci\u00f3n con el servidor se puede realizar en base a funciones de env\u00edo de texto o binario: int esp_websocket_client_send(esp_websocket_client_handle_tclient, const char *data, int len, TickType_t timeout) esp_websocket_client_send_bin(esp_websocket_client_handle_tclient, const char *data, int len, TickType_t timeout) No existen funciones de recepci\u00f3n, ya que \u00e9sta es impl\u00edcita y se notifica v\u00eda eventos.","title":"Websockets en el ESP32"},{"location":"RPI-II/P4/#ejemplo-basico-cliente-echo","text":"Veremos en primer lugar un ejemplo completo de cliente ejecutado sobre el ESP32. En este punto, configura, compila, flashea y monitoriza el ejemplo examples/protocols/websockets . El ejemplo simplemente conecta con un servidor echo Websockets en la nube (disponible en ws://websockets.org ). Dicho servidor simplemente espera, por parte de cada cliente, el env\u00edo a trav\u00e9s de la conexi\u00f3n de una cadena, respondiendo con la misma cadena en sentido contrario, siempre usando el mismo socket . Tarea Observa el c\u00f3digo del ejemplo y su ejecuci\u00f3n. Determina cu\u00e1l es el funcionamiento del ejemplo, y comprueba que los fragmentos de c\u00f3digo anteriores tienen su funci\u00f3n dentro del c\u00f3digo completo. \u00bfC\u00f3mo implementa el programa la espera limitada en tiempo si no se recibe ning\u00fan paquete tras cierto per\u00edodo?","title":"Ejemplo b\u00e1sico: cliente echo"},{"location":"RPI-II/P4/#ejercicio-entregable-comunicacion-asincrona","text":"El objetivo del ejercicio entregable es conseguir que el ESP32 se comunique con el servidor Python que se prob\u00f3 en la secci\u00f3n anterior, y que implementaba comunicaci\u00f3n bidireccional para mantener y difundir el estado interno (contador y n\u00famero de clientes conectados) entre todos los clientes conectados. Para ello, se pide modificar el ejemplo de cliente echo para que: El cliente conecte con el servidor Python especificando su IP y puerto. El cliente sea cien por cien pasivo, es decir, no env\u00ede nunca mensajes al servidor. La funci\u00f3n de manejo de paquetes recibidos trate de forma especial el tipo de mensajes esperado por parte del servidor. Recuerda que se pueden recibir dos tipos de mensajes de texto: Mensajes de estado: {\"type\": \"users\", \"count\": usuarios} Mensajes de usuarios: {\"type\": \"state\", \"value\": VALOR} Observa que ambos mensajes, pese a ser recibidos como texto, corresponden con una representaci\u00f3n JSON de la informaci\u00f3n. Para tratarla desde ESP-IDF, puedes hacer uso del componente cJSON del framework . Por ejemplo, para tratar un mensaje de entrada de tipo \"state\", podr\u00edamos a\u00f1adir la siguiente secuencia de c\u00f3digo en nuestro manejador: #include \"cJSON.h\" // ... if( data->op_code == 1 ) { // Text frame only. cJSON *root = cJSON_Parse((char*)data->data_ptr); char *type = cJSON_GetObjectItem(root,\"type\")->valuestring; ESP_LOGI(TAG, \"type=%s\",type); int field = 0; if( strcmp( type, \"state\" ) == 0) { field = cJSON_GetObjectItem(root,\"value\")->valueint; ESP_LOGI(TAG, \"value=%d\",field); } } Tarea entregable Modifica el firmware de ejemplo websockets para que pueda comunicarse en modo lectura con el servidor Python que mantiene y publicita estado, cuyo c\u00f3digo se te proporciona. El programa ESP-IDF, al menos, mostar\u00e1 por pantalla un mensaje con los datos asociados cada vez que se reciban paquetes de tipo texto ( state o users ). Tambi\u00e9n mostrar\u00e1 un mensaje cada vez que el servidor env\u00ede un mensaje de tipo ping o pong (para ello, consulta el RFC que describe el protocolo para determinar el opcode asociado). Para comprobar el funcionamiento de la soluci\u00f3n, arranca el servidor y al menos dos clientes web. Cuando arranques el ESP32, ambos deber\u00e1n incrementar el n\u00famero de clientes reportado, en respuesta al mensaje enviado por el servidor. Cuando cualquiera de los clientes web incremente el valor del contador, el ESP32 recibir\u00e1 un mensaje con el valor actualizado, del mismo modo que cuando cierres uno de los navegadores web. Tarea opcional Modifica el c\u00f3digo para que el cliente, peri\u00f3dicamente, env\u00ede un mensaje de petici\u00f3n de suma o resta siguiendo las especificaciones y tipos de mensaje que se explicaron anteriormente.","title":"Ejercicio entregable: Comunicaci\u00f3n as\u00edncrona"},{"location":"RPI-II/P5/","text":"Pr\u00e1ctica 5. Representaci\u00f3n de la informaci\u00f3n. CBOR","title":"Pr\u00e1ctica 5"},{"location":"RPI-II/P5/#practica-5-representacion-de-la-informacion-cbor","text":"","title":"Pr\u00e1ctica 5. Representaci\u00f3n de la informaci\u00f3n. CBOR"},{"location":"RPI-II/P5/notas/","text":"Implementaci\u00f3n de una interfaz REST v\u00eda HTTP Ejemplo Ejemplo: restful_server navegar a front/webdemo apt-get install npm node-vue* npm install y npm run build en direcrorio front/web-demo idf.py build","title":"Notas"},{"location":"RPI-II/P5/notas/#implementacion-de-una-interfaz-rest-via-http","text":"","title":"Implementaci\u00f3n de una interfaz REST v\u00eda HTTP"},{"location":"RPI-II/P5/notas/#ejemplo","text":"Ejemplo: restful_server navegar a front/webdemo apt-get install npm node-vue* npm install y npm run build en direcrorio front/web-demo idf.py build","title":"Ejemplo"},{"location":"RPI-II/P6/","text":"Pr\u00e1ctica 6. El protocolo MQTT","title":"Pr\u00e1ctica 6"},{"location":"RPI-II/P6/#practica-6-el-protocolo-mqtt","text":"","title":"Pr\u00e1ctica 6. El protocolo MQTT"},{"location":"RPI-II/P7/","text":"Pr\u00e1ctica 7. El protocolo CoAP","title":"Pr\u00e1ctica 7"},{"location":"RPI-II/P7/#practica-7-el-protocolo-coap","text":"","title":"Pr\u00e1ctica 7. El protocolo CoAP"},{"location":"RPI-II/P8/","text":"Pr\u00e1ctica 8. El protocolo LWM2M","title":"Pr\u00e1ctica 8"},{"location":"RPI-II/P8/#practica-8-el-protocolo-lwm2m","text":"","title":"Pr\u00e1ctica 8. El protocolo LWM2M"},{"location":"RPI-II/P9/","text":"Pr\u00e1ctica 9. Node-RED","title":"Pr\u00e1ctica 9"},{"location":"RPI-II/P9/#practica-9-node-red","text":"","title":"Pr\u00e1ctica 9. Node-RED"}]}