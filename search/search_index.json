{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Redes, Protocolos e Interfaces Calendario RPI-I Pr\u00e1ctica D\u00eda T\u00edtulo 1 05/10 Introducci\u00f3n al entorno de desarrollo 12/10 FESTIVO 2 19/10 WiFi 3 26/10 WiFi Mesh 02/11 FESTIVO 09/11 FESTIVO 4 16/11 Bluetooth Low Energy 5 23/11 BLE Mesh 6 30/11 6LowPAN (Simulaci\u00f3n) 07/12 FESTIVO 7 14/12 6LowPAN (SensorTag) 8 21/12 LoRA Calendario RPI-II Pr\u00e1ctica D\u00eda T\u00edtulo 1 01/10 Sockets TCP/UDP (Linux) 2 08/10 Sockets TCP/UDP (ESP32) 3 15/10 TLS/OpenSSL 4 22/10 HTTP/Websockets 5 29/11 Representaci\u00f3n de la informaci\u00f3n. CBOR 6 05/11 MQTT (I) 6 12/11 MQTT (II) 7 19/11 CoAP 8 26/11 LWM2M (I) 8 03/12 LWM2M (II) 9 10/12 Node-RED 10 17/12 Entornos Cloud / Frameworks IoT","title":"Calendario"},{"location":"#redes-protocolos-e-interfaces","text":"","title":"Redes, Protocolos e Interfaces"},{"location":"#calendario-rpi-i","text":"Pr\u00e1ctica D\u00eda T\u00edtulo 1 05/10 Introducci\u00f3n al entorno de desarrollo 12/10 FESTIVO 2 19/10 WiFi 3 26/10 WiFi Mesh 02/11 FESTIVO 09/11 FESTIVO 4 16/11 Bluetooth Low Energy 5 23/11 BLE Mesh 6 30/11 6LowPAN (Simulaci\u00f3n) 07/12 FESTIVO 7 14/12 6LowPAN (SensorTag) 8 21/12 LoRA","title":"Calendario RPI-I"},{"location":"#calendario-rpi-ii","text":"Pr\u00e1ctica D\u00eda T\u00edtulo 1 01/10 Sockets TCP/UDP (Linux) 2 08/10 Sockets TCP/UDP (ESP32) 3 15/10 TLS/OpenSSL 4 22/10 HTTP/Websockets 5 29/11 Representaci\u00f3n de la informaci\u00f3n. CBOR 6 05/11 MQTT (I) 6 12/11 MQTT (II) 7 19/11 CoAP 8 26/11 LWM2M (I) 8 03/12 LWM2M (II) 9 10/12 Node-RED 10 17/12 Entornos Cloud / Frameworks IoT","title":"Calendario RPI-II"},{"location":"RPI-I/P1/","text":"Pr\u00e1ctica 1. Introducci\u00f3n al entorno","title":"Pr\u00e1ctica 1"},{"location":"RPI-I/P1/#practica-1-introduccion-al-entorno","text":"","title":"Pr\u00e1ctica 1. Introducci\u00f3n al entorno"},{"location":"RPI-I/P2/","text":"Pr\u00e1ctica 2. Soporte WiFi en ESP32","title":"Pr\u00e1ctica 2"},{"location":"RPI-I/P2/#practica-2-soporte-wifi-en-esp32","text":"","title":"Pr\u00e1ctica 2. Soporte WiFi en ESP32"},{"location":"RPI-I/P3/","text":"Pr\u00e1ctica 3. WiFi Mesh","title":"Pr\u00e1ctica 3"},{"location":"RPI-I/P3/#practica-3-wifi-mesh","text":"","title":"Pr\u00e1ctica 3. WiFi Mesh"},{"location":"RPI-I/P4/","text":"Pr\u00e1ctica 4. Bluetooth Low Energy (BLE)","title":"Pr\u00e1ctica 4"},{"location":"RPI-I/P5/","text":"Pr\u00e1ctica 4. Bluetooth Mesh","title":"Pr\u00e1ctica 5"},{"location":"RPI-I/P5/#practica-4-bluetooth-mesh","text":"","title":"Pr\u00e1ctica 4. Bluetooth Mesh"},{"location":"RPI-I/P6/","text":"Pr\u00e1ctica 6. 6LowPAN (simulaci\u00f3n en Cooja)","title":"Pr\u00e1ctica 6"},{"location":"RPI-I/P6/#practica-6-6lowpan-simulacion-en-cooja","text":"","title":"Pr\u00e1ctica 6. 6LowPAN (simulaci\u00f3n en Cooja)"},{"location":"RPI-I/P7/","text":"Pr\u00e1ctica 6. 6LowPAN (SensorTag)","title":"Pr\u00e1ctica 7"},{"location":"RPI-I/P7/#practica-6-6lowpan-sensortag","text":"","title":"Pr\u00e1ctica 6. 6LowPAN (SensorTag)"},{"location":"RPI-I/P8/","text":"Pr\u00e1ctica 8. LoRA","title":"Pr\u00e1ctica 8"},{"location":"RPI-I/P8/#practica-8-lora","text":"","title":"Pr\u00e1ctica 8. LoRA"},{"location":"RPI-II/P1/","text":"Pr\u00e1ctica 1. Programaci\u00f3n con sockets en Python Objetivos Familiarizarse con la API de sockets en Python. Desarrollar esquemas b\u00e1sicos de sistemas cliente/servidor TCP y UDP utilizando Python. Ser capaces de analizar el tr\u00e1fico generado en una conexi\u00f3n TCP y UDP a trav\u00e9s de Wireshark. Dise\u00f1ar un protocolo de capa de aplicaci\u00f3n para simular una aplicaci\u00f3n cliente/servidor utilizando TCP y UDP. Observar la diferencia en tr\u00e1fico generado para una misma aplicaci\u00f3n utilizando TCP y UDP. Introducci\u00f3n La historia de los sockets se remonta al origen de ARPANET, en 1971, y su posterior estandarizaci\u00f3n en forma de API dentro del sistema operativo Berkeley Software Distribution (BSD) , liberado en 1983, bajo el nombre de sockets de Berkeley . Con la popularizaci\u00f3n de Internet en los a\u00f1os 90, y de la mano de la World Wide Web , la programaci\u00f3n de red sufri\u00f3 tambi\u00e9n una notable evoluci\u00f3n. Los servidores web y los navegadores no fueron (ni son) las \u00fanicas aplicaciones basadas en sockets . De hecho, los sistemas cliente/servidor son a d\u00eda de hoy ubicuos e incluyen, por supuesto, a todos los protocolos de alto nivel que dan soporte a Internet de las Cosas. De hecho, a d\u00eda de hoy, aunque los potocolos de alto nivel (capa de aplicaci\u00f3n) han evolucionado hasta niveles de sofisticaci\u00f3n no considerados en sus inicios, la API de bajo nivel sobre la que se basan se mantiene inalterada. El tipo m\u00e1s com\u00fan de aplicaciones basadas en sockets se basa en el paradigma cliente/servidor, donde una de las partes act\u00faa como servidor , esperando pasivamente conexiones desde un conjunto de uno o m\u00e1s clientes . A continuaci\u00f3n, veremos c\u00f3mo desarrollar este tipo de paradigma desde Python, utilizando sockets Berkeley . Existen tambi\u00e9n los llamados Unix domain sockets , que permiten la comunicaci\u00f3n directa entre procesos en el mismo host , aunque quedan fuera de nuestro inter\u00e9s en el \u00e1mbito de IoT. La API de sockets en Python El m\u00f3dulo socket de Python proporciona una interfaz completa para trabajar con la API de sockets de Berkeley . En la presente pr\u00e1ctica, trabajaremos exclusivamente con esta API para desarrollar aplicaciones cliente/servidor utilizando los protocolos TCP y UDP. Las funciones y m\u00e9todos principales de la API de sockets son: socket() - bind() - listen() - accept() - connect() - connect_ex() - send() - recv() - close() - Python prorpociona una API consistente y completa mapeada directamente a las anteriores llamadas al sistema, t\u00edpicamente escritas en lenguaje C. Como parte de su biblioteca est\u00e1ndar, Python tambi\u00e9n proporciona clases que facilitan el trabajo con las funciones de bajo nivel. Aunque no lo cubriremos, el m\u00f3dulo socketserver proporciona una forma sencilla de crear servidores de red. Existen tambi\u00e9n numerosos m\u00f3dulos disponibles para implementar protocolos de alto nivel (por ejemplo HTTP o SMTP), v\u00e9ase . Sockets TCP En Python, los sockets TCP se crean en Python utilizando socket.socket() , especificando el tipo de socket como socket.SOCK_STREAM . El protocolo de control de transmisi\u00f3n (TCP) se caracteriza por dos rasgos principales: Es confiable : se implementan mecanismos de detecci\u00f3n de p\u00e9rdidas en la red y reenv\u00edo de paquetes perdidos. Garantiza una entrega de paquetes en orden : los datos se entregan a las capas superiores (aplicaciones) en el mismo orden en el que fueron enviados. En contra, los sockets UDP se crean a trav\u00e9s de socket.SOCK_DGRAM , y no son confiables ni garantizan la entrega de paquetes en orden. Por tanto, es el desarrollador de aplicaciones quien, en caso de as\u00ed desearlo en el dise\u00f1o de la aplicaci\u00f3n, debe implementar estos mecanismos de forma espec\u00edfica. En el siguiente diagrama se muestra la secuencia t\u00edpica de invocaciones a la API de sockets para TCP: En la figura, la columna de la izquierda representa al servidor, mientras que la columna de la derecha representa al cliente en la conexi\u00f3n TCP. Observa las invocaciones necesarias para configurar un socket a la escucha de conexiones entrantes: socket() bind() listen() accept() En este extremo, un socket escucha ( listen ) potenciales conexiones entrantes desde clientes. Cuando un cliente solicita conectar, el servidor acepta ( accept ) la conexi\u00f3n, complet\u00e1ndola. El cliente invoca a connect() para establecer una conexi\u00f3n con el servidor e inicia el proceso de conexi\u00f3n a tres v\u00edas ( three-way connection ). Una vez establecida la conexi\u00f3n, los datos se intercambian entre cliente y servidor a trav\u00e9s de invocaciones a send() y recv() . Finalmente, el socket se destruye (esto es, la conexi\u00f3n entre ambos extremos se cierra) a trav\u00e9s de una invocaci\u00f3n a close() en cada extremo. Cliente/servidor echo TCP Veamos un ejemplo sencillo para crear un par cliente-servidor. En este caso, el servidor simplemente responder\u00e1 con la misma cadena que reciba desde el cliente. Servidor echo #!/usr/bin/env python3 #### servidor_echo.py import socket HOST = '127.0.0.1' # Interfaz est\u00e1ndar de loopback (localhost) PORT = 65432 # Puerto de escucha (los puertos mayores a 1023 son no privilegiados) with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: s.bind((HOST, PORT)) s.listen() conn, addr = s.accept() with conn: print('Conectado ', addr) while True: data = conn.recv(1024) if not data: break conn.sendall(data) Nota De momento, no importa si no entiendes todas las l\u00edneas en el anterior c\u00f3digo. Simplemente se trata de un punto de partida para desarrollar un servidor sencillo. Sin embargo, es conveniente que copies el c\u00f3digo en un fichero de texto (por ejemplo, llamado servidor_echo.py ) para que podeamos probarlo. Veamos l\u00ednea a l\u00ednea las partes m\u00e1s importantes del anterior c\u00f3digo. socket.socket() crea un objeto socket . Observa que, al crearse a trav\u00e9s de una construcci\u00f3n with , no es necesario invocar expl\u00edcitamente a s.close() , aunque debes tener en cuenta que el objeto es destruido al finalizar la construcci\u00f3n: with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: pass # Es posible usar el socket win invocar a s.close(). Los argumentos que se proporcionan a socket() especifican la familia de direcciones ( AF_INET ) y tipo de socket ( SOCK_STREAM ). AF_INET es la familia de direcciones de Internet para IPv4. SOCK_STREAM es el tipo de socket que permite la creaci\u00f3n de conexiones TCP. bind() se utiliza para asociar el socket a una interfaz de red y n\u00famero de puerto espec\u00edficos: HOST = '127.0.0.1' # Interfaz est\u00e1ndar de loopback (localhost) PORT = 65432 # Puerto de escucha (los puertos mayores a 1023 son no privilegiados) # ... s.bind((HOST, PORT)) Los valores proporcionados a bind() dependen de la familia de direcciones seleccionada para el socket . En este ejemplo, al utilizar AF_INET , espera una tupla con \u00fanicamente dos valores (host, puerto) . Para determinar el host , es posible utilizar un nombre de host , una direcci\u00f3n IP o una cadena vac\u00eda. Si utilizamos una direcci\u00f3n IP, \u00e9sta debe ser especificarse mediante una cadena que contenga una direcci\u00f3n IPv4 bien formada. La direcci\u00f3n 127.0.0.1 es la direcci\u00f3n IPv4 est\u00e1ndar para la interfaz de loopback , por lo que \u00fanicamente procesos que est\u00e9n ejecut\u00e1ndose en el propio host podr\u00e1n comunicar con el servidor. Si proporcionamos una cadena vac\u00eda, el servidro aceptar\u00e1 conexiones entrantes a trav\u00e9s de todas las interfaces IPv4 disponibles en el sistema. El n\u00famero de puerto ( port ) se especifica con un valor entero entre 1 y 65535, y espcifica el puerto (en este caso, TCP) a trav\u00e9s del cual el servidor aceptar\u00e1 conexiones desde los clientes. La mayor\u00eda de sistemas requieren permisos de superusuario para escuchar a trav\u00e9s de los puertos ( well-known ), es decir, con valor inferior a 1024. Continuando con el ejemplo, listen() posibilita que un servidor pueda, en el futuro, aceptar ( accept() ) conexiones entrantes. En otras palabras, pone a la escucha al socket : s.listen() conn, addr = s.accept() La invocaci\u00f3n a accept() bloquea el proceso y espera a una conexi\u00f3n entrante. Cuando un cliente conecta, devuelve un objeto socket que representa la conexi\u00f3n, as\u00ed como una tupla ( addr ) que contiene la direcci\u00f3n del cliente. Concretamente, esta tupla contiene los valores (host, port) que almacenan la direcci\u00f3n IPv4 y puerto del cliente que solicita la conexi\u00f3n. Observa que, en el ejemplo, conn es el objeto socket que usaremos para comunicar con el cliente: conn, addr = s.accept() with conn: print('Conectado ', addr) while True: data = conn.recv(1024) if not data: break conn.sendall(data) Tras obtener el objeto devuelto por accept() , dise\u00f1amos el servidor como un bucle infinito que invoca repetidamente a llamadas bloqueantes a conn.recv() . As\u00ed, leemos los datos enviados por el cliente y los reenviamos sin modificaci\u00f3n utilizando conn.sendall() . Si conn.recv() devuelve un objeto de tipo bytes vac\u00edo ( b'' ) significa que el cliente cerr\u00f3 la conexi\u00f3n, en cuyo caso el bucle termina, destruy\u00e9ndose el socket al salir de la sentencia with . Cliente echo Veamos a continuaci\u00f3n la estructura general del cliente (puedes usar, por ejemplo, cliente_echo.py como nombre para el fichero): #!/usr/bin/env python3 ### cliente_echo.py import socket HOST = '127.0.0.1' # IP del servidor PORT = 65432 # Puerto de escucha del servidor with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: s.connect((HOST, PORT)) s.sendall(b'Hola, mundo') data = s.recv(1024) print('Recibido ', repr(data)) En comparaci\u00f3n con el servidor, la estructura del cliente es m\u00e1s simple; simplemente crea un nuevo objeto socket , conecta con el servidor e invoca a s.sendall() para enviar el mensaje. Finalmente, espera la recepci\u00f3n de la respuesta utilizando s.recv() y la imprime por pantalla. Ejecuci\u00f3n del cliente y servidor echo A continuaci\u00f3n, ejecutaremos cliente y servidor para observar el estado de las conexiones durante su ciclo de vida. Ejecuta en una terminal el servidor: $ python3 ./servidor-echo.py Como ves, la terminal se bloquea (de hecho, el servidor permanece en estado bloqueado) en la invocaci\u00f3n: conn, addr = s.accept() Realmente, el servidor est\u00e1 esperando a que haya conexiones entrantes por parte de un cliente. Abre otra terminal y ejecuta el cliente: $ python3 cliente-echo.py Recibido 'Hola, mundo' En la ventana del servidor, deber\u00edas ver algo similar a: $ python3 ./servidor-echo.py Conectado ('127.0.0.1, 61234') En esta salida, el servidor ha mostrado por pantalla la tupla devuelta por s.accept() , que incluye la direcci\u00f3n IP y el n\u00famero de puerto TCP. Dicho n\u00famero de puerto (en el ejemplo anterior, 61234) es seleccionado aleatoriamente por el sistema operativo y puede variar en tu ejecuci\u00f3n. Herramientas para observar el estado del socket Podemos utilizar la herramienta netstat para observar el estado actual de los sockets en cualquier sistema operativo (macOS, Linux e incluso Windows). Por ejemplo, esta ser\u00eda la salida de netstat en Linux tras ejecutar el servidor: netstat -an | grep 65432 Conexiones activas de Internet (servidores y establecidos) Proto Recib Enviad Direcci\u00f3n local Direcci\u00f3n remota Estado tcp 0 0 127.0.0.1:65432 0.0.0.0:* ESCUCHAR Observa que hemos filtrado la salida de la orden netcat seg\u00fan el n\u00famero de puerto utilizado. Observa el valor de las columnas Proto, Direcci\u00f3n local y Estado . Nota Otra forma de observar el estado de las conexiones es a trav\u00e9s de la orden lsof -i -n . Ejec\u00fatala y observa su salida. Capturas de tr\u00e1fico v\u00eda Wireshark Wireshark es una herramienta de c\u00f3digo abierto ampliamente utilizada para analizar protocolos de comunicaci\u00f3n de red en cualquiera de las capas de la pila TCP/IP (como tambi\u00e9n en otros protocolos). Wireshark implementa un amplio abanico de filtros para definir criterios de b\u00fasqueda en las capturas de tr\u00e1fico, aunque de momento, en nuestro caso, no ser\u00e1 necesario utilizar filtros espec\u00edficos. Para arrancar Wireshark en la m\u00e1quina virtual proporcionada (o en cualquier instalaci\u00f3n b\u00e1sica Linux), teclea en tu terminal: $ sudo wireshark Tras el arranque, podemos comenzar una nueva captura de tr\u00e1fico a trav\u00e9s del men\u00fa Capture , opci\u00f3n Start . La pantalla de selecci\u00f3n de interfaz nos permitir\u00e1 definir en qu\u00e9 interfaz de red se realizar\u00e1 la captura. En nuestro caso, ya que vamos a comunicar dos procesos en la misma m\u00e1quina, elegiremos la interfaz de Loopback (lo) y comenzaremos la captura. Tarea Arranca Wireshark y prepara una captura sobre la interfaz de loopback . Ejecuta el servidor echo TCP y el cliente correspondiente, y analiza el tr\u00e1fico generado. Especialmente, f\u00edjate en el proceso de establecimiento de conexi\u00f3n en tres v\u00edas, paquetes de Acknowledge tras el env\u00edo de cada mensaje y, en general, en cualquier otro aspecto que consideres de inter\u00e9s. Sockets UDP La creaci\u00f3n y gesti\u00f3n de sockets UDP en Python resulta todav\u00eda m\u00e1s sencilla. Observa el siguiente c\u00f3digo, que crea un servidor UDP utilizando la API de sockets Python: import socket udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) udp_socket.bind((\"localhost\", 5005)) data = udp_socket.recv(512) print(data) Primero, importamos la biblioteca socket de recepci\u00f3n, igual que en el caso de TCP. Obviamente, en este caso el tipo de socket pasa a ser socket.DOCK_DGRAM , para indicar que deseamos utilizar UDP en la comunicaci\u00f3n. El programa espera a la recepci\u00f3n de un paquete utilizando el m\u00e9todo bloqueante recv , cuyo \u00fanico par\u00e1metro indica el n\u00famero m\u00e1ximo de bytes que deseamos recibir. Cuando un paquete llega al socket, el metodo recv devolver\u00e1 un array de bytes, que ser\u00e1 almacenado en la variable que deseemos. El env\u00edo de datos a trav\u00e9s de un socket UDP es tambi\u00e9n sencillo: import socket udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) udp_socket.bind((\"localhost\", 0)) data = b\"Hola, mundo!\" udp_socket.sendto(data,(\"localhost\", 5005)) Observa que, en este caso, asociamos ( bind ) el socket a un puerto especificado como 0. Este valor especial indica al sistema operativo que elija para la transimisi\u00f3n un puerto origen aleatorio de entre los disponibles en el sistema. A continuaci\u00f3n, creamos los datos a enviar y los enviamos utilizando el m\u00e9todo sendto() . Este m\u00e9todo tomados argumentos: datos a enviar, y precisamente la direcci\u00f3n de env\u00edo. Los datos enviados a trav\u00e9s del socket deben formar parte de un array de bytes (por ello, la cadena a enviar viene precedida por el car\u00e1cter b ). Tarea Comprueba que, efectivamente, los c\u00f3digos de env\u00edo y recepci\u00f3n a trav\u00e9s de UDP funcionan como se espera. Nota Desde la versi\u00f3n 3 de Python, las cadenas se codifican utilizando Unicode. Al contrario que ASCII, conde cada caracter tiene una representaci\u00f3n en byte directa, Unicode utiliza enteros par representar cada caracter, que deben ser codificados para obtener una representaci\u00f3n en forma de byte. Uno de esos esquemas de codificaci\u00f3n es UTF-8. Por ejemplo, el siguiente c\u00f3digo muestra c\u00f3mo codificar una cadena Unicode en una representaci\u00f3n de bytes: cadena= \"Hola\" data = cadena.encode(\"UTF-8\") print(data, type(data)) lo cual genera b\"Hola\" <class 'bytes'> que puede ya ser enviado directamente por red. Hasta este punto, los programas UDP han sido totalmente unidireccionales en el env\u00edo/recepci\u00f3n de datos, pero obviamente, un socket UDP es un canal de comunicaci\u00f3n bidireccional. Tarea Implementa una funcionalidad similar al servidor echo que vimos para TCP, pero utilizando en este caso UDP. Realiza una captura de tr\u00e1fico en Wireshark similar a la realizada en el caso de TCP, y observa las principales diferencias entre ellas a nivel de tr\u00e1fico generado. Env\u00edo de datos binarios a trav\u00e9s de sockets Hasta este punto, hemos visto \u00fanicamente c\u00f3mo enviar cadenas de texto a trav\u00e9s de sockets TCP o UDP, pero es muy probable que sea necesario (o conveniente), en ocasiones, enviar datos directamente en formato binario (por ejemplo, valores num\u00e9ricos en punto flotante o enteros). Utilizando el m\u00f3dulo struct de Python podemos especificar qu\u00e9 tipo o tipos de datos se almacenan en una secuencia de bytes y c\u00f3mo decodificarlos. Tambi\u00e9n es posible especificar en qu\u00e9 lugar de la secuencia se alojan dichos datos, permitiendo el empaquetado de m\u00faltiples datos de distintos tipos de forma sencilla, y su posterior decodificaci\u00f3n en el otro extremo de la comunicaci\u00f3n. Nota Para todos los detalles del m\u00f3dulo struct , consulta la p\u00e1gina oficial de documentaci\u00f3n . El m\u00f3dulo struct proporciona dos m\u00e9todos de inter\u00e9s: pack y unpack . La siguiente sentencia: struct.pack(\">iii\", 1, 2, 3) utiliza el m\u00e9todo pack para realizar un empaquetado de datos. Concretamente, observa como el m\u00e9todo recibe dos par\u00e1metros: En primer lugar, el par\u00e1metro de formato \">iii\" . Define como debe codificarse cada valor en la secuencia de bytes. El primer car\u00e1cter indica el endianness utilizado, en este caso big endian (utilizar\u00edamos \">\" para big endian , \"<\" para little endian y \"=\" para network (big) endian). En segundo lugar, los valores a empaquetar. Observa que el formato, adem\u00e1s, incluye el n\u00famero y tipo de los datos a empaquetar (en este caso, tres valores detipo entero). Para otros tipos de datos, consulta la documentaci\u00f3n del m\u00f3dulo. Desempaquetar los datos enviados en el extremo opuesto es intuitivo: a, b, c = struct.unpack( \">iii\" ) A continuaci\u00f3n, mostramos un ejemplo de sistema cliente/servidor TCP que hace uso del m\u00f3dulo struct para realizar el env\u00edo de dos datos enteros y uno flotante entre un cliente y un servidor. # Cliente import binascii import socket import struct import sys # Socket TCP sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_address = ('localhost', 10001) sock.connect(server_address) packed_data = struct.pack(\"=iif\", 1, 4, 2.7) try: # Envio de datos print('Enviando \"%s\"' % binascii.hexlify(packed_data)) sock.sendall(packed_data) finally: print('Cerrando socket') sock.close() # Servidor import binascii import socket import struct import sys # Socket TCP sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_address = ('localhost', 10001) sock.bind(server_address) sock.listen(1) while True: print('Esperando conexiones entrantes') connection, client_address = sock.accept() try: data = connection.recv(1024) print('Recibido \"%s\"' % binascii.hexlify(data)) unpacked_data = struct.unpack(\"=iif\", data) print('Desempaquetado:', unpacked_data) finally: connection.close() Tarea Ejecuta el anterior sistema cliente servidor y analiza el tr\u00e1fico generado, en busca de los datos binarios empaquetados. Experimenta con otros tipos de datos y endianess y observa las diferencias. Tarea entregable Tarea entregable Se pide dise\u00f1ar un sistema cliente/servidor programado en Python, que simule el env\u00edo de un conjunto de datos sensorizados desde un cliente hacia un servidor. El protocolo a utilizar (formato de datos enviado por la red) debe ser propuesto por el propio alumno y descrito previamente al desarrollo. Se valorar\u00e1 el uso de m\u00faltiples tipos de datos tanto en el env\u00edo de datos sensorizados como de posibles respuestas por parte del servidor. Se desarrollar\u00e1 una versi\u00f3n utilizando TCP y otra equivalente usando UDP. Los datos se enviar\u00e1n de forma peri\u00f3dica y se generar\u00e1n de modo aleatorio. A modo de entrega, se solicitan los c\u00f3digos desarrollados, as\u00ed como un an\u00e1lisis del tr\u00e1fico generado, considerando la sobrecarga (en bytes reales enviados) introducida por cada protocolo de capa de transporte.","title":"Pr\u00e1ctica 1"},{"location":"RPI-II/P1/#practica-1-programacion-con-sockets-en-python","text":"","title":"Pr\u00e1ctica 1. Programaci\u00f3n con sockets en Python"},{"location":"RPI-II/P1/#objetivos","text":"Familiarizarse con la API de sockets en Python. Desarrollar esquemas b\u00e1sicos de sistemas cliente/servidor TCP y UDP utilizando Python. Ser capaces de analizar el tr\u00e1fico generado en una conexi\u00f3n TCP y UDP a trav\u00e9s de Wireshark. Dise\u00f1ar un protocolo de capa de aplicaci\u00f3n para simular una aplicaci\u00f3n cliente/servidor utilizando TCP y UDP. Observar la diferencia en tr\u00e1fico generado para una misma aplicaci\u00f3n utilizando TCP y UDP.","title":"Objetivos"},{"location":"RPI-II/P1/#introduccion","text":"La historia de los sockets se remonta al origen de ARPANET, en 1971, y su posterior estandarizaci\u00f3n en forma de API dentro del sistema operativo Berkeley Software Distribution (BSD) , liberado en 1983, bajo el nombre de sockets de Berkeley . Con la popularizaci\u00f3n de Internet en los a\u00f1os 90, y de la mano de la World Wide Web , la programaci\u00f3n de red sufri\u00f3 tambi\u00e9n una notable evoluci\u00f3n. Los servidores web y los navegadores no fueron (ni son) las \u00fanicas aplicaciones basadas en sockets . De hecho, los sistemas cliente/servidor son a d\u00eda de hoy ubicuos e incluyen, por supuesto, a todos los protocolos de alto nivel que dan soporte a Internet de las Cosas. De hecho, a d\u00eda de hoy, aunque los potocolos de alto nivel (capa de aplicaci\u00f3n) han evolucionado hasta niveles de sofisticaci\u00f3n no considerados en sus inicios, la API de bajo nivel sobre la que se basan se mantiene inalterada. El tipo m\u00e1s com\u00fan de aplicaciones basadas en sockets se basa en el paradigma cliente/servidor, donde una de las partes act\u00faa como servidor , esperando pasivamente conexiones desde un conjunto de uno o m\u00e1s clientes . A continuaci\u00f3n, veremos c\u00f3mo desarrollar este tipo de paradigma desde Python, utilizando sockets Berkeley . Existen tambi\u00e9n los llamados Unix domain sockets , que permiten la comunicaci\u00f3n directa entre procesos en el mismo host , aunque quedan fuera de nuestro inter\u00e9s en el \u00e1mbito de IoT.","title":"Introducci\u00f3n"},{"location":"RPI-II/P1/#la-api-de-sockets-en-python","text":"El m\u00f3dulo socket de Python proporciona una interfaz completa para trabajar con la API de sockets de Berkeley . En la presente pr\u00e1ctica, trabajaremos exclusivamente con esta API para desarrollar aplicaciones cliente/servidor utilizando los protocolos TCP y UDP. Las funciones y m\u00e9todos principales de la API de sockets son: socket() - bind() - listen() - accept() - connect() - connect_ex() - send() - recv() - close() - Python prorpociona una API consistente y completa mapeada directamente a las anteriores llamadas al sistema, t\u00edpicamente escritas en lenguaje C. Como parte de su biblioteca est\u00e1ndar, Python tambi\u00e9n proporciona clases que facilitan el trabajo con las funciones de bajo nivel. Aunque no lo cubriremos, el m\u00f3dulo socketserver proporciona una forma sencilla de crear servidores de red. Existen tambi\u00e9n numerosos m\u00f3dulos disponibles para implementar protocolos de alto nivel (por ejemplo HTTP o SMTP), v\u00e9ase .","title":"La API de sockets en Python"},{"location":"RPI-II/P1/#sockets-tcp","text":"En Python, los sockets TCP se crean en Python utilizando socket.socket() , especificando el tipo de socket como socket.SOCK_STREAM . El protocolo de control de transmisi\u00f3n (TCP) se caracteriza por dos rasgos principales: Es confiable : se implementan mecanismos de detecci\u00f3n de p\u00e9rdidas en la red y reenv\u00edo de paquetes perdidos. Garantiza una entrega de paquetes en orden : los datos se entregan a las capas superiores (aplicaciones) en el mismo orden en el que fueron enviados. En contra, los sockets UDP se crean a trav\u00e9s de socket.SOCK_DGRAM , y no son confiables ni garantizan la entrega de paquetes en orden. Por tanto, es el desarrollador de aplicaciones quien, en caso de as\u00ed desearlo en el dise\u00f1o de la aplicaci\u00f3n, debe implementar estos mecanismos de forma espec\u00edfica. En el siguiente diagrama se muestra la secuencia t\u00edpica de invocaciones a la API de sockets para TCP: En la figura, la columna de la izquierda representa al servidor, mientras que la columna de la derecha representa al cliente en la conexi\u00f3n TCP. Observa las invocaciones necesarias para configurar un socket a la escucha de conexiones entrantes: socket() bind() listen() accept() En este extremo, un socket escucha ( listen ) potenciales conexiones entrantes desde clientes. Cuando un cliente solicita conectar, el servidor acepta ( accept ) la conexi\u00f3n, complet\u00e1ndola. El cliente invoca a connect() para establecer una conexi\u00f3n con el servidor e inicia el proceso de conexi\u00f3n a tres v\u00edas ( three-way connection ). Una vez establecida la conexi\u00f3n, los datos se intercambian entre cliente y servidor a trav\u00e9s de invocaciones a send() y recv() . Finalmente, el socket se destruye (esto es, la conexi\u00f3n entre ambos extremos se cierra) a trav\u00e9s de una invocaci\u00f3n a close() en cada extremo.","title":"Sockets TCP"},{"location":"RPI-II/P1/#clienteservidor-echo-tcp","text":"Veamos un ejemplo sencillo para crear un par cliente-servidor. En este caso, el servidor simplemente responder\u00e1 con la misma cadena que reciba desde el cliente.","title":"Cliente/servidor echo TCP"},{"location":"RPI-II/P1/#servidor-echo","text":"#!/usr/bin/env python3 #### servidor_echo.py import socket HOST = '127.0.0.1' # Interfaz est\u00e1ndar de loopback (localhost) PORT = 65432 # Puerto de escucha (los puertos mayores a 1023 son no privilegiados) with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: s.bind((HOST, PORT)) s.listen() conn, addr = s.accept() with conn: print('Conectado ', addr) while True: data = conn.recv(1024) if not data: break conn.sendall(data) Nota De momento, no importa si no entiendes todas las l\u00edneas en el anterior c\u00f3digo. Simplemente se trata de un punto de partida para desarrollar un servidor sencillo. Sin embargo, es conveniente que copies el c\u00f3digo en un fichero de texto (por ejemplo, llamado servidor_echo.py ) para que podeamos probarlo. Veamos l\u00ednea a l\u00ednea las partes m\u00e1s importantes del anterior c\u00f3digo. socket.socket() crea un objeto socket . Observa que, al crearse a trav\u00e9s de una construcci\u00f3n with , no es necesario invocar expl\u00edcitamente a s.close() , aunque debes tener en cuenta que el objeto es destruido al finalizar la construcci\u00f3n: with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: pass # Es posible usar el socket win invocar a s.close(). Los argumentos que se proporcionan a socket() especifican la familia de direcciones ( AF_INET ) y tipo de socket ( SOCK_STREAM ). AF_INET es la familia de direcciones de Internet para IPv4. SOCK_STREAM es el tipo de socket que permite la creaci\u00f3n de conexiones TCP. bind() se utiliza para asociar el socket a una interfaz de red y n\u00famero de puerto espec\u00edficos: HOST = '127.0.0.1' # Interfaz est\u00e1ndar de loopback (localhost) PORT = 65432 # Puerto de escucha (los puertos mayores a 1023 son no privilegiados) # ... s.bind((HOST, PORT)) Los valores proporcionados a bind() dependen de la familia de direcciones seleccionada para el socket . En este ejemplo, al utilizar AF_INET , espera una tupla con \u00fanicamente dos valores (host, puerto) . Para determinar el host , es posible utilizar un nombre de host , una direcci\u00f3n IP o una cadena vac\u00eda. Si utilizamos una direcci\u00f3n IP, \u00e9sta debe ser especificarse mediante una cadena que contenga una direcci\u00f3n IPv4 bien formada. La direcci\u00f3n 127.0.0.1 es la direcci\u00f3n IPv4 est\u00e1ndar para la interfaz de loopback , por lo que \u00fanicamente procesos que est\u00e9n ejecut\u00e1ndose en el propio host podr\u00e1n comunicar con el servidor. Si proporcionamos una cadena vac\u00eda, el servidro aceptar\u00e1 conexiones entrantes a trav\u00e9s de todas las interfaces IPv4 disponibles en el sistema. El n\u00famero de puerto ( port ) se especifica con un valor entero entre 1 y 65535, y espcifica el puerto (en este caso, TCP) a trav\u00e9s del cual el servidor aceptar\u00e1 conexiones desde los clientes. La mayor\u00eda de sistemas requieren permisos de superusuario para escuchar a trav\u00e9s de los puertos ( well-known ), es decir, con valor inferior a 1024. Continuando con el ejemplo, listen() posibilita que un servidor pueda, en el futuro, aceptar ( accept() ) conexiones entrantes. En otras palabras, pone a la escucha al socket : s.listen() conn, addr = s.accept() La invocaci\u00f3n a accept() bloquea el proceso y espera a una conexi\u00f3n entrante. Cuando un cliente conecta, devuelve un objeto socket que representa la conexi\u00f3n, as\u00ed como una tupla ( addr ) que contiene la direcci\u00f3n del cliente. Concretamente, esta tupla contiene los valores (host, port) que almacenan la direcci\u00f3n IPv4 y puerto del cliente que solicita la conexi\u00f3n. Observa que, en el ejemplo, conn es el objeto socket que usaremos para comunicar con el cliente: conn, addr = s.accept() with conn: print('Conectado ', addr) while True: data = conn.recv(1024) if not data: break conn.sendall(data) Tras obtener el objeto devuelto por accept() , dise\u00f1amos el servidor como un bucle infinito que invoca repetidamente a llamadas bloqueantes a conn.recv() . As\u00ed, leemos los datos enviados por el cliente y los reenviamos sin modificaci\u00f3n utilizando conn.sendall() . Si conn.recv() devuelve un objeto de tipo bytes vac\u00edo ( b'' ) significa que el cliente cerr\u00f3 la conexi\u00f3n, en cuyo caso el bucle termina, destruy\u00e9ndose el socket al salir de la sentencia with .","title":"Servidor echo"},{"location":"RPI-II/P1/#cliente-echo","text":"Veamos a continuaci\u00f3n la estructura general del cliente (puedes usar, por ejemplo, cliente_echo.py como nombre para el fichero): #!/usr/bin/env python3 ### cliente_echo.py import socket HOST = '127.0.0.1' # IP del servidor PORT = 65432 # Puerto de escucha del servidor with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: s.connect((HOST, PORT)) s.sendall(b'Hola, mundo') data = s.recv(1024) print('Recibido ', repr(data)) En comparaci\u00f3n con el servidor, la estructura del cliente es m\u00e1s simple; simplemente crea un nuevo objeto socket , conecta con el servidor e invoca a s.sendall() para enviar el mensaje. Finalmente, espera la recepci\u00f3n de la respuesta utilizando s.recv() y la imprime por pantalla.","title":"Cliente echo"},{"location":"RPI-II/P1/#ejecucion-del-cliente-y-servidor-echo","text":"A continuaci\u00f3n, ejecutaremos cliente y servidor para observar el estado de las conexiones durante su ciclo de vida. Ejecuta en una terminal el servidor: $ python3 ./servidor-echo.py Como ves, la terminal se bloquea (de hecho, el servidor permanece en estado bloqueado) en la invocaci\u00f3n: conn, addr = s.accept() Realmente, el servidor est\u00e1 esperando a que haya conexiones entrantes por parte de un cliente. Abre otra terminal y ejecuta el cliente: $ python3 cliente-echo.py Recibido 'Hola, mundo' En la ventana del servidor, deber\u00edas ver algo similar a: $ python3 ./servidor-echo.py Conectado ('127.0.0.1, 61234') En esta salida, el servidor ha mostrado por pantalla la tupla devuelta por s.accept() , que incluye la direcci\u00f3n IP y el n\u00famero de puerto TCP. Dicho n\u00famero de puerto (en el ejemplo anterior, 61234) es seleccionado aleatoriamente por el sistema operativo y puede variar en tu ejecuci\u00f3n.","title":"Ejecuci\u00f3n del cliente y servidor echo"},{"location":"RPI-II/P1/#herramientas-para-observar-el-estado-del-socket","text":"Podemos utilizar la herramienta netstat para observar el estado actual de los sockets en cualquier sistema operativo (macOS, Linux e incluso Windows). Por ejemplo, esta ser\u00eda la salida de netstat en Linux tras ejecutar el servidor: netstat -an | grep 65432 Conexiones activas de Internet (servidores y establecidos) Proto Recib Enviad Direcci\u00f3n local Direcci\u00f3n remota Estado tcp 0 0 127.0.0.1:65432 0.0.0.0:* ESCUCHAR Observa que hemos filtrado la salida de la orden netcat seg\u00fan el n\u00famero de puerto utilizado. Observa el valor de las columnas Proto, Direcci\u00f3n local y Estado . Nota Otra forma de observar el estado de las conexiones es a trav\u00e9s de la orden lsof -i -n . Ejec\u00fatala y observa su salida.","title":"Herramientas para observar el estado del socket"},{"location":"RPI-II/P1/#capturas-de-trafico-via-wireshark","text":"Wireshark es una herramienta de c\u00f3digo abierto ampliamente utilizada para analizar protocolos de comunicaci\u00f3n de red en cualquiera de las capas de la pila TCP/IP (como tambi\u00e9n en otros protocolos). Wireshark implementa un amplio abanico de filtros para definir criterios de b\u00fasqueda en las capturas de tr\u00e1fico, aunque de momento, en nuestro caso, no ser\u00e1 necesario utilizar filtros espec\u00edficos. Para arrancar Wireshark en la m\u00e1quina virtual proporcionada (o en cualquier instalaci\u00f3n b\u00e1sica Linux), teclea en tu terminal: $ sudo wireshark Tras el arranque, podemos comenzar una nueva captura de tr\u00e1fico a trav\u00e9s del men\u00fa Capture , opci\u00f3n Start . La pantalla de selecci\u00f3n de interfaz nos permitir\u00e1 definir en qu\u00e9 interfaz de red se realizar\u00e1 la captura. En nuestro caso, ya que vamos a comunicar dos procesos en la misma m\u00e1quina, elegiremos la interfaz de Loopback (lo) y comenzaremos la captura. Tarea Arranca Wireshark y prepara una captura sobre la interfaz de loopback . Ejecuta el servidor echo TCP y el cliente correspondiente, y analiza el tr\u00e1fico generado. Especialmente, f\u00edjate en el proceso de establecimiento de conexi\u00f3n en tres v\u00edas, paquetes de Acknowledge tras el env\u00edo de cada mensaje y, en general, en cualquier otro aspecto que consideres de inter\u00e9s.","title":"Capturas de tr\u00e1fico v\u00eda Wireshark"},{"location":"RPI-II/P1/#sockets-udp","text":"La creaci\u00f3n y gesti\u00f3n de sockets UDP en Python resulta todav\u00eda m\u00e1s sencilla. Observa el siguiente c\u00f3digo, que crea un servidor UDP utilizando la API de sockets Python: import socket udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) udp_socket.bind((\"localhost\", 5005)) data = udp_socket.recv(512) print(data) Primero, importamos la biblioteca socket de recepci\u00f3n, igual que en el caso de TCP. Obviamente, en este caso el tipo de socket pasa a ser socket.DOCK_DGRAM , para indicar que deseamos utilizar UDP en la comunicaci\u00f3n. El programa espera a la recepci\u00f3n de un paquete utilizando el m\u00e9todo bloqueante recv , cuyo \u00fanico par\u00e1metro indica el n\u00famero m\u00e1ximo de bytes que deseamos recibir. Cuando un paquete llega al socket, el metodo recv devolver\u00e1 un array de bytes, que ser\u00e1 almacenado en la variable que deseemos. El env\u00edo de datos a trav\u00e9s de un socket UDP es tambi\u00e9n sencillo: import socket udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) udp_socket.bind((\"localhost\", 0)) data = b\"Hola, mundo!\" udp_socket.sendto(data,(\"localhost\", 5005)) Observa que, en este caso, asociamos ( bind ) el socket a un puerto especificado como 0. Este valor especial indica al sistema operativo que elija para la transimisi\u00f3n un puerto origen aleatorio de entre los disponibles en el sistema. A continuaci\u00f3n, creamos los datos a enviar y los enviamos utilizando el m\u00e9todo sendto() . Este m\u00e9todo tomados argumentos: datos a enviar, y precisamente la direcci\u00f3n de env\u00edo. Los datos enviados a trav\u00e9s del socket deben formar parte de un array de bytes (por ello, la cadena a enviar viene precedida por el car\u00e1cter b ). Tarea Comprueba que, efectivamente, los c\u00f3digos de env\u00edo y recepci\u00f3n a trav\u00e9s de UDP funcionan como se espera. Nota Desde la versi\u00f3n 3 de Python, las cadenas se codifican utilizando Unicode. Al contrario que ASCII, conde cada caracter tiene una representaci\u00f3n en byte directa, Unicode utiliza enteros par representar cada caracter, que deben ser codificados para obtener una representaci\u00f3n en forma de byte. Uno de esos esquemas de codificaci\u00f3n es UTF-8. Por ejemplo, el siguiente c\u00f3digo muestra c\u00f3mo codificar una cadena Unicode en una representaci\u00f3n de bytes: cadena= \"Hola\" data = cadena.encode(\"UTF-8\") print(data, type(data)) lo cual genera b\"Hola\" <class 'bytes'> que puede ya ser enviado directamente por red. Hasta este punto, los programas UDP han sido totalmente unidireccionales en el env\u00edo/recepci\u00f3n de datos, pero obviamente, un socket UDP es un canal de comunicaci\u00f3n bidireccional. Tarea Implementa una funcionalidad similar al servidor echo que vimos para TCP, pero utilizando en este caso UDP. Realiza una captura de tr\u00e1fico en Wireshark similar a la realizada en el caso de TCP, y observa las principales diferencias entre ellas a nivel de tr\u00e1fico generado.","title":"Sockets UDP"},{"location":"RPI-II/P1/#envio-de-datos-binarios-a-traves-de-sockets","text":"Hasta este punto, hemos visto \u00fanicamente c\u00f3mo enviar cadenas de texto a trav\u00e9s de sockets TCP o UDP, pero es muy probable que sea necesario (o conveniente), en ocasiones, enviar datos directamente en formato binario (por ejemplo, valores num\u00e9ricos en punto flotante o enteros). Utilizando el m\u00f3dulo struct de Python podemos especificar qu\u00e9 tipo o tipos de datos se almacenan en una secuencia de bytes y c\u00f3mo decodificarlos. Tambi\u00e9n es posible especificar en qu\u00e9 lugar de la secuencia se alojan dichos datos, permitiendo el empaquetado de m\u00faltiples datos de distintos tipos de forma sencilla, y su posterior decodificaci\u00f3n en el otro extremo de la comunicaci\u00f3n. Nota Para todos los detalles del m\u00f3dulo struct , consulta la p\u00e1gina oficial de documentaci\u00f3n . El m\u00f3dulo struct proporciona dos m\u00e9todos de inter\u00e9s: pack y unpack . La siguiente sentencia: struct.pack(\">iii\", 1, 2, 3) utiliza el m\u00e9todo pack para realizar un empaquetado de datos. Concretamente, observa como el m\u00e9todo recibe dos par\u00e1metros: En primer lugar, el par\u00e1metro de formato \">iii\" . Define como debe codificarse cada valor en la secuencia de bytes. El primer car\u00e1cter indica el endianness utilizado, en este caso big endian (utilizar\u00edamos \">\" para big endian , \"<\" para little endian y \"=\" para network (big) endian). En segundo lugar, los valores a empaquetar. Observa que el formato, adem\u00e1s, incluye el n\u00famero y tipo de los datos a empaquetar (en este caso, tres valores detipo entero). Para otros tipos de datos, consulta la documentaci\u00f3n del m\u00f3dulo. Desempaquetar los datos enviados en el extremo opuesto es intuitivo: a, b, c = struct.unpack( \">iii\" ) A continuaci\u00f3n, mostramos un ejemplo de sistema cliente/servidor TCP que hace uso del m\u00f3dulo struct para realizar el env\u00edo de dos datos enteros y uno flotante entre un cliente y un servidor. # Cliente import binascii import socket import struct import sys # Socket TCP sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_address = ('localhost', 10001) sock.connect(server_address) packed_data = struct.pack(\"=iif\", 1, 4, 2.7) try: # Envio de datos print('Enviando \"%s\"' % binascii.hexlify(packed_data)) sock.sendall(packed_data) finally: print('Cerrando socket') sock.close() # Servidor import binascii import socket import struct import sys # Socket TCP sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_address = ('localhost', 10001) sock.bind(server_address) sock.listen(1) while True: print('Esperando conexiones entrantes') connection, client_address = sock.accept() try: data = connection.recv(1024) print('Recibido \"%s\"' % binascii.hexlify(data)) unpacked_data = struct.unpack(\"=iif\", data) print('Desempaquetado:', unpacked_data) finally: connection.close() Tarea Ejecuta el anterior sistema cliente servidor y analiza el tr\u00e1fico generado, en busca de los datos binarios empaquetados. Experimenta con otros tipos de datos y endianess y observa las diferencias.","title":"Env\u00edo de datos binarios a trav\u00e9s de sockets"},{"location":"RPI-II/P1/#tarea-entregable","text":"Tarea entregable Se pide dise\u00f1ar un sistema cliente/servidor programado en Python, que simule el env\u00edo de un conjunto de datos sensorizados desde un cliente hacia un servidor. El protocolo a utilizar (formato de datos enviado por la red) debe ser propuesto por el propio alumno y descrito previamente al desarrollo. Se valorar\u00e1 el uso de m\u00faltiples tipos de datos tanto en el env\u00edo de datos sensorizados como de posibles respuestas por parte del servidor. Se desarrollar\u00e1 una versi\u00f3n utilizando TCP y otra equivalente usando UDP. Los datos se enviar\u00e1n de forma peri\u00f3dica y se generar\u00e1n de modo aleatorio. A modo de entrega, se solicitan los c\u00f3digos desarrollados, as\u00ed como un an\u00e1lisis del tr\u00e1fico generado, considerando la sobrecarga (en bytes reales enviados) introducida por cada protocolo de capa de transporte.","title":"Tarea entregable"},{"location":"RPI-II/P10/","text":"Pr\u00e1ctica 10. Frameworks IoT. Cloud","title":"Pr\u00e1ctica 10"},{"location":"RPI-II/P10/#practica-10-frameworks-iot-cloud","text":"","title":"Pr\u00e1ctica 10. Frameworks IoT. Cloud"},{"location":"RPI-II/P2/","text":"Pr\u00e1ctica 2. Sockets TCP y UDP en ESP-IDF","title":"Pr\u00e1ctica 2"},{"location":"RPI-II/P2/#practica-2-sockets-tcp-y-udp-en-esp-idf","text":"","title":"Pr\u00e1ctica 2. Sockets TCP y UDP en ESP-IDF"},{"location":"RPI-II/P3/","text":"Pr\u00e1ctica 3. Seguridad (TLS y OpenSSL)","title":"Pr\u00e1ctica 3"},{"location":"RPI-II/P3/#practica-3-seguridad-tls-y-openssl","text":"","title":"Pr\u00e1ctica 3. Seguridad (TLS y OpenSSL)"},{"location":"RPI-II/P4/","text":"Pr\u00e1ctica 4. Protocolos b\u00e1sicos. HTTP y Websocket","title":"Pr\u00e1ctica 4"},{"location":"RPI-II/P4/#practica-4-protocolos-basicos-http-y-websocket","text":"","title":"Pr\u00e1ctica 4. Protocolos b\u00e1sicos. HTTP y Websocket"},{"location":"RPI-II/P5/","text":"Pr\u00e1ctica 5. Representaci\u00f3n de la informaci\u00f3n. CBOR","title":"Pr\u00e1ctica 5"},{"location":"RPI-II/P5/#practica-5-representacion-de-la-informacion-cbor","text":"","title":"Pr\u00e1ctica 5. Representaci\u00f3n de la informaci\u00f3n. CBOR"},{"location":"RPI-II/P6/","text":"Pr\u00e1ctica 6. El protocolo MQTT","title":"Pr\u00e1ctica 6"},{"location":"RPI-II/P6/#practica-6-el-protocolo-mqtt","text":"","title":"Pr\u00e1ctica 6. El protocolo MQTT"},{"location":"RPI-II/P7/","text":"Pr\u00e1ctica 7. El protocolo CoAP","title":"Pr\u00e1ctica 7"},{"location":"RPI-II/P7/#practica-7-el-protocolo-coap","text":"","title":"Pr\u00e1ctica 7. El protocolo CoAP"},{"location":"RPI-II/P8/","text":"Pr\u00e1ctica 8. El protocolo LWM2M","title":"Pr\u00e1ctica 8"},{"location":"RPI-II/P8/#practica-8-el-protocolo-lwm2m","text":"","title":"Pr\u00e1ctica 8. El protocolo LWM2M"},{"location":"RPI-II/P9/","text":"Pr\u00e1ctica 9. Node-RED","title":"Pr\u00e1ctica 9"},{"location":"RPI-II/P9/#practica-9-node-red","text":"","title":"Pr\u00e1ctica 9. Node-RED"}]}