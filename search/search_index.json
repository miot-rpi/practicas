{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Calendario RPI-I Pr\u00e1ctica D\u00eda T\u00edtulo 09/09 Clase de Teor\u00eda 1 16/09 Introducci\u00f3n al entorno de desarrollo 2 23/09 WiFi en el ESP32 3 30/09 WiFi. Provisionamiento y ahorro de energ\u00eda 4 07/10 ESP WiFi Mesh 5 14/10 BLE: servidor GATT 6 21/10 BLE: cliente GATT 7 28/10 BLE Mesh 8 04/11 802.15.4 y Thread 9 11/11 6LowPAN y RPL 10 18/11 LoRa y LoRaWan 25/11 Charla UnaBiz/Sigfox 02/12 Proyecto 09/12 Proyecto RPI-II Pr\u00e1ctica D\u00eda T\u00edtulo - 09/09 Clase de teor\u00eda (intro) 1 16/09 TCP/UDP (Host) 1 23/09 TCP/UDP (ESP32) . Ap\u00e9ndice I. Introducci\u00f3n a Node-RED Ap\u00e9ndice II. Programaci\u00f3n de sockets en Python 2 30/10 TLS/DTLS 3 07/10 REST y representaci\u00f3n de la informaci\u00f3n 4 14/10 Websockets 5 21/10 MQTT (I) 5 28/10 MQTT (II) 6 04/11 Introducci\u00f3n a Thingsboard 7 11/11 CoAP 8 18/11 LWM2M (I) 9 25/11 LWM2M (II) 02/12 Proyecto 09/12 Proyecto ANIOT Pr\u00e1ctica D\u00eda T\u00edtulo 10/09 Presentaci\u00f3n del curso 1 17/09 Introducci\u00f3n al entorno. GPIO 1 24/09 Depuraci\u00f3n, loggging y monitorizaci\u00f3n de rendimiento 2 01/10 Entorno de compilaci\u00f3n. Timers 3 08/10 Tarea y eventos 3 15/10 Tarea y eventos (sesi\u00f3n 2) 4 22/10 Continuaci\u00f3n P3 4 29/10 I2C 5 05/11 ADC 6 12/11 Modos de consumo 7 19/11 OTA . Parte adicional (OTA en Thingsboard) 8 26/11 Arranque seguro y encriptaci\u00f3n 03/12 Proyecto 10/12 Proyecto LSI Lab. D\u00eda T\u00edtulo 0 11/03 Entorno experimental Raspberry Pi 1 18/03 Introducci\u00f3n a TFLite sobre la Raspberry Pi 2 25/03 TensorFlow Lite en ESP32-S3-EYE","title":"Calendario"},{"location":"#calendario","text":"","title":"Calendario"},{"location":"#rpi-i","text":"Pr\u00e1ctica D\u00eda T\u00edtulo 09/09 Clase de Teor\u00eda 1 16/09 Introducci\u00f3n al entorno de desarrollo 2 23/09 WiFi en el ESP32 3 30/09 WiFi. Provisionamiento y ahorro de energ\u00eda 4 07/10 ESP WiFi Mesh 5 14/10 BLE: servidor GATT 6 21/10 BLE: cliente GATT 7 28/10 BLE Mesh 8 04/11 802.15.4 y Thread 9 11/11 6LowPAN y RPL 10 18/11 LoRa y LoRaWan 25/11 Charla UnaBiz/Sigfox 02/12 Proyecto 09/12 Proyecto","title":"RPI-I"},{"location":"#rpi-ii","text":"Pr\u00e1ctica D\u00eda T\u00edtulo - 09/09 Clase de teor\u00eda (intro) 1 16/09 TCP/UDP (Host) 1 23/09 TCP/UDP (ESP32) . Ap\u00e9ndice I. Introducci\u00f3n a Node-RED Ap\u00e9ndice II. Programaci\u00f3n de sockets en Python 2 30/10 TLS/DTLS 3 07/10 REST y representaci\u00f3n de la informaci\u00f3n 4 14/10 Websockets 5 21/10 MQTT (I) 5 28/10 MQTT (II) 6 04/11 Introducci\u00f3n a Thingsboard 7 11/11 CoAP 8 18/11 LWM2M (I) 9 25/11 LWM2M (II) 02/12 Proyecto 09/12 Proyecto","title":"RPI-II"},{"location":"#aniot","text":"Pr\u00e1ctica D\u00eda T\u00edtulo 10/09 Presentaci\u00f3n del curso 1 17/09 Introducci\u00f3n al entorno. GPIO 1 24/09 Depuraci\u00f3n, loggging y monitorizaci\u00f3n de rendimiento 2 01/10 Entorno de compilaci\u00f3n. Timers 3 08/10 Tarea y eventos 3 15/10 Tarea y eventos (sesi\u00f3n 2) 4 22/10 Continuaci\u00f3n P3 4 29/10 I2C 5 05/11 ADC 6 12/11 Modos de consumo 7 19/11 OTA . Parte adicional (OTA en Thingsboard) 8 26/11 Arranque seguro y encriptaci\u00f3n 03/12 Proyecto 10/12 Proyecto","title":"ANIOT"},{"location":"#lsi","text":"Lab. D\u00eda T\u00edtulo 0 11/03 Entorno experimental Raspberry Pi 1 18/03 Introducci\u00f3n a TFLite sobre la Raspberry Pi 2 25/03 TensorFlow Lite en ESP32-S3-EYE","title":"LSI"},{"location":"uc/","text":"Under Construction","title":"Under Construction"},{"location":"uc/#under-construction","text":"","title":"Under Construction"},{"location":"ANIOT/P1/","text":"Pr\u00e1ctica 1. Introducci\u00f3n al entorno Objetivos El objetivo de esta pr\u00e1ctica es la introducci\u00f3n al entorno de desarrollo proporcionado por Espressif para sus SoC de la familia ESP32, utilizando la extensi\u00f3n de ESP-IDF existente en VSCode. Aprovecharemos para ver varios aspectos del entorno ESP-IDF: Configuraci\u00f3n del proyecto mediante menuconfig Inclusi\u00f3n de par\u00e1metros de configuraci\u00f3n mediante Kconfig Presentaci\u00f3n del mapa de memoria y uso del heap Material de consulta Para ver los detalles de cada aspecto de esta pr\u00e1ctica se recomienda la lectura de los siguientes enlaces: Gu\u00eda b\u00e1sica ESP-IDF . Si queremos usar directamente las herramientas de Espressif, conviene conocer el flujo de trabajo b\u00e1sico en l\u00ednea de comandos. Extensi\u00f3n ESP-IDF para VSCode . Documentaci\u00f3n de la extensi\u00f3n de ESP-IDF para VSCode. API de ESP-IDF Kbuild . Definici\u00f3n del lenguaje KConfig Esquem\u00e1ticos placa DevKitC-v4 Extensi\u00f3n ESP-IDF para VSCode ESP-IDF es el entorno de desarrollo oficial de Espressif para las series de SoC ESP32, ESP32-S y ESP32- C. Est\u00e1 basado en FreeRTOS , uno de los sistemas operativos de tiempo real para microcontroladores m\u00e1s utilizado en la actualidad. En su get-started-guide queda descrito el proceso de instalaci\u00f3n de las herramientas nativas en l\u00ednea de comando. En nuestro caso, utilizaremos la extensi\u00f3n oficial de Espressif de VSCode. La primera parte de esta sesi\u00f3n consistir\u00e1 en la instalaci\u00f3n de dicha extensi\u00f3n y su configuraci\u00f3n para volcar un ejemplo en nuestra placa ESP32. La documentaci\u00f3n proporcionada por Espressif se encuentra en su repositorio de GitHub . A partir de ah\u00ed, es posible encontrar enlaces a diferentes tutoriales que explican con detalle el proceso de instalaci\u00f3n, configuraci\u00f3n, desarrollo... En primer lugar, sigue los pasos indicados en su gu\u00eda de instalaci\u00f3n para instalar de la extensi\u00f3n en VSCode. Realiza este paso antes de venir al laboratorio , pues la instalaci\u00f3n tardar\u00e1 varios minutos. Pod\u00e9is saltar el paso 6 (OPCIONAL) y basta con elegir la opci\u00f3n EXPRESS A continuaci\u00f3n, sigue los pasos del ejemplo b\u00e1sico para volcar en la placa el c\u00f3digo del ejemplo Blink . Recuerda esocger esp32-ESP32 Chip (Via USB-Bridge) como Device Target . Por ahora, salta los pasos 5 y 6 (configuraci\u00f3n) y procede directamente a la compilaci\u00f3n y descarga en la placa. El nombre asociado al puerto serie al que se conecta la placa depender\u00e1 del sistema operativo usado. En Linux ser\u00e1 algo similar /dev/ttyUSB0 . IMPORTANTE : usando la placa ESP32-Devkit-c (del malet\u00edn), debes usar UART como m\u00e9todo de programar el dispositivo (y no JTAG como aparece por defecto). Cuestiones \u00bfQu\u00e9 versi\u00f3n es la actualmente estable de ESP-IDF? \u00bfCu\u00e1l es la salida est\u00e1ndar por defecto de nuestro proyecto? \u00bfEn qu\u00e9 unidades debemos expresar el argumento de vTaskDelay() ? Investiga la macro pdTICKS_TO_MS. \u00bfC\u00f3mo se reescribir\u00eda esa l\u00ednea usando dicha macro? Configuraci\u00f3n de un proyecto ESP-IDF, en su porting de FreeRTOS, ofrece un mecanismo de configuraci\u00f3n del proyecto, que permite especificar qu\u00e9 servicios de ESP-IDF necesitaremos usar y establecer par\u00e1metros de dichos servicios. Asimismo, permite definir nuestros propios par\u00e1metros de configuraci\u00f3n mediante el lenguaje [KConfig]https://github.com/torvalds/linux/blob/master/Documentation/kbuild/kconfig-language.rst). Para realizar dicha configuraci\u00f3n, debemos ejecutar el comando menuconfig de la paleta de comandos proporcionadas por la extensi\u00f3n de ESP-IDF (paso 5 del tutorial usado en el paso anterior). En la nueva ventanda podremos activar/desactivar m\u00f3dulos del sistema operativo y configurar valores de dichos m\u00f3dulos. Como se puede ver en la siguiente figura, el proyecto Blink incorpora algunas opciones propias: BLINK LED Type , Blink GPIO number y Blink period . Para que dichas opciones figuren en el men\u00fa de edici\u00f3n de configuraciones, se debe editar un fichero de texto Kconfig.projbuild presente en la carpeta principal ('main') del proyecto. Concretamente, el contenido del proyecto inicial es el siguiente: menu \"Example Configuration\" choice BLINK_LED prompt \"Blink LED type\" default BLINK_LED_GPIO if IDF_TARGET_ESP32 default BLINK_LED_RMT help Defines the default peripheral for blink example config BLINK_LED_GPIO bool \"GPIO\" config BLINK_LED_RMT bool \"RMT - Addressable LED\" endchoice config BLINK_LED_RMT_CHANNEL depends on BLINK_LED_RMT int \"RMT Channel\" range 0 7 default 0 help Set the RMT peripheral channel. ESP32 RMT channel from 0 to 7 ESP32-S2 RMT channel from 0 to 3 ESP32-S3 RMT channel from 0 to 3 ESP32-C3 RMT channel from 0 to 1 config BLINK_GPIO int \"Blink GPIO number\" range 0 48 default 8 if IDF_TARGET_ESP32C3 || IDF_TARGET_ESP32H2 default 18 if IDF_TARGET_ESP32S2 default 48 if IDF_TARGET_ESP32S3 default 5 help GPIO number (IOxx) to blink on and off or the RMT signal for the addressable LED. Some GPIOs are used for other purposes (flash connections, etc.) and cannot be used to blink. config BLINK_PERIOD int \"Blink period in ms\" range 10 3600000 default 1000 help Define the blinking period in milliseconds. endmenu El lenguaje KConfig es casi autoexplicativo, y resulta sencillo ver la correspondencia entre este contenido y el men\u00fa que se muestra en la figura anterior. Al construir el proyecto, se procesar\u00e1 el fichero Kconfig.projbuild que dar\u00e1 lugar a una versi\u00f3n del fichero sdkconfig con los valores escogidos para cada opci\u00f3n. # # Example Configuration # CONFIG_BLINK_LED_GPIO=y # CONFIG_BLINK_LED_RMT is not set CONFIG_BLINK_GPIO=5 CONFIG_BLINK_PERIOD=1000 # end of Example Configuration Como se puede observar, el fichero sdkconfig recoge una serie de macros a las que podremos referirnos en nuestro c\u00f3digo para actuar en funci\u00f3n de sus valores. En el c\u00f3digo de blink podemos encontrar ejemplos de ese uso: #define BLINK_GPIO CONFIG_BLINK_GPIO #ifdef CONFIG_BLINK_LED_RMT static led_strip_t *pStrip_a; static void blink_led(void) ... #elif CONFIG_BLINK_LED_GPIO static void blink_led(void) ... #endif void app_main(void) { /* Configure the peripheral according to the LED type */ configure_led(); while (1) { ESP_LOGI(TAG, \"Turning the LED %s!\", s_led_state == true ? \"ON\" : \"OFF\"); blink_led(); /* Toggle the LED state */ s_led_state = !s_led_state; vTaskDelay(CONFIG_BLINK_PERIOD / portTICK_PERIOD_MS); } } Cuestiones \u00bfPor qu\u00e9 no parpadea el LED de la placa? \u00bfD\u00f3nde est\u00e1 conectado ese LED? (compru\u00e9balo en los esquem\u00e1ticos placa DevKitC-v4 ) Cambia la frecuencia de parpadeo usando menuconfig . Compila de nuevo y comprueba que el cambio ha surtido efecto Conecta la placa con el ESP32 a un LED del entrenador del laboratorio. \u00bfPuedes usar cualquier pin de la placa?","title":"Pr\u00e1ctica 1"},{"location":"ANIOT/P1/#practica-1-introduccion-al-entorno","text":"","title":"Pr\u00e1ctica 1. Introducci\u00f3n al entorno"},{"location":"ANIOT/P1/#objetivos","text":"El objetivo de esta pr\u00e1ctica es la introducci\u00f3n al entorno de desarrollo proporcionado por Espressif para sus SoC de la familia ESP32, utilizando la extensi\u00f3n de ESP-IDF existente en VSCode. Aprovecharemos para ver varios aspectos del entorno ESP-IDF: Configuraci\u00f3n del proyecto mediante menuconfig Inclusi\u00f3n de par\u00e1metros de configuraci\u00f3n mediante Kconfig Presentaci\u00f3n del mapa de memoria y uso del heap","title":"Objetivos"},{"location":"ANIOT/P1/#material-de-consulta","text":"Para ver los detalles de cada aspecto de esta pr\u00e1ctica se recomienda la lectura de los siguientes enlaces: Gu\u00eda b\u00e1sica ESP-IDF . Si queremos usar directamente las herramientas de Espressif, conviene conocer el flujo de trabajo b\u00e1sico en l\u00ednea de comandos. Extensi\u00f3n ESP-IDF para VSCode . Documentaci\u00f3n de la extensi\u00f3n de ESP-IDF para VSCode. API de ESP-IDF Kbuild . Definici\u00f3n del lenguaje KConfig Esquem\u00e1ticos placa DevKitC-v4","title":"Material de consulta"},{"location":"ANIOT/P1/#extension-esp-idf-para-vscode","text":"ESP-IDF es el entorno de desarrollo oficial de Espressif para las series de SoC ESP32, ESP32-S y ESP32- C. Est\u00e1 basado en FreeRTOS , uno de los sistemas operativos de tiempo real para microcontroladores m\u00e1s utilizado en la actualidad. En su get-started-guide queda descrito el proceso de instalaci\u00f3n de las herramientas nativas en l\u00ednea de comando. En nuestro caso, utilizaremos la extensi\u00f3n oficial de Espressif de VSCode. La primera parte de esta sesi\u00f3n consistir\u00e1 en la instalaci\u00f3n de dicha extensi\u00f3n y su configuraci\u00f3n para volcar un ejemplo en nuestra placa ESP32. La documentaci\u00f3n proporcionada por Espressif se encuentra en su repositorio de GitHub . A partir de ah\u00ed, es posible encontrar enlaces a diferentes tutoriales que explican con detalle el proceso de instalaci\u00f3n, configuraci\u00f3n, desarrollo... En primer lugar, sigue los pasos indicados en su gu\u00eda de instalaci\u00f3n para instalar de la extensi\u00f3n en VSCode. Realiza este paso antes de venir al laboratorio , pues la instalaci\u00f3n tardar\u00e1 varios minutos. Pod\u00e9is saltar el paso 6 (OPCIONAL) y basta con elegir la opci\u00f3n EXPRESS A continuaci\u00f3n, sigue los pasos del ejemplo b\u00e1sico para volcar en la placa el c\u00f3digo del ejemplo Blink . Recuerda esocger esp32-ESP32 Chip (Via USB-Bridge) como Device Target . Por ahora, salta los pasos 5 y 6 (configuraci\u00f3n) y procede directamente a la compilaci\u00f3n y descarga en la placa. El nombre asociado al puerto serie al que se conecta la placa depender\u00e1 del sistema operativo usado. En Linux ser\u00e1 algo similar /dev/ttyUSB0 . IMPORTANTE : usando la placa ESP32-Devkit-c (del malet\u00edn), debes usar UART como m\u00e9todo de programar el dispositivo (y no JTAG como aparece por defecto). Cuestiones \u00bfQu\u00e9 versi\u00f3n es la actualmente estable de ESP-IDF? \u00bfCu\u00e1l es la salida est\u00e1ndar por defecto de nuestro proyecto? \u00bfEn qu\u00e9 unidades debemos expresar el argumento de vTaskDelay() ? Investiga la macro pdTICKS_TO_MS. \u00bfC\u00f3mo se reescribir\u00eda esa l\u00ednea usando dicha macro?","title":"Extensi\u00f3n ESP-IDF para VSCode"},{"location":"ANIOT/P1/#configuracion-de-un-proyecto","text":"ESP-IDF, en su porting de FreeRTOS, ofrece un mecanismo de configuraci\u00f3n del proyecto, que permite especificar qu\u00e9 servicios de ESP-IDF necesitaremos usar y establecer par\u00e1metros de dichos servicios. Asimismo, permite definir nuestros propios par\u00e1metros de configuraci\u00f3n mediante el lenguaje [KConfig]https://github.com/torvalds/linux/blob/master/Documentation/kbuild/kconfig-language.rst). Para realizar dicha configuraci\u00f3n, debemos ejecutar el comando menuconfig de la paleta de comandos proporcionadas por la extensi\u00f3n de ESP-IDF (paso 5 del tutorial usado en el paso anterior). En la nueva ventanda podremos activar/desactivar m\u00f3dulos del sistema operativo y configurar valores de dichos m\u00f3dulos. Como se puede ver en la siguiente figura, el proyecto Blink incorpora algunas opciones propias: BLINK LED Type , Blink GPIO number y Blink period . Para que dichas opciones figuren en el men\u00fa de edici\u00f3n de configuraciones, se debe editar un fichero de texto Kconfig.projbuild presente en la carpeta principal ('main') del proyecto. Concretamente, el contenido del proyecto inicial es el siguiente: menu \"Example Configuration\" choice BLINK_LED prompt \"Blink LED type\" default BLINK_LED_GPIO if IDF_TARGET_ESP32 default BLINK_LED_RMT help Defines the default peripheral for blink example config BLINK_LED_GPIO bool \"GPIO\" config BLINK_LED_RMT bool \"RMT - Addressable LED\" endchoice config BLINK_LED_RMT_CHANNEL depends on BLINK_LED_RMT int \"RMT Channel\" range 0 7 default 0 help Set the RMT peripheral channel. ESP32 RMT channel from 0 to 7 ESP32-S2 RMT channel from 0 to 3 ESP32-S3 RMT channel from 0 to 3 ESP32-C3 RMT channel from 0 to 1 config BLINK_GPIO int \"Blink GPIO number\" range 0 48 default 8 if IDF_TARGET_ESP32C3 || IDF_TARGET_ESP32H2 default 18 if IDF_TARGET_ESP32S2 default 48 if IDF_TARGET_ESP32S3 default 5 help GPIO number (IOxx) to blink on and off or the RMT signal for the addressable LED. Some GPIOs are used for other purposes (flash connections, etc.) and cannot be used to blink. config BLINK_PERIOD int \"Blink period in ms\" range 10 3600000 default 1000 help Define the blinking period in milliseconds. endmenu El lenguaje KConfig es casi autoexplicativo, y resulta sencillo ver la correspondencia entre este contenido y el men\u00fa que se muestra en la figura anterior. Al construir el proyecto, se procesar\u00e1 el fichero Kconfig.projbuild que dar\u00e1 lugar a una versi\u00f3n del fichero sdkconfig con los valores escogidos para cada opci\u00f3n. # # Example Configuration # CONFIG_BLINK_LED_GPIO=y # CONFIG_BLINK_LED_RMT is not set CONFIG_BLINK_GPIO=5 CONFIG_BLINK_PERIOD=1000 # end of Example Configuration Como se puede observar, el fichero sdkconfig recoge una serie de macros a las que podremos referirnos en nuestro c\u00f3digo para actuar en funci\u00f3n de sus valores. En el c\u00f3digo de blink podemos encontrar ejemplos de ese uso: #define BLINK_GPIO CONFIG_BLINK_GPIO #ifdef CONFIG_BLINK_LED_RMT static led_strip_t *pStrip_a; static void blink_led(void) ... #elif CONFIG_BLINK_LED_GPIO static void blink_led(void) ... #endif void app_main(void) { /* Configure the peripheral according to the LED type */ configure_led(); while (1) { ESP_LOGI(TAG, \"Turning the LED %s!\", s_led_state == true ? \"ON\" : \"OFF\"); blink_led(); /* Toggle the LED state */ s_led_state = !s_led_state; vTaskDelay(CONFIG_BLINK_PERIOD / portTICK_PERIOD_MS); } } Cuestiones \u00bfPor qu\u00e9 no parpadea el LED de la placa? \u00bfD\u00f3nde est\u00e1 conectado ese LED? (compru\u00e9balo en los esquem\u00e1ticos placa DevKitC-v4 ) Cambia la frecuencia de parpadeo usando menuconfig . Compila de nuevo y comprueba que el cambio ha surtido efecto Conecta la placa con el ESP32 a un LED del entrenador del laboratorio. \u00bfPuedes usar cualquier pin de la placa?","title":"Configuraci\u00f3n de un proyecto"},{"location":"ANIOT/P1b/","text":"Pr\u00e1ctica 1 (segunda parte). Flujos de trabajo. Compilaci\u00f3n en la nube y herramientas de depuraci\u00f3n, perfilado y logging Objetivos Aprender a utilizar Github Actions para compilar un proyecto ESP-IDF de forma remota. Introducir los conceptos b\u00e1sicos de depuraci\u00f3n a nivel de gesti\u00f3n de memoria (heap). Aprender la API b\u00e1sica de monitorizaci\u00f3n de rendimiento en ESP-IDF. Material de consulta Para ver los detalles de cada aspecto de esta pr\u00e1ctica se recomienda la lectura de los siguientes enlaces: Git and github essentials Git cheatsheet Github Actions Heap memory allocation Performance monitoring Github Actions GitHub Actions es una plataforma de integraci\u00f3n y despliegue continuos (CI/CD) que permite automatizar el flujo de compilaci\u00f3n, pruebas y despliegue. GitHub Actions permite ejecutar flujos de trabajo cuando suceden determinados eventos en un repositorio. Por ejemplo, es posible ejecutar un flujo de trabajo para que agregue autom\u00e1ticamente las etiquetas adecuadas cada que alguien cree una propuesta nueva en un repositorio, o compilar un c\u00f3digo cuando se realiza un push sobre el mismo. GitHub proporciona m\u00e1quinas virtuales Linux, Windows y macOS para ejecutar flujos de trabajo, o es posible hospedar ejecutores propios hospedados en una m\u00e1quina propia o en una infraestructura en la nube. Componentes en Github Actions Es posible configurar un flujo de trabajo de GitHub Actions que se desencadene cuando se produzca un evento en el repositorio, por ejemplo, la apertura de una solicitud de incorporaci\u00f3n de cambios o la creaci\u00f3n de una incidencia. El flujo de trabajo contiene uno o varios trabajos que se pueden ejecutar en orden secuencial o en paralelo. Cada trabajo se ejecutar\u00e1 dentro de su propio ejecutor de m\u00e1quina virtual o dentro de un contenedor, y tendr\u00e1 uno o varios pasos que pueden ejecutar un script que defina, o bien una acci\u00f3n, que es una extensi\u00f3n reutilizable que puede simplificar el flujo de trabajo. Flujos de trabajo Un flujo de trabajo es un proceso automatizado configurable que ejecutar\u00e1 uno o m\u00e1s trabajos. Los flujos de trabajo se definen mediante un archivo de YAML que se verifica en tu repositorio y se ejecutar\u00e1 cuando lo active un evento dentro de este o puede activarse manualmente o en una programaci\u00f3n definida. Los flujos de trabajo se definen en el directorio .github/workflows de un repositorio. Un repositorio puede tener varios flujos de trabajo, y cada uno puede realizar un conjunto diferente de tareas, como las siguientes: Compilar y probar de solicitudes de incorporaci\u00f3n de cambios. Implementar la aplicaci\u00f3n cada vez que se crea una versi\u00f3n. Agregar una etiqueta cada vez que se abre una incidencia nueva. Un flujo de trabajo debe contener los siguientes componentes b\u00e1sicos: Uno o varios eventos que desencadenar\u00e1n el flujo de trabajo. Uno o varios trabajos, cada uno de los cuales se ejecutar\u00e1 en una m\u00e1quina del ejecutor y ejecutar\u00e1 uno o varios pasos. Cada paso puede ejecutar un script que definas, o bien una acci\u00f3n, que es una extensi\u00f3n reutilizable que puede simplificar el flujo de trabajo. Los activadores de los flujos de trabajo son eventos que ocasionan que se ejecute un flujo de trabajo. Estos eventos pueden ser: Eventos que ocurren en el repositorio de tu flujo de trabajo Eventos que se producen fuera de GitHub y desencadenan un evento repository_dispatch en GitHub Tiempos programados Manual Por ejemplo, puedes configurar tu flujo de trabajo para que se ejecute cuando se realiza una subida a la rama predeterminada de tu repositorio, cuando se crea un lanzamiento o cuando se abre una propuesta. Los flujos de trabajo se definen mediante YAML. Para obtener la referencia completa de la sintaxis de YAML para crear flujos de trabajo, consulta \"Sintaxis del flujo de trabajo para Acciones de GitHub\" . Un ejemplo: creaci\u00f3n de un flujo de trabajo para compilaci\u00f3n de un proyecto ESP-IDF Imagina que dispones de un fork de ESP-IDF en forma de un repositorio propio asociado a tu usuario. El siguiente fragmento de c\u00f3digo compilar\u00e1 un firmware que incluir\u00e1 el ejemplo hello_world proporcionado por la distribuci\u00f3n est\u00e1ndar de ESP_IDF: name: \"Espressif IoT Development Framework (ESP-IDF) on push\" on: push: branches: master inputs: path: description: \"Relative path under $GITHUB_WORKSPACE to place the repository\" default: \"examples/get-started/hello_world\" required: false esp_idf_version: description: \"Version of ESP-IDF docker image to use\" default: \"latest\" required: false target: description: \"ESP32 variant to build for\" default: \"esp32c3\" required: false command: description: \"Command to run inside the docker container (default: builds the project)\" default: \"idf.py build\" required: false jobs: build: runs-on: ubuntu-latest steps: - name: Checkout repo uses: actions/checkout@v2 with: submodules: 'recursive' - name: esp-idf build uses: espressif/esp-idf-ci-action@v1 with: esp_idf_version: v5.3 target: esp32c3 path: 'examples/get-started/hello_world' - name: Download built firmware uses: actions/upload-artifact@v4 with: name: hello_world.bin path: | examples/get-started/hello_world/build/hello_world.bin Observa sus partes principales: Nombre : nombre del flujo de trabajo. Eventos sobre los que se activar\u00e1 . En este caso, lo har\u00e1 ante la acci\u00f3n de push sobre la rama master del repositorio.Adem\u00e1s, el flujo de trabajo recibe ciertos argumentos obligatorios como entradas, requeridos por la acci\u00f3n espec\u00edfica de construcci\u00f3n (esp-idf-ci-action) proporcionada por Espressif. Estas entradas incluyen la ruta al ejemplo dentro del repositorio, la versi\u00f3n de ESP-IDF a utilizar, la variante de ESP32 a usar y el comando espec\u00edfico que se ejecutar\u00e1. Todos estos inputs son configurables. Tareas/trabajos a ejecutar . En esta secci\u00f3n, incluimos una tarea de construcci\u00f3n, a ejecutar sobre una distribuci\u00f3n Ubuntu, compuesta por una serie de pasos consecutivos. Estos pasos incluyen el checkout de nuestro repositorio en la m\u00e1quina destino, la construcci\u00f3n (usando una acci\u00f3n espec\u00edfica proporcionada por ESP-IDF), y por \u00faltimo la publicaci\u00f3n de un artifact (resultado de la compilaci\u00f3n) como resultado de la ejecuci\u00f3n del flujo de trabajo. Alternativamente, es posible controlar de forma manual la ejecuci\u00f3n de la acci\u00f3n. Simplemente, utiliza un workflow como el siguiente (podr\u00e1s a continuaci\u00f3n lanzar el proceso de compilaci\u00f3n desde la propia pesta\u00f1a de Github Actions en el repositorio): name: \"Espressif IoT Development Framework (ESP-IDF)\" on: workflow_dispatch: inputs: path: description: \"Relative path under $GITHUB_WORKSPACE to place the repository\" default: \"\" required: false esp_idf_version: description: \"Version of ESP-IDF docker image to use\" default: \"latest\" required: false target: description: \"ESP32 variant to build for\" default: \"esp32\" required: false command: description: \"Command to run inside the docker container (default: builds the project)\" default: \"idf.py build\" required: false jobs: build: runs-on: ubuntu-latest steps: - name: Checkout repo uses: actions/checkout@v2 with: submodules: 'recursive' - name: esp-idf build uses: espressif/esp-idf-ci-action@v1 with: esp_idf_version: v5.3 target: esp32c3 path: 'examples/get-started/hello_world' - name: Download built firmware uses: actions/upload-artifact@v4 with: name: hello_world.bin path: | examples/get-started/hello_world/build/hello_world.bin Tarea Si no tienes un usuario Github, cr\u00e9alo. Realiza una operaci\u00f3n de fork sobre el repositorio ESP-IDF de Espressif sobre tu usuario. Cl\u00f3nalo en tu m\u00e1quina (puedes usar l\u00ednea de comandos o bien la herramienta Github Desktop). Crea el fichero .github/workflows/idf_build.yml con el contenido anterior. Sube los cambios al repositorio ( git commit + git push ) y observa, en la pesta\u00f1a Actions de tu repositorio, que efectivamente se ha construido con \u00e9xito el artifact resultado de la compilaci\u00f3n. Adapta el trabajo para otro ejemplo (elige t\u00fa mismo/a el ejemplo) y consigue una imagen compilada para cualquiera de tus placas. \u00bfSer\u00edas capaz de descargarla y flashearla manualmente en la placa (necesitar\u00e1s determinar qu\u00e9 comandos son necesarios para un proceso de flasheo manual observando la salida de VSCode para dicho proceso)? Proporciona al profesor un enlace al repositorio creado para que pueda revisar la correcta compilaci\u00f3n del proyecto. Depuraci\u00f3n de memoria din\u00e1mica Aunque ya conoces la funcionalidad de depuraci\u00f3n integrada en VS Code, en ocasiones hay situaciones que son dif\u00edcilmente detectables por un depurador. Uno de estos ejemplos es la depuraci\u00f3n de memoria din\u00e1mica (alojada en el heap ). ESP-IDF integra herramientas para solicitar informaci\u00f3n sobre el heap, para detectar corrupci\u00f3n en el heap y para tracear el estado del heap peri\u00f3dicamente. Obtenci\u00f3n de informaci\u00f3n sobre el heap To obtain information about the state of the heap, call the following functions: heap_caps_get_free_size() se puede utilizar para devolver la memoria libre actual para diferentes tipos de memoria. heap_caps_get_largest_free_block() se puede usar para devolver el bloque libre m\u00e1s grande del heap, que tambi\u00e9n es la asignaci\u00f3n individual m\u00e1s grande posible actualmente. El seguimiento de este valor y su comparaci\u00f3n con el heap libre total permite detectar la fragmentaci\u00f3n del mont\u00f3n. heap_caps_get_minimum_free_size() puede usarse para obtener el m\u00ednimo tama\u00f1o libre en el heap desde el arranque. heap_caps_get_info() retorna una estructura multi_heap_info_t , que contiene informaci\u00f3n sobre las funciones de m\u00e1s arriba, as\u00ed como datos espec\u00edficos sobre el heap (n\u00famero de reservas, por ejemplo). heap_caps_print_heap_info() imprime por salida est\u00e1ndar la informaci\u00f3n recogida por la anterior funci\u00f3n. heap_caps_dump() y heap_caps_dump_all() muestran informaci\u00f3n detallada sobre la estructura de cada bloque en el heap. La salida puede ser grande. Tarea Compila y estudia el ejemplo system/heap_task_tracking de ESP-IDF. Observa el uso de las anteriores funciones. Moficia el c\u00f3digo para que la cantidad de memoria reservada en cada iteraci\u00f3n de la tarea sea constante. Prueba a eliminar la invocaci\u00f3n a free cada cierto n\u00famero de iteraciones, para observar c\u00f3mo va agot\u00e1ndose el espacio libre en el heap . Intenta observar la fragmentaci\u00f3n en el heap volviendo a hacer reservas de tama\u00f1o aleatorias, y liberaciones s\u00f3lo cada cierto n\u00famero de iteraciones. Hooks para la reserva y liberaci\u00f3n de memoria en el heap Los hooks para la asignaci\u00f3n y liberaci\u00f3n de memoria en el heap permiten recibir notificaciones cada vez que se realiza una reserva o una liberaci\u00f3n sobre el mismo: Si se proporciona una definici\u00f3n de la funci\u00f3n esp_heap_trace_alloc_hook() , se notificar\u00e1 cada vez que se realice con \u00e9xito una reserva de memoria. Si se proporciona una definici\u00f3n de la funci\u00f3n esp_heap_trace_free_hook() , se notificar\u00e1 cada vez que se realice con \u00e9xito una liberaci\u00f3n de memoria. Por ejemplo: #include \"esp_heap_caps.h\" void esp_heap_trace_alloc_hook(void* ptr, size_t size, uint32_t caps) { ... } void esp_heap_trace_free_hook(void* ptr) { ... } void app_main() { ... } Esta caracter\u00edstica se activa fijando la opci\u00f3n de configuraci\u00f3n CONFIG_HEAP_USE_HOOKS . Tarea Modifica el anterior ejemplo para que se invoque a tus hooks de informaci\u00f3n en cada reserva y liberaci\u00f3n de memoria, y que se aporte en el mensaje que se mostrar\u00e1 por pantalla informaci\u00f3n sobre la misma. Monitorizaci\u00f3n de rendimiento ESP-IDF proporciona un componente dedicado exclusivamente a la monitorizaci\u00f3n del rendimiento de las aplicaciones. Este componente proporciona una API para utilizar los contadores hardware de rendimiento disponibles en los ESP32. Este tipo de componentes permiten perfilar y evaluar el rendimiento de partes concretas del c\u00f3digo, de modo que dan soporte a la optimizaci\u00f3n del mismo sobre una arquitectura concreta. En primer lugar, compila y estudia el ejemplo proporcionado por ESP-IDF para monitorizaci\u00f3n de rendimiento . Este ejemplo no es funcional sobre arquitecturas RISC-V, por lo que deber\u00e1s utilizar la placa DevkitC que tienes en tu malet\u00edn . Una vez compilado y flasheado, ejecuta el binario y estudia el c\u00f3digo proporcionado. B\u00e1sicamente, el c\u00f3digo de ejemplo calcula estad\u00edsticas de redimiento para una funci\u00f3n de test determinada. Esta funci\u00f3n ( exec_test_function ) simplemente introduce instrucciones NOP ( no operation ) durante 100 iteraciones. Esta funci\u00f3n, que puede ser reemplazada por cualquier otra, se invocar\u00e1 consecutivamente 200 veces con dos configuraciones distintas: recolectando todos los posibles contadores hardware, y a continuaci\u00f3n seleccionando un subconjunto a partir de una lista proporcionada por el programador. Tarea Estudia el c\u00f3digo asociado a la tarea, as\u00ed como la salida proporcionada en cada caso. Observa c\u00f3mo se utiliza la API para seleccionar qu\u00e9 contadores hardware se desean reportar. Ap\u00f3yate en la descripci\u00f3n de la API proporcionada en la documentaci\u00f3n oficial para ayudarte en la tarea. Por \u00faltimo, modifica la funci\u00f3n de ejemplo para implementar alg\u00fan tipo de funcionalidad avanzada (por ejemplo, que incluya operaciones aritm\u00e9ticas), y observa los cambios en la salida. Experimenta con distintas opciones de compilador para optimizac\u00f3n (a trav\u00e9s de menuconfig), para ver si puedes obtener cambios significativos en los valores reportados (adicionalmente, puedes observar el impacto de estos flags en el tama\u00f1o del ejecutable).","title":"Pr\u00e1ctica 1 (segunda parte). Flujos de trabajo. Compilaci\u00f3n en la nube y herramientas de depuraci\u00f3n, perfilado y logging"},{"location":"ANIOT/P1b/#practica-1-segunda-parte-flujos-de-trabajo-compilacion-en-la-nube-y-herramientas-de-depuracion-perfilado-y-logging","text":"","title":"Pr\u00e1ctica 1 (segunda parte). Flujos de trabajo. Compilaci\u00f3n en la nube y herramientas de depuraci\u00f3n, perfilado y logging"},{"location":"ANIOT/P1b/#objetivos","text":"Aprender a utilizar Github Actions para compilar un proyecto ESP-IDF de forma remota. Introducir los conceptos b\u00e1sicos de depuraci\u00f3n a nivel de gesti\u00f3n de memoria (heap). Aprender la API b\u00e1sica de monitorizaci\u00f3n de rendimiento en ESP-IDF.","title":"Objetivos"},{"location":"ANIOT/P1b/#material-de-consulta","text":"Para ver los detalles de cada aspecto de esta pr\u00e1ctica se recomienda la lectura de los siguientes enlaces: Git and github essentials Git cheatsheet Github Actions Heap memory allocation Performance monitoring","title":"Material de consulta"},{"location":"ANIOT/P1b/#github-actions","text":"GitHub Actions es una plataforma de integraci\u00f3n y despliegue continuos (CI/CD) que permite automatizar el flujo de compilaci\u00f3n, pruebas y despliegue. GitHub Actions permite ejecutar flujos de trabajo cuando suceden determinados eventos en un repositorio. Por ejemplo, es posible ejecutar un flujo de trabajo para que agregue autom\u00e1ticamente las etiquetas adecuadas cada que alguien cree una propuesta nueva en un repositorio, o compilar un c\u00f3digo cuando se realiza un push sobre el mismo. GitHub proporciona m\u00e1quinas virtuales Linux, Windows y macOS para ejecutar flujos de trabajo, o es posible hospedar ejecutores propios hospedados en una m\u00e1quina propia o en una infraestructura en la nube.","title":"Github Actions"},{"location":"ANIOT/P1b/#componentes-en-github-actions","text":"Es posible configurar un flujo de trabajo de GitHub Actions que se desencadene cuando se produzca un evento en el repositorio, por ejemplo, la apertura de una solicitud de incorporaci\u00f3n de cambios o la creaci\u00f3n de una incidencia. El flujo de trabajo contiene uno o varios trabajos que se pueden ejecutar en orden secuencial o en paralelo. Cada trabajo se ejecutar\u00e1 dentro de su propio ejecutor de m\u00e1quina virtual o dentro de un contenedor, y tendr\u00e1 uno o varios pasos que pueden ejecutar un script que defina, o bien una acci\u00f3n, que es una extensi\u00f3n reutilizable que puede simplificar el flujo de trabajo.","title":"Componentes en Github Actions"},{"location":"ANIOT/P1b/#flujos-de-trabajo","text":"Un flujo de trabajo es un proceso automatizado configurable que ejecutar\u00e1 uno o m\u00e1s trabajos. Los flujos de trabajo se definen mediante un archivo de YAML que se verifica en tu repositorio y se ejecutar\u00e1 cuando lo active un evento dentro de este o puede activarse manualmente o en una programaci\u00f3n definida. Los flujos de trabajo se definen en el directorio .github/workflows de un repositorio. Un repositorio puede tener varios flujos de trabajo, y cada uno puede realizar un conjunto diferente de tareas, como las siguientes: Compilar y probar de solicitudes de incorporaci\u00f3n de cambios. Implementar la aplicaci\u00f3n cada vez que se crea una versi\u00f3n. Agregar una etiqueta cada vez que se abre una incidencia nueva. Un flujo de trabajo debe contener los siguientes componentes b\u00e1sicos: Uno o varios eventos que desencadenar\u00e1n el flujo de trabajo. Uno o varios trabajos, cada uno de los cuales se ejecutar\u00e1 en una m\u00e1quina del ejecutor y ejecutar\u00e1 uno o varios pasos. Cada paso puede ejecutar un script que definas, o bien una acci\u00f3n, que es una extensi\u00f3n reutilizable que puede simplificar el flujo de trabajo. Los activadores de los flujos de trabajo son eventos que ocasionan que se ejecute un flujo de trabajo. Estos eventos pueden ser: Eventos que ocurren en el repositorio de tu flujo de trabajo Eventos que se producen fuera de GitHub y desencadenan un evento repository_dispatch en GitHub Tiempos programados Manual Por ejemplo, puedes configurar tu flujo de trabajo para que se ejecute cuando se realiza una subida a la rama predeterminada de tu repositorio, cuando se crea un lanzamiento o cuando se abre una propuesta. Los flujos de trabajo se definen mediante YAML. Para obtener la referencia completa de la sintaxis de YAML para crear flujos de trabajo, consulta \"Sintaxis del flujo de trabajo para Acciones de GitHub\" .","title":"Flujos de trabajo"},{"location":"ANIOT/P1b/#un-ejemplo-creacion-de-un-flujo-de-trabajo-para-compilacion-de-un-proyecto-esp-idf","text":"Imagina que dispones de un fork de ESP-IDF en forma de un repositorio propio asociado a tu usuario. El siguiente fragmento de c\u00f3digo compilar\u00e1 un firmware que incluir\u00e1 el ejemplo hello_world proporcionado por la distribuci\u00f3n est\u00e1ndar de ESP_IDF: name: \"Espressif IoT Development Framework (ESP-IDF) on push\" on: push: branches: master inputs: path: description: \"Relative path under $GITHUB_WORKSPACE to place the repository\" default: \"examples/get-started/hello_world\" required: false esp_idf_version: description: \"Version of ESP-IDF docker image to use\" default: \"latest\" required: false target: description: \"ESP32 variant to build for\" default: \"esp32c3\" required: false command: description: \"Command to run inside the docker container (default: builds the project)\" default: \"idf.py build\" required: false jobs: build: runs-on: ubuntu-latest steps: - name: Checkout repo uses: actions/checkout@v2 with: submodules: 'recursive' - name: esp-idf build uses: espressif/esp-idf-ci-action@v1 with: esp_idf_version: v5.3 target: esp32c3 path: 'examples/get-started/hello_world' - name: Download built firmware uses: actions/upload-artifact@v4 with: name: hello_world.bin path: | examples/get-started/hello_world/build/hello_world.bin Observa sus partes principales: Nombre : nombre del flujo de trabajo. Eventos sobre los que se activar\u00e1 . En este caso, lo har\u00e1 ante la acci\u00f3n de push sobre la rama master del repositorio.Adem\u00e1s, el flujo de trabajo recibe ciertos argumentos obligatorios como entradas, requeridos por la acci\u00f3n espec\u00edfica de construcci\u00f3n (esp-idf-ci-action) proporcionada por Espressif. Estas entradas incluyen la ruta al ejemplo dentro del repositorio, la versi\u00f3n de ESP-IDF a utilizar, la variante de ESP32 a usar y el comando espec\u00edfico que se ejecutar\u00e1. Todos estos inputs son configurables. Tareas/trabajos a ejecutar . En esta secci\u00f3n, incluimos una tarea de construcci\u00f3n, a ejecutar sobre una distribuci\u00f3n Ubuntu, compuesta por una serie de pasos consecutivos. Estos pasos incluyen el checkout de nuestro repositorio en la m\u00e1quina destino, la construcci\u00f3n (usando una acci\u00f3n espec\u00edfica proporcionada por ESP-IDF), y por \u00faltimo la publicaci\u00f3n de un artifact (resultado de la compilaci\u00f3n) como resultado de la ejecuci\u00f3n del flujo de trabajo. Alternativamente, es posible controlar de forma manual la ejecuci\u00f3n de la acci\u00f3n. Simplemente, utiliza un workflow como el siguiente (podr\u00e1s a continuaci\u00f3n lanzar el proceso de compilaci\u00f3n desde la propia pesta\u00f1a de Github Actions en el repositorio): name: \"Espressif IoT Development Framework (ESP-IDF)\" on: workflow_dispatch: inputs: path: description: \"Relative path under $GITHUB_WORKSPACE to place the repository\" default: \"\" required: false esp_idf_version: description: \"Version of ESP-IDF docker image to use\" default: \"latest\" required: false target: description: \"ESP32 variant to build for\" default: \"esp32\" required: false command: description: \"Command to run inside the docker container (default: builds the project)\" default: \"idf.py build\" required: false jobs: build: runs-on: ubuntu-latest steps: - name: Checkout repo uses: actions/checkout@v2 with: submodules: 'recursive' - name: esp-idf build uses: espressif/esp-idf-ci-action@v1 with: esp_idf_version: v5.3 target: esp32c3 path: 'examples/get-started/hello_world' - name: Download built firmware uses: actions/upload-artifact@v4 with: name: hello_world.bin path: | examples/get-started/hello_world/build/hello_world.bin Tarea Si no tienes un usuario Github, cr\u00e9alo. Realiza una operaci\u00f3n de fork sobre el repositorio ESP-IDF de Espressif sobre tu usuario. Cl\u00f3nalo en tu m\u00e1quina (puedes usar l\u00ednea de comandos o bien la herramienta Github Desktop). Crea el fichero .github/workflows/idf_build.yml con el contenido anterior. Sube los cambios al repositorio ( git commit + git push ) y observa, en la pesta\u00f1a Actions de tu repositorio, que efectivamente se ha construido con \u00e9xito el artifact resultado de la compilaci\u00f3n. Adapta el trabajo para otro ejemplo (elige t\u00fa mismo/a el ejemplo) y consigue una imagen compilada para cualquiera de tus placas. \u00bfSer\u00edas capaz de descargarla y flashearla manualmente en la placa (necesitar\u00e1s determinar qu\u00e9 comandos son necesarios para un proceso de flasheo manual observando la salida de VSCode para dicho proceso)? Proporciona al profesor un enlace al repositorio creado para que pueda revisar la correcta compilaci\u00f3n del proyecto.","title":"Un ejemplo: creaci\u00f3n de un flujo de trabajo para compilaci\u00f3n de un proyecto ESP-IDF"},{"location":"ANIOT/P1b/#depuracion-de-memoria-dinamica","text":"Aunque ya conoces la funcionalidad de depuraci\u00f3n integrada en VS Code, en ocasiones hay situaciones que son dif\u00edcilmente detectables por un depurador. Uno de estos ejemplos es la depuraci\u00f3n de memoria din\u00e1mica (alojada en el heap ). ESP-IDF integra herramientas para solicitar informaci\u00f3n sobre el heap, para detectar corrupci\u00f3n en el heap y para tracear el estado del heap peri\u00f3dicamente.","title":"Depuraci\u00f3n de memoria din\u00e1mica"},{"location":"ANIOT/P1b/#obtencion-de-informacion-sobre-el-heap","text":"To obtain information about the state of the heap, call the following functions: heap_caps_get_free_size() se puede utilizar para devolver la memoria libre actual para diferentes tipos de memoria. heap_caps_get_largest_free_block() se puede usar para devolver el bloque libre m\u00e1s grande del heap, que tambi\u00e9n es la asignaci\u00f3n individual m\u00e1s grande posible actualmente. El seguimiento de este valor y su comparaci\u00f3n con el heap libre total permite detectar la fragmentaci\u00f3n del mont\u00f3n. heap_caps_get_minimum_free_size() puede usarse para obtener el m\u00ednimo tama\u00f1o libre en el heap desde el arranque. heap_caps_get_info() retorna una estructura multi_heap_info_t , que contiene informaci\u00f3n sobre las funciones de m\u00e1s arriba, as\u00ed como datos espec\u00edficos sobre el heap (n\u00famero de reservas, por ejemplo). heap_caps_print_heap_info() imprime por salida est\u00e1ndar la informaci\u00f3n recogida por la anterior funci\u00f3n. heap_caps_dump() y heap_caps_dump_all() muestran informaci\u00f3n detallada sobre la estructura de cada bloque en el heap. La salida puede ser grande. Tarea Compila y estudia el ejemplo system/heap_task_tracking de ESP-IDF. Observa el uso de las anteriores funciones. Moficia el c\u00f3digo para que la cantidad de memoria reservada en cada iteraci\u00f3n de la tarea sea constante. Prueba a eliminar la invocaci\u00f3n a free cada cierto n\u00famero de iteraciones, para observar c\u00f3mo va agot\u00e1ndose el espacio libre en el heap . Intenta observar la fragmentaci\u00f3n en el heap volviendo a hacer reservas de tama\u00f1o aleatorias, y liberaciones s\u00f3lo cada cierto n\u00famero de iteraciones.","title":"Obtenci\u00f3n de informaci\u00f3n sobre el heap"},{"location":"ANIOT/P1b/#hooks-para-la-reserva-y-liberacion-de-memoria-en-el-heap","text":"Los hooks para la asignaci\u00f3n y liberaci\u00f3n de memoria en el heap permiten recibir notificaciones cada vez que se realiza una reserva o una liberaci\u00f3n sobre el mismo: Si se proporciona una definici\u00f3n de la funci\u00f3n esp_heap_trace_alloc_hook() , se notificar\u00e1 cada vez que se realice con \u00e9xito una reserva de memoria. Si se proporciona una definici\u00f3n de la funci\u00f3n esp_heap_trace_free_hook() , se notificar\u00e1 cada vez que se realice con \u00e9xito una liberaci\u00f3n de memoria. Por ejemplo: #include \"esp_heap_caps.h\" void esp_heap_trace_alloc_hook(void* ptr, size_t size, uint32_t caps) { ... } void esp_heap_trace_free_hook(void* ptr) { ... } void app_main() { ... } Esta caracter\u00edstica se activa fijando la opci\u00f3n de configuraci\u00f3n CONFIG_HEAP_USE_HOOKS . Tarea Modifica el anterior ejemplo para que se invoque a tus hooks de informaci\u00f3n en cada reserva y liberaci\u00f3n de memoria, y que se aporte en el mensaje que se mostrar\u00e1 por pantalla informaci\u00f3n sobre la misma.","title":"Hooks para la reserva y liberaci\u00f3n de memoria en el heap"},{"location":"ANIOT/P1b/#monitorizacion-de-rendimiento","text":"ESP-IDF proporciona un componente dedicado exclusivamente a la monitorizaci\u00f3n del rendimiento de las aplicaciones. Este componente proporciona una API para utilizar los contadores hardware de rendimiento disponibles en los ESP32. Este tipo de componentes permiten perfilar y evaluar el rendimiento de partes concretas del c\u00f3digo, de modo que dan soporte a la optimizaci\u00f3n del mismo sobre una arquitectura concreta. En primer lugar, compila y estudia el ejemplo proporcionado por ESP-IDF para monitorizaci\u00f3n de rendimiento . Este ejemplo no es funcional sobre arquitecturas RISC-V, por lo que deber\u00e1s utilizar la placa DevkitC que tienes en tu malet\u00edn . Una vez compilado y flasheado, ejecuta el binario y estudia el c\u00f3digo proporcionado. B\u00e1sicamente, el c\u00f3digo de ejemplo calcula estad\u00edsticas de redimiento para una funci\u00f3n de test determinada. Esta funci\u00f3n ( exec_test_function ) simplemente introduce instrucciones NOP ( no operation ) durante 100 iteraciones. Esta funci\u00f3n, que puede ser reemplazada por cualquier otra, se invocar\u00e1 consecutivamente 200 veces con dos configuraciones distintas: recolectando todos los posibles contadores hardware, y a continuaci\u00f3n seleccionando un subconjunto a partir de una lista proporcionada por el programador. Tarea Estudia el c\u00f3digo asociado a la tarea, as\u00ed como la salida proporcionada en cada caso. Observa c\u00f3mo se utiliza la API para seleccionar qu\u00e9 contadores hardware se desean reportar. Ap\u00f3yate en la descripci\u00f3n de la API proporcionada en la documentaci\u00f3n oficial para ayudarte en la tarea. Por \u00faltimo, modifica la funci\u00f3n de ejemplo para implementar alg\u00fan tipo de funcionalidad avanzada (por ejemplo, que incluya operaciones aritm\u00e9ticas), y observa los cambios en la salida. Experimenta con distintas opciones de compilador para optimizac\u00f3n (a trav\u00e9s de menuconfig), para ver si puedes obtener cambios significativos en los valores reportados (adicionalmente, puedes observar el impacto de estos flags en el tama\u00f1o del ejecutable).","title":"Monitorizaci\u00f3n de rendimiento"},{"location":"ANIOT/P2/","text":"Pr\u00e1ctica 2. Entorno de compilaci\u00f3n. Uso de timers Objetivos El objetivo de esta pr\u00e1ctica es familiarizarse con la estructura de componentes en que se basa la compilaci\u00f3n de proyectos en ESP-IDF. As\u00edmismo, aprovecharemos para utlizar timers . Trabajaremos los siguientes aspectos: Creaci\u00f3n de componentes en nuestro proyecto. Incorporar componentes externos. Uso del componente console para tener un entorno interactivo. Familiarizarse con la API de High Resolution Timers en ESP/IDF. Material de consulta Para ver los detalles de cada aspecto de esta pr\u00e1ctica se recomienda la lectura de los siguientes enlaces: Documentaci\u00f3n sobre el sistema de compilaci\u00f3n Documentaci\u00f3n del componente console Documentaci\u00f3n sobre la librer\u00eda Argtable Documentaci\u00f3n sobre CMake API de High Resolution Timers API sobre GPIO en ESP-IDF Proyectos ESP-IDF Tal y como hemos visto en clase, un proyecto ESP-IDF est\u00e1 formada de componentes . un componente es la unidad en la que se organiza el c\u00f3digo en un proyecto ESP-IDF. Cada componente se compila formando una librer\u00eda est\u00e1tica, que posteriormente se enlazar\u00e1 junto al resto de componentes y al kernel de ESP-IDF para crear la aplicaci\u00f3n. El c\u00f3digo que incluyamos en la carpeta main no es m\u00e1s que otro componente, con peque\u00f1os matices que lo diferencian de otros. Los elementos principales en ESP-IDF son: Proyecto . Un directorio que contiene todos los ficheros y configuraci\u00f3n para construir un \u201capp\u201d (ejecutable). Incluye elementos como tabla de partici\u00f3n, sistemas de ficheros y bootloader Configuraci\u00f3n de proyecto . Se mantiene en el fichero sdkconfig en el directorio ra\u00edz del proyecto. Se modifica a trav\u00e9s de menuconfig. Cada proyecto tiene un \u00fanico fichero de configuraci\u00f3n. app . Es un ejecutable resultado de la compilaci\u00f3n/enlazado. De un proyecto se suelen crear 2 apps Project app: el ejectuable principal con nuestro c\u00f3digo Bootloader app: el programa inicial que se encarga de cargar nuestro c\u00f3digo Componentes . Partes modulares del c\u00f3digo que se compilan como librear\u00edas est\u00e1ticas (ficheros .a) y se enlazan en la app. Algunos componentes los proporciona ESP-IDF, pero pueden ser externos https://components.espressif.com/ (a\u00fan no p\u00fablico) Target . Es el hardware para el que construimos la aplicaci\u00f3n. Podemos comprobar los targets disponibles para una versi\u00f3n de ESP-IDF con el comando idf.py -list-targets La compilaci\u00f3n se basa en la herramienta CMake , por lo que tendremos un fichero CMakeLists.txt para cada componente, y uno general para el proyecto. As\u00ed, la estructura general de un proyecto podr\u00eda ser similar a: El contenido m\u00ednimo del fichero CMakeLists.txt del proyecto (el que se encuentra en la carpeta myProject en el ejemplo anterior) es: cmake_minimum_required(VERSION 3.5) include($ENV{IDF_PATH}/tools/cmake/project.cmake) project(si7021) Componentes Un componente es cualquier directorio en COMPONENT_DIRS que contenga un fichero CMakeLists.txt . Puede ser un directorio sin CMakeLists.txt pero con subdirectorios, cada uno de ellos con su CMakeLists.txt . Se crear\u00e1 una librer\u00eda est\u00e1tica para cada componente, cuyo nombre ser\u00e1, por defecto, el nombre del directorio. Cada componente puede, asimismo, tener su propio fichero Kconfig . El fichero CMakeLists.txt debe indicar las fuentes que se enlazar\u00e1n en la librer\u00eda y la ubicaci\u00f3n de los ficheros de cabecera p\u00fablicos del componente. Asimismo, puede indicar dependencias con otros componentes (si las hubiera) idf_component_register(SRCS \"foo.c\" \"bar.c\" INCLUDE_DIRS \"include\" REQUIRES driver ) La variable COMPONENT_DIRS indica los directorios en los que ESP-IDF buscar\u00e1 componentes. Crear\u00e1 bibliotecas para todos aquellos componentes que encuentre. Por defecto buscar\u00e1 en: IDF_PATH/components PROJECT_DIR/components EXTRA_COMPONENT_DIRS Es posible reescribir la variable COMPONENT_DIRS para incluir alg\u00fan directorio o, especialmente, para limitar la b\u00fasquda de directorios. La variable EXTRA_COMPONENT_DIRS nos permite incluir directorios adicionales en la b\u00fasqueda de componentes. Las rutas pueden ser absolutas o relativas al directorio del proyecto. Se indica en el top-level CMakeLists.txt , antes del include . La variable COMPONENTS permita hacer expl\u00edcita la lista de componentes que queremos incluir en el proyecto. Como dec\u00edamos anteriormente, por defecto ser\u00e1n todos aquellos que se encuentren en COMPONENT_DIRS . Su uso permite reducir el tama\u00f1o del binario final, lo que puede resultar conveniente en muchos proyectos. Aplicaci\u00f3n Consola (opcional) En muchos entornos resulta muy conveniente tener una aplicaci\u00f3n de tipo consola : un int\u00e9rprete de comandos que nos permita interaccionar de forma b\u00e1sica con el sistema. Muchos sistemas empotrados tienen la opci\u00f3n de arrancar en modo consola, para tareas de mantenimiento y depuraci\u00f3n. En funcionamiento normal la consola no se ejecutar\u00e1 o se saldr\u00e1 de dicho modo transcurrido un tiempo de inactividad, arranc\u00e1ndose entonces la aplicaci\u00f3n real. ESP-IDF incluye un componente llamado Console que nos da un servicio m\u00ednimo tipo REPL (Read-Evaluate-Print-Loop) El componente incluye toda la funcionalidad necesaria para el procesamiento/eidci\u00f3n de l\u00ednea, bas\u00e1ndose en la librer\u00eda lineoise . De ese modo, sabe interpretar la acci\u00f3n de borrado, movimiento por cursores, auto completa, indica el formato de cada comando... Asimismo, tiene funciones para que sea sencillo registrar nuevos comandos escritos por nosotros mismos. Vamos a partir del ejemplo de consola b\u00e1sico . Estudia el c\u00f3digo, y responde a las siguientes preguntas: Cuesti\u00f3n \u00bfQu\u00e9 componente se est\u00e1 incluyendo adem\u00e1s de los que siempre se incluyen por defecto? \u00bfQu\u00e9 funcionalidad se importa de dicho componente? \u00bfQu\u00e9 particiones se crean al volcar el proyecto en nuestro dispositivo? Importar c\u00f3digo externo como componente Espressif tiene una base de datos de componentes que permite incorporar componentes open-source en nuestros proyectos ESP-IDF de forma sencilla. Podemos incluir un componente del registro mediante el comando idf.py add-dependency <componentName> o descargando el fichero de la web de componentes y copi\u00e1ndolo en nuestro proyecto. Bastar\u00e1 con copiar la carpeta descargada dentro de la carpeta components de nuestro proyecto. En ocasiones, encontraremos c\u00f3digos no incluidos en el registro oficial de Espressif pero que pueden resultar \u00fatiles para nuestros desarollos. Nuevamente, resulta aconsejable importar esos proyectos externos como componentes en nuestros proyectos. Y as\u00ed lo haremos en la siguiente tarea: Tarea La placa de desarrollo ESP32-C3-DevKit-RUST-1 tiene dos sensores de temperatura. Uno est\u00e1 integrado en el propio ESP32-C3 (puedes econtrar su API en la documentaci\u00f3n de ESP-IDF ). El segundo est\u00e1 en la placa, tal y como se indica en su documentaci\u00f3n . Se trata de un sensor SHTC3 de Sensirion que est\u00e1 conectado al SoC mediante el bus I2C. A partir del c\u00f3digo disponible en este repositorio de Github https://github.com/mauriciobarroso/shtc3 crea un componente llamado shtc3 para poder utilizar el sensor sin necesidad de consultar el datasheet . Los ficheros del repositorio ya est\u00e1n preparados para usarse como un componente en ESP-IDF v5.3 S\u00f3lo debes ubicarlos en la carpeta correcta. En el fichero principal de tu aplicaci\u00f3n, deber\u00e1s inicializar el driver del bus I2C y el propio sensor. Puedes usar el c\u00f3digo que se proporciona a continuaci\u00f3n. shtc3_t tempSensor; i2c_master_bus_handle_t bus_handle; void init_i2c(void) { uint16_t id; i2c_master_bus_config_t i2c_bus_config = { .clk_source = I2C_CLK_SRC_DEFAULT, .i2c_port = I2C_NUM_0, .scl_io_num = 8, .sda_io_num = 10, .glitch_ignore_cnt = 7, .flags.enable_internal_pullup = true, }; ESP_ERROR_CHECK(i2c_new_master_bus(&i2c_bus_config, &bus_handle)); shtc3_init(&tempSensor, bus_handle, 0x70); } Tarea En relaci\u00f3n al c\u00f3digo anterior: \u00bfPor qu\u00e9 scl_io_num es 8? \u00bfPor qu\u00e9 sda_io_num es 10? \u00bfSe pueden cambiar? \u00bfPor qu\u00e9 la llamada a shtc3_init() reciba 0x70 como tercer argumento? Controladores GPIO Los controladores de GPIO ( General Purpose Input-Ouput ) permiten controlar ciertos pines de nuestro dispositivo para usarlos como entrada (por ejemplo, para conectar un bot\u00f3n) o salida (por ejemplo para conectar un LED) o con funciones especiales (que forme parte de un bus serie, por ejemplo). Placa ESP32-DevKitC v4 El SoC ESP32 que usamos proporciona 40 GPIO pads (el SoC no tiene pines propiamente dichos, sino conectores, normalmente de superf\u00edcie, que se deminan pad ). El m\u00f3dulo WROOM-32 que usamos expone 38 de ellos, que son accesibles a traves de los pines (los conectores f\u00edsicos a ambos lados de la placa) que incorpora nuestra placa DevKitC. En la siguiente figura se muestra la disposici\u00f3n de los pines en la placa ESP32-DevKitC que usamos en nuestras pr\u00e1cticas: En la web de Espressif se pueden encontrar m\u00e1s detalles de la placa. Como se indica en la documentaci\u00f3n de ESP-IDF , algunos de esos pines tiene un prop\u00f3sito espec\u00edfico. Por ejemplo, GPIO6-11 y 16-17 no deben usarse porque est\u00e1n internamente conectados a la memoria SPI flash. Tambi\u00e9n nos indica que los pines del canal 2 del ADC (ADC2) NO deben usarse mientras se utiliza Wi-Fi. Es muy conveniente leer todas las restricciones para evitar problemas en nuestros desarrollos. Placa Rust Board ESP32-C3 En la siguiente figura se muestra la disposici\u00f3n de los pines en la placa ESP32-Rust board que usamos en nuestras pr\u00e1cticas: En la web de la placa se pueden encontrar m\u00e1s detalles sobre los componenentes, esquem\u00e1ticos, BOM... Entre otra documentaci\u00f3n pod\u00e9is encontrar el esquem\u00e1tico de la placa, que permite conocer a qu\u00e9 pines del SoC se conectan los diferentes elementos (LEDs, botones) de la placa: API de ESP-IDF La documentaci\u00f3n muestra tambi\u00e9n la API que ofrece ESP-IDF para configurar los pines (entrada o salida, uso de pull-up/pull-down) establecer un valor l\u00f3gico (0 \u00f3 1)en un pin (previamente configurado como salida) o leer el valor l\u00f3gico de un pin (configurado como entrada). El siguiente c\u00f3digo, extra\u00eddo del ejemplo de GPIO proporcionado en la distribuci\u00f3n ESP-IDF , muestra c\u00f3mo configurar los pines GPIO18 y GPIO19 como salida. Observa c\u00f3mo se construye la m\u00e1scara de bits GPIO_OUTPUT_PIN_SEL para indicar a gpio_config() qu\u00e9 pines se configuran. #define GPIO_OUTPUT_IO_0 18 #define GPIO_OUTPUT_IO_1 19 #define GPIO_OUTPUT_PIN_SEL ((1ULL<<GPIO_OUTPUT_IO_0) | (1ULL<<GPIO_OUTPUT_IO_1)) gpio_config_t io_conf; io_conf.intr_type = GPIO_PIN_INTR_DISABLE; io_conf.mode = GPIO_MODE_OUTPUT; io_conf.pin_bit_mask = GPIO_OUTPUT_PIN_SEL; io_conf.pull_down_en = 0; io_conf.pull_up_en = 0; gpio_config(&io_conf); Posteriormente, podemos establecer el valor l\u00f3gico de la salida con una llamada similar a gpio_set_level(GPIO_OUTPUT_IO_1, valor); , siendo valor igual a 0 \u00f3 1. De forma similar el siguiente c\u00f3digo configura los pines 4 y 5 como entrada: #define GPIO_INPUT_IO_0 4 #define GPIO_INPUT_IO_1 5 #define GPIO_INPUT_PIN_SEL ((1ULL<<GPIO_INPUT_IO_0) | (1ULL<<GPIO_INPUT_IO_1)) gpio_config_t io_conf; io_conf.pin_bit_mask = GPIO_INPUT_PIN_SEL; io_conf.mode = GPIO_MODE_INPUT; gpio_config(&io_conf); Posteriormente, podremos leer el valor l\u00f3gico de esos pines con una llamada a gpio_get_level() . Busca informaci\u00f3n En relaci\u00f3n al c\u00f3digo anterior: en la configuraci\u00f3n anterior, los pines de entrada deben muestrearse peri\u00f3dicamente para conocer su estado. Investiga c\u00f3mo configurar los pines como entrada de modo que generen una interrupci\u00f3n cuando se produce un flanco (subida, bajado o ambos). ESP-IDF: High Resolution Timer Un Timer es un temporizador que podemos programar para que nos avise transcurrido un cierto tiempo. Es similar a una cuenta atr\u00e1s con alarma y es un mecanismo perfecto para planificar tareas peri\u00f3dicas. El aviso ser\u00e1 as\u00edncrono, por lo que no sabemos en qu\u00e9 punto de nuestro c\u00f3digo estaremos cuando se dispare la alarma. ESP-IDF ofrece un API para el uso de timers que, a su vez, utlizan los timers de 64 bits disponibles en el hardware para garantizar una precisi\u00f3n de hasta 50us. Cuando programamos un timer podemos optar por 2 comportamientos: One-shot ( esp_timer_start_once() ), que programr\u00e1 el timer para que genere una \u00fanica alarma transcurrido el plazo establecido. Continuo ( esp_timer_start_periodic() ) que re-programar\u00e1 el timer de forma autom\u00e1tica cada vez que la cuenta llegue a 0. Este mecanismo es el id\u00f3neo para muestreos peri\u00f3dicos. Cuando el timer genere la alarma, se ejecutar\u00e1 un callback , una funci\u00f3n que habremos definido previamente (y asociado a ese timer ). Dicha funci\u00f3n se ejecutar\u00e1 en el contexto de una tarea espec\u00edfica ( ESP_TIMER_TASK ) o en el de una rutina de tratamiento de interrupci\u00f3n ( ESP_TIMER_ISR ). En nuestro caso, es aconsejable usar el primer mecanismo (tarea espec\u00edfica). En la documentaci\u00f3n de ESP-IDF pod\u00e9is encontrar el resto de llamadas relevantes para crear y configurar timers . Es muy recomendable, asimismo, estudiar los ejemplos disponibles en la distribuci\u00f3n A continuaci\u00f3n se incluye un ejemplo de uso, extra\u00edado de la distribuci\u00f3n de ESP-IDF: void app_main() { ... const esp_timer_create_args_t periodic_timer_args = { .callback = &periodic_timer_callback, .name = \"periodic\" }; esp_timer_handle_t periodic_timer; esp_timer_create(&periodic_timer_args, &periodic_timer); ... esp_timer_start_periodic(periodic_timer, 500000); .... esp_timer_stop(periodic_timer); ... esp_timer_delete(periodic_timer); } static void periodic_timer_callback(void* arg) { int64_t time_since_boot = esp_timer_get_time(); printf(\"Periodic timer called, time since boot: %lld us\",time_since_boot); } Encendido de LEDs con GPIO y timer La placa de desarrollo ESP32-C3-DevKit-RUST-1 tiene dos LEDs, uno de ellos conectado Tarea Configura el GPIO asociado al LED (GPIO 7) como salida. Programa un timer para cambiar el estado del LED cada segundo. Ejercicio final Completa este ejercicio despu\u00e9s de haber resuelto los anteriores. De cara la entrega de la pr\u00e1ctica, s\u00f3lo es necesario entregar este ejercicio Tareas Partiendo del ejemplo Blink (usando el denominado LED_STRIP en GPIO 2, no como la usamos el primer d\u00eda), crea una applicaci\u00f3n que: Incluya el componente shtc3 en tu proyecto. Muestree la temperatura cada segundo utilizando un timer . Muestre el progreso de la temperatura en el LED programable de la placa. Si la temperatura es inferior a 20 grados, estar\u00e1 apagado. Por cada grado que suba la temperatura, se modificar\u00e1 el color/intensidad del LED. Para variar el color/intensidad, s\u00f3lo debes cambiar los 3 \u00faltimos argumentos de la llamada led_strip_set_pixel() del c\u00f3digo de ejemplo. Se programar\u00e1 un segundo timer que mostrar\u00e1 por pantalla (puerto serie) la \u00faltima medida de temperatura realizada cada 10 segundos. [Opcional] Configura el GPIO 9, al que est\u00e1 conectado el bot\u00f3n BOOT, para que genere interrupciones cuando soltemos el bot\u00f3n. \u00bfQu\u00e9 valor l\u00f3gico se lee del GPIO 9 con el bot\u00f3n pulsado?. Consulta la documentaci\u00f3n de GPIO y el ejemplo de GPIO gen\u00e9rico para entender c\u00f3mo configurar un GPIO como entrada por interrupciones.","title":"Pr\u00e1ctica 2"},{"location":"ANIOT/P2/#practica-2-entorno-de-compilacion-uso-de-timers","text":"","title":"Pr\u00e1ctica 2. Entorno de compilaci\u00f3n. Uso de timers"},{"location":"ANIOT/P2/#objetivos","text":"El objetivo de esta pr\u00e1ctica es familiarizarse con la estructura de componentes en que se basa la compilaci\u00f3n de proyectos en ESP-IDF. As\u00edmismo, aprovecharemos para utlizar timers . Trabajaremos los siguientes aspectos: Creaci\u00f3n de componentes en nuestro proyecto. Incorporar componentes externos. Uso del componente console para tener un entorno interactivo. Familiarizarse con la API de High Resolution Timers en ESP/IDF.","title":"Objetivos"},{"location":"ANIOT/P2/#material-de-consulta","text":"Para ver los detalles de cada aspecto de esta pr\u00e1ctica se recomienda la lectura de los siguientes enlaces: Documentaci\u00f3n sobre el sistema de compilaci\u00f3n Documentaci\u00f3n del componente console Documentaci\u00f3n sobre la librer\u00eda Argtable Documentaci\u00f3n sobre CMake API de High Resolution Timers API sobre GPIO en ESP-IDF","title":"Material de consulta"},{"location":"ANIOT/P2/#proyectos-esp-idf","text":"Tal y como hemos visto en clase, un proyecto ESP-IDF est\u00e1 formada de componentes . un componente es la unidad en la que se organiza el c\u00f3digo en un proyecto ESP-IDF. Cada componente se compila formando una librer\u00eda est\u00e1tica, que posteriormente se enlazar\u00e1 junto al resto de componentes y al kernel de ESP-IDF para crear la aplicaci\u00f3n. El c\u00f3digo que incluyamos en la carpeta main no es m\u00e1s que otro componente, con peque\u00f1os matices que lo diferencian de otros. Los elementos principales en ESP-IDF son: Proyecto . Un directorio que contiene todos los ficheros y configuraci\u00f3n para construir un \u201capp\u201d (ejecutable). Incluye elementos como tabla de partici\u00f3n, sistemas de ficheros y bootloader Configuraci\u00f3n de proyecto . Se mantiene en el fichero sdkconfig en el directorio ra\u00edz del proyecto. Se modifica a trav\u00e9s de menuconfig. Cada proyecto tiene un \u00fanico fichero de configuraci\u00f3n. app . Es un ejecutable resultado de la compilaci\u00f3n/enlazado. De un proyecto se suelen crear 2 apps Project app: el ejectuable principal con nuestro c\u00f3digo Bootloader app: el programa inicial que se encarga de cargar nuestro c\u00f3digo Componentes . Partes modulares del c\u00f3digo que se compilan como librear\u00edas est\u00e1ticas (ficheros .a) y se enlazan en la app. Algunos componentes los proporciona ESP-IDF, pero pueden ser externos https://components.espressif.com/ (a\u00fan no p\u00fablico) Target . Es el hardware para el que construimos la aplicaci\u00f3n. Podemos comprobar los targets disponibles para una versi\u00f3n de ESP-IDF con el comando idf.py -list-targets La compilaci\u00f3n se basa en la herramienta CMake , por lo que tendremos un fichero CMakeLists.txt para cada componente, y uno general para el proyecto. As\u00ed, la estructura general de un proyecto podr\u00eda ser similar a: El contenido m\u00ednimo del fichero CMakeLists.txt del proyecto (el que se encuentra en la carpeta myProject en el ejemplo anterior) es: cmake_minimum_required(VERSION 3.5) include($ENV{IDF_PATH}/tools/cmake/project.cmake) project(si7021)","title":"Proyectos ESP-IDF"},{"location":"ANIOT/P2/#componentes","text":"Un componente es cualquier directorio en COMPONENT_DIRS que contenga un fichero CMakeLists.txt . Puede ser un directorio sin CMakeLists.txt pero con subdirectorios, cada uno de ellos con su CMakeLists.txt . Se crear\u00e1 una librer\u00eda est\u00e1tica para cada componente, cuyo nombre ser\u00e1, por defecto, el nombre del directorio. Cada componente puede, asimismo, tener su propio fichero Kconfig . El fichero CMakeLists.txt debe indicar las fuentes que se enlazar\u00e1n en la librer\u00eda y la ubicaci\u00f3n de los ficheros de cabecera p\u00fablicos del componente. Asimismo, puede indicar dependencias con otros componentes (si las hubiera) idf_component_register(SRCS \"foo.c\" \"bar.c\" INCLUDE_DIRS \"include\" REQUIRES driver ) La variable COMPONENT_DIRS indica los directorios en los que ESP-IDF buscar\u00e1 componentes. Crear\u00e1 bibliotecas para todos aquellos componentes que encuentre. Por defecto buscar\u00e1 en: IDF_PATH/components PROJECT_DIR/components EXTRA_COMPONENT_DIRS Es posible reescribir la variable COMPONENT_DIRS para incluir alg\u00fan directorio o, especialmente, para limitar la b\u00fasquda de directorios. La variable EXTRA_COMPONENT_DIRS nos permite incluir directorios adicionales en la b\u00fasqueda de componentes. Las rutas pueden ser absolutas o relativas al directorio del proyecto. Se indica en el top-level CMakeLists.txt , antes del include . La variable COMPONENTS permita hacer expl\u00edcita la lista de componentes que queremos incluir en el proyecto. Como dec\u00edamos anteriormente, por defecto ser\u00e1n todos aquellos que se encuentren en COMPONENT_DIRS . Su uso permite reducir el tama\u00f1o del binario final, lo que puede resultar conveniente en muchos proyectos.","title":"Componentes"},{"location":"ANIOT/P2/#aplicacion-consola-opcional","text":"En muchos entornos resulta muy conveniente tener una aplicaci\u00f3n de tipo consola : un int\u00e9rprete de comandos que nos permita interaccionar de forma b\u00e1sica con el sistema. Muchos sistemas empotrados tienen la opci\u00f3n de arrancar en modo consola, para tareas de mantenimiento y depuraci\u00f3n. En funcionamiento normal la consola no se ejecutar\u00e1 o se saldr\u00e1 de dicho modo transcurrido un tiempo de inactividad, arranc\u00e1ndose entonces la aplicaci\u00f3n real. ESP-IDF incluye un componente llamado Console que nos da un servicio m\u00ednimo tipo REPL (Read-Evaluate-Print-Loop) El componente incluye toda la funcionalidad necesaria para el procesamiento/eidci\u00f3n de l\u00ednea, bas\u00e1ndose en la librer\u00eda lineoise . De ese modo, sabe interpretar la acci\u00f3n de borrado, movimiento por cursores, auto completa, indica el formato de cada comando... Asimismo, tiene funciones para que sea sencillo registrar nuevos comandos escritos por nosotros mismos. Vamos a partir del ejemplo de consola b\u00e1sico . Estudia el c\u00f3digo, y responde a las siguientes preguntas: Cuesti\u00f3n \u00bfQu\u00e9 componente se est\u00e1 incluyendo adem\u00e1s de los que siempre se incluyen por defecto? \u00bfQu\u00e9 funcionalidad se importa de dicho componente? \u00bfQu\u00e9 particiones se crean al volcar el proyecto en nuestro dispositivo?","title":"Aplicaci\u00f3n Consola (opcional)"},{"location":"ANIOT/P2/#importar-codigo-externo-como-componente","text":"Espressif tiene una base de datos de componentes que permite incorporar componentes open-source en nuestros proyectos ESP-IDF de forma sencilla. Podemos incluir un componente del registro mediante el comando idf.py add-dependency <componentName> o descargando el fichero de la web de componentes y copi\u00e1ndolo en nuestro proyecto. Bastar\u00e1 con copiar la carpeta descargada dentro de la carpeta components de nuestro proyecto. En ocasiones, encontraremos c\u00f3digos no incluidos en el registro oficial de Espressif pero que pueden resultar \u00fatiles para nuestros desarollos. Nuevamente, resulta aconsejable importar esos proyectos externos como componentes en nuestros proyectos. Y as\u00ed lo haremos en la siguiente tarea: Tarea La placa de desarrollo ESP32-C3-DevKit-RUST-1 tiene dos sensores de temperatura. Uno est\u00e1 integrado en el propio ESP32-C3 (puedes econtrar su API en la documentaci\u00f3n de ESP-IDF ). El segundo est\u00e1 en la placa, tal y como se indica en su documentaci\u00f3n . Se trata de un sensor SHTC3 de Sensirion que est\u00e1 conectado al SoC mediante el bus I2C. A partir del c\u00f3digo disponible en este repositorio de Github https://github.com/mauriciobarroso/shtc3 crea un componente llamado shtc3 para poder utilizar el sensor sin necesidad de consultar el datasheet . Los ficheros del repositorio ya est\u00e1n preparados para usarse como un componente en ESP-IDF v5.3 S\u00f3lo debes ubicarlos en la carpeta correcta. En el fichero principal de tu aplicaci\u00f3n, deber\u00e1s inicializar el driver del bus I2C y el propio sensor. Puedes usar el c\u00f3digo que se proporciona a continuaci\u00f3n. shtc3_t tempSensor; i2c_master_bus_handle_t bus_handle; void init_i2c(void) { uint16_t id; i2c_master_bus_config_t i2c_bus_config = { .clk_source = I2C_CLK_SRC_DEFAULT, .i2c_port = I2C_NUM_0, .scl_io_num = 8, .sda_io_num = 10, .glitch_ignore_cnt = 7, .flags.enable_internal_pullup = true, }; ESP_ERROR_CHECK(i2c_new_master_bus(&i2c_bus_config, &bus_handle)); shtc3_init(&tempSensor, bus_handle, 0x70); } Tarea En relaci\u00f3n al c\u00f3digo anterior: \u00bfPor qu\u00e9 scl_io_num es 8? \u00bfPor qu\u00e9 sda_io_num es 10? \u00bfSe pueden cambiar? \u00bfPor qu\u00e9 la llamada a shtc3_init() reciba 0x70 como tercer argumento?","title":"Importar c\u00f3digo externo como componente"},{"location":"ANIOT/P2/#controladores-gpio","text":"Los controladores de GPIO ( General Purpose Input-Ouput ) permiten controlar ciertos pines de nuestro dispositivo para usarlos como entrada (por ejemplo, para conectar un bot\u00f3n) o salida (por ejemplo para conectar un LED) o con funciones especiales (que forme parte de un bus serie, por ejemplo).","title":"Controladores GPIO"},{"location":"ANIOT/P2/#placa-esp32-devkitc-v4","text":"El SoC ESP32 que usamos proporciona 40 GPIO pads (el SoC no tiene pines propiamente dichos, sino conectores, normalmente de superf\u00edcie, que se deminan pad ). El m\u00f3dulo WROOM-32 que usamos expone 38 de ellos, que son accesibles a traves de los pines (los conectores f\u00edsicos a ambos lados de la placa) que incorpora nuestra placa DevKitC. En la siguiente figura se muestra la disposici\u00f3n de los pines en la placa ESP32-DevKitC que usamos en nuestras pr\u00e1cticas: En la web de Espressif se pueden encontrar m\u00e1s detalles de la placa. Como se indica en la documentaci\u00f3n de ESP-IDF , algunos de esos pines tiene un prop\u00f3sito espec\u00edfico. Por ejemplo, GPIO6-11 y 16-17 no deben usarse porque est\u00e1n internamente conectados a la memoria SPI flash. Tambi\u00e9n nos indica que los pines del canal 2 del ADC (ADC2) NO deben usarse mientras se utiliza Wi-Fi. Es muy conveniente leer todas las restricciones para evitar problemas en nuestros desarrollos.","title":"Placa ESP32-DevKitC v4"},{"location":"ANIOT/P2/#placa-rust-board-esp32-c3","text":"En la siguiente figura se muestra la disposici\u00f3n de los pines en la placa ESP32-Rust board que usamos en nuestras pr\u00e1cticas: En la web de la placa se pueden encontrar m\u00e1s detalles sobre los componenentes, esquem\u00e1ticos, BOM... Entre otra documentaci\u00f3n pod\u00e9is encontrar el esquem\u00e1tico de la placa, que permite conocer a qu\u00e9 pines del SoC se conectan los diferentes elementos (LEDs, botones) de la placa:","title":"Placa Rust Board ESP32-C3"},{"location":"ANIOT/P2/#api-de-esp-idf","text":"La documentaci\u00f3n muestra tambi\u00e9n la API que ofrece ESP-IDF para configurar los pines (entrada o salida, uso de pull-up/pull-down) establecer un valor l\u00f3gico (0 \u00f3 1)en un pin (previamente configurado como salida) o leer el valor l\u00f3gico de un pin (configurado como entrada). El siguiente c\u00f3digo, extra\u00eddo del ejemplo de GPIO proporcionado en la distribuci\u00f3n ESP-IDF , muestra c\u00f3mo configurar los pines GPIO18 y GPIO19 como salida. Observa c\u00f3mo se construye la m\u00e1scara de bits GPIO_OUTPUT_PIN_SEL para indicar a gpio_config() qu\u00e9 pines se configuran. #define GPIO_OUTPUT_IO_0 18 #define GPIO_OUTPUT_IO_1 19 #define GPIO_OUTPUT_PIN_SEL ((1ULL<<GPIO_OUTPUT_IO_0) | (1ULL<<GPIO_OUTPUT_IO_1)) gpio_config_t io_conf; io_conf.intr_type = GPIO_PIN_INTR_DISABLE; io_conf.mode = GPIO_MODE_OUTPUT; io_conf.pin_bit_mask = GPIO_OUTPUT_PIN_SEL; io_conf.pull_down_en = 0; io_conf.pull_up_en = 0; gpio_config(&io_conf); Posteriormente, podemos establecer el valor l\u00f3gico de la salida con una llamada similar a gpio_set_level(GPIO_OUTPUT_IO_1, valor); , siendo valor igual a 0 \u00f3 1. De forma similar el siguiente c\u00f3digo configura los pines 4 y 5 como entrada: #define GPIO_INPUT_IO_0 4 #define GPIO_INPUT_IO_1 5 #define GPIO_INPUT_PIN_SEL ((1ULL<<GPIO_INPUT_IO_0) | (1ULL<<GPIO_INPUT_IO_1)) gpio_config_t io_conf; io_conf.pin_bit_mask = GPIO_INPUT_PIN_SEL; io_conf.mode = GPIO_MODE_INPUT; gpio_config(&io_conf); Posteriormente, podremos leer el valor l\u00f3gico de esos pines con una llamada a gpio_get_level() . Busca informaci\u00f3n En relaci\u00f3n al c\u00f3digo anterior: en la configuraci\u00f3n anterior, los pines de entrada deben muestrearse peri\u00f3dicamente para conocer su estado. Investiga c\u00f3mo configurar los pines como entrada de modo que generen una interrupci\u00f3n cuando se produce un flanco (subida, bajado o ambos).","title":"API de ESP-IDF"},{"location":"ANIOT/P2/#esp-idf-high-resolution-timer","text":"Un Timer es un temporizador que podemos programar para que nos avise transcurrido un cierto tiempo. Es similar a una cuenta atr\u00e1s con alarma y es un mecanismo perfecto para planificar tareas peri\u00f3dicas. El aviso ser\u00e1 as\u00edncrono, por lo que no sabemos en qu\u00e9 punto de nuestro c\u00f3digo estaremos cuando se dispare la alarma. ESP-IDF ofrece un API para el uso de timers que, a su vez, utlizan los timers de 64 bits disponibles en el hardware para garantizar una precisi\u00f3n de hasta 50us. Cuando programamos un timer podemos optar por 2 comportamientos: One-shot ( esp_timer_start_once() ), que programr\u00e1 el timer para que genere una \u00fanica alarma transcurrido el plazo establecido. Continuo ( esp_timer_start_periodic() ) que re-programar\u00e1 el timer de forma autom\u00e1tica cada vez que la cuenta llegue a 0. Este mecanismo es el id\u00f3neo para muestreos peri\u00f3dicos. Cuando el timer genere la alarma, se ejecutar\u00e1 un callback , una funci\u00f3n que habremos definido previamente (y asociado a ese timer ). Dicha funci\u00f3n se ejecutar\u00e1 en el contexto de una tarea espec\u00edfica ( ESP_TIMER_TASK ) o en el de una rutina de tratamiento de interrupci\u00f3n ( ESP_TIMER_ISR ). En nuestro caso, es aconsejable usar el primer mecanismo (tarea espec\u00edfica). En la documentaci\u00f3n de ESP-IDF pod\u00e9is encontrar el resto de llamadas relevantes para crear y configurar timers . Es muy recomendable, asimismo, estudiar los ejemplos disponibles en la distribuci\u00f3n A continuaci\u00f3n se incluye un ejemplo de uso, extra\u00edado de la distribuci\u00f3n de ESP-IDF: void app_main() { ... const esp_timer_create_args_t periodic_timer_args = { .callback = &periodic_timer_callback, .name = \"periodic\" }; esp_timer_handle_t periodic_timer; esp_timer_create(&periodic_timer_args, &periodic_timer); ... esp_timer_start_periodic(periodic_timer, 500000); .... esp_timer_stop(periodic_timer); ... esp_timer_delete(periodic_timer); } static void periodic_timer_callback(void* arg) { int64_t time_since_boot = esp_timer_get_time(); printf(\"Periodic timer called, time since boot: %lld us\",time_since_boot); }","title":"ESP-IDF: High Resolution Timer"},{"location":"ANIOT/P2/#encendido-de-leds-con-gpio-y-timer","text":"La placa de desarrollo ESP32-C3-DevKit-RUST-1 tiene dos LEDs, uno de ellos conectado Tarea Configura el GPIO asociado al LED (GPIO 7) como salida. Programa un timer para cambiar el estado del LED cada segundo.","title":"Encendido de LEDs con GPIO y timer"},{"location":"ANIOT/P2/#ejercicio-final","text":"Completa este ejercicio despu\u00e9s de haber resuelto los anteriores. De cara la entrega de la pr\u00e1ctica, s\u00f3lo es necesario entregar este ejercicio Tareas Partiendo del ejemplo Blink (usando el denominado LED_STRIP en GPIO 2, no como la usamos el primer d\u00eda), crea una applicaci\u00f3n que: Incluya el componente shtc3 en tu proyecto. Muestree la temperatura cada segundo utilizando un timer . Muestre el progreso de la temperatura en el LED programable de la placa. Si la temperatura es inferior a 20 grados, estar\u00e1 apagado. Por cada grado que suba la temperatura, se modificar\u00e1 el color/intensidad del LED. Para variar el color/intensidad, s\u00f3lo debes cambiar los 3 \u00faltimos argumentos de la llamada led_strip_set_pixel() del c\u00f3digo de ejemplo. Se programar\u00e1 un segundo timer que mostrar\u00e1 por pantalla (puerto serie) la \u00faltima medida de temperatura realizada cada 10 segundos. [Opcional] Configura el GPIO 9, al que est\u00e1 conectado el bot\u00f3n BOOT, para que genere interrupciones cuando soltemos el bot\u00f3n. \u00bfQu\u00e9 valor l\u00f3gico se lee del GPIO 9 con el bot\u00f3n pulsado?. Consulta la documentaci\u00f3n de GPIO y el ejemplo de GPIO gen\u00e9rico para entender c\u00f3mo configurar un GPIO como entrada por interrupciones.","title":"Ejercicio final"},{"location":"ANIOT/P3/","text":"Pr\u00e1ctica 3. Programaci\u00f3n con tareas y eventos en ESP-IDF Objetivos El objetivo de esta pr\u00e1ctica es conocer los mecanismos para la gesti\u00f3n de tareas que ofrece FreeRTOS, concretamente en su porting ESP-IDF. Trabajaremos los siguientes aspectos del API de ESP-IDF: Familiarizarse con la API de tareas y eventos en ESP/IDF. Comunicaci\u00f3n y sincronizaci\u00f3n de tareas mediante colas. Material de consulta Para ver los detalles de cada aspecto de esta pr\u00e1ctica se recomienda la lectura de los siguientes enlaces: API de ESP-IDF Documentaci\u00f3n oficial de FreeRTOS Introducci\u00f3n Al desarrollar c\u00f3digo para sistemas empotrados, como nuestro nodo basado en ESP32, es habitual organizar la aplicaci\u00f3n en torno a diferentes tareas que se ejecutan de forma concurrente. Habr\u00e1 tareas dedicadas al muestreo de sensores, tareas dedicadas a la conectividad, tareas de logging ... Por tanto, al comenzar un desarrollo con un nuevo RTOS (Real-Time Operating System) es importante conocer qu\u00e9 servicios ofrece el sistema para la gesti\u00f3n de hilos/tareas. En ocasiones, puede no haber ning\u00fan soporte. En otras ocasiones, el API ofrecida ser\u00e1 espec\u00edfica del sistema operativo utilizado (como es el caso con FreeRTOS y, por tanto, con la extensi\u00f3n que usaremos: ESP-IDF). Y, en ocasiones, el sistema ofrecer\u00e1 alg\u00fan API est\u00e1ndar, como el de POSIX . En los v\u00eddeos y transparencias de la asignatura disponibles en el Campus Virtual se hace una breve introducci\u00f3n de los mecanismos de: Creaci\u00f3n y destrucci\u00f3n de tareas en ESP-IDF. Comunicaci\u00f3n y sincronizaci\u00f3n de tareas mediante colas Uso de eventos como sistema de comunicaci\u00f3n as\u00edncrona. Los siguientes ejercicios se proponen como una pr\u00e1ctica sencilla de esos mecanismos. Primera sesi\u00f3n: Ejercicios b\u00e1sicos Creaci\u00f3n de una tarea para realizar el muestreo Escribe una aplicaci\u00f3n que crear\u00e1 una tarea para muestrear un sensor. Denominaremos muestreadora a dicha tarea y deber\u00e1 muestrear peri\u00f3dicamnete el sensor SHTC3 de Sensirion . La tarea muestreadora comunicar\u00e1 la lectura con la tarea inicial (la que ejecuta app_main() ) a trav\u00e9s de una variable global. Tarea La tarea creada leer\u00e1 el valor del sensor con un per\u00edodo que se pasar\u00e1 como argumento a la tarea. Dicha tarea tendr\u00e1 un bucle infinito en el que realizar\u00e1 la lectura del sensor, modificar\u00e1 la variable global y dormir\u00e1 durante el tiempo establecido. La tarea inicial (app_main) recoger\u00e1 el valor muestreado y lo mostrar\u00e1 por puerto serie. Cuesti\u00f3n \u00bfQu\u00e9 prioridad tiene la tarea inicial que ejecuta la funci\u00f3n app_main() ? \u00bfCon qu\u00e9 llamada de ESP-IDF podemos conocer la prioridad de una tarea? \u00bfC\u00f3mo sincronizas ambas tareas? \u00bfC\u00f3mo sabe la tarea inicial que hay un nuevo dato generado por la tarea muestreadora? Si adem\u00e1s de pasar el per\u00edodo como par\u00e1metro, quisi\u00e9ramos pasar como argumento la direcci\u00f3n en la que la tarea muestreadora debe escribir las lecturas, \u00bfc\u00f3mo pasar\u00edamos los dos argumentos a la nueva tarea? Comunicaci\u00f3n mediante colas Modifica el c\u00f3digo anterior para que las dos tareas (inicial y muestreadora) se comuniquen mediante una [cola de ESP-IDF]https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/system/freertos_idf.html#queue-api). Tarea La tarea creada (muestreadora) recibir\u00e1 como argumento el per\u00edodo de muestreo y la cola en la que deber\u00e1 escribir los datos le\u00eddos. Cuesti\u00f3n Al enviar un dato por una cola, \u00bfel dato se pasa por copia o por referencia?. Consulta la documentaci\u00f3n para responder. Uso de eventos Finalmente, se modificar\u00e1 nuevamente el c\u00f3digo de muestreo original (no el que usa una cola para comunicar) para que utilice eventos para notificar que hay una nueva lectura que mostrar por el puerto serie. Para ello se declara un nuevo event base llamado SENSOR_EVENT y al menos un event ID que se denominar\u00e1 SENSOR_EVENT_NEWSAMPLE . Tarea La tarea creada (muestreadora) recibir\u00e1 como argumento el per\u00edodo de muestreo. Cuando tenga una nueva muestra, la comunicar\u00e1 a trav\u00e9s de esp_event_post_to() . La tarea inicial registrar\u00e1 un handler que se encargar\u00e1 de escribir en el puerto serie. Cuesti\u00f3n \u00bfQu\u00e9 debe hacer la tarea inicial tras registrar el handle ? \u00bfPuede finalizar? ENTREGA NO ES NECESARIO HACER UNA ENTREGA DE LAS TAREAS DE ESTA SESI\u00d3N Segunda sesi\u00f3n: ejercicio de estructuraci\u00f3n de c\u00f3digo Queremos montar un sistema monitorice la temperatura y humedad con un cierto per\u00edodo, y env\u00ede los datos por red. As\u00ed mismo, monitorizar\u00e1 la pulsaci\u00f3n de un bot\u00f3n para detectar la cercan\u00eda de un operador, lo que llevar\u00e1 al sistema a un modo de funcionamiento diferente, mostrando una consola por puerto serie. La funcionalidad del sistema ser\u00e1 la siguiente: El sistema tendr\u00e1 dos modos de funcionamiento: monitorizaci\u00f3n o consola . En el primero, se monitorizar\u00e1 y enviar\u00e1 la temperatura y humedad. En el segundo se permitir\u00e1 el uso de una consola de comandos. Monitorizar\u00e1 la temperatura y la humedad cada n segundos, siendo \u00e9ste un par\u00e1metro seleccionable por menuconfig . La lectura de cada medida se comunicar\u00e1 mediante eventos . Todo el c\u00f3digo relacionado con las lecturas del sensor estar\u00e1 en un componente separado. Se valorar\u00e1 la modularizaci\u00f3n del c\u00f3digo (uso de m\u00e1s componentes) para el resto de funcionalidad de este punto. Las lecturas se enviar\u00e1n por red mediante WiFi. En este caso, no usaremos realmente la WiFi pero se programar\u00e1 un componente que lo simule. Ofrecer\u00e1 un API similar a: wifi_connect() trata de conectar a WiFi. Cuando la conexi\u00f3n se produce, recibiremos un evento. Una vez conseguida, tratar\u00e1 de conseguir una IP (sin que hagamos ninguna otra llamada) y recibiremos un evento al conseguirla. wifi_disconnect() . Desconecta de la WiFi. esp_err_t send_data_wifi(void* data, size_t size) . Permite enviar un dato mediante la conexi\u00f3n WiFI. Devolver\u00e1 un error si el env\u00edo no se pudo realizar. Imprimir\u00e1 el dato por puerto serie (pasaremos siempre una cadena de caracteres como dato de entrada). El componente enviar\u00e1 los siguientes eventos: * WIFI_CONECTADO . Se enviar\u00e1 cuando el m\u00f3dulo de WiFi consiga conexi\u00f3n (equivalente a conectar al SSID) * WIFI_DESCONECTADO . Se enviar\u00e1 cuando se pierda la conectividad. Ser\u00e1 necesario llamar a wifi_connect() nuevamente para volver a conectar. * IP_CONSEGUIDA . Se enviar\u00e1 cuando se haya conseguido IP. Hasta entonces, la aplicaci\u00f3n no deber\u00eda llara a send_data_wifi pues fallar\u00e1 siempre. En otro caso, esa llamada siempre dar\u00e1 \u00e9xito. El componente simular\u00e1 la conexi\u00f3n WiFI y tendr\u00e1 un par\u00e1metro que modelar\u00e1 la latencia de conexi\u00f3n (tiempo desde que se llama a wifi_connect() hasta que se conecta a WiFi), latencia para conseguir IP y la tasa de desconexi\u00f3n (probabilidad de que la conexi\u00f3n falle y tengamos que volver a conectar. Se modelar\u00e1 como un n\u00famero de segundos tras la conexi\u00f3n) Cuando no se disponga de conectividad WiFi, las lecturas del sensor se seguir\u00e1n realizando, pero se almacenar\u00e1n en memoria Flash. Para simular esta parte, se crear\u00e1 un nuevo componente que emular\u00e1 el uso de la memoria Flash mediante el siguiente API: esp_err_t writeToFlash(void* data, size_t size) permite escribir en memoria flash el dato data de tama\u00f1o size bytes La siguiente llamada a writeToFlash() escribir\u00e1 a continuaci\u00f3n del dato anterior sin sobreescribirlo. void* readFromFlash(size_t size) . Lee el dato ( size bytes) m\u00e1s antiguo almacenado en la flash. Esos bytes quedan marcados como le\u00eddos y se podr\u00e1n usar en futuras escrituras. size_t getDataLeft() nos devuelve cu\u00e1ntos bytes hay pendientes de ser le\u00eddos en la flash. Se realizar\u00e1 un componente que emule as\u00ed el comportamiento de una memoria Flash. Como simplificaci\u00f3n, se asumir\u00e1 que el tama\u00f1o de lectura/escritura siempre ser\u00e1 el mismo (el tama\u00f1o de un float , que ser\u00e1 el tipo usado en las lecturas del sensor). Los datos se almancenar\u00e1n en un buffer circular (no hay que usar la flash de verdad). Cuando consigamos conexi\u00f3n (WiFi + IP), enviaremos los datos que tengamos pendientes en la memoria flash (si hay alguno). La aplicaci\u00f3n monitorizar\u00e1 (cada nbutton segundos; parametrizable) un pin de GPIO para detectar pulsaciones de un bot\u00f3n. Si se produce una pulsaci\u00f3n, pasaremos al modo consola . Se escribir\u00e1 un componente para esta funcionalida. Si se detecta una pulsaci\u00f3n, se enviar\u00e1 un evento . Cuando estemos en el modo consola se utilizar\u00e1 el componente consola de ESP-IDF para leer comandos del usuario. En concreto habr\u00e1 3 comandos disponibles: help que mostrar\u00e1 los comandos disponibles monitor que volver\u00e1 nuevamente al modo monitorizaci\u00f3n , tratando de conectar a WiFi de nuevo. quota que nos informar\u00e1 de cu\u00e1ntos bytes tiene ocupadas la flash simulada (es decir, cu\u00e1ntos no se han le\u00eddo) Durante este modo de funcionamiento, no se monitorizar\u00e1 el sensor SHTC3 de Sensirion y nos desconetaremos de la WiFi. Tarea Escribe una aplicaci\u00f3n que realice la funcionalidad anterior. Se valorar\u00e1 especialmente la modularidad y estructura del c\u00f3digo, de modo que sea extensible y reutilizable.","title":"Pr\u00e1ctica 3"},{"location":"ANIOT/P3/#practica-3-programacion-con-tareas-y-eventos-en-esp-idf","text":"","title":"Pr\u00e1ctica 3. Programaci\u00f3n con tareas y eventos en ESP-IDF"},{"location":"ANIOT/P3/#objetivos","text":"El objetivo de esta pr\u00e1ctica es conocer los mecanismos para la gesti\u00f3n de tareas que ofrece FreeRTOS, concretamente en su porting ESP-IDF. Trabajaremos los siguientes aspectos del API de ESP-IDF: Familiarizarse con la API de tareas y eventos en ESP/IDF. Comunicaci\u00f3n y sincronizaci\u00f3n de tareas mediante colas.","title":"Objetivos"},{"location":"ANIOT/P3/#material-de-consulta","text":"Para ver los detalles de cada aspecto de esta pr\u00e1ctica se recomienda la lectura de los siguientes enlaces: API de ESP-IDF Documentaci\u00f3n oficial de FreeRTOS","title":"Material de consulta"},{"location":"ANIOT/P3/#introduccion","text":"Al desarrollar c\u00f3digo para sistemas empotrados, como nuestro nodo basado en ESP32, es habitual organizar la aplicaci\u00f3n en torno a diferentes tareas que se ejecutan de forma concurrente. Habr\u00e1 tareas dedicadas al muestreo de sensores, tareas dedicadas a la conectividad, tareas de logging ... Por tanto, al comenzar un desarrollo con un nuevo RTOS (Real-Time Operating System) es importante conocer qu\u00e9 servicios ofrece el sistema para la gesti\u00f3n de hilos/tareas. En ocasiones, puede no haber ning\u00fan soporte. En otras ocasiones, el API ofrecida ser\u00e1 espec\u00edfica del sistema operativo utilizado (como es el caso con FreeRTOS y, por tanto, con la extensi\u00f3n que usaremos: ESP-IDF). Y, en ocasiones, el sistema ofrecer\u00e1 alg\u00fan API est\u00e1ndar, como el de POSIX . En los v\u00eddeos y transparencias de la asignatura disponibles en el Campus Virtual se hace una breve introducci\u00f3n de los mecanismos de: Creaci\u00f3n y destrucci\u00f3n de tareas en ESP-IDF. Comunicaci\u00f3n y sincronizaci\u00f3n de tareas mediante colas Uso de eventos como sistema de comunicaci\u00f3n as\u00edncrona. Los siguientes ejercicios se proponen como una pr\u00e1ctica sencilla de esos mecanismos.","title":"Introducci\u00f3n"},{"location":"ANIOT/P3/#primera-sesion-ejercicios-basicos","text":"","title":"Primera sesi\u00f3n: Ejercicios b\u00e1sicos"},{"location":"ANIOT/P3/#creacion-de-una-tarea-para-realizar-el-muestreo","text":"Escribe una aplicaci\u00f3n que crear\u00e1 una tarea para muestrear un sensor. Denominaremos muestreadora a dicha tarea y deber\u00e1 muestrear peri\u00f3dicamnete el sensor SHTC3 de Sensirion . La tarea muestreadora comunicar\u00e1 la lectura con la tarea inicial (la que ejecuta app_main() ) a trav\u00e9s de una variable global. Tarea La tarea creada leer\u00e1 el valor del sensor con un per\u00edodo que se pasar\u00e1 como argumento a la tarea. Dicha tarea tendr\u00e1 un bucle infinito en el que realizar\u00e1 la lectura del sensor, modificar\u00e1 la variable global y dormir\u00e1 durante el tiempo establecido. La tarea inicial (app_main) recoger\u00e1 el valor muestreado y lo mostrar\u00e1 por puerto serie. Cuesti\u00f3n \u00bfQu\u00e9 prioridad tiene la tarea inicial que ejecuta la funci\u00f3n app_main() ? \u00bfCon qu\u00e9 llamada de ESP-IDF podemos conocer la prioridad de una tarea? \u00bfC\u00f3mo sincronizas ambas tareas? \u00bfC\u00f3mo sabe la tarea inicial que hay un nuevo dato generado por la tarea muestreadora? Si adem\u00e1s de pasar el per\u00edodo como par\u00e1metro, quisi\u00e9ramos pasar como argumento la direcci\u00f3n en la que la tarea muestreadora debe escribir las lecturas, \u00bfc\u00f3mo pasar\u00edamos los dos argumentos a la nueva tarea?","title":"Creaci\u00f3n de una tarea para realizar el muestreo"},{"location":"ANIOT/P3/#comunicacion-mediante-colas","text":"Modifica el c\u00f3digo anterior para que las dos tareas (inicial y muestreadora) se comuniquen mediante una [cola de ESP-IDF]https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/system/freertos_idf.html#queue-api). Tarea La tarea creada (muestreadora) recibir\u00e1 como argumento el per\u00edodo de muestreo y la cola en la que deber\u00e1 escribir los datos le\u00eddos. Cuesti\u00f3n Al enviar un dato por una cola, \u00bfel dato se pasa por copia o por referencia?. Consulta la documentaci\u00f3n para responder.","title":"Comunicaci\u00f3n mediante colas"},{"location":"ANIOT/P3/#uso-de-eventos","text":"Finalmente, se modificar\u00e1 nuevamente el c\u00f3digo de muestreo original (no el que usa una cola para comunicar) para que utilice eventos para notificar que hay una nueva lectura que mostrar por el puerto serie. Para ello se declara un nuevo event base llamado SENSOR_EVENT y al menos un event ID que se denominar\u00e1 SENSOR_EVENT_NEWSAMPLE . Tarea La tarea creada (muestreadora) recibir\u00e1 como argumento el per\u00edodo de muestreo. Cuando tenga una nueva muestra, la comunicar\u00e1 a trav\u00e9s de esp_event_post_to() . La tarea inicial registrar\u00e1 un handler que se encargar\u00e1 de escribir en el puerto serie. Cuesti\u00f3n \u00bfQu\u00e9 debe hacer la tarea inicial tras registrar el handle ? \u00bfPuede finalizar? ENTREGA NO ES NECESARIO HACER UNA ENTREGA DE LAS TAREAS DE ESTA SESI\u00d3N","title":"Uso de eventos"},{"location":"ANIOT/P3/#segunda-sesion-ejercicio-de-estructuracion-de-codigo","text":"Queremos montar un sistema monitorice la temperatura y humedad con un cierto per\u00edodo, y env\u00ede los datos por red. As\u00ed mismo, monitorizar\u00e1 la pulsaci\u00f3n de un bot\u00f3n para detectar la cercan\u00eda de un operador, lo que llevar\u00e1 al sistema a un modo de funcionamiento diferente, mostrando una consola por puerto serie. La funcionalidad del sistema ser\u00e1 la siguiente: El sistema tendr\u00e1 dos modos de funcionamiento: monitorizaci\u00f3n o consola . En el primero, se monitorizar\u00e1 y enviar\u00e1 la temperatura y humedad. En el segundo se permitir\u00e1 el uso de una consola de comandos. Monitorizar\u00e1 la temperatura y la humedad cada n segundos, siendo \u00e9ste un par\u00e1metro seleccionable por menuconfig . La lectura de cada medida se comunicar\u00e1 mediante eventos . Todo el c\u00f3digo relacionado con las lecturas del sensor estar\u00e1 en un componente separado. Se valorar\u00e1 la modularizaci\u00f3n del c\u00f3digo (uso de m\u00e1s componentes) para el resto de funcionalidad de este punto. Las lecturas se enviar\u00e1n por red mediante WiFi. En este caso, no usaremos realmente la WiFi pero se programar\u00e1 un componente que lo simule. Ofrecer\u00e1 un API similar a: wifi_connect() trata de conectar a WiFi. Cuando la conexi\u00f3n se produce, recibiremos un evento. Una vez conseguida, tratar\u00e1 de conseguir una IP (sin que hagamos ninguna otra llamada) y recibiremos un evento al conseguirla. wifi_disconnect() . Desconecta de la WiFi. esp_err_t send_data_wifi(void* data, size_t size) . Permite enviar un dato mediante la conexi\u00f3n WiFI. Devolver\u00e1 un error si el env\u00edo no se pudo realizar. Imprimir\u00e1 el dato por puerto serie (pasaremos siempre una cadena de caracteres como dato de entrada). El componente enviar\u00e1 los siguientes eventos: * WIFI_CONECTADO . Se enviar\u00e1 cuando el m\u00f3dulo de WiFi consiga conexi\u00f3n (equivalente a conectar al SSID) * WIFI_DESCONECTADO . Se enviar\u00e1 cuando se pierda la conectividad. Ser\u00e1 necesario llamar a wifi_connect() nuevamente para volver a conectar. * IP_CONSEGUIDA . Se enviar\u00e1 cuando se haya conseguido IP. Hasta entonces, la aplicaci\u00f3n no deber\u00eda llara a send_data_wifi pues fallar\u00e1 siempre. En otro caso, esa llamada siempre dar\u00e1 \u00e9xito. El componente simular\u00e1 la conexi\u00f3n WiFI y tendr\u00e1 un par\u00e1metro que modelar\u00e1 la latencia de conexi\u00f3n (tiempo desde que se llama a wifi_connect() hasta que se conecta a WiFi), latencia para conseguir IP y la tasa de desconexi\u00f3n (probabilidad de que la conexi\u00f3n falle y tengamos que volver a conectar. Se modelar\u00e1 como un n\u00famero de segundos tras la conexi\u00f3n) Cuando no se disponga de conectividad WiFi, las lecturas del sensor se seguir\u00e1n realizando, pero se almacenar\u00e1n en memoria Flash. Para simular esta parte, se crear\u00e1 un nuevo componente que emular\u00e1 el uso de la memoria Flash mediante el siguiente API: esp_err_t writeToFlash(void* data, size_t size) permite escribir en memoria flash el dato data de tama\u00f1o size bytes La siguiente llamada a writeToFlash() escribir\u00e1 a continuaci\u00f3n del dato anterior sin sobreescribirlo. void* readFromFlash(size_t size) . Lee el dato ( size bytes) m\u00e1s antiguo almacenado en la flash. Esos bytes quedan marcados como le\u00eddos y se podr\u00e1n usar en futuras escrituras. size_t getDataLeft() nos devuelve cu\u00e1ntos bytes hay pendientes de ser le\u00eddos en la flash. Se realizar\u00e1 un componente que emule as\u00ed el comportamiento de una memoria Flash. Como simplificaci\u00f3n, se asumir\u00e1 que el tama\u00f1o de lectura/escritura siempre ser\u00e1 el mismo (el tama\u00f1o de un float , que ser\u00e1 el tipo usado en las lecturas del sensor). Los datos se almancenar\u00e1n en un buffer circular (no hay que usar la flash de verdad). Cuando consigamos conexi\u00f3n (WiFi + IP), enviaremos los datos que tengamos pendientes en la memoria flash (si hay alguno). La aplicaci\u00f3n monitorizar\u00e1 (cada nbutton segundos; parametrizable) un pin de GPIO para detectar pulsaciones de un bot\u00f3n. Si se produce una pulsaci\u00f3n, pasaremos al modo consola . Se escribir\u00e1 un componente para esta funcionalida. Si se detecta una pulsaci\u00f3n, se enviar\u00e1 un evento . Cuando estemos en el modo consola se utilizar\u00e1 el componente consola de ESP-IDF para leer comandos del usuario. En concreto habr\u00e1 3 comandos disponibles: help que mostrar\u00e1 los comandos disponibles monitor que volver\u00e1 nuevamente al modo monitorizaci\u00f3n , tratando de conectar a WiFi de nuevo. quota que nos informar\u00e1 de cu\u00e1ntos bytes tiene ocupadas la flash simulada (es decir, cu\u00e1ntos no se han le\u00eddo) Durante este modo de funcionamiento, no se monitorizar\u00e1 el sensor SHTC3 de Sensirion y nos desconetaremos de la WiFi. Tarea Escribe una aplicaci\u00f3n que realice la funcionalidad anterior. Se valorar\u00e1 especialmente la modularidad y estructura del c\u00f3digo, de modo que sea extensible y reutilizable.","title":"Segunda sesi\u00f3n: ejercicio de estructuraci\u00f3n de c\u00f3digo"},{"location":"ANIOT/P4/","text":"Pr\u00e1ctica 4. Bus I2C. Sensor de temperatura Objetivos El objetivo de esta pr\u00e1ctica es conocer el funcionamiento del bus I2C y la interfaz que ofrece ESP-IDF para su uso. Trabajaremos los siguientes aspectos del API de ESP-IDF: * Configuraci\u00f3n y uso del controlador I2C. * Uso de sensor de temperatura y humedad (Si7021). * Uso del sensor ICM-42670-P (IMU) Material de consulta Para ver los detalles de cada aspecto de esta pr\u00e1ctica se recomienda la lectura de los siguientes enlaces: Documentaci\u00f3n del API de I2C Recurso online sobre I2C Hoja de especificaciones del sensor Si7021 Bus I2C Fue desarrollado en la empresa Philips (ahora NXP ) en la d\u00e9cada de los 80 con el objetivo de comunicar circuitos integrados con n\u00famero m\u00ednimo de pines. El nombre I2C viene de Inter IC . Se usa tanto la abreviatura I2C como IIC. En 2014, NXP public\u00f3 la Rev. 6 del protocolo. Proporciona una conexi\u00f3n serie s\u00edncrona unidireccional (no permite env\u00edos en dos direcciones de forma simultanea). La velocida m\u00e1xima de comunicaci\u00f3n era originalmente de 100 kbit/s, y muchas aplicaciones no requieren de velocidades mayores. Existe un fast mode a 400kbits/s, fast mode plus (1Mbits/s), ambos compatibles hacia atr\u00e1s y sin l\u00f3gica adicional (aunque puede suponer ajustes en las resistencias de pull-up para controlar las corrientes requeridas). La especificaci\u00f3n high speed mode - HS I2C permite conexiones a 3.4Mbits/s, pero exige l\u00f3gica adicional. En nuestras pruebas, se recomienda mantener 400 kbits/s. Las principales caracter\u00edsticas de I2C son: * S\u00f3lo require dos l\u00edneas: SDA y SCL. * No hay requerimientos estrictos de baud rate como en RS232, ya que el master genera la se\u00f1al de reloj. * Existe una relaci\u00f3n sencilla master/slave entre todos los componentes. * Permite tener varios master pues proporciona mecanismos de arbitraje y detecci\u00f3n de colisiones. * Cada dispositivo tiene una \u00fanica direcci\u00f3n de 7-bits (en ocasiones, de 10 bits) que proporciona el fabricante. Nueva interfaz I2C en ESP-IDF ESP-IDF ha cambiado completamente el interfaz para el uso de dispositivos I2C, simplificando significativamente su uso. La nueva estructura puede observarse en la siguiente figura, obtenida de la documentaci\u00f3n de ESP-IDF . (fuente: ESP-IDF Programming Guide) Consulta la documentaci\u00f3n de ESP-IDF sobre I2C para ver los detalles de la API. A continuaci\u00f3n, resumimos lo m\u00e1s relevante. El uso de dispositivos I2C con ESP-IDF sigue las siguientes etapas: Inicializaci\u00f3n e instanciaci\u00f3n del master bus driver . Es necesario obtener un handle del bus I2C qie se vaya a utilizar. En el SoC montado en la placa ESP32 Devkit-c hay 2 controladores I2C, mientras que en el SoC montado en la placa ESP32-C3 Rust Board s\u00f3lo hay uno. Esta acci\u00f3n debe hacerse una \u00fanica vez en toda la aplicaci\u00f3n. Especificar y condigurar el dispositivo al que conectaremos . Deberemos a\u00f1adir al bus cada dispositivo I2C que conectemos a nuestro ESP32, obteniendo as\u00ed un handle que ser\u00e1 el que finalmente utilizaremos en las llamadas de lectura/escritrura. Lectura y escritura del dispositivo . A partir de ese punto, podemos realizar transacciones con el dispositivo. Liberar recursos . Como en cualquier otro caso, una vez se haya finalizado con el uso de los recursos, conviene liberarlos para evitar memory leaks . Inicializaci\u00f3n e instanciaci\u00f3n del master bus driver ESP-IDF proporciona 2 llamadas para configurar el bus I2C (pin SDA, pin SCL, se\u00f1al de reloj...) e instanciar el bus para obtener un handle . A continuaci\u00f3n se incluye un extracto de c\u00f3digo con un ejemplo: static i2c_master_bus_handle_t i2c_handle; i2c_master_bus_config_t bus_config = { .clk_source = I2C_CLK_SRC_DEFAULT, .i2c_port = I2C_NUM_0, .scl_io_num = 8, .sda_io_num = 10, .glitch_ignore_cnt = 7, .flags.enable_internal_pullup = true, }; ESP_ERROR_CHECK(i2c_new_master_bus(&bus_config, &i2c_handle)); Especificar y condigurar el dispositivo al que conectaremos Para cada dispositivo I2C que conectemos a nuestro bus (recuerda que podemos conectar m\u00faltiples dispositivos a las mismas l\u00edneas SDA/SCL) debemos obtener un handle especificando aspectos como su direcci\u00f3n, la velocidad del bus, la longitud de la direcci\u00f3n (7 bits por defecto, pero puede ser 10 bits)... Se incluye un peque\u00f1o extracto de c\u00f3digo como ejemplo: i2c_master_dev_handle_t dev_handle; const i2c_device_config_t i2c_dev_cfg = { .device_address = 0x43, .scl_speed_hz = 400000, }; i2c_master_bus_add_device(i2c_bus, &i2c_dev_cfg, &dev_handle); Lectura y escritura del dispositivo Una vez hemos obtenido el handle del dispositivo, podemos proceder a enviar comandos (mediante una escritura al dispositivo) y leer los valores enviados por el sensor (o escribir si se trata de un dispositivo de salida). Para ello, ESP-IDF proporciona varias funciones. A continuaci\u00f3n se incluye el prototipo de las m\u00e1s habituales: // Trasnmite write_size bytes de informaci\u00f3n disponibles en write_buffer al dispositivo i2c_dev esp_err_t i2c_master_transmit(i2c_master_dev_handle_t i2c_dev, const uint8_t *write_buffer, size_t write_size, int xfer_timeout_ms); // Solicita read_size bytes de informaci\u00f3n al dispositivo i2c_dev para almancenarnos en read_buffer esp_err_t i2c_master_receive(i2c_master_dev_handle_t i2c_dev, uint8_t *read_buffer, size_t read_size, int xfer_timeout_ms); // Opreaci\u00f3n de escritura I2C seguida de lectura esp_err_t i2c_master_transmit_receive(i2c_master_dev_handle_t i2c_dev, const uint8_t *write_buffer, size_t write_size, uint8_t *read_buffer, size_t read_size, int xfer_timeout_ms); Habitualmente, se enviar\u00e1 primero un comando con la funci\u00f3n i2c_master_transmit() y posteriormente se recibir\u00e1 la informaci\u00f3n con i2c_master_receive() . Interfaz I2C en ESP-IDF (antiguo driver) ESP-IDF proporcionaba este API para el uso de dispositivos I2C. Permite usar el ESP32 tanto como master como en modo slave . Nuestro SoC ESP2 dispone de dos controladores, por lo que podr\u00edamos configurar uno como master y otro como slave (o cualquier otra combinaci\u00f3n). Los pasos para usar un dispositivo I2C son: Configuraci\u00f3n de la conexi\u00f3n. Indcaremos qu\u00e9 pines usamos como SDA y como SCL, si queremos habilitar pull-up (es aconsejable tener uno externo), el modo ( master/slave ) y la frecuencia de reloj en HZ. Todo ello se escribe en una estructura de tipo i2c_configt_t y se cconfigura mediante la llamada a i2c_param_config() . Instalaci\u00f3n del driver mediante la llamada i2c_driver_install , donde indicaremos, entre otras cosas, qu\u00e9 controlador I2C usaremos (0 o 1). Realizar las escrituras y lecturas necesarias. Para comuicarnos con un sensor, configuraremos el ESP32 en modo master . Tras instalar el driver procederemos a iniciar la comunicaci\u00f3n con el sensor: Como se indica en la figura anterior, extra\u00edda de la web oficial de Espressif, debemos crear un paquete de comandos ( cmd_link ) mediante la llamda a i2c_cmd_link_create() . En ella incluiremos cada elemento del protocolo I2C: * Bit de start. * Direcci\u00f3n del dispositivo slave (7 bits). * Bit de lectura/escritura. * Secuencia de bytes que se desean escribir. Es importante resaltar que, aunque lo que deseemos sea leer de un sensor (por ejemplo, leer la temperatura), es necesario escribir en el bus, pues lo primero que haremos ser\u00e1 enviar la direcci\u00f3n (primer write_byte ) y, habitualmente, un comando al dispositivo sensor. Tambi\u00e9n conviene resaltar que la comunicaci\u00f3n no se produce hasta que no se llega a la llamada i2c_master_cmd_begin() . En la siguiente figura se observa un patr\u00f3n habitual para la lectura: Nuevamente, la primera llamada (tras crear el enlace y el bit de start ), es a i2c_master_write_byte() , pero esta vez se establecer\u00e1 el bit de operaci\u00f3n a lectura (el bit que se incluye tras los 7 bits de direcci\u00f3n del slave ). Tras enviar ese primer byte, el ESP32 quedar\u00e1 a la escucha de bytes por parte del sensor mediante llamadas a i2c_master_read() . Como en el ejemplo anterior, la comunicaci\u00f3n no se produce hasta que no se llega a la llamada i2c_master_cmd_begin() , por lo que si queremos leer varios bytes debemos almacenarlos en posiciones diferentes de memoria y procesarlos despu\u00e9s de esta llamada. Existen tambi\u00e9n llamadas de m\u00e1s alto nivel, como i2c_master_read_from_device() y i2c_master_write_read_device() que permiten, en ocasiones, simplificar nuestro c\u00f3digo. Sensor Si7021 El Si7021 es un sensor de humedad y temperatura fabricado por Silicon Labs . Este sensor incopora un ADC internamente, que permite digitalizar las lecturas de los sensores y enviarlas a trav\u00e9s del interfaz I2C integrado. En el malet\u00edn del m\u00e1ster viene montado en una placa fabricada por Adafruit . Adfruit es una compa\u00f1\u00eda fundada por Limor Fried con la intenci\u00f3n de convertirse en un portal de referencia para el aprendizaje de electr\u00f3nica y la fabricaci\u00f3n de dise\u00f1os para makers de todos los niveles. \u00a1Merece mucho la pena echar un vistazo a su web ! Dependiendo de la versi\u00f3n del PCB que haya en el malet\u00edn, puede que \u00fanicamente haya pines expuestos ( Vin , 3Vo , GND , SCL y SDA ) o conectores STEMMA QT , compatible con los conectores Qwiic de Sparkfun (Sparkfun es otra compa\u00f1\u00eda tan interesante como Adafruit ). Lamentablemente, nuestra placa ESP32 DevKit-C no tiene conectores de ese tipo, por lo que necesitaremos conectar directamente los 4 cables: alimentaci\u00f3n, tierra, SCL y SDA. De acuerdo a las especificaciones del sensor Si7021 , el voltaje de entrada no debe superar los 3.6V. La placa de Adafruit proporcionada tiene un regulador de voltaje que nos permite conectar tanto 3.3V como 5V. La secci\u00f3n de la hoja de especificaciones del sensor Si7021 informa acerca del interfaz I2C que ofrece el sensor. Nos indica los 7 bits de direcci\u00f3n del sensor, as\u00ed como de los comandos disponibles (la mayor\u00eda de ellos de 1 byte). La secci\u00f3n 5.1.2 del documento explica c\u00f3mo obtener una medida de temperatura tras haber realizado una medidad de humedad. Para ello usa el comando 0xE0. En nuestro caso deberemos usar 0xE3 o 0xF3. i2ctools (opcional) Compila y prueba el ejemplo i2c_tools de la carpeta de ejemplos ( examples/peripherals/i2c/i2c_tools ). Conecta el sensor a los pines indicados por defecto (tambi\u00e9n a Vcc y a tierra) y ejecuta al comando i2cdetect . Prueba a los distintos comandos disponibles para tratar de leer informaci\u00f3n del sensor. Ejercicios obligatorios Usar componente ICM-42670-P con nuevo driver El registro de componentes de IDF incluye un componente para utilizar la IMU incluida en la placa ESP-RUST-BOARD (con el SoC ESP32-C3): ICM42607/ICM42670 6-Axis MotionTracking (Accelerometer and Gyroscope) . Crea una aplicaci\u00f3n que monitorice el estado del aceler\u00f3metro y determine si la placa est\u00e1 boca arriba o boca abajo. El LED RGB cambiar\u00e1 de color en funci\u00f3n de la orientaci\u00f3n, y se imprimir\u00e1 por terminal el estado actual. Recuerda que, antes de poder usar cualquier dispositivo I2C, es necesario instanciar el controlador de bus I2C que vayamos a utilizar (en este caso, el \u00fainico disponible en esta placa). static i2c_master_bus_handle_t i2c_handle; static void i2c_bus_init(void) { i2c_master_bus_config_t bus_config = { .clk_source = I2C_CLK_SRC_DEFAULT, .i2c_port = I2C_NUM_0, .scl_io_num = 8, .sda_io_num = 10, .glitch_ignore_cnt = 7, .flags.enable_internal_pullup = true, }; ESP_ERROR_CHECK(i2c_new_master_bus(&bus_config, &i2c_handle)); } Asimismo, tras crear el handle del dispositivo, es necesario configurarlo. El componente ofrece una llamada para ello: icm42670_config() . Puedes usar el siguiente c\u00f3digo de configuraci\u00f3n: /* Configuration of the accelerometer and gyroscope */ const icm42670_cfg_t imu_cfg = { .acce_fs = ACCE_FS_2G, .acce_odr = ACCE_ODR_400HZ, .gyro_fs = GYRO_FS_2000DPS, .gyro_odr = GYRO_ODR_400HZ, }; ret = icm42670_config(icm42670, &imu_cfg); Es muy recomendable consultar la carepta test_apps incluida en el propio componente para aprender a utilizarlo. Cuestiones \u00bfQu\u00e9 direcci\u00f3n tiene el dispositivo I2C? \u00bfQu\u00e9 llamada de ESP-IDF utiliza el c\u00f3digo para determinar el device id ? \u00bfQu\u00e9 comando se env\u00eda? Antes de usar el aceler\u00f3metro, es necesario activarlo con la llamada icm42670_acce_set_pwr(icm42670, ACCE_PWR_LOWNOISE); . Describe las transacciones en el bus I2C que se desencadena esa llamada. Usa un formato similar a: START | 0x34 WR | 0x44 ACK | ... | STOP | START .... \u00bfQu\u00e9 comando se utiliza para leer el valor en crudo ( raw ) del aceler\u00f3metro? \u00bfCu\u00e1ntos bytes se leen tras enviar el comando de lectura de aceler\u00f3metro raw ? \u00bfA qu\u00e9 se corresponde cada byte? Ejercicios opcionales Usar sensor Si7021 en ESP32 devkit-c Escribe un c\u00f3digo que monitorice la temperatura leyendo el sensor Si7021 conectado al ESP32 devkit-c v4 (placa antigua). Utiliza el nuevo driver para realizar la implementaci\u00f3n. Uso de CRC en sensor El sensor Si7021 permite el c\u00e1lculo de un byte de checksum (CRC) para comprobar que no ha habido errores en el env\u00edo. Completa el c\u00f3digo del componente para leer dicho byte y comprobar que no ha habido errores. Conviene leer la secci\u00f3n 5.1 y una librer\u00eda para el c\u00e1lculo de CRC como la ofrecida por BARR .","title":"Pr\u00e1ctica 4"},{"location":"ANIOT/P4/#practica-4-bus-i2c-sensor-de-temperatura","text":"","title":"Pr\u00e1ctica 4. Bus I2C. Sensor de temperatura"},{"location":"ANIOT/P4/#objetivos","text":"El objetivo de esta pr\u00e1ctica es conocer el funcionamiento del bus I2C y la interfaz que ofrece ESP-IDF para su uso. Trabajaremos los siguientes aspectos del API de ESP-IDF: * Configuraci\u00f3n y uso del controlador I2C. * Uso de sensor de temperatura y humedad (Si7021). * Uso del sensor ICM-42670-P (IMU)","title":"Objetivos"},{"location":"ANIOT/P4/#material-de-consulta","text":"Para ver los detalles de cada aspecto de esta pr\u00e1ctica se recomienda la lectura de los siguientes enlaces: Documentaci\u00f3n del API de I2C Recurso online sobre I2C Hoja de especificaciones del sensor Si7021","title":"Material de consulta"},{"location":"ANIOT/P4/#bus-i2c","text":"Fue desarrollado en la empresa Philips (ahora NXP ) en la d\u00e9cada de los 80 con el objetivo de comunicar circuitos integrados con n\u00famero m\u00ednimo de pines. El nombre I2C viene de Inter IC . Se usa tanto la abreviatura I2C como IIC. En 2014, NXP public\u00f3 la Rev. 6 del protocolo. Proporciona una conexi\u00f3n serie s\u00edncrona unidireccional (no permite env\u00edos en dos direcciones de forma simultanea). La velocida m\u00e1xima de comunicaci\u00f3n era originalmente de 100 kbit/s, y muchas aplicaciones no requieren de velocidades mayores. Existe un fast mode a 400kbits/s, fast mode plus (1Mbits/s), ambos compatibles hacia atr\u00e1s y sin l\u00f3gica adicional (aunque puede suponer ajustes en las resistencias de pull-up para controlar las corrientes requeridas). La especificaci\u00f3n high speed mode - HS I2C permite conexiones a 3.4Mbits/s, pero exige l\u00f3gica adicional. En nuestras pruebas, se recomienda mantener 400 kbits/s. Las principales caracter\u00edsticas de I2C son: * S\u00f3lo require dos l\u00edneas: SDA y SCL. * No hay requerimientos estrictos de baud rate como en RS232, ya que el master genera la se\u00f1al de reloj. * Existe una relaci\u00f3n sencilla master/slave entre todos los componentes. * Permite tener varios master pues proporciona mecanismos de arbitraje y detecci\u00f3n de colisiones. * Cada dispositivo tiene una \u00fanica direcci\u00f3n de 7-bits (en ocasiones, de 10 bits) que proporciona el fabricante.","title":"Bus I2C"},{"location":"ANIOT/P4/#nueva-interfaz-i2c-en-esp-idf","text":"ESP-IDF ha cambiado completamente el interfaz para el uso de dispositivos I2C, simplificando significativamente su uso. La nueva estructura puede observarse en la siguiente figura, obtenida de la documentaci\u00f3n de ESP-IDF . (fuente: ESP-IDF Programming Guide) Consulta la documentaci\u00f3n de ESP-IDF sobre I2C para ver los detalles de la API. A continuaci\u00f3n, resumimos lo m\u00e1s relevante. El uso de dispositivos I2C con ESP-IDF sigue las siguientes etapas: Inicializaci\u00f3n e instanciaci\u00f3n del master bus driver . Es necesario obtener un handle del bus I2C qie se vaya a utilizar. En el SoC montado en la placa ESP32 Devkit-c hay 2 controladores I2C, mientras que en el SoC montado en la placa ESP32-C3 Rust Board s\u00f3lo hay uno. Esta acci\u00f3n debe hacerse una \u00fanica vez en toda la aplicaci\u00f3n. Especificar y condigurar el dispositivo al que conectaremos . Deberemos a\u00f1adir al bus cada dispositivo I2C que conectemos a nuestro ESP32, obteniendo as\u00ed un handle que ser\u00e1 el que finalmente utilizaremos en las llamadas de lectura/escritrura. Lectura y escritura del dispositivo . A partir de ese punto, podemos realizar transacciones con el dispositivo. Liberar recursos . Como en cualquier otro caso, una vez se haya finalizado con el uso de los recursos, conviene liberarlos para evitar memory leaks .","title":"Nueva interfaz I2C en ESP-IDF"},{"location":"ANIOT/P4/#inicializacion-e-instanciacion-del-master-bus-driver","text":"ESP-IDF proporciona 2 llamadas para configurar el bus I2C (pin SDA, pin SCL, se\u00f1al de reloj...) e instanciar el bus para obtener un handle . A continuaci\u00f3n se incluye un extracto de c\u00f3digo con un ejemplo: static i2c_master_bus_handle_t i2c_handle; i2c_master_bus_config_t bus_config = { .clk_source = I2C_CLK_SRC_DEFAULT, .i2c_port = I2C_NUM_0, .scl_io_num = 8, .sda_io_num = 10, .glitch_ignore_cnt = 7, .flags.enable_internal_pullup = true, }; ESP_ERROR_CHECK(i2c_new_master_bus(&bus_config, &i2c_handle));","title":"Inicializaci\u00f3n e instanciaci\u00f3n del master bus driver"},{"location":"ANIOT/P4/#especificar-y-condigurar-el-dispositivo-al-que-conectaremos","text":"Para cada dispositivo I2C que conectemos a nuestro bus (recuerda que podemos conectar m\u00faltiples dispositivos a las mismas l\u00edneas SDA/SCL) debemos obtener un handle especificando aspectos como su direcci\u00f3n, la velocidad del bus, la longitud de la direcci\u00f3n (7 bits por defecto, pero puede ser 10 bits)... Se incluye un peque\u00f1o extracto de c\u00f3digo como ejemplo: i2c_master_dev_handle_t dev_handle; const i2c_device_config_t i2c_dev_cfg = { .device_address = 0x43, .scl_speed_hz = 400000, }; i2c_master_bus_add_device(i2c_bus, &i2c_dev_cfg, &dev_handle);","title":"Especificar y condigurar el dispositivo al que conectaremos"},{"location":"ANIOT/P4/#lectura-y-escritura-del-dispositivo","text":"Una vez hemos obtenido el handle del dispositivo, podemos proceder a enviar comandos (mediante una escritura al dispositivo) y leer los valores enviados por el sensor (o escribir si se trata de un dispositivo de salida). Para ello, ESP-IDF proporciona varias funciones. A continuaci\u00f3n se incluye el prototipo de las m\u00e1s habituales: // Trasnmite write_size bytes de informaci\u00f3n disponibles en write_buffer al dispositivo i2c_dev esp_err_t i2c_master_transmit(i2c_master_dev_handle_t i2c_dev, const uint8_t *write_buffer, size_t write_size, int xfer_timeout_ms); // Solicita read_size bytes de informaci\u00f3n al dispositivo i2c_dev para almancenarnos en read_buffer esp_err_t i2c_master_receive(i2c_master_dev_handle_t i2c_dev, uint8_t *read_buffer, size_t read_size, int xfer_timeout_ms); // Opreaci\u00f3n de escritura I2C seguida de lectura esp_err_t i2c_master_transmit_receive(i2c_master_dev_handle_t i2c_dev, const uint8_t *write_buffer, size_t write_size, uint8_t *read_buffer, size_t read_size, int xfer_timeout_ms); Habitualmente, se enviar\u00e1 primero un comando con la funci\u00f3n i2c_master_transmit() y posteriormente se recibir\u00e1 la informaci\u00f3n con i2c_master_receive() .","title":"Lectura y escritura del dispositivo"},{"location":"ANIOT/P4/#interfaz-i2c-en-esp-idf-antiguo-driver","text":"ESP-IDF proporcionaba este API para el uso de dispositivos I2C. Permite usar el ESP32 tanto como master como en modo slave . Nuestro SoC ESP2 dispone de dos controladores, por lo que podr\u00edamos configurar uno como master y otro como slave (o cualquier otra combinaci\u00f3n). Los pasos para usar un dispositivo I2C son: Configuraci\u00f3n de la conexi\u00f3n. Indcaremos qu\u00e9 pines usamos como SDA y como SCL, si queremos habilitar pull-up (es aconsejable tener uno externo), el modo ( master/slave ) y la frecuencia de reloj en HZ. Todo ello se escribe en una estructura de tipo i2c_configt_t y se cconfigura mediante la llamada a i2c_param_config() . Instalaci\u00f3n del driver mediante la llamada i2c_driver_install , donde indicaremos, entre otras cosas, qu\u00e9 controlador I2C usaremos (0 o 1). Realizar las escrituras y lecturas necesarias. Para comuicarnos con un sensor, configuraremos el ESP32 en modo master . Tras instalar el driver procederemos a iniciar la comunicaci\u00f3n con el sensor: Como se indica en la figura anterior, extra\u00edda de la web oficial de Espressif, debemos crear un paquete de comandos ( cmd_link ) mediante la llamda a i2c_cmd_link_create() . En ella incluiremos cada elemento del protocolo I2C: * Bit de start. * Direcci\u00f3n del dispositivo slave (7 bits). * Bit de lectura/escritura. * Secuencia de bytes que se desean escribir. Es importante resaltar que, aunque lo que deseemos sea leer de un sensor (por ejemplo, leer la temperatura), es necesario escribir en el bus, pues lo primero que haremos ser\u00e1 enviar la direcci\u00f3n (primer write_byte ) y, habitualmente, un comando al dispositivo sensor. Tambi\u00e9n conviene resaltar que la comunicaci\u00f3n no se produce hasta que no se llega a la llamada i2c_master_cmd_begin() . En la siguiente figura se observa un patr\u00f3n habitual para la lectura: Nuevamente, la primera llamada (tras crear el enlace y el bit de start ), es a i2c_master_write_byte() , pero esta vez se establecer\u00e1 el bit de operaci\u00f3n a lectura (el bit que se incluye tras los 7 bits de direcci\u00f3n del slave ). Tras enviar ese primer byte, el ESP32 quedar\u00e1 a la escucha de bytes por parte del sensor mediante llamadas a i2c_master_read() . Como en el ejemplo anterior, la comunicaci\u00f3n no se produce hasta que no se llega a la llamada i2c_master_cmd_begin() , por lo que si queremos leer varios bytes debemos almacenarlos en posiciones diferentes de memoria y procesarlos despu\u00e9s de esta llamada. Existen tambi\u00e9n llamadas de m\u00e1s alto nivel, como i2c_master_read_from_device() y i2c_master_write_read_device() que permiten, en ocasiones, simplificar nuestro c\u00f3digo.","title":"Interfaz I2C en ESP-IDF (antiguo driver)"},{"location":"ANIOT/P4/#sensor-si7021","text":"El Si7021 es un sensor de humedad y temperatura fabricado por Silicon Labs . Este sensor incopora un ADC internamente, que permite digitalizar las lecturas de los sensores y enviarlas a trav\u00e9s del interfaz I2C integrado. En el malet\u00edn del m\u00e1ster viene montado en una placa fabricada por Adafruit . Adfruit es una compa\u00f1\u00eda fundada por Limor Fried con la intenci\u00f3n de convertirse en un portal de referencia para el aprendizaje de electr\u00f3nica y la fabricaci\u00f3n de dise\u00f1os para makers de todos los niveles. \u00a1Merece mucho la pena echar un vistazo a su web ! Dependiendo de la versi\u00f3n del PCB que haya en el malet\u00edn, puede que \u00fanicamente haya pines expuestos ( Vin , 3Vo , GND , SCL y SDA ) o conectores STEMMA QT , compatible con los conectores Qwiic de Sparkfun (Sparkfun es otra compa\u00f1\u00eda tan interesante como Adafruit ). Lamentablemente, nuestra placa ESP32 DevKit-C no tiene conectores de ese tipo, por lo que necesitaremos conectar directamente los 4 cables: alimentaci\u00f3n, tierra, SCL y SDA. De acuerdo a las especificaciones del sensor Si7021 , el voltaje de entrada no debe superar los 3.6V. La placa de Adafruit proporcionada tiene un regulador de voltaje que nos permite conectar tanto 3.3V como 5V. La secci\u00f3n de la hoja de especificaciones del sensor Si7021 informa acerca del interfaz I2C que ofrece el sensor. Nos indica los 7 bits de direcci\u00f3n del sensor, as\u00ed como de los comandos disponibles (la mayor\u00eda de ellos de 1 byte). La secci\u00f3n 5.1.2 del documento explica c\u00f3mo obtener una medida de temperatura tras haber realizado una medidad de humedad. Para ello usa el comando 0xE0. En nuestro caso deberemos usar 0xE3 o 0xF3. i2ctools (opcional) Compila y prueba el ejemplo i2c_tools de la carpeta de ejemplos ( examples/peripherals/i2c/i2c_tools ). Conecta el sensor a los pines indicados por defecto (tambi\u00e9n a Vcc y a tierra) y ejecuta al comando i2cdetect . Prueba a los distintos comandos disponibles para tratar de leer informaci\u00f3n del sensor.","title":"Sensor Si7021"},{"location":"ANIOT/P4/#ejercicios-obligatorios","text":"","title":"Ejercicios obligatorios"},{"location":"ANIOT/P4/#usar-componente-icm-42670-p-con-nuevo-driver","text":"El registro de componentes de IDF incluye un componente para utilizar la IMU incluida en la placa ESP-RUST-BOARD (con el SoC ESP32-C3): ICM42607/ICM42670 6-Axis MotionTracking (Accelerometer and Gyroscope) . Crea una aplicaci\u00f3n que monitorice el estado del aceler\u00f3metro y determine si la placa est\u00e1 boca arriba o boca abajo. El LED RGB cambiar\u00e1 de color en funci\u00f3n de la orientaci\u00f3n, y se imprimir\u00e1 por terminal el estado actual. Recuerda que, antes de poder usar cualquier dispositivo I2C, es necesario instanciar el controlador de bus I2C que vayamos a utilizar (en este caso, el \u00fainico disponible en esta placa). static i2c_master_bus_handle_t i2c_handle; static void i2c_bus_init(void) { i2c_master_bus_config_t bus_config = { .clk_source = I2C_CLK_SRC_DEFAULT, .i2c_port = I2C_NUM_0, .scl_io_num = 8, .sda_io_num = 10, .glitch_ignore_cnt = 7, .flags.enable_internal_pullup = true, }; ESP_ERROR_CHECK(i2c_new_master_bus(&bus_config, &i2c_handle)); } Asimismo, tras crear el handle del dispositivo, es necesario configurarlo. El componente ofrece una llamada para ello: icm42670_config() . Puedes usar el siguiente c\u00f3digo de configuraci\u00f3n: /* Configuration of the accelerometer and gyroscope */ const icm42670_cfg_t imu_cfg = { .acce_fs = ACCE_FS_2G, .acce_odr = ACCE_ODR_400HZ, .gyro_fs = GYRO_FS_2000DPS, .gyro_odr = GYRO_ODR_400HZ, }; ret = icm42670_config(icm42670, &imu_cfg); Es muy recomendable consultar la carepta test_apps incluida en el propio componente para aprender a utilizarlo. Cuestiones \u00bfQu\u00e9 direcci\u00f3n tiene el dispositivo I2C? \u00bfQu\u00e9 llamada de ESP-IDF utiliza el c\u00f3digo para determinar el device id ? \u00bfQu\u00e9 comando se env\u00eda? Antes de usar el aceler\u00f3metro, es necesario activarlo con la llamada icm42670_acce_set_pwr(icm42670, ACCE_PWR_LOWNOISE); . Describe las transacciones en el bus I2C que se desencadena esa llamada. Usa un formato similar a: START | 0x34 WR | 0x44 ACK | ... | STOP | START .... \u00bfQu\u00e9 comando se utiliza para leer el valor en crudo ( raw ) del aceler\u00f3metro? \u00bfCu\u00e1ntos bytes se leen tras enviar el comando de lectura de aceler\u00f3metro raw ? \u00bfA qu\u00e9 se corresponde cada byte?","title":"Usar componente ICM-42670-P con nuevo driver"},{"location":"ANIOT/P4/#ejercicios-opcionales","text":"","title":"Ejercicios opcionales"},{"location":"ANIOT/P4/#usar-sensor-si7021-en-esp32-devkit-c","text":"Escribe un c\u00f3digo que monitorice la temperatura leyendo el sensor Si7021 conectado al ESP32 devkit-c v4 (placa antigua). Utiliza el nuevo driver para realizar la implementaci\u00f3n.","title":"Usar sensor Si7021 en ESP32 devkit-c"},{"location":"ANIOT/P4/#uso-de-crc-en-sensor","text":"El sensor Si7021 permite el c\u00e1lculo de un byte de checksum (CRC) para comprobar que no ha habido errores en el env\u00edo. Completa el c\u00f3digo del componente para leer dicho byte y comprobar que no ha habido errores. Conviene leer la secci\u00f3n 5.1 y una librer\u00eda para el c\u00e1lculo de CRC como la ofrecida por BARR .","title":"Uso de CRC en sensor"},{"location":"ANIOT/P5/","text":"Pr\u00e1ctica 5. Uso de ADC. Objetivos El objetivo de esta pr\u00e1ctica es continuar conociendo los mecanismos de entrada/salida ofrecidos por ESP-IDF para interaccionar con dispositivos usando ESP32. Trabajaremos los siguientes aspectos del API de ESP-IDF: Uso de un conversor anal\u00f3gico-digital (ADC). Uso de un sensor de infrarrojos para medir distancias. Material de consulta Para ver los detalles de cada aspecto de esta pr\u00e1ctica se recomienda la lectura de los siguientes enlaces: Documentaci\u00f3n del API de ESP-IDF para los 2 ADCs disponibles en modo one-shot . Calibraci\u00f3n de ADC en ESP-IDF La hoja de especificaciones del sensor de infrarrojos SHARP GP2Y0A41SK, disponible en el Campus Virtual M\u00e1s informaci\u00f3n sobre la operaci\u00f3n de una ADC Conversor Anal\u00f3gico-Digital (ADC) Un sensor permite capturar magnitudes f\u00edsicas (temperatura, presi\u00f3n, distancia, intensidad lum\u00ednica...) y transformarlas en una se\u00f1al el\u00e9ctrica anal\u00f3gica mediante un transductor. Un conversor anal\u00f3gico-digital (ADC) muestrea esas se\u00f1ales anal\u00f3gicas y las transforma en una se\u00f1al digital, que podemos procesar en nuestra CPU. Un ADC muestrea peri\u00f3dicamente una se\u00f1al anal\u00f3gica y asigna un valor digital a cada muestra ( sampling y quantization ). El valor se obtiene al dividir el valor del voltaje de entrada muestreado por un voltaje de referencia y multiplic\u00e1ndolo por el n\u00famero de niveles digitales. El valor resultante se representa como un entero, en un formato adecuado para su almacenamiento en memoria y su uso por parte de nuestro procesador. La resoluci\u00f3n de un ADC indica cu\u00e1ntos bits tiene la salida (es decir, cu\u00e1ntos bits emplea para codificar cada muestra que toma de la se\u00f1ala de entrada anal\u00f3gica) La siguiente figura muestra un ejemplo de la cuantizaci\u00f3n de una se\u00f1al anal\u00f3gica (en gris) y su transformaci\u00f3n a una serie de valores, cada uno de ellos codificados usando 3 bits. Otro factor relevante a la hora de escoger un ADC es su frecuencia de muestreo . De acuerdo al Teorema del muestreo para que la se\u00f1al muestreada x(nT) represente fielmente la se\u00f1al anal\u00f3gica x(t) : * x(t) debe ser una se\u00f1al limitada en banda de ancho de banda fN . * La frecuencia de muestreo fs debe ser al menos el doble de la m\u00e1xima frecuencia de la se\u00f1al anal\u00f3gica x(t) . ### ADCs en nuestro ESP32 El ESP32 dispone de 2 ADCs tipo SAR ( Succesive Aproximation-Register ) de 12 bit (es configurable entre 9 y 12 bits). El voltaje de referencia es 1100mV, por lo que deber\u00edamos adaptar la se\u00f1al de entrada a ese rango para obtener la mayor precisi\u00f3n. Hay 2 ADCs disponibles que ofrecen un total de 18 canales: 8 en el ADC1 (GPIO32 - GPIO39) y 10 m\u00e1s en el ADC2 (GPIO0, GPIO2, GPIO4, GPIO12 - GPIO15, GOIO25 - GPIO27. Es mejor evitar el uso de GPIO2, GPIO2 y GPIO15 como canal de ADC. Consultad la documentaci\u00f3n para m\u00e1s detalles ). Es decir, podr\u00edamos muestrear hasta 18 se\u00f1ales anal\u00f3gicas diferentes, conectando cada una a un pin GPIO diferente. Es importante recordar que no podemos usar un mismo GPIO para varios prop\u00f3sitos simult\u00e1neamente (por ejemplo, como entrada digital y como ADC). ADC2 y WiFI Recuerda que la radio WiFi usa el ADC2. Por tanto, tu aplicaci\u00f3n no debe usar ning\u00fan canal del ADC2 si est\u00e1 utilizando la radio WiFi. Voltaje de referencia: atenuaci\u00f3n Aunque el voltaje de referencia indicado por Espressif es de 1100mV, cada placa sufrir\u00e1 peque\u00f1as variaciones durante su fabricaci\u00f3n, que mover\u00e1n ligeramente dicha referencia. Para solventarlo, las placas se someten a una calibraci\u00f3n tras su fabricaci\u00f3n. Todos nuestros SoCs est\u00e1n calibrados y su referencia real est\u00e1 presenta en memoria no vol\u00e1til (eFuse). El ESP32 permite atenuar la se\u00f1al de entrada para adaptarla al rango de referencia (aunque siempre resulta aconsejable hacerlo con un circuito externo si es posible). Atenuaci\u00f3n Rango medible en la entrada ADC_ATTEN_DB_0 100 mV ~ 950 mV ADC_ATTEN_DB_2_5 100 mV ~ 1250 mV ADC_ATTEN_DB_6 150 mV ~ 1750 mV ADC_ATTEN_DB_11 150 mV ~ 2450 mV Lectura del ADC Consulta las transparencias de la asignatura y la documentaci\u00f3n del API de ESP-IDF del modo one-shot as\u00ed como la de la calibraci\u00f3n de ADC en ESP-IDF . Asimismo, es muy recomendable revisar el ejemplo disponible en la distribuci\u00f3n de esp-idf . Lectura del sensor de infrarrojos El sensor GP2Y0A41SK0F de Sharp permite medir distancias de entre 4 y 30cm usando infrarrojos. Combina un PSD ( Position Sensitive Detector ) y IR-LED ( infrared emitting diode ) de manera que puede emitir luz infrarroja y determinar cu\u00e1ndo ha vuelto al sensor tras reflejarse en un obst\u00e1culo cercano. Ese tiempo de vuelo se utiliza para determinar la distancia al objeto. De acuerdo a la hoja de especificaciones que se puede encontrar en el Campus Virtual, este sensor proporciona una tensi\u00f3n en funci\u00f3n de la distancia al obejto m\u00e1s cercano. La siguiente figura muestra esa relaci\u00f3n (figura extra\u00edda de la hoja de especificaciones del sensor): Dicha curva nos indica que, para una distancia de 8cm debemos esperar un voltaje de salida de aprox. 1.58V. Para 22cm, veremos 0.6V en la salida del sensor. Es importante observar que, para distancias inferiores a 4cm, los valores obtenidos en la salida no nos permiten discriminar la distancia de forma correcta. Por tanto, bastar\u00e1 con conectar la salida del sensor (cable amarillo) a un canal ADC de nuestro ESP32 y medir el voltaje que saca el sensor (ojo: no el valor raw del ADC, sino el valor de voltaje que ofrece el sensor). Voltaje a distancia Una vez conseguido el voltaje que est\u00e1 devolviendo el sensor, \u00bfqu\u00e9 expresi\u00f3n usar\u00e1s en el c\u00f3digo para obtener la distancia en cent\u00edmetros? En la p\u00e1gina 3 de la hoja de especificaciones del GP2Y0A41SK0F se nos indica que Vcc = 4.5 - 5.5 V. Por tanto, debemos alimentar el sensor con 5V (cable rojo del sensor al pin de 5V; cable negro a pin de tierra). De acuerdo a la figura anterior (en p\u00e1gina 4 de la hoja de especificaciones), el voltaje de salida del sensor es siempre inferior a 3.3V por lo que en principio no deber\u00eda ser un problema conectar directamente dicha salida (cable amarillo) a un pin GPIO del ESP32 Voltaje de entrada en ESP32 El ESP32 funciona a 3.3V, lo que significa que nunca deber\u00edamos presentarle un voltaje mayor de 3.3V en ning\u00fan pin (configurado como entrada o como ADC). Espressif no especifica claramente si dispone de circuito de protecci\u00f3n en todos los pines, por lo que debemos obrar con cautela. En este ejercicio, conectaremos directamente el sensor de ifnrarrojos a un pin, pero de acuerdo a la hoja de especificaciones (p\u00e1gina 3, primera tabla), el voltaje de salida podr\u00eda ser de Vcc (5V en nuestro caso), potencialmente da\u00f1ando el ESP32. Dicha salida se dar\u00e1 en situaciones extarordinarias de reflexi\u00f3n, y no deber\u00edan producirse en nuestras pruebas (usaremos un folio en blanco). Pero, para mayor robustez y seguridad, convendr\u00eda adaptar la se\u00f1al con un divisor de tensi\u00f3n o un op-amp. Ejercicio: lectura de distancias USaremos el sensor de distancia GP2Y0A41SK0F de Sharp conectado al ADC de ESP32. Deber\u00e1s conectar la alimentaci\u00f3n del senor al pin de 5V del ESP32, las tierras en com\u00fan y el cable de medida a un pin GPIO del ESP32 que configurar\u00e1s para usar un canal de ADC. Muestrear el ADC correspondiente cada segundo, haciendo la media de N lecturas en cada muestreo (siendo N una constante que se puede modificar via menuconfig ). Usad un timer para el muestreo. Se notificar\u00e1 mediante *un evento^, la disponibilidad de un nuevo dato. El c\u00f3digo relativo al acceso al sensor estar\u00e1 en un componente separado con llamadas para la configuraci\u00f3n, arranque/parada de las medidas, y obtener el \u00faltimo valor de distancia medido. El programa principal registar\u00e1 un handle del evento correspondiente. En dicho handle se invocar\u00e1 a la funci\u00f3n del m\u00f3dulo anterior para conseguir el valor de la \u00faltima distancia medida, y se mostrar\u00e1 por pantalla. Se deber\u00e1 comprobar la salida de las funciones invocadas, e informar en caso de error. Utiliza las funciones proporcionadas por ESP-IDF documentadas en su web","title":"Pr\u00e1ctica 5"},{"location":"ANIOT/P5/#practica-5-uso-de-adc","text":"","title":"Pr\u00e1ctica 5. Uso de ADC."},{"location":"ANIOT/P5/#objetivos","text":"El objetivo de esta pr\u00e1ctica es continuar conociendo los mecanismos de entrada/salida ofrecidos por ESP-IDF para interaccionar con dispositivos usando ESP32. Trabajaremos los siguientes aspectos del API de ESP-IDF: Uso de un conversor anal\u00f3gico-digital (ADC). Uso de un sensor de infrarrojos para medir distancias.","title":"Objetivos"},{"location":"ANIOT/P5/#material-de-consulta","text":"Para ver los detalles de cada aspecto de esta pr\u00e1ctica se recomienda la lectura de los siguientes enlaces: Documentaci\u00f3n del API de ESP-IDF para los 2 ADCs disponibles en modo one-shot . Calibraci\u00f3n de ADC en ESP-IDF La hoja de especificaciones del sensor de infrarrojos SHARP GP2Y0A41SK, disponible en el Campus Virtual M\u00e1s informaci\u00f3n sobre la operaci\u00f3n de una ADC","title":"Material de consulta"},{"location":"ANIOT/P5/#conversor-analogico-digital-adc","text":"Un sensor permite capturar magnitudes f\u00edsicas (temperatura, presi\u00f3n, distancia, intensidad lum\u00ednica...) y transformarlas en una se\u00f1al el\u00e9ctrica anal\u00f3gica mediante un transductor. Un conversor anal\u00f3gico-digital (ADC) muestrea esas se\u00f1ales anal\u00f3gicas y las transforma en una se\u00f1al digital, que podemos procesar en nuestra CPU. Un ADC muestrea peri\u00f3dicamente una se\u00f1al anal\u00f3gica y asigna un valor digital a cada muestra ( sampling y quantization ). El valor se obtiene al dividir el valor del voltaje de entrada muestreado por un voltaje de referencia y multiplic\u00e1ndolo por el n\u00famero de niveles digitales. El valor resultante se representa como un entero, en un formato adecuado para su almacenamiento en memoria y su uso por parte de nuestro procesador. La resoluci\u00f3n de un ADC indica cu\u00e1ntos bits tiene la salida (es decir, cu\u00e1ntos bits emplea para codificar cada muestra que toma de la se\u00f1ala de entrada anal\u00f3gica) La siguiente figura muestra un ejemplo de la cuantizaci\u00f3n de una se\u00f1al anal\u00f3gica (en gris) y su transformaci\u00f3n a una serie de valores, cada uno de ellos codificados usando 3 bits. Otro factor relevante a la hora de escoger un ADC es su frecuencia de muestreo . De acuerdo al Teorema del muestreo para que la se\u00f1al muestreada x(nT) represente fielmente la se\u00f1al anal\u00f3gica x(t) : * x(t) debe ser una se\u00f1al limitada en banda de ancho de banda fN . * La frecuencia de muestreo fs debe ser al menos el doble de la m\u00e1xima frecuencia de la se\u00f1al anal\u00f3gica x(t) . ### ADCs en nuestro ESP32 El ESP32 dispone de 2 ADCs tipo SAR ( Succesive Aproximation-Register ) de 12 bit (es configurable entre 9 y 12 bits). El voltaje de referencia es 1100mV, por lo que deber\u00edamos adaptar la se\u00f1al de entrada a ese rango para obtener la mayor precisi\u00f3n. Hay 2 ADCs disponibles que ofrecen un total de 18 canales: 8 en el ADC1 (GPIO32 - GPIO39) y 10 m\u00e1s en el ADC2 (GPIO0, GPIO2, GPIO4, GPIO12 - GPIO15, GOIO25 - GPIO27. Es mejor evitar el uso de GPIO2, GPIO2 y GPIO15 como canal de ADC. Consultad la documentaci\u00f3n para m\u00e1s detalles ). Es decir, podr\u00edamos muestrear hasta 18 se\u00f1ales anal\u00f3gicas diferentes, conectando cada una a un pin GPIO diferente. Es importante recordar que no podemos usar un mismo GPIO para varios prop\u00f3sitos simult\u00e1neamente (por ejemplo, como entrada digital y como ADC). ADC2 y WiFI Recuerda que la radio WiFi usa el ADC2. Por tanto, tu aplicaci\u00f3n no debe usar ning\u00fan canal del ADC2 si est\u00e1 utilizando la radio WiFi.","title":"Conversor Anal\u00f3gico-Digital (ADC)"},{"location":"ANIOT/P5/#voltaje-de-referencia-atenuacion","text":"Aunque el voltaje de referencia indicado por Espressif es de 1100mV, cada placa sufrir\u00e1 peque\u00f1as variaciones durante su fabricaci\u00f3n, que mover\u00e1n ligeramente dicha referencia. Para solventarlo, las placas se someten a una calibraci\u00f3n tras su fabricaci\u00f3n. Todos nuestros SoCs est\u00e1n calibrados y su referencia real est\u00e1 presenta en memoria no vol\u00e1til (eFuse). El ESP32 permite atenuar la se\u00f1al de entrada para adaptarla al rango de referencia (aunque siempre resulta aconsejable hacerlo con un circuito externo si es posible). Atenuaci\u00f3n Rango medible en la entrada ADC_ATTEN_DB_0 100 mV ~ 950 mV ADC_ATTEN_DB_2_5 100 mV ~ 1250 mV ADC_ATTEN_DB_6 150 mV ~ 1750 mV ADC_ATTEN_DB_11 150 mV ~ 2450 mV","title":"Voltaje de referencia: atenuaci\u00f3n"},{"location":"ANIOT/P5/#lectura-del-adc","text":"Consulta las transparencias de la asignatura y la documentaci\u00f3n del API de ESP-IDF del modo one-shot as\u00ed como la de la calibraci\u00f3n de ADC en ESP-IDF . Asimismo, es muy recomendable revisar el ejemplo disponible en la distribuci\u00f3n de esp-idf .","title":"Lectura del ADC"},{"location":"ANIOT/P5/#lectura-del-sensor-de-infrarrojos","text":"El sensor GP2Y0A41SK0F de Sharp permite medir distancias de entre 4 y 30cm usando infrarrojos. Combina un PSD ( Position Sensitive Detector ) y IR-LED ( infrared emitting diode ) de manera que puede emitir luz infrarroja y determinar cu\u00e1ndo ha vuelto al sensor tras reflejarse en un obst\u00e1culo cercano. Ese tiempo de vuelo se utiliza para determinar la distancia al objeto. De acuerdo a la hoja de especificaciones que se puede encontrar en el Campus Virtual, este sensor proporciona una tensi\u00f3n en funci\u00f3n de la distancia al obejto m\u00e1s cercano. La siguiente figura muestra esa relaci\u00f3n (figura extra\u00edda de la hoja de especificaciones del sensor): Dicha curva nos indica que, para una distancia de 8cm debemos esperar un voltaje de salida de aprox. 1.58V. Para 22cm, veremos 0.6V en la salida del sensor. Es importante observar que, para distancias inferiores a 4cm, los valores obtenidos en la salida no nos permiten discriminar la distancia de forma correcta. Por tanto, bastar\u00e1 con conectar la salida del sensor (cable amarillo) a un canal ADC de nuestro ESP32 y medir el voltaje que saca el sensor (ojo: no el valor raw del ADC, sino el valor de voltaje que ofrece el sensor). Voltaje a distancia Una vez conseguido el voltaje que est\u00e1 devolviendo el sensor, \u00bfqu\u00e9 expresi\u00f3n usar\u00e1s en el c\u00f3digo para obtener la distancia en cent\u00edmetros? En la p\u00e1gina 3 de la hoja de especificaciones del GP2Y0A41SK0F se nos indica que Vcc = 4.5 - 5.5 V. Por tanto, debemos alimentar el sensor con 5V (cable rojo del sensor al pin de 5V; cable negro a pin de tierra). De acuerdo a la figura anterior (en p\u00e1gina 4 de la hoja de especificaciones), el voltaje de salida del sensor es siempre inferior a 3.3V por lo que en principio no deber\u00eda ser un problema conectar directamente dicha salida (cable amarillo) a un pin GPIO del ESP32 Voltaje de entrada en ESP32 El ESP32 funciona a 3.3V, lo que significa que nunca deber\u00edamos presentarle un voltaje mayor de 3.3V en ning\u00fan pin (configurado como entrada o como ADC). Espressif no especifica claramente si dispone de circuito de protecci\u00f3n en todos los pines, por lo que debemos obrar con cautela. En este ejercicio, conectaremos directamente el sensor de ifnrarrojos a un pin, pero de acuerdo a la hoja de especificaciones (p\u00e1gina 3, primera tabla), el voltaje de salida podr\u00eda ser de Vcc (5V en nuestro caso), potencialmente da\u00f1ando el ESP32. Dicha salida se dar\u00e1 en situaciones extarordinarias de reflexi\u00f3n, y no deber\u00edan producirse en nuestras pruebas (usaremos un folio en blanco). Pero, para mayor robustez y seguridad, convendr\u00eda adaptar la se\u00f1al con un divisor de tensi\u00f3n o un op-amp.","title":"Lectura del sensor de infrarrojos"},{"location":"ANIOT/P5/#ejercicio-lectura-de-distancias","text":"USaremos el sensor de distancia GP2Y0A41SK0F de Sharp conectado al ADC de ESP32. Deber\u00e1s conectar la alimentaci\u00f3n del senor al pin de 5V del ESP32, las tierras en com\u00fan y el cable de medida a un pin GPIO del ESP32 que configurar\u00e1s para usar un canal de ADC. Muestrear el ADC correspondiente cada segundo, haciendo la media de N lecturas en cada muestreo (siendo N una constante que se puede modificar via menuconfig ). Usad un timer para el muestreo. Se notificar\u00e1 mediante *un evento^, la disponibilidad de un nuevo dato. El c\u00f3digo relativo al acceso al sensor estar\u00e1 en un componente separado con llamadas para la configuraci\u00f3n, arranque/parada de las medidas, y obtener el \u00faltimo valor de distancia medido. El programa principal registar\u00e1 un handle del evento correspondiente. En dicho handle se invocar\u00e1 a la funci\u00f3n del m\u00f3dulo anterior para conseguir el valor de la \u00faltima distancia medida, y se mostrar\u00e1 por pantalla. Se deber\u00e1 comprobar la salida de las funciones invocadas, e informar en caso de error. Utiliza las funciones proporcionadas por ESP-IDF documentadas en su web","title":"Ejercicio: lectura de distancias"},{"location":"ANIOT/P6/","text":"Pr\u00e1ctica 6. Modos de bajo consumo Objetivos El objetivo de esta pr\u00e1ctica es conocer los diferentes modos de bajo consumo que ofrece el ESP32 y la interfaz que expone ESP-IDF para usarlos. Trabajaremos los siguientes aspectos: Paso expl\u00edcito a light-sleep y a deep-sleep . Probar diferentes mecanismos para volver de modos de bajo consumo. Usar el gestor autom\u00e1tico de ahorro energ\u00e9tico. Material de consulta Descripci\u00f3n de modos de bajo consumo Gesti\u00f3n autom\u00e1tica de consumo Ejemplo sobre light-sleep Ejemplo sobre deep-sleep Modos de bajos consumo ESP32 ofrece dos modos de ahorro de consumo energ\u00e9tico: Light-sleep y Deep-sleep . En el modo light-sleep se corta la se\u00f1al de reloj de los perif\u00e9ricos digitales, la mayor parte de la RAM y la CPU; adem\u00e1s, se reduce la tensi\u00f3n de alimentaci\u00f3n, pero se mantiene por encima de la necesaria para retener la informaci\u00f3n. As\u00ed, el sistema no puede ejecutar ninguna tarea, pero no perdemos la informaci\u00f3n almacenada en registros y memoria. Al salir de light-sleep los perif\u00e9ricos digitales, RAM y CPU contin\u00faan su operaci\u00f3n como si nada hubiera pasado. En el modo deep-sleep la CPU, la mayor parte de la RAM y los perif\u00e9ricos cuyo se\u00f1al de reloj viene de APB_CLK se apagan por completo. Las \u00fanicas partes del chip que mantienen alimentaci\u00f3n son: Controlador RTC (Real Time Clock). Para mantener la hora del sistema Co-procesador ULP ( ultra-lowpower ). RTC fast memory RTC slow memory Hay varias fuentes que permiten despertar al sistema cuando se encuentra en deep-sleep o en light-sleep . Podemos especificar varias fuentes de manera que el sistema despierte ante cualquier de ellas. Para configurarlas, ESP-IDF proporciona llamadas de la forma esp_sleep_enable_X_wakeup() ; para deshabilitarlas, existe esp_sleep_disable_wakeup_source() . Tras configurar la(s) fuente(s) que nos permitir\u00e1n salir del modo de bajo consumo, podemos entrar en uno de los dos llamando a esp_light_sleep_start() or esp_deep_sleep_start() . Tanto Wi-Fi como Bluetooth dejar\u00e1n de funcionar y deber\u00edan apagarse antes de entrar en modos de bajo consumo. Si la conexi\u00f3n Wi-Fi debe mantenerse, ser\u00e1 necesario utlizar el gestor autom\u00e1tico de ahorro energ\u00e9tico. Gestor autom\u00e1tico de consumo El Power Manager proporcionado por ESP-IDF permite controlar la frecuencia las se\u00f1ales de reloj de la CPU y del bus APB, e incluso pasar a light-sleep en per\u00edodos de inactividad. Asimismo permite el uso y creaci\u00f3n de cerrojos que, en determinadas fases de nuestra aplicaci\u00f3n, limitan las acciones del gestor de consumo por determinadas necesidades (mantener una velocidad de APB, mantener interrupciones activas...). El gestor autom\u00e1tico se puede habilitar en tiempo de compilaci\u00f3n (a trav\u00e9s de menuconfig ) usando la opci\u00f3n CONFIG_PM_ENABLE . Habilitar esta opci\u00f3n aumenta la latencia del tratamiento de interrupciones y disminuye la precisi\u00f3n del reloj del sistema (utilizado para mantener la hora, timers ...). Adem\u00e1s de hablitar la opci\u00f3n en tiempo de compilaci\u00f3n, es necesario configurar su uso en ejecuci\u00f3n llamando a esp_pm_configure() que recibe un argumento de tipo esp_pm_config_esp32_t que tiene tres campos: max_freq_mhz : frecuencia de CPU m\u00e1xima en MHz. Es la frecuencia que se utilizar\u00e1 cuando el alg\u00fan componente adquiera le cerrojo 'ESP_PM_CPU_FREQ_MAX'. Lo habitual es que se deje a la frecuencia por defecto (240MHZ). min_freq_mhz : frecuencia m\u00ednima en MHz. Es la frecuencia que se usar\u00e1 si se adquiere el cerrojo ESP_PM_APB_FREQ_MAX . light_sleep_enable : indica si el sistema deber\u00eda pasar autom\u00e1ticamente al modo light-sleep en per\u00edodos de inactividad (con ning\u00fan cerrojo adquirido por ning\u00fan componente). Es un valor true o false . Para poder habilitar la tercera opci\u00f3n ( light_sleep_enable ), debemos habilitar la funcionalidad Tickless Idle en Menuconfig con la opci\u00f3n CONFIG_FREERTOS_USE_TICKLESS_IDLE . En caso contrario, esp_pm_configure() devolver\u00e1 el error ESP_ERR_NOT_SUPPORTED si tratamos de habiltar la opci\u00f3n light_sleep_enable . Si todo est\u00e1 configurado correctamente y no hay ning\u00fan cerrojo adquirido, el sistema podr\u00e1 pasar al modo light-sleep tras un per\u00edodo de inactividad. El sistema permanecer\u00e1 en dicho modo en funci\u00f3n de eventos como: Tareas de FreeRTOS bloqueadas por alg\u00fan timeout finito (como vTaskDelay() ). Timers registrados con el API de High resolution timer El sistema saldr\u00e1 de light-sleep para tratar el evento m\u00e1s pr\u00f3ximo. Si queremos que nuestros timers no nos saquen de light-sleep los podemos inicializar con la opci\u00f3n skip_unhandled_events . Librer\u00eda NVS La librer\u00eda Non-volatile storage (NVS) est\u00e1 dise\u00f1ada para almacenar pares clave-valor en memoria flash (soporte no vol\u00e1til). Resulta muy \u00fatil para mantener determinados par\u00e1metros de diferentes m\u00f3dulos de nuestra aplicaci\u00f3n, que queremos mantener almacenados entre diferentes arranques de nuestro sistema. Para utilizar la librer\u00eda es necesario disponer de una partici\u00f3n de tipo NVS en nuestro dispositivo flash. Una partici\u00f3n es una porci\u00f3n del dispositivo de almacenamiento (flash en nuestro caso) a la que daremos una identidad espec\u00edfica. Por ejemplo, una partici\u00f3n contendr\u00e1 la lista de pares clave-valor tal y como los organiza la librer\u00eda NVS. Otra partici\u00f3n puede contener un sistema de ficheros basado en FAT, para que podamos almacenar informaci\u00f3n y distribuirla en ficheros y directorios. En la zona inicial de la flash se ubicar\u00e1 la tabla de particiones que indica qu\u00e9 particiones tendremos en nuestro dipositivo y de qu\u00e9 tama\u00f1o y tipo son cada una de ellas. El ejemplo proporcionado por ESP-IDF es un buen punto de partida para observar el funcionamiento de la API proporcionada por el framework para la gesti\u00f3n de NVS. Tarea Compila y ejecuta el ejemplo nvs_rw_value proporcionado por ESP-IDF. Observa la salida. Ampl\u00edalo para que, adem\u00e1s del n\u00famero de reinicios, se escriba otro par clave-valor en NVS, en este caso almacenando una cadena. Tras cada reinicio, lee el valor de dicha cadena y mu\u00e9stralo por pantalla. Es recomendable que tengas a mano la API para la escritura/lectura de pares . En esa misma secci\u00f3n encontrar\u00e1s ejemplos de uso de las funciones que necesitar\u00e1s para escribir/leer cadenas. Ejercicios b\u00e1sicos Vamos a partir del ejemplo que entra manualmente en light-sleep . Tareas Hacer funcionar el ejemplo, permitiendo que volvamos de light-sleep \u00fanicamente por un timer o por GPIO. Cuesti\u00f3n \u00bfQu\u00e9 n\u00famero de GPIO est\u00e1 configurado por defecto para despertar al sistema? \u00bfEst\u00e1 conectado dicho GPIO a alg\u00fan elemento de la placa ESP Devkit-c que estamos usando? Puedes tratar de responder consultando el esquem\u00e1tico de la placa \u00bfQu\u00e9 flanco provocar\u00e1 que salgamos de light-sleep tras configurar el GPIO con gpio_wakeup_enable(GPIO_WAKEUP_NUM, GPIO_WAKEUP_LEVEL == 0 ? GPIO_INTR_LOW_LEVEL : GPIO_INTR_HIGH_LEVEL) ? Tareas Incluir un timer en el c\u00f3digo. La aplicaci\u00f3n arrancar\u00e1, configurar\u00e1 un timer para que se ejecute su callback cada 0.5 segundos, y se dormir\u00e1 durante 3 segundos (con vTaskDelay() ). Tras despertar del delay , pasar\u00e1 a light-sleep (configuraremos el mecanismo de despertar para que lo haga en 5 segundos, si no usamos el GPIO correspondiente). El callback del timer simplemente imprimir\u00e1 un mensaje que incluir\u00e1 el valor devuelto por esp_timer_get_time() . Cuesti\u00f3n \u00bfQu\u00e9 observas en la ejecuci\u00f3n de los timer ?\u00bfSe ejecutan en el instante adecuado? \u00bfSe pierde alguno? Tareas Modifica el c\u00f3digo anterior para que, tras 5 pasos por light-sleep , pasemos a deep-sleep . Incluye c\u00f3digo para determinar el motivo por el que hemos despertado de deep-sleep y mu\u00e9stralo por pantalla. Cuesti\u00f3n \u00bfQu\u00e9 diferencia se observa al volver de deep-sleep respecto a volver de light-sleep ? Ejercicio final Integraremos el control de energ\u00eda en la aplicaci\u00f3n de la pr\u00e1ctica 3 (monitorizaci\u00f3n de temperatura) Tareas Completar la aplicaci\u00f3n de modo que: Se configure el gestor de energ\u00eda para que entre autom\u00e1ticamente en light-sleep cuando sea posible. Tras 12 horas de funcionamiento, pasar\u00e1 al modo deep-sleep durante otras 12 horas (para pruebas, en lugar de 12 horas probadlo con 1 minuto). Compruebe el motivo por el que se produce cada reinicio y lo anote en NVS. Escriba en NVS la \u00faltima medida del sensor tomada.","title":"Pr\u00e1ctica 6"},{"location":"ANIOT/P6/#practica-6-modos-de-bajo-consumo","text":"","title":"Pr\u00e1ctica 6. Modos de bajo consumo"},{"location":"ANIOT/P6/#objetivos","text":"El objetivo de esta pr\u00e1ctica es conocer los diferentes modos de bajo consumo que ofrece el ESP32 y la interfaz que expone ESP-IDF para usarlos. Trabajaremos los siguientes aspectos: Paso expl\u00edcito a light-sleep y a deep-sleep . Probar diferentes mecanismos para volver de modos de bajo consumo. Usar el gestor autom\u00e1tico de ahorro energ\u00e9tico.","title":"Objetivos"},{"location":"ANIOT/P6/#material-de-consulta","text":"Descripci\u00f3n de modos de bajo consumo Gesti\u00f3n autom\u00e1tica de consumo Ejemplo sobre light-sleep Ejemplo sobre deep-sleep","title":"Material de consulta"},{"location":"ANIOT/P6/#modos-de-bajos-consumo","text":"ESP32 ofrece dos modos de ahorro de consumo energ\u00e9tico: Light-sleep y Deep-sleep . En el modo light-sleep se corta la se\u00f1al de reloj de los perif\u00e9ricos digitales, la mayor parte de la RAM y la CPU; adem\u00e1s, se reduce la tensi\u00f3n de alimentaci\u00f3n, pero se mantiene por encima de la necesaria para retener la informaci\u00f3n. As\u00ed, el sistema no puede ejecutar ninguna tarea, pero no perdemos la informaci\u00f3n almacenada en registros y memoria. Al salir de light-sleep los perif\u00e9ricos digitales, RAM y CPU contin\u00faan su operaci\u00f3n como si nada hubiera pasado. En el modo deep-sleep la CPU, la mayor parte de la RAM y los perif\u00e9ricos cuyo se\u00f1al de reloj viene de APB_CLK se apagan por completo. Las \u00fanicas partes del chip que mantienen alimentaci\u00f3n son: Controlador RTC (Real Time Clock). Para mantener la hora del sistema Co-procesador ULP ( ultra-lowpower ). RTC fast memory RTC slow memory Hay varias fuentes que permiten despertar al sistema cuando se encuentra en deep-sleep o en light-sleep . Podemos especificar varias fuentes de manera que el sistema despierte ante cualquier de ellas. Para configurarlas, ESP-IDF proporciona llamadas de la forma esp_sleep_enable_X_wakeup() ; para deshabilitarlas, existe esp_sleep_disable_wakeup_source() . Tras configurar la(s) fuente(s) que nos permitir\u00e1n salir del modo de bajo consumo, podemos entrar en uno de los dos llamando a esp_light_sleep_start() or esp_deep_sleep_start() . Tanto Wi-Fi como Bluetooth dejar\u00e1n de funcionar y deber\u00edan apagarse antes de entrar en modos de bajo consumo. Si la conexi\u00f3n Wi-Fi debe mantenerse, ser\u00e1 necesario utlizar el gestor autom\u00e1tico de ahorro energ\u00e9tico.","title":"Modos de bajos consumo"},{"location":"ANIOT/P6/#gestor-automatico-de-consumo","text":"El Power Manager proporcionado por ESP-IDF permite controlar la frecuencia las se\u00f1ales de reloj de la CPU y del bus APB, e incluso pasar a light-sleep en per\u00edodos de inactividad. Asimismo permite el uso y creaci\u00f3n de cerrojos que, en determinadas fases de nuestra aplicaci\u00f3n, limitan las acciones del gestor de consumo por determinadas necesidades (mantener una velocidad de APB, mantener interrupciones activas...). El gestor autom\u00e1tico se puede habilitar en tiempo de compilaci\u00f3n (a trav\u00e9s de menuconfig ) usando la opci\u00f3n CONFIG_PM_ENABLE . Habilitar esta opci\u00f3n aumenta la latencia del tratamiento de interrupciones y disminuye la precisi\u00f3n del reloj del sistema (utilizado para mantener la hora, timers ...). Adem\u00e1s de hablitar la opci\u00f3n en tiempo de compilaci\u00f3n, es necesario configurar su uso en ejecuci\u00f3n llamando a esp_pm_configure() que recibe un argumento de tipo esp_pm_config_esp32_t que tiene tres campos: max_freq_mhz : frecuencia de CPU m\u00e1xima en MHz. Es la frecuencia que se utilizar\u00e1 cuando el alg\u00fan componente adquiera le cerrojo 'ESP_PM_CPU_FREQ_MAX'. Lo habitual es que se deje a la frecuencia por defecto (240MHZ). min_freq_mhz : frecuencia m\u00ednima en MHz. Es la frecuencia que se usar\u00e1 si se adquiere el cerrojo ESP_PM_APB_FREQ_MAX . light_sleep_enable : indica si el sistema deber\u00eda pasar autom\u00e1ticamente al modo light-sleep en per\u00edodos de inactividad (con ning\u00fan cerrojo adquirido por ning\u00fan componente). Es un valor true o false . Para poder habilitar la tercera opci\u00f3n ( light_sleep_enable ), debemos habilitar la funcionalidad Tickless Idle en Menuconfig con la opci\u00f3n CONFIG_FREERTOS_USE_TICKLESS_IDLE . En caso contrario, esp_pm_configure() devolver\u00e1 el error ESP_ERR_NOT_SUPPORTED si tratamos de habiltar la opci\u00f3n light_sleep_enable . Si todo est\u00e1 configurado correctamente y no hay ning\u00fan cerrojo adquirido, el sistema podr\u00e1 pasar al modo light-sleep tras un per\u00edodo de inactividad. El sistema permanecer\u00e1 en dicho modo en funci\u00f3n de eventos como: Tareas de FreeRTOS bloqueadas por alg\u00fan timeout finito (como vTaskDelay() ). Timers registrados con el API de High resolution timer El sistema saldr\u00e1 de light-sleep para tratar el evento m\u00e1s pr\u00f3ximo. Si queremos que nuestros timers no nos saquen de light-sleep los podemos inicializar con la opci\u00f3n skip_unhandled_events .","title":"Gestor autom\u00e1tico de consumo"},{"location":"ANIOT/P6/#libreria-nvs","text":"La librer\u00eda Non-volatile storage (NVS) est\u00e1 dise\u00f1ada para almacenar pares clave-valor en memoria flash (soporte no vol\u00e1til). Resulta muy \u00fatil para mantener determinados par\u00e1metros de diferentes m\u00f3dulos de nuestra aplicaci\u00f3n, que queremos mantener almacenados entre diferentes arranques de nuestro sistema. Para utilizar la librer\u00eda es necesario disponer de una partici\u00f3n de tipo NVS en nuestro dispositivo flash. Una partici\u00f3n es una porci\u00f3n del dispositivo de almacenamiento (flash en nuestro caso) a la que daremos una identidad espec\u00edfica. Por ejemplo, una partici\u00f3n contendr\u00e1 la lista de pares clave-valor tal y como los organiza la librer\u00eda NVS. Otra partici\u00f3n puede contener un sistema de ficheros basado en FAT, para que podamos almacenar informaci\u00f3n y distribuirla en ficheros y directorios. En la zona inicial de la flash se ubicar\u00e1 la tabla de particiones que indica qu\u00e9 particiones tendremos en nuestro dipositivo y de qu\u00e9 tama\u00f1o y tipo son cada una de ellas. El ejemplo proporcionado por ESP-IDF es un buen punto de partida para observar el funcionamiento de la API proporcionada por el framework para la gesti\u00f3n de NVS. Tarea Compila y ejecuta el ejemplo nvs_rw_value proporcionado por ESP-IDF. Observa la salida. Ampl\u00edalo para que, adem\u00e1s del n\u00famero de reinicios, se escriba otro par clave-valor en NVS, en este caso almacenando una cadena. Tras cada reinicio, lee el valor de dicha cadena y mu\u00e9stralo por pantalla. Es recomendable que tengas a mano la API para la escritura/lectura de pares . En esa misma secci\u00f3n encontrar\u00e1s ejemplos de uso de las funciones que necesitar\u00e1s para escribir/leer cadenas.","title":"Librer\u00eda NVS"},{"location":"ANIOT/P6/#ejercicios-basicos","text":"Vamos a partir del ejemplo que entra manualmente en light-sleep . Tareas Hacer funcionar el ejemplo, permitiendo que volvamos de light-sleep \u00fanicamente por un timer o por GPIO. Cuesti\u00f3n \u00bfQu\u00e9 n\u00famero de GPIO est\u00e1 configurado por defecto para despertar al sistema? \u00bfEst\u00e1 conectado dicho GPIO a alg\u00fan elemento de la placa ESP Devkit-c que estamos usando? Puedes tratar de responder consultando el esquem\u00e1tico de la placa \u00bfQu\u00e9 flanco provocar\u00e1 que salgamos de light-sleep tras configurar el GPIO con gpio_wakeup_enable(GPIO_WAKEUP_NUM, GPIO_WAKEUP_LEVEL == 0 ? GPIO_INTR_LOW_LEVEL : GPIO_INTR_HIGH_LEVEL) ? Tareas Incluir un timer en el c\u00f3digo. La aplicaci\u00f3n arrancar\u00e1, configurar\u00e1 un timer para que se ejecute su callback cada 0.5 segundos, y se dormir\u00e1 durante 3 segundos (con vTaskDelay() ). Tras despertar del delay , pasar\u00e1 a light-sleep (configuraremos el mecanismo de despertar para que lo haga en 5 segundos, si no usamos el GPIO correspondiente). El callback del timer simplemente imprimir\u00e1 un mensaje que incluir\u00e1 el valor devuelto por esp_timer_get_time() . Cuesti\u00f3n \u00bfQu\u00e9 observas en la ejecuci\u00f3n de los timer ?\u00bfSe ejecutan en el instante adecuado? \u00bfSe pierde alguno? Tareas Modifica el c\u00f3digo anterior para que, tras 5 pasos por light-sleep , pasemos a deep-sleep . Incluye c\u00f3digo para determinar el motivo por el que hemos despertado de deep-sleep y mu\u00e9stralo por pantalla. Cuesti\u00f3n \u00bfQu\u00e9 diferencia se observa al volver de deep-sleep respecto a volver de light-sleep ?","title":"Ejercicios b\u00e1sicos"},{"location":"ANIOT/P6/#ejercicio-final","text":"Integraremos el control de energ\u00eda en la aplicaci\u00f3n de la pr\u00e1ctica 3 (monitorizaci\u00f3n de temperatura) Tareas Completar la aplicaci\u00f3n de modo que: Se configure el gestor de energ\u00eda para que entre autom\u00e1ticamente en light-sleep cuando sea posible. Tras 12 horas de funcionamiento, pasar\u00e1 al modo deep-sleep durante otras 12 horas (para pruebas, en lugar de 12 horas probadlo con 1 minuto). Compruebe el motivo por el que se produce cada reinicio y lo anote en NVS. Escriba en NVS la \u00faltima medida del sensor tomada.","title":"Ejercicio final"},{"location":"ANIOT/P7/","text":"Pr\u00e1ctica 7. Over-The-Air Updates (OTA) Objetivos El objetivo de esta pr\u00e1ctica es familiarizarse con el concepto de OTA, la actualizaci\u00f3n del firmware de forma remota. Espec\u00edficamente, usaremos el interfaz simplificado que ofrece ESP-IDF para realizar la actualizaci\u00f3n de aplicaciones. Trabajaremos los siguientes aspectos: Actualizaci\u00f3n de firmware mendiante HTTPS. Incorporaci\u00f3n de certificados en nuestra aplicaci\u00f3n. Firmado de binarios. Material de consulta Documentaci\u00f3n sobre el mecanismo de OTA Documentaci\u00f3n sobre el proceso de arranque segurlo Documentaci\u00f3n sobre la tabla de particiones de ESP-IDF Ejemplos de OTA proporicionados por ESP-IDF Documentaci\u00f3n sobre c\u00f3mo incluir datos binarios/texto en la app Tutorial b\u00e1sico sobre TLS Over-The-Air Update (OTA) OTA es el nombre que suele dar al proceso de actualizaci\u00f3n de firmware de forma remota, independientemente del mecanismo de comunicaci\u00f3n utilizado (WiFi, Bluetooth, Ethernet...). Dicho proceso implica la recepci\u00f3n de una nueva imagen, su escritura y comprobaci\u00f3n en un dispositivo de almacenamiento (no vol\u00e1til), y el posterior arranque a partor de la nueva imagen. En un despliegue IoT, la funcionalidad OTA es imprescindible. Debe contemplarse desde el inicio en el dise\u00f1o de la aplicaci\u00f3n, porque su buen funcionamiento es cr\u00edtico. Particiones y tabla de particiones Habitualmente, la imagen que se recibe v\u00eda red se almancear\u00e1 en una partici\u00f3n diferente a la que se est\u00e9 actualizando para ejecutar en el dispositivo. Una partici\u00f3n es una regi\u00f3n de un dispositivo de almacenamiento que se gestiona de forma independiente. Se puede ver como un dispositivo virtual en s\u00ed mismo. La tabla de particiones es la estructura que almacena la divisi\u00f3n del dispositivo de almacenamiento en particiones. La tabla indica el tama\u00f1o, tipo y ubicaci\u00f3n de cada una. Se suele almacenar en una posici\u00f3n fija del propio dispositivo y ser de tama\u00f1o fijo. En el caso concreto del ESP32 utilizado, la tabla de particiones se almacena en la flash (\u00fanico dispositivo de almacenamiento presente), en el desplazamiento 0x8000 (32KiB m\u00e1s all\u00e1 del comienzo de la flash ). Tiene un tama\u00f1o de 3072 bytes, m\u00e1s un checksum MD5 almacenado tras la tabla para garantizar la integridad. Por tanto, se asigna un sector de flash (4KiB) para almacenar la tabla. Por defecto, el contenido de la tabla en ESP32 es: # ESP-IDF Partition Table # Name, Type, SubType, Offset, Size, Flags nvs, data, nvs, 0x9000, 0x6000, phy_init, data, phy, 0xf000, 0x1000, factory, app, factory, 0x10000, 1M, Como se puede observar, justo tras la propia tabla (recordemos, en el desplazamiento 0x8000 y de tama\u00f1o un sector), se encuentra una partici\u00f3n de tipo nvs ( Non-Volatile Storage API) cuyo cometido se observ\u00f3 en pr\u00e1cticas anteriores (almacenamiento de pares clave-valor). Esta partici\u00f3n, de 6 sectores (24KiB) por defecto, almacena infomraci\u00f3n de la interfaz WiFi (entre otras) si se utiliza WIFI_STORAGE_FLASH como argumento de esp_wifi_set_storage() (y as\u00ed es por defecto). Se recomienda que el m\u00ednimo de esta partici\u00f3n sea de 3 sectores, y que se haga mayor de 6 si se prev\u00e9 almacenar mucha informaci\u00f3n propia de la aplicaci\u00f3n. La partici\u00f3n phy_init almacena datos de configuraci\u00f3n para la inicializaci\u00f3n del interfaz PHY. Por defecto, esta partici\u00f3n no se utiliza y los datos de inicializaci\u00f3n del PHY se compilan en el propio binario de la aplicaci\u00f3n. Si queremos que se cargue la configuraci\u00f3n PHY desde esta partici\u00f3n (para, por ejemplo, particularizar el calibrado por dispositivo) debemos habilitar CONFIG_ESP_PHY_INIT_DATA_IN_PARTITION en menuconfig y volcar expl\u00edcitamente la partici\u00f3n, ya que no se hace por defecto. Finalmente, la partici\u00f3n factory de tipo app y subtipo factory es la partici\u00f3n donde escribiremos nuestro c\u00f3digo (fichero .bin generado a partir del .elf ) cuando volquemos el proyecto en la placa ( idf.py flash -p <port> ). Particiones para OTA En ESP-IDF, si nuestro proyecto quiere incorporar la posibilidad de actualizarse de forma remota, debemos preverlo desde el comienzo, pues son necesarias varias particiones espec\u00edficas: # Name, Type, SubType, Offset, Size, Flags nvs, data, nvs, 0x9000, 0x4000 otadata, data, ota, 0xd000, 0x2000 phy_init, data, phy, 0xf000, 0x1000 factory, app, factory, 0x10000, 1M ota_0, app, ota_0, , 1M ota_1, app, ota_1, , 1M nvs_key, data, nvs_keys, , 0x1000 Comparando con la tabla anterior, vemos dos tipo de particiones nuevas: otadata de tipo ota . Ocupa dos sectores y mantiene la informaci\u00f3n sobre las particiones ota_ existentes y su estado. Inicialmente, se debe inicializar a 0xFF (todo unos ) para indicar que el arranque se debe hacer desde la partici\u00f3n factory ota_0 y ota_1 . Son dos particiones similares a factory , que almacenar\u00e1n futuras im\u00e1genes recibidas por un interfaz de red. ESP-IDF exige que al menos tengamos dos de estas particiones, pero podemos incluir m\u00e1s. OTA rollback ESP-IDF incluye la posibilidad de hacer rollback tras recibir una nueva imagen. La secuencia de estados por los que pasa una partici\u00f3n es la siguiente: Un posible c\u00f3digo para usar esta funcionalidad ser\u00eda: void app_main(void) { ... const esp_partition_t *running = esp_ota_get_running_partition(); esp_ota_img_states_t ota_state; if (esp_ota_get_state_partition(running, &ota_state) == ESP_OK) { if (ota_state == ESP_OTA_IMG_PENDING_VERIFY) { // run diagnostic function ... bool diagnostic_is_ok = diagnostic(); if (diagnostic_is_ok) { ESP_LOGI(TAG, \"Diagnostics completed successfully! Continuing execution ...\"); esp_ota_mark_app_valid_cancel_rollback(); } else { ESP_LOGE(TAG, \"Diagnostics failed! Start rollback to the previous version ...\"); esp_ota_mark_app_invalid_rollback_and_reboot(); } } } Como se puede comprobar en la figura y en el c\u00f3digo, en un arranque que se produce tras escribir una nueva imagen en flash deber\u00edamos seguir los siguientes pasos: Conseguir el manejador de la partici\u00f3n activa (la que est\u00e1 ejecutando la imagen actualemnte) mediante esp_ota_get_running_partition() Conseguir el estado de dicha partici\u00f3n con esp_ota_get_state_partition() Realizar un diagn\u00f3stico para determinar si esta nueva imagen funciona adecuadamente (llamada a diagnostic() en el c\u00f3digo de ejemplo). Esta funci\u00f3n la debemos desarrollar nosotros mismos, no forma parte de ESP-IDF porque es espec\u00edfica de nuestra aplicaci\u00f3n. Tambi\u00e9n es importante resaltar que no es una comprobaci\u00f3n de la integridad de la imagen o un proceso de autenticaci\u00f3n. La integridad se comprueba tras el env\u00edo. Para la autenticaci\u00f3n (garantizar que el remitente es quien debe ser) podemos obligar a que la imagen venga firmada. ESP-IDF s\u00ed ofrece funcionalidad para esta comprobaci\u00f3n. Si la funcionalidad de la nueva imagen es correcta, llamaremos a esp_ota_mark_app_valid_cancel_rollback() y el estado de esa partici\u00f3n pasar\u00e1 a ESP_OTA_IMG_VALID . Los arranques posteriores (tras reset ) seguir\u00e1n siendo desde esta partici\u00f3n. Si la funcionalidad de la nueva imagen no es correcta, llamaremos a esp_ota_mark_app_invalid_rollback_and_reboot() y el estado de esa partici\u00f3n pasar\u00e1 a ESP_OTA_IMG_INVALID . No se voler\u00e1 a tratar de arrancar esta imange, y se volver\u00e1 a marcar como activa la partici\u00f3n OTA que estuvi\u00e9ramos usando antes de iniciar el proceso de actualizaci\u00f3n. Seguridad Hay varios aspectos que debemos considerar en la seguridad de la operaci\u00f3n OTA: El servidor del que descargamos la nueva imagen es de confianza ( autenticaci\u00f3n ). Usar HTTPS es una opci\u00f3n segura, almacenando el certificado p\u00fablico de dicho servidor (o una cadena de certificados de confianza) en el nodo. Algunos dispositivos disponen de hardware espec\u00edfico para almacenar este tipo de secretos compartidos (claves p\u00fablicas; tambi\u00e9n claves privadas en ocasiones), pero no es el caso de nuestro ESP32. Al usar HTTPS, se usar\u00e1 el protocolo TLS para garantizar la autenticaci\u00f3n, integridad y confidencialidad de las comunicaciones. Para ello, debemos usar certificados TLS: una clave p\u00fablica con cierta informaci\u00f3n incorporada. Este certificiado puede ser autofirmado, como haremos en esta pr\u00e1ctica, o podemos tener que usar una entidad certificadora (CA - Certification Authority). Revisad las opciones de compilaci\u00f3n para saber c\u00f3mo podemos incrustar el certificado en nuestro binario La imagen recibida es de confianza. Parte de este aspecto queda cubierto por la garant\u00eda de integridad de TLS, pero podemos ir un paso m\u00e1s all\u00e1: podemos requerir que la imagen recibida est\u00e9 firmada. Nuevamente, exigir\u00e1 la generaci\u00f3n de un par de claves para la firma del binario (con la clave privada) y su comprobaci\u00f3n (con la clave p\u00fablica). Puedes leer acerca de este proceso en la documentaci\u00f3n de ESP-IDF IMPORTANTE NO habilit\u00e9is nunca el arranque seguro (Secure Boot) en menuconfig . Una vez activado, no podemos desactivarlo, y supondr\u00eda un problema para el hardware del laboratorio. Es posible habilitar \u00fanicamente la verificaci\u00f3n de la APP sin el arranque segruo completo. Ejercicios b\u00e1sicos Vamos a partir del ejemplo de OTA b\u00e1sico . Estudia el c\u00f3digo, y responde a las siguientes preguntas: Cuesti\u00f3n \u00bfQu\u00e9 entradas tiene la tabla de particiones usada? \u00bfC\u00f3mo se llama el fichero de certificado que se incluir\u00e1 en el binario? \u00bfC\u00f3mo y d\u00f3nde se indica que se debe incluir el certificado? \u00bfQu\u00e9 es el s\u00edmbolo server_cert_pem_start ? Tareas Hacer funcionar el ejemplo conectando a un servidor que estar\u00e1 ejecutando en el equipo del profesor. Se usar\u00e1 el certificado proporcionado en Campus Virtual y la red WiFi creada en el laboratorio. Se proporcionara\u00e1n los credenciales de la WiFi y la IP del servidor durante el laboratorio. Alterar un byte del fichero del certificado y probar nuevamente. Seguir los pasos del ejemplo para crear vuestro propio servidor HTTPS y certificado y probad de nuevo. Ejercicio avanzado Integraremos OTA en la aplicaci\u00f3n que hemos ido desarrollando a lo largo de estas pr\u00e1cticas (lectura peri\u00f3dica del sensor de temperatura). Tareas La aplicaci\u00f3n inicial corresponder\u00e1 con una aplicaci\u00f3n similar a la de pr\u00e1cticas anteriores: una lectura peri\u00f3dica del sensor de temperatura. Se a\u00f1adir\u00e1 la siguiente funcionalidad: Cuando se reciba un evento externo (la pulsaci\u00f3n de un bot\u00f3n, la lectura del sensor de infrarrojos de una distancia menor que un umbral o la recepci\u00f3n de un mensaje MQTT), la aplicaci\u00f3n se conectar\u00e1 al servidor HTTPS predefinido y se bajar\u00e1 la nueva imagen (si se usa MQTT, la URL del servidor y el nombre de la nueva imagen se pueden comunicar en el mensaje; pero el certificado deber\u00eda estar preinstalado). Se desarrollar\u00e1 una funci\u00f3n de auto-diagn\u00f3stico ( self-test ) que permita decidir si la nueva imagen se comporta de forma correcta. Se utilizar\u00e1 la opci\u00f3n de rollback para indicar si la nueva imagen se elige para futuros arranques o se marca como inv\u00e1lida. Para investigar... HTTPS (SSL/TLS) no exige tener pre-almacenado el certificado de cada servidor al que nos queramos conectar. Es el propio servidor el que env\u00eda el certificado, firmado con la clave privada de una autoridad certificador ( CA ) que s\u00ed debemos conocer. Es un papel similar al de un notario, que valida el certificado de un servidor para que podamos confiar en su identidad. Investiga qu\u00e9 ofrece ESP-IDF para configurar as\u00ed nuestro sistema, de modo que no tengamos que cargar el certificado de un servidor concreto, sino el de una CA (o una cadena de CAs). Enlaces recomendados para empezar: ESP x509 Certififcate Budle ESP-TLS Mbed TLS","title":"Pr\u00e1ctica 7"},{"location":"ANIOT/P7/#practica-7-over-the-air-updates-ota","text":"","title":"Pr\u00e1ctica 7. Over-The-Air Updates (OTA)"},{"location":"ANIOT/P7/#objetivos","text":"El objetivo de esta pr\u00e1ctica es familiarizarse con el concepto de OTA, la actualizaci\u00f3n del firmware de forma remota. Espec\u00edficamente, usaremos el interfaz simplificado que ofrece ESP-IDF para realizar la actualizaci\u00f3n de aplicaciones. Trabajaremos los siguientes aspectos: Actualizaci\u00f3n de firmware mendiante HTTPS. Incorporaci\u00f3n de certificados en nuestra aplicaci\u00f3n. Firmado de binarios.","title":"Objetivos"},{"location":"ANIOT/P7/#material-de-consulta","text":"Documentaci\u00f3n sobre el mecanismo de OTA Documentaci\u00f3n sobre el proceso de arranque segurlo Documentaci\u00f3n sobre la tabla de particiones de ESP-IDF Ejemplos de OTA proporicionados por ESP-IDF Documentaci\u00f3n sobre c\u00f3mo incluir datos binarios/texto en la app Tutorial b\u00e1sico sobre TLS","title":"Material de consulta"},{"location":"ANIOT/P7/#over-the-air-update-ota","text":"OTA es el nombre que suele dar al proceso de actualizaci\u00f3n de firmware de forma remota, independientemente del mecanismo de comunicaci\u00f3n utilizado (WiFi, Bluetooth, Ethernet...). Dicho proceso implica la recepci\u00f3n de una nueva imagen, su escritura y comprobaci\u00f3n en un dispositivo de almacenamiento (no vol\u00e1til), y el posterior arranque a partor de la nueva imagen. En un despliegue IoT, la funcionalidad OTA es imprescindible. Debe contemplarse desde el inicio en el dise\u00f1o de la aplicaci\u00f3n, porque su buen funcionamiento es cr\u00edtico.","title":"Over-The-Air Update (OTA)"},{"location":"ANIOT/P7/#particiones-y-tabla-de-particiones","text":"Habitualmente, la imagen que se recibe v\u00eda red se almancear\u00e1 en una partici\u00f3n diferente a la que se est\u00e9 actualizando para ejecutar en el dispositivo. Una partici\u00f3n es una regi\u00f3n de un dispositivo de almacenamiento que se gestiona de forma independiente. Se puede ver como un dispositivo virtual en s\u00ed mismo. La tabla de particiones es la estructura que almacena la divisi\u00f3n del dispositivo de almacenamiento en particiones. La tabla indica el tama\u00f1o, tipo y ubicaci\u00f3n de cada una. Se suele almacenar en una posici\u00f3n fija del propio dispositivo y ser de tama\u00f1o fijo. En el caso concreto del ESP32 utilizado, la tabla de particiones se almacena en la flash (\u00fanico dispositivo de almacenamiento presente), en el desplazamiento 0x8000 (32KiB m\u00e1s all\u00e1 del comienzo de la flash ). Tiene un tama\u00f1o de 3072 bytes, m\u00e1s un checksum MD5 almacenado tras la tabla para garantizar la integridad. Por tanto, se asigna un sector de flash (4KiB) para almacenar la tabla. Por defecto, el contenido de la tabla en ESP32 es: # ESP-IDF Partition Table # Name, Type, SubType, Offset, Size, Flags nvs, data, nvs, 0x9000, 0x6000, phy_init, data, phy, 0xf000, 0x1000, factory, app, factory, 0x10000, 1M, Como se puede observar, justo tras la propia tabla (recordemos, en el desplazamiento 0x8000 y de tama\u00f1o un sector), se encuentra una partici\u00f3n de tipo nvs ( Non-Volatile Storage API) cuyo cometido se observ\u00f3 en pr\u00e1cticas anteriores (almacenamiento de pares clave-valor). Esta partici\u00f3n, de 6 sectores (24KiB) por defecto, almacena infomraci\u00f3n de la interfaz WiFi (entre otras) si se utiliza WIFI_STORAGE_FLASH como argumento de esp_wifi_set_storage() (y as\u00ed es por defecto). Se recomienda que el m\u00ednimo de esta partici\u00f3n sea de 3 sectores, y que se haga mayor de 6 si se prev\u00e9 almacenar mucha informaci\u00f3n propia de la aplicaci\u00f3n. La partici\u00f3n phy_init almacena datos de configuraci\u00f3n para la inicializaci\u00f3n del interfaz PHY. Por defecto, esta partici\u00f3n no se utiliza y los datos de inicializaci\u00f3n del PHY se compilan en el propio binario de la aplicaci\u00f3n. Si queremos que se cargue la configuraci\u00f3n PHY desde esta partici\u00f3n (para, por ejemplo, particularizar el calibrado por dispositivo) debemos habilitar CONFIG_ESP_PHY_INIT_DATA_IN_PARTITION en menuconfig y volcar expl\u00edcitamente la partici\u00f3n, ya que no se hace por defecto. Finalmente, la partici\u00f3n factory de tipo app y subtipo factory es la partici\u00f3n donde escribiremos nuestro c\u00f3digo (fichero .bin generado a partir del .elf ) cuando volquemos el proyecto en la placa ( idf.py flash -p <port> ).","title":"Particiones y tabla de particiones"},{"location":"ANIOT/P7/#particiones-para-ota","text":"En ESP-IDF, si nuestro proyecto quiere incorporar la posibilidad de actualizarse de forma remota, debemos preverlo desde el comienzo, pues son necesarias varias particiones espec\u00edficas: # Name, Type, SubType, Offset, Size, Flags nvs, data, nvs, 0x9000, 0x4000 otadata, data, ota, 0xd000, 0x2000 phy_init, data, phy, 0xf000, 0x1000 factory, app, factory, 0x10000, 1M ota_0, app, ota_0, , 1M ota_1, app, ota_1, , 1M nvs_key, data, nvs_keys, , 0x1000 Comparando con la tabla anterior, vemos dos tipo de particiones nuevas: otadata de tipo ota . Ocupa dos sectores y mantiene la informaci\u00f3n sobre las particiones ota_ existentes y su estado. Inicialmente, se debe inicializar a 0xFF (todo unos ) para indicar que el arranque se debe hacer desde la partici\u00f3n factory ota_0 y ota_1 . Son dos particiones similares a factory , que almacenar\u00e1n futuras im\u00e1genes recibidas por un interfaz de red. ESP-IDF exige que al menos tengamos dos de estas particiones, pero podemos incluir m\u00e1s.","title":"Particiones para OTA"},{"location":"ANIOT/P7/#ota-rollback","text":"ESP-IDF incluye la posibilidad de hacer rollback tras recibir una nueva imagen. La secuencia de estados por los que pasa una partici\u00f3n es la siguiente: Un posible c\u00f3digo para usar esta funcionalidad ser\u00eda: void app_main(void) { ... const esp_partition_t *running = esp_ota_get_running_partition(); esp_ota_img_states_t ota_state; if (esp_ota_get_state_partition(running, &ota_state) == ESP_OK) { if (ota_state == ESP_OTA_IMG_PENDING_VERIFY) { // run diagnostic function ... bool diagnostic_is_ok = diagnostic(); if (diagnostic_is_ok) { ESP_LOGI(TAG, \"Diagnostics completed successfully! Continuing execution ...\"); esp_ota_mark_app_valid_cancel_rollback(); } else { ESP_LOGE(TAG, \"Diagnostics failed! Start rollback to the previous version ...\"); esp_ota_mark_app_invalid_rollback_and_reboot(); } } } Como se puede comprobar en la figura y en el c\u00f3digo, en un arranque que se produce tras escribir una nueva imagen en flash deber\u00edamos seguir los siguientes pasos: Conseguir el manejador de la partici\u00f3n activa (la que est\u00e1 ejecutando la imagen actualemnte) mediante esp_ota_get_running_partition() Conseguir el estado de dicha partici\u00f3n con esp_ota_get_state_partition() Realizar un diagn\u00f3stico para determinar si esta nueva imagen funciona adecuadamente (llamada a diagnostic() en el c\u00f3digo de ejemplo). Esta funci\u00f3n la debemos desarrollar nosotros mismos, no forma parte de ESP-IDF porque es espec\u00edfica de nuestra aplicaci\u00f3n. Tambi\u00e9n es importante resaltar que no es una comprobaci\u00f3n de la integridad de la imagen o un proceso de autenticaci\u00f3n. La integridad se comprueba tras el env\u00edo. Para la autenticaci\u00f3n (garantizar que el remitente es quien debe ser) podemos obligar a que la imagen venga firmada. ESP-IDF s\u00ed ofrece funcionalidad para esta comprobaci\u00f3n. Si la funcionalidad de la nueva imagen es correcta, llamaremos a esp_ota_mark_app_valid_cancel_rollback() y el estado de esa partici\u00f3n pasar\u00e1 a ESP_OTA_IMG_VALID . Los arranques posteriores (tras reset ) seguir\u00e1n siendo desde esta partici\u00f3n. Si la funcionalidad de la nueva imagen no es correcta, llamaremos a esp_ota_mark_app_invalid_rollback_and_reboot() y el estado de esa partici\u00f3n pasar\u00e1 a ESP_OTA_IMG_INVALID . No se voler\u00e1 a tratar de arrancar esta imange, y se volver\u00e1 a marcar como activa la partici\u00f3n OTA que estuvi\u00e9ramos usando antes de iniciar el proceso de actualizaci\u00f3n.","title":"OTA rollback"},{"location":"ANIOT/P7/#seguridad","text":"Hay varios aspectos que debemos considerar en la seguridad de la operaci\u00f3n OTA: El servidor del que descargamos la nueva imagen es de confianza ( autenticaci\u00f3n ). Usar HTTPS es una opci\u00f3n segura, almacenando el certificado p\u00fablico de dicho servidor (o una cadena de certificados de confianza) en el nodo. Algunos dispositivos disponen de hardware espec\u00edfico para almacenar este tipo de secretos compartidos (claves p\u00fablicas; tambi\u00e9n claves privadas en ocasiones), pero no es el caso de nuestro ESP32. Al usar HTTPS, se usar\u00e1 el protocolo TLS para garantizar la autenticaci\u00f3n, integridad y confidencialidad de las comunicaciones. Para ello, debemos usar certificados TLS: una clave p\u00fablica con cierta informaci\u00f3n incorporada. Este certificiado puede ser autofirmado, como haremos en esta pr\u00e1ctica, o podemos tener que usar una entidad certificadora (CA - Certification Authority). Revisad las opciones de compilaci\u00f3n para saber c\u00f3mo podemos incrustar el certificado en nuestro binario La imagen recibida es de confianza. Parte de este aspecto queda cubierto por la garant\u00eda de integridad de TLS, pero podemos ir un paso m\u00e1s all\u00e1: podemos requerir que la imagen recibida est\u00e9 firmada. Nuevamente, exigir\u00e1 la generaci\u00f3n de un par de claves para la firma del binario (con la clave privada) y su comprobaci\u00f3n (con la clave p\u00fablica). Puedes leer acerca de este proceso en la documentaci\u00f3n de ESP-IDF IMPORTANTE NO habilit\u00e9is nunca el arranque seguro (Secure Boot) en menuconfig . Una vez activado, no podemos desactivarlo, y supondr\u00eda un problema para el hardware del laboratorio. Es posible habilitar \u00fanicamente la verificaci\u00f3n de la APP sin el arranque segruo completo.","title":"Seguridad"},{"location":"ANIOT/P7/#ejercicios-basicos","text":"Vamos a partir del ejemplo de OTA b\u00e1sico . Estudia el c\u00f3digo, y responde a las siguientes preguntas: Cuesti\u00f3n \u00bfQu\u00e9 entradas tiene la tabla de particiones usada? \u00bfC\u00f3mo se llama el fichero de certificado que se incluir\u00e1 en el binario? \u00bfC\u00f3mo y d\u00f3nde se indica que se debe incluir el certificado? \u00bfQu\u00e9 es el s\u00edmbolo server_cert_pem_start ? Tareas Hacer funcionar el ejemplo conectando a un servidor que estar\u00e1 ejecutando en el equipo del profesor. Se usar\u00e1 el certificado proporcionado en Campus Virtual y la red WiFi creada en el laboratorio. Se proporcionara\u00e1n los credenciales de la WiFi y la IP del servidor durante el laboratorio. Alterar un byte del fichero del certificado y probar nuevamente. Seguir los pasos del ejemplo para crear vuestro propio servidor HTTPS y certificado y probad de nuevo.","title":"Ejercicios b\u00e1sicos"},{"location":"ANIOT/P7/#ejercicio-avanzado","text":"Integraremos OTA en la aplicaci\u00f3n que hemos ido desarrollando a lo largo de estas pr\u00e1cticas (lectura peri\u00f3dica del sensor de temperatura). Tareas La aplicaci\u00f3n inicial corresponder\u00e1 con una aplicaci\u00f3n similar a la de pr\u00e1cticas anteriores: una lectura peri\u00f3dica del sensor de temperatura. Se a\u00f1adir\u00e1 la siguiente funcionalidad: Cuando se reciba un evento externo (la pulsaci\u00f3n de un bot\u00f3n, la lectura del sensor de infrarrojos de una distancia menor que un umbral o la recepci\u00f3n de un mensaje MQTT), la aplicaci\u00f3n se conectar\u00e1 al servidor HTTPS predefinido y se bajar\u00e1 la nueva imagen (si se usa MQTT, la URL del servidor y el nombre de la nueva imagen se pueden comunicar en el mensaje; pero el certificado deber\u00eda estar preinstalado). Se desarrollar\u00e1 una funci\u00f3n de auto-diagn\u00f3stico ( self-test ) que permita decidir si la nueva imagen se comporta de forma correcta. Se utilizar\u00e1 la opci\u00f3n de rollback para indicar si la nueva imagen se elige para futuros arranques o se marca como inv\u00e1lida. Para investigar... HTTPS (SSL/TLS) no exige tener pre-almacenado el certificado de cada servidor al que nos queramos conectar. Es el propio servidor el que env\u00eda el certificado, firmado con la clave privada de una autoridad certificador ( CA ) que s\u00ed debemos conocer. Es un papel similar al de un notario, que valida el certificado de un servidor para que podamos confiar en su identidad. Investiga qu\u00e9 ofrece ESP-IDF para configurar as\u00ed nuestro sistema, de modo que no tengamos que cargar el certificado de un servidor concreto, sino el de una CA (o una cadena de CAs). Enlaces recomendados para empezar: ESP x509 Certififcate Budle ESP-TLS Mbed TLS","title":"Ejercicio avanzado"},{"location":"ANIOT/P7/index2/","text":"Pr\u00e1ctica 7 (adicional). OTA en Thingsboard Objetivos El objetivo de esta pr\u00e1ctica es familiarizarse con el proceso de OTA en la plataforma Thingsboard, para realizar actualizaciones de fimware/software de forma remota. Note Esta parte de la pr\u00e1ctica se considera opcional y no entregable. Sin embargo, se solicitar\u00e1 la integraci\u00f3n del proceso de OTA desde Thingsboard en el trabajo final de integraci\u00f3n del M\u00f3dulo Tecnolog\u00eda, por lo que se sugiere al menos completar las partes esenciales del bolet\u00edn. Trabajaremos los siguientes aspectos: Actualizaci\u00f3n de firmware mendiante MQTT en Thingsboard. Interacci\u00f3n a trav\u00e9s de la plataforma para la actualizaci\u00f3n de firmware. Desarrollo de un panel de control para monitorizaci\u00f3n de actualizaciones. Material de consulta Documentaci\u00f3n sobre el mecanismo de OTA en Thingsboard Over-The-Air Update (OTA) en Thingsboard En versiones modernas de la plataforma (desde su versi\u00f3n 3.3), Thingsboard permite procesar y distribuir actualizaciones OTA a dispositivos. Los tenants de la plataforma pueen subir a un repositorio de OTAs (bien gr\u00e1ficamente, o bien mediante una API) im\u00e1genes que pueden a continuaci\u00f3n asignarse a dispositivos individuales o perfiles de dispositivo. Thingsboard se encarga, a partir de ese unto, de notificar al dispositivo sobre la disponibilidad de una nueva versi\u00f3n, y proporciona una API espec\u00edfica (usando LWM2M, HTTP(s), MQTT(s) o CoAP) para llevar a cabo la descarga. Adem\u00e1s, la plataforma monitoriza el proceso de actualizaci\u00f3n y mantiene un historial de las actualizaciones llevadas a cabo en cada dispositivo: Gesti\u00f3n del repositorio de im\u00e1genes Navegando hasta la entrada del men\u00fa principal titulada \"OTA Updates\" (Actualizaciones OTA), podemos encontrar la lista paquetes de actualizaci\u00f3n disponibles. Cada paquete viene descrito por: T\u00edtulo . Nombre del paquete. Versi\u00f3n . Versi\u00f3n del paquete. La combinaci\u00f3n de t\u00edtulo y versi\u00f3n debe ser \u00fanica para cada tenant de la plataforma. Perfil de dispositivo . Cada paquete es compatible con un perfil de dispositivo. Tipo . Puede ser firmware (FOTA) o software (SOTA). Nosotros utilizaremos la primera opci\u00f3n. Algoritmo de checksum . Par\u00e1metro opcional, con el nombre del algoritmo de checksum a usar. Checksum . Par\u00e1metro opcional que contiene el valor del checksum calculado para el fichero correspondiente. Si no se indica lo contrario, la plataforma utilizar\u00e1 SHA256 como algoritmo de c\u00e1lculo de checksum. Descripci\u00f3n . Texto opcional y libre que describe al firmware. Tarea Crea en el repositorio de im\u00e1genes tantos paquetes como desees. Puedes subir im\u00e1genes ESP32 (ficheros .bin) creadas, o en general, cualquier tipo de fichero. Asignaci\u00f3n de paquetes OTA a perfiles de dispositivo Podemos asignar paquetes de firmware a perfiles de dispositivo para distribuir autom\u00e1ticamente el paquete a todos los dispositivos que compartan dicho perfil: El perfil de dispositivo permite que si asignamos un paquete de firmware al perfil, se lance un proceso de actualizaci\u00f3n en todos los dispositivos que pertenecen a dicho perfil, ahorrando tiempo. Asignaci\u00f3n de paquetes OTA a dispositivos Es posible asignar im\u00e1genes de firmware/software a dispositivos espec\u00edficos. Observa los pasos en las siguientes capturas: La versi\u00f3n de firmware asignada a un dispositivo sobreescribir\u00e1 la versi\u00f3n del firmware que se ha asignado al perfil de dispositivo. Por ejemplo, asumamos que disponemos de los dispositivos D1 y D2 con perfil P1: Si asignamos el paquete F1 al perfil P1 (a trav\u00e9s de la UI de gesti\u00f3n del perfil vista en el punto anterior), los dispositivos D1 y D2 se actualizar\u00e1n a F1. Si asignamos el paquete F2 al dispositivo D1 (a trav\u00e9s de la UI de gesti\u00f3n del dispositivo), solo D1 se actualizar\u00e1 a F2. si asignamos el paquete F3 al perfil P1 solo afectar\u00e1 a D2, porque no tiene versi\u00f3n espec\u00edfica de firmware asignada a nivel de dispositivo individual. Proceso de actualizaci\u00f3n La asignaci\u00f3n de firmware/software a un dispositivo o perfil de dispositivo desencadena autom\u00e1ticamente un proceso de actualicaci\u00f3n. Thingsboard mantiene monitorizado el proceso de actualizaci\u00f3n a trav\u00e9s de los atributos del dispositivo. El proceso de actualizaci\u00f3n puede residir en un instante determinado en uno de los siguientes estados. Dicho estado se almacena com oun atributo de dispositivo y se usa para visualizar el proceso en un dashboard. Estado QUEUED Es el primer estado de la actualizaci\u00f3n, marcado por el servidor. Significa que l anotificaci\u00f3n sobre nuevo firmware disponible est\u00e1 encolada pero todav\u00eda no se ha llevado al dispositivo. Thingsboard encola las notificaciones para evitar picos de peticiones en el tiempo, ya que la cola se procesa ritmo constante, independientemente del n\u00famero de peticiones (por defecto, se sirven 100 peticiones por minuto). Estado INITIATED Significa que la notificaci\u00f3n se ha enviado al dispositivo tras extraerla de la cola. Por debajo, Thingsboard convierte la notificaci\u00f3n en una actualizaci\u00f3n de los siguientes atributos compartidos (visibles por tanto para el dispositivo): fw_title . Nombre del firmware. fw_version . Versi\u00f3n del firmware. fw_size . Tama\u00f1o del firmware en bytes. fw_checksum . Suma de verificaci\u00f3n del paquete recibido. fw_checksum_algorithm . Algoritmo que se usar\u00e1 para verificar la integridad del paquete recibido. El resto de estados se reportan por el dispositivo que est\u00e1 procesando la actualizaci\u00f3n, y no por el servidor: Estado DOWNLOADING El paquete est\u00e1 siendo descargado tras la recepci\u00f3n de la notificaci\u00f3n de nuevo firmware/software. Estado DOWNLOADED El paquete ha sido descargado. Estado VERIFIED El dispositivo ha verificado con \u00e9xito el checksum. Estado UPDATING El dispositivo ha comenzado la actualizaci\u00f3n. T\u00edpicamente se env\u00eda ants del reinicio del dispositivo (en el caso de FOTA) o servicio (para SOTA). Estado UPDATED El firmware fue correctamente actualizado a la nueva versi\u00f3n. Estado FAILED El checksum no fue verificado, o el dispositivo fallo en el proceso de actualizaci\u00f3n. Una vez el firmware se ha actualizado con \u00e9xito, Thingsboard espera que el usuario env\u00ede la siguiente telemetr\u00eda: {\"current_fw_title\": \"myFirmware\", \"current_fw_version\": \"1.2.3\", \"fw_state\": \"UPDATED\"} En caso de error, la plataforma espera la recepci\u00f3n de la siguiente telemetr\u00eda: {\"fw_state\": \"FAILED\", \"fw_error\": \"causa del error (legible)\"} API MQTT de gesti\u00f3n de OTA/firmware Cuando Thingsboard inicia un proceso de actualizaci\u00f3n de firmware v\u00eda MQTT, establece los atributos compartidos fw_title , fw_version , fw_checksum y fw_checksum_algorithm , como se ha dicho anteriormente. Para recibir actualizaciones de estos atributos compartidos, el dispositivo debe suscribirse a: v1/devices/me/attributes/response/+ Cuando el dispositivo recibe actualizaciones para fw_title y fw_version , \u00e9ste debe publicar v\u00eda MQTT un mensaje bajo el topic: v2/fw/request/${requestId}/chunk/${chunkIndex} donde: ${requestId} es un n\u00famero correspondiente al n\u00famero de acuatlizaciones firmware desarrolladas por el dispositivo, que debe ser \u00fanico y diferente para cada actualizaci\u00f3n de firmware. ${chunkIndex} es un n\u00famero correspondiente al \u00edndice de los fragmentos (chunks) de firmware recibidos; comienzan a contar en 0. El dispositivo debe incrementar el \u00edndice para cada petici\u00f3n, hasta que el chunk recibido sea 0. El payload debe ser el tama\u00f1o del chunk en bytes. Para cada actualizaci\u00f3n, debe modificarse el ID de la petici\u00f3n y suscribirse a: v2/fw/response/+/chunk/+ Simulaci\u00f3n de una actualizaci\u00f3n OTA desde Python usando la API MQTT A continuaci\u00f3n, se propone el uso de un script Python sencillo que gestiona la actualizaci\u00f3n OTA simulando un dispositivo cliente. El objetivo es que este script sirva de base para implementar los componentes necesario en ESP-IDF que permitan la actualizaci\u00f3n remota de nuestros dispositivos. Al igual que en la pr\u00e1ctica sobre provisionamiento, crea un entorno virtual e instala los paquetes necearios para la ejecuci\u00f3n del script: python3 -m venv entorno source entorno/bin/activate pip3 install paho-mqtt mmh3 --user A continuaci\u00f3n, descarga el script Python desde este enlace . En la documentaci\u00f3n de la plataforma tienes scripts equivalentes para HTTP y CoAP. Ejecuta el script: python3 mqtt_firmware_client.py El script solicitar\u00e1 ciertos valores para configurar el cliente, incluyendo la URL y puerto de la instalaci\u00f3n de ThingsBoard que est\u00e9s usando, el token del dispositivo y el tama\u00f1o de cada fragmento de fichero descargado (si se desea fragmentar la recepci\u00f3n). Si todo es correcto, el dispositivo emular\u00e1 la actualizaci\u00f3n del software, simplemente descargando y almacenando en disco el fichero correspondiente: Tarea Ejecuta el cliente para un dispositivo existente en Thingsboard. Prepara un paquete de actualizaci\u00f3n y lanza el proceso. Observa lo que ocurre en el cliente. Comprueba que efectivamente el fichero recibido es el que subiste a la plataforma (visualmente, o calculando su checksum). Tarea Repite el proceso con m\u00faltiples clientes conectados bajo un mismo perfil, y gestiona la actualizaci\u00f3n con un \u00fanico paquete para todos los dispositivos. Comprueba que la l\u00f3gica de versiones para dispositivos individuales anteriormente explicada se cumple. An\u00e1lisis del proceso de actualizaci\u00f3n Tras recoger los datos proporcionados por el usuario, el cliente instancia un cliente PAHO MQTT, y conecta al broker proporcionado. Pregunta \u00bfQu\u00e9 credenciales se utilizan en el proceso de conexi\u00f3n? M\u00e9todo __on_connect La funci\u00f3n __on_connect se procesa si la conexi\u00f3n al broker ha tenido \u00e9xito. Pregunta \u00bfA qu\u00e9 topics se suscribe el cliente tras conectar con el broker? \u00bfQu\u00e9 datos de telemetr\u00eda env\u00eda? Por \u00faltimo, el cliente invoca a la funci\u00f3n request_firware_info . Pregunta \u00bfQu\u00e9 datos y bajo qu\u00e9 topic env\u00eda el cliente en este punto? M\u00e9todo __on_message La funci\u00f3n __on_message se procesa si la conexi\u00f3n al broker ha tenido \u00e9xito. Esta funci\u00f3n es m\u00e1s compleja, ya que debe procesar la recepci\u00f3n de distintos tipos de mensajes por parte de Thingsboard. En ella reside la mayor parte de la l\u00f3gica de recepci\u00f3n del firmware. Pregunta \u00bfQu\u00e9 casos se procesan analizando la estructura de los topics asociados al mensaje recibido? \u00bfQu\u00e9 ocurre si la versi\u00f3n recibida es la misma que la instalada? \u00bfY si es diferente? \u00bfC\u00f3mo se procesa el mensaje de respuesta por parte de Thingsboard que incluye el firmware (o parte del mismo)? \u00bfC\u00f3mo se gestiona la recepci\u00f3n en m\u00faltiples fragmentos ( chunks )? \u00bfSe env\u00edan datos de telemetr\u00eda modificando el estado de la actualizaci\u00f3n (DOWNLOADING)? Funci\u00f3n get_firmware La funci\u00f3n se invoca peri\u00f3dicamente en el proceso de recepci\u00f3n del firmware. Pregunta \u00bfEn qu\u00e9 estado se encuentra en esta fase el proceso de actualizaci\u00f3n? \u00bfQu\u00e9 datos de telemetr\u00eda se env\u00edan? Funci\u00f3n process_firmware Esta funci\u00f3n se invoca cuando se ha recibido la totalidad del firmware en el cliente. Observa que se env\u00edan datos de telemetr\u00eda indicando el paso por los estados DOWNLOADED, VERIFIED o FAILED. Pregunta \u00bfQu\u00e9 tarea principal realiza la funci\u00f3n process_firmware ? \u00bfC\u00f3mo lo hace? L\u00f3gica de actualizaci\u00f3n Observa, por \u00faltimo, que el script Python crea un hilo que simplemente espera de forma activa (funci\u00f3n punto de entrada __update_thread a la recepci\u00f3n del firmware completo, pasando por los estados UPDATING y UPDATED. La funci\u00f3n dummy_upgrade simplemente introduce esperas artificiales para simular el proceso de actualizaci\u00f3n dilatado en el tiempo. Observa tambi\u00e9n que el firmware recibido se escribe en un fichero en esta funci\u00f3n. Tarea entregable (opcional) Tras estudiar y experimentar con el script Python, desarrolla una versi\u00f3n equivalente que gestione el proceso de actualizaci\u00f3n de firmware en un ESP32 usando Thingsboard. Para ello, opera en dos fases. En primer lugar, implementa la l\u00f3gica de comunicaci\u00f3n con la plataforma a trav\u00e9s de la API MQTT, pero no realices el proceso de flasheo en el ESP32 (sim\u00falalo como hace el script). Una vez comprobado el correcto funcionamiento de la l\u00f3gica implementada (similar al del script), procede a la integraci\u00f3n del proceso de actualizaci\u00f3n OTA utilizando la API de ESP-IDF. NOTA IMPORTANTE: el desarrollo de esta tarea es complejo y no se espera su entrega como una pr\u00e1ctica \"normal\". Sin embargo, se solicitar\u00e1 esta funcionalidad (aunque de forma opcional) en el trabajo de integraci\u00f3n, por lo que se sugiere comenzar a trabajar en la tarea antes del inicio del proyecto. Panel de control de monitorizaci\u00f3n OTA Thingsboard proporciona un panel de control con el resumen de procesos de actualizaci\u00f3n de firmware, que permite monitorizar el progreso de cada actualizaci\u00f3n en cada dispositivo (qu\u00e9 dispositivos est\u00e1n ahora mismo en actualizaci\u00f3n, errores en los procesos de actualizaci\u00f3n, procesos completados con \u00e9xito, ...) El panel de control se crea autom\u00e1ticamente con cada nuevo usuario tenant del sistema, mostrando una lista de dispositivos con informaci\u00f3n completa sobre su firmware: As\u00ed como un historial (pulsando el bot\u00f3n tras el nombre del dispositivo) que permite ver el hist\u00f3rico de actualizaciones del sistema: Tarea Utiliza el panel de control para monitorizar el proceso de actualizaci\u00f3n tanto del dispositivo emulado v\u00eda Python como de tu ESP32 (en el caso de haber resuelto ya la tarea anterior).","title":"Pr\u00e1ctica 7 (adicional)"},{"location":"ANIOT/P7/index2/#practica-7-adicional-ota-en-thingsboard","text":"","title":"Pr\u00e1ctica 7 (adicional). OTA en Thingsboard"},{"location":"ANIOT/P7/index2/#objetivos","text":"El objetivo de esta pr\u00e1ctica es familiarizarse con el proceso de OTA en la plataforma Thingsboard, para realizar actualizaciones de fimware/software de forma remota. Note Esta parte de la pr\u00e1ctica se considera opcional y no entregable. Sin embargo, se solicitar\u00e1 la integraci\u00f3n del proceso de OTA desde Thingsboard en el trabajo final de integraci\u00f3n del M\u00f3dulo Tecnolog\u00eda, por lo que se sugiere al menos completar las partes esenciales del bolet\u00edn. Trabajaremos los siguientes aspectos: Actualizaci\u00f3n de firmware mendiante MQTT en Thingsboard. Interacci\u00f3n a trav\u00e9s de la plataforma para la actualizaci\u00f3n de firmware. Desarrollo de un panel de control para monitorizaci\u00f3n de actualizaciones.","title":"Objetivos"},{"location":"ANIOT/P7/index2/#material-de-consulta","text":"Documentaci\u00f3n sobre el mecanismo de OTA en Thingsboard","title":"Material de consulta"},{"location":"ANIOT/P7/index2/#over-the-air-update-ota-en-thingsboard","text":"En versiones modernas de la plataforma (desde su versi\u00f3n 3.3), Thingsboard permite procesar y distribuir actualizaciones OTA a dispositivos. Los tenants de la plataforma pueen subir a un repositorio de OTAs (bien gr\u00e1ficamente, o bien mediante una API) im\u00e1genes que pueden a continuaci\u00f3n asignarse a dispositivos individuales o perfiles de dispositivo. Thingsboard se encarga, a partir de ese unto, de notificar al dispositivo sobre la disponibilidad de una nueva versi\u00f3n, y proporciona una API espec\u00edfica (usando LWM2M, HTTP(s), MQTT(s) o CoAP) para llevar a cabo la descarga. Adem\u00e1s, la plataforma monitoriza el proceso de actualizaci\u00f3n y mantiene un historial de las actualizaciones llevadas a cabo en cada dispositivo:","title":"Over-The-Air Update (OTA) en Thingsboard"},{"location":"ANIOT/P7/index2/#gestion-del-repositorio-de-imagenes","text":"Navegando hasta la entrada del men\u00fa principal titulada \"OTA Updates\" (Actualizaciones OTA), podemos encontrar la lista paquetes de actualizaci\u00f3n disponibles. Cada paquete viene descrito por: T\u00edtulo . Nombre del paquete. Versi\u00f3n . Versi\u00f3n del paquete. La combinaci\u00f3n de t\u00edtulo y versi\u00f3n debe ser \u00fanica para cada tenant de la plataforma. Perfil de dispositivo . Cada paquete es compatible con un perfil de dispositivo. Tipo . Puede ser firmware (FOTA) o software (SOTA). Nosotros utilizaremos la primera opci\u00f3n. Algoritmo de checksum . Par\u00e1metro opcional, con el nombre del algoritmo de checksum a usar. Checksum . Par\u00e1metro opcional que contiene el valor del checksum calculado para el fichero correspondiente. Si no se indica lo contrario, la plataforma utilizar\u00e1 SHA256 como algoritmo de c\u00e1lculo de checksum. Descripci\u00f3n . Texto opcional y libre que describe al firmware. Tarea Crea en el repositorio de im\u00e1genes tantos paquetes como desees. Puedes subir im\u00e1genes ESP32 (ficheros .bin) creadas, o en general, cualquier tipo de fichero.","title":"Gesti\u00f3n del repositorio de im\u00e1genes"},{"location":"ANIOT/P7/index2/#asignacion-de-paquetes-ota-a-perfiles-de-dispositivo","text":"Podemos asignar paquetes de firmware a perfiles de dispositivo para distribuir autom\u00e1ticamente el paquete a todos los dispositivos que compartan dicho perfil: El perfil de dispositivo permite que si asignamos un paquete de firmware al perfil, se lance un proceso de actualizaci\u00f3n en todos los dispositivos que pertenecen a dicho perfil, ahorrando tiempo.","title":"Asignaci\u00f3n de paquetes OTA a perfiles de dispositivo"},{"location":"ANIOT/P7/index2/#asignacion-de-paquetes-ota-a-dispositivos","text":"Es posible asignar im\u00e1genes de firmware/software a dispositivos espec\u00edficos. Observa los pasos en las siguientes capturas: La versi\u00f3n de firmware asignada a un dispositivo sobreescribir\u00e1 la versi\u00f3n del firmware que se ha asignado al perfil de dispositivo. Por ejemplo, asumamos que disponemos de los dispositivos D1 y D2 con perfil P1: Si asignamos el paquete F1 al perfil P1 (a trav\u00e9s de la UI de gesti\u00f3n del perfil vista en el punto anterior), los dispositivos D1 y D2 se actualizar\u00e1n a F1. Si asignamos el paquete F2 al dispositivo D1 (a trav\u00e9s de la UI de gesti\u00f3n del dispositivo), solo D1 se actualizar\u00e1 a F2. si asignamos el paquete F3 al perfil P1 solo afectar\u00e1 a D2, porque no tiene versi\u00f3n espec\u00edfica de firmware asignada a nivel de dispositivo individual.","title":"Asignaci\u00f3n de paquetes OTA a dispositivos"},{"location":"ANIOT/P7/index2/#proceso-de-actualizacion","text":"La asignaci\u00f3n de firmware/software a un dispositivo o perfil de dispositivo desencadena autom\u00e1ticamente un proceso de actualicaci\u00f3n. Thingsboard mantiene monitorizado el proceso de actualizaci\u00f3n a trav\u00e9s de los atributos del dispositivo. El proceso de actualizaci\u00f3n puede residir en un instante determinado en uno de los siguientes estados. Dicho estado se almacena com oun atributo de dispositivo y se usa para visualizar el proceso en un dashboard.","title":"Proceso de actualizaci\u00f3n"},{"location":"ANIOT/P7/index2/#estado-queued","text":"Es el primer estado de la actualizaci\u00f3n, marcado por el servidor. Significa que l anotificaci\u00f3n sobre nuevo firmware disponible est\u00e1 encolada pero todav\u00eda no se ha llevado al dispositivo. Thingsboard encola las notificaciones para evitar picos de peticiones en el tiempo, ya que la cola se procesa ritmo constante, independientemente del n\u00famero de peticiones (por defecto, se sirven 100 peticiones por minuto).","title":"Estado QUEUED"},{"location":"ANIOT/P7/index2/#estado-initiated","text":"Significa que la notificaci\u00f3n se ha enviado al dispositivo tras extraerla de la cola. Por debajo, Thingsboard convierte la notificaci\u00f3n en una actualizaci\u00f3n de los siguientes atributos compartidos (visibles por tanto para el dispositivo): fw_title . Nombre del firmware. fw_version . Versi\u00f3n del firmware. fw_size . Tama\u00f1o del firmware en bytes. fw_checksum . Suma de verificaci\u00f3n del paquete recibido. fw_checksum_algorithm . Algoritmo que se usar\u00e1 para verificar la integridad del paquete recibido. El resto de estados se reportan por el dispositivo que est\u00e1 procesando la actualizaci\u00f3n, y no por el servidor:","title":"Estado INITIATED"},{"location":"ANIOT/P7/index2/#estado-downloading","text":"El paquete est\u00e1 siendo descargado tras la recepci\u00f3n de la notificaci\u00f3n de nuevo firmware/software.","title":"Estado DOWNLOADING"},{"location":"ANIOT/P7/index2/#estado-downloaded","text":"El paquete ha sido descargado.","title":"Estado DOWNLOADED"},{"location":"ANIOT/P7/index2/#estado-verified","text":"El dispositivo ha verificado con \u00e9xito el checksum.","title":"Estado VERIFIED"},{"location":"ANIOT/P7/index2/#estado-updating","text":"El dispositivo ha comenzado la actualizaci\u00f3n. T\u00edpicamente se env\u00eda ants del reinicio del dispositivo (en el caso de FOTA) o servicio (para SOTA).","title":"Estado UPDATING"},{"location":"ANIOT/P7/index2/#estado-updated","text":"El firmware fue correctamente actualizado a la nueva versi\u00f3n.","title":"Estado UPDATED"},{"location":"ANIOT/P7/index2/#estado-failed","text":"El checksum no fue verificado, o el dispositivo fallo en el proceso de actualizaci\u00f3n. Una vez el firmware se ha actualizado con \u00e9xito, Thingsboard espera que el usuario env\u00ede la siguiente telemetr\u00eda: {\"current_fw_title\": \"myFirmware\", \"current_fw_version\": \"1.2.3\", \"fw_state\": \"UPDATED\"} En caso de error, la plataforma espera la recepci\u00f3n de la siguiente telemetr\u00eda: {\"fw_state\": \"FAILED\", \"fw_error\": \"causa del error (legible)\"}","title":"Estado FAILED"},{"location":"ANIOT/P7/index2/#api-mqtt-de-gestion-de-otafirmware","text":"Cuando Thingsboard inicia un proceso de actualizaci\u00f3n de firmware v\u00eda MQTT, establece los atributos compartidos fw_title , fw_version , fw_checksum y fw_checksum_algorithm , como se ha dicho anteriormente. Para recibir actualizaciones de estos atributos compartidos, el dispositivo debe suscribirse a: v1/devices/me/attributes/response/+ Cuando el dispositivo recibe actualizaciones para fw_title y fw_version , \u00e9ste debe publicar v\u00eda MQTT un mensaje bajo el topic: v2/fw/request/${requestId}/chunk/${chunkIndex} donde: ${requestId} es un n\u00famero correspondiente al n\u00famero de acuatlizaciones firmware desarrolladas por el dispositivo, que debe ser \u00fanico y diferente para cada actualizaci\u00f3n de firmware. ${chunkIndex} es un n\u00famero correspondiente al \u00edndice de los fragmentos (chunks) de firmware recibidos; comienzan a contar en 0. El dispositivo debe incrementar el \u00edndice para cada petici\u00f3n, hasta que el chunk recibido sea 0. El payload debe ser el tama\u00f1o del chunk en bytes. Para cada actualizaci\u00f3n, debe modificarse el ID de la petici\u00f3n y suscribirse a: v2/fw/response/+/chunk/+","title":"API MQTT de gesti\u00f3n de OTA/firmware"},{"location":"ANIOT/P7/index2/#simulacion-de-una-actualizacion-ota-desde-python-usando-la-api-mqtt","text":"A continuaci\u00f3n, se propone el uso de un script Python sencillo que gestiona la actualizaci\u00f3n OTA simulando un dispositivo cliente. El objetivo es que este script sirva de base para implementar los componentes necesario en ESP-IDF que permitan la actualizaci\u00f3n remota de nuestros dispositivos. Al igual que en la pr\u00e1ctica sobre provisionamiento, crea un entorno virtual e instala los paquetes necearios para la ejecuci\u00f3n del script: python3 -m venv entorno source entorno/bin/activate pip3 install paho-mqtt mmh3 --user A continuaci\u00f3n, descarga el script Python desde este enlace . En la documentaci\u00f3n de la plataforma tienes scripts equivalentes para HTTP y CoAP. Ejecuta el script: python3 mqtt_firmware_client.py El script solicitar\u00e1 ciertos valores para configurar el cliente, incluyendo la URL y puerto de la instalaci\u00f3n de ThingsBoard que est\u00e9s usando, el token del dispositivo y el tama\u00f1o de cada fragmento de fichero descargado (si se desea fragmentar la recepci\u00f3n). Si todo es correcto, el dispositivo emular\u00e1 la actualizaci\u00f3n del software, simplemente descargando y almacenando en disco el fichero correspondiente: Tarea Ejecuta el cliente para un dispositivo existente en Thingsboard. Prepara un paquete de actualizaci\u00f3n y lanza el proceso. Observa lo que ocurre en el cliente. Comprueba que efectivamente el fichero recibido es el que subiste a la plataforma (visualmente, o calculando su checksum). Tarea Repite el proceso con m\u00faltiples clientes conectados bajo un mismo perfil, y gestiona la actualizaci\u00f3n con un \u00fanico paquete para todos los dispositivos. Comprueba que la l\u00f3gica de versiones para dispositivos individuales anteriormente explicada se cumple.","title":"Simulaci\u00f3n de una actualizaci\u00f3n OTA desde Python usando la API MQTT"},{"location":"ANIOT/P7/index2/#analisis-del-proceso-de-actualizacion","text":"Tras recoger los datos proporcionados por el usuario, el cliente instancia un cliente PAHO MQTT, y conecta al broker proporcionado. Pregunta \u00bfQu\u00e9 credenciales se utilizan en el proceso de conexi\u00f3n?","title":"An\u00e1lisis del proceso de actualizaci\u00f3n"},{"location":"ANIOT/P7/index2/#metodo-__on_connect","text":"La funci\u00f3n __on_connect se procesa si la conexi\u00f3n al broker ha tenido \u00e9xito. Pregunta \u00bfA qu\u00e9 topics se suscribe el cliente tras conectar con el broker? \u00bfQu\u00e9 datos de telemetr\u00eda env\u00eda? Por \u00faltimo, el cliente invoca a la funci\u00f3n request_firware_info . Pregunta \u00bfQu\u00e9 datos y bajo qu\u00e9 topic env\u00eda el cliente en este punto?","title":"M\u00e9todo __on_connect"},{"location":"ANIOT/P7/index2/#metodo-__on_message","text":"La funci\u00f3n __on_message se procesa si la conexi\u00f3n al broker ha tenido \u00e9xito. Esta funci\u00f3n es m\u00e1s compleja, ya que debe procesar la recepci\u00f3n de distintos tipos de mensajes por parte de Thingsboard. En ella reside la mayor parte de la l\u00f3gica de recepci\u00f3n del firmware. Pregunta \u00bfQu\u00e9 casos se procesan analizando la estructura de los topics asociados al mensaje recibido? \u00bfQu\u00e9 ocurre si la versi\u00f3n recibida es la misma que la instalada? \u00bfY si es diferente? \u00bfC\u00f3mo se procesa el mensaje de respuesta por parte de Thingsboard que incluye el firmware (o parte del mismo)? \u00bfC\u00f3mo se gestiona la recepci\u00f3n en m\u00faltiples fragmentos ( chunks )? \u00bfSe env\u00edan datos de telemetr\u00eda modificando el estado de la actualizaci\u00f3n (DOWNLOADING)?","title":"M\u00e9todo __on_message"},{"location":"ANIOT/P7/index2/#funcion-get_firmware","text":"La funci\u00f3n se invoca peri\u00f3dicamente en el proceso de recepci\u00f3n del firmware. Pregunta \u00bfEn qu\u00e9 estado se encuentra en esta fase el proceso de actualizaci\u00f3n? \u00bfQu\u00e9 datos de telemetr\u00eda se env\u00edan?","title":"Funci\u00f3n get_firmware"},{"location":"ANIOT/P7/index2/#funcion-process_firmware","text":"Esta funci\u00f3n se invoca cuando se ha recibido la totalidad del firmware en el cliente. Observa que se env\u00edan datos de telemetr\u00eda indicando el paso por los estados DOWNLOADED, VERIFIED o FAILED. Pregunta \u00bfQu\u00e9 tarea principal realiza la funci\u00f3n process_firmware ? \u00bfC\u00f3mo lo hace?","title":"Funci\u00f3n process_firmware"},{"location":"ANIOT/P7/index2/#logica-de-actualizacion","text":"Observa, por \u00faltimo, que el script Python crea un hilo que simplemente espera de forma activa (funci\u00f3n punto de entrada __update_thread a la recepci\u00f3n del firmware completo, pasando por los estados UPDATING y UPDATED. La funci\u00f3n dummy_upgrade simplemente introduce esperas artificiales para simular el proceso de actualizaci\u00f3n dilatado en el tiempo. Observa tambi\u00e9n que el firmware recibido se escribe en un fichero en esta funci\u00f3n. Tarea entregable (opcional) Tras estudiar y experimentar con el script Python, desarrolla una versi\u00f3n equivalente que gestione el proceso de actualizaci\u00f3n de firmware en un ESP32 usando Thingsboard. Para ello, opera en dos fases. En primer lugar, implementa la l\u00f3gica de comunicaci\u00f3n con la plataforma a trav\u00e9s de la API MQTT, pero no realices el proceso de flasheo en el ESP32 (sim\u00falalo como hace el script). Una vez comprobado el correcto funcionamiento de la l\u00f3gica implementada (similar al del script), procede a la integraci\u00f3n del proceso de actualizaci\u00f3n OTA utilizando la API de ESP-IDF. NOTA IMPORTANTE: el desarrollo de esta tarea es complejo y no se espera su entrega como una pr\u00e1ctica \"normal\". Sin embargo, se solicitar\u00e1 esta funcionalidad (aunque de forma opcional) en el trabajo de integraci\u00f3n, por lo que se sugiere comenzar a trabajar en la tarea antes del inicio del proyecto.","title":"L\u00f3gica de actualizaci\u00f3n"},{"location":"ANIOT/P7/index2/#panel-de-control-de-monitorizacion-ota","text":"Thingsboard proporciona un panel de control con el resumen de procesos de actualizaci\u00f3n de firmware, que permite monitorizar el progreso de cada actualizaci\u00f3n en cada dispositivo (qu\u00e9 dispositivos est\u00e1n ahora mismo en actualizaci\u00f3n, errores en los procesos de actualizaci\u00f3n, procesos completados con \u00e9xito, ...) El panel de control se crea autom\u00e1ticamente con cada nuevo usuario tenant del sistema, mostrando una lista de dispositivos con informaci\u00f3n completa sobre su firmware: As\u00ed como un historial (pulsando el bot\u00f3n tras el nombre del dispositivo) que permite ver el hist\u00f3rico de actualizaciones del sistema: Tarea Utiliza el panel de control para monitorizar el proceso de actualizaci\u00f3n tanto del dispositivo emulado v\u00eda Python como de tu ESP32 (en el caso de haber resuelto ya la tarea anterior).","title":"Panel de control de monitorizaci\u00f3n OTA"},{"location":"ANIOT/P8/","text":"Pr\u00e1ctica 8. Arranque seguro y encriptaci\u00f3n Objetivos El objetivo de esta pr\u00e1ctica es familiarizarse con las t\u00e9cnicas y herramientas que ofrece ESP-IDF para integrar arranque seguro y encriptaci\u00f3n de flash en nuestros proyectos. Trabajaremos los siguientes aspectos: QEMU como plataforma de emulaci\u00f3n para desarrollar aspectos relacionados con arranque seguro y encriptaci\u00f3n. Arranque seguro y firmado de binarios. Encriptaci\u00f3n de flash y NVS. Material de consulta QEMU con soporte para ESP32 Secure Boot v2 Encriptaci\u00f3n FLASH Encriptaci\u00f3n NVS Emulador QEMU para ESP32 Debido a que, durante esta pr\u00e1tica, modificaremos algunos aspectos de nuestros proyectos que no son reversibles, es conveniente no utilizar una placa f\u00edsica para su desarrollo. Nota importante Mant\u00e9n desconectadas tus placas durante toda esta pr\u00e1ctica . No las necesitar\u00e1s y cualquier error podr\u00eda ser irreversible o dejar la placa inutilizable. Recordatorio de la nota importante Repetimos: mant\u00e9n desconectadas tus placas durante toda esta pr\u00e1ctica . No las necesitar\u00e1s y cualquier error podr\u00eda ser irreversible o dejar la placa inutilizable. QEMU es un emulador de procesadores de c\u00f3digo abierto. Proporciona multitud de soporte para hardware y dispositivos, con capacidad para ejecutar en ellos cualquier sistema operativo. En conjunci\u00f3n con KVM, QEMU es capaz de ejecutar m\u00e1quinas virtuales con un rendimiento similar al nativo. Espressif ha desarrollado y mantiene un fork del proyecto QEMU, dando soporte tanto a procesadores con arquitectura Xtensa (ESP32) como RISC-V (ESP32-C3 y similares). Adem\u00e1s, el fork de Espressif para el ESP32 proporciona no solo emulaci\u00f3n de CPU, sino de los perif\u00e9ricos m\u00e1s comunes para el ESP32. Para m\u00e1s informaci\u00f3n sobre las capacidades del fork , se sugiere consultar la documentaci\u00f3n espec\u00edfica proporcionada por Espressif. La herramienta idf.py , proporcionada en la instalaci\u00f3n por defecto de ESP-IDF, proporciona la funcionalidad necesaria para ejecutar y depurar aplicaciones en QEMU. Es la forma m\u00e1s conveniente de testear aplicaciones y funcionalidades cr\u00edticas sin necesidad de tener que flashearlas en hardware real. Nota importante Se sugiere el uso de una instalaci\u00f3n nativa, virtual o a trav\u00e9s de WSL de Linux para el desarrollo de esta pr\u00e1ctica. Tambi\u00e9n se ofrece soporte en MacOS. Prerequisitos e instalaci\u00f3n de QEMU Antes de comenzar, es necesario instalar ciertos prerequisitos necesarios de cara a la instalaci\u00f3n de QEMU. Dependiendo de tu distribuci\u00f3n o sistema operativo: Ubuntu/Debian: sudo apt-get install -y libgcrypt20 libglib2.0-0 libpixman-1-0 libsdl2-2.0-0 libslirp0 Arch: sudo pacman -S --needed libgcrypt glib2 pixman sdl2 libslirp macOS: brew install libgcrypt glib pixman sdl2 libslirp A continuaci\u00f3n, instala los binarios de QEMU con el siguiente comando: python $IDF_PATH/tools/idf_tools.py install qemu-xtensa qemu-riscv32 Observa que con esto instalar\u00e1s el emulador para Xtensa (ESP32) y RISC-V (ESP32-C3), por lo que podr\u00e1s emular tus dos placas generando proyectos como si fueras a utilizarlas de la forma habitual. Tras la instalaci\u00f3n, y antes de su uso en cualquier sesi\u00f3n, recuerda ejecutar . ./export.sh en el directorio de la instalaci\u00f3n de ESP-IDF. Uso de QEMU Ejecuci\u00f3n de una aplicaci\u00f3n Para ejecutar una aplicaci\u00f3n IDF en QEMU, simplemente es necesario construirla de forma habitual para una de las arquitecturas soportadas por el emulador (en nuestro caso, ESP32 o ESP32-C3), y ejecutar el siguiente comando: idf.py qemu monitor Este comando construir\u00e1 la aplicaci\u00f3n (si no lo est\u00e1 ya), arrancar\u00e1 QEMU y abrir\u00e1 un monitor IDF, conect\u00e1ndolo al puerto UART emulado. As\u00ed, veremos la salida por consola igual que si se tratase de una ejecuci\u00f3n en una placa f\u00edsica. Tarea En esta pr\u00e1ctica, se sugiere trabajar con un proyecto sencillo que no incluya demasiada funcionalidad adicional (uso de perif\u00e9ricos, por ejemplo). Un buen ejemplo es blink . Clona el proyecto, constr\u00fayelo y ejec\u00fatalo con el anterior comando. Anota la salida que observas, e intenta determinar (a la vista de la invocaci\u00f3n a qemu que se realiza) cu\u00e1les son sus principales par\u00e1metros de ejecuci\u00f3n. Depuraci\u00f3n (actividad opcional) Para depurar una aplicaci\u00f3n en QEMU, utiliza el siguiente comando: idf.py qemu gdb Este comando permite construir la aplicaci\u00f3n, arranca QEMU con un servidor GDB activado, y abre una terminal interactiva GDB. Este comando es muy \u00fatil para depurar un binario construido, por ejemplo, para nuestros ESP32, ya que no proporcionan capacidades de depuraci\u00f3n en chip (en el caso de los ESP32-C3, esto s\u00ed es posible). En este caso, para observar la salida del programa mientras est\u00e1s depurando, utiliza dos terminales: En la primera, ejecuta el siguiente comando, que arranca QEMU y el monitor IDF, e indica al primero que espere a una conexi\u00f3n entrante GDB: idf.py qemu --gdb monitor En la segunda, ejecuta el siguiente comando, que inicia una sesi\u00f3n GDB y la conecta a QEMU. Desde esta sesi\u00f3n puedes depurar el c\u00f3digo, y la salida ser\u00e1 visible en la primera: idf.py gdb Tarea (opcional) Depura tu proyecto blink estableciendo un breakpont en la funci\u00f3n app_main , y ejec\u00fatalo paso a paso observando la salida por pantalla. Emulaci\u00f3n de eFuse QEMU soporta tambi\u00e9n la emulaci\u00f3n de eFuse, clave para el desarrollo de la pr\u00e1ctica, ya que es una forma muy adecuada de probar aspectos de seguridad como arranque seguro y encriptaci\u00f3n de flash, sin dejar a las placas f\u00edsicas en estados irreversibles. La herramienta idf.py es la encargada de programar eFuses. Al ejecutar cualquiera de los siguientes comandos, se programan los eFuses del procesador emulado por QEMU a trav\u00e9s del fichero qemu_efuse.bin , que se utiliza como habr\u00e1s observado como argumento en la ejecuci\u00f3n. Por ejemplo: idf.py qemu efuse-burn FLASH_CRYPT_CNT 1 idf.py qemu efuse-burn-key flash_encryption my_flash_encryption_key.bin Para mostrar un resumen del contenido de los eFuse, ejecuta: idf.py qemu efuse-summary Especificaci\u00f3n del fichero de imagen Por defecto, QEMU usa un fichero de imagen llamado qemu_flash.bin que se construye en el directorio de construcci\u00f3n ( build ). Este fichero se genera en base a la informaci\u00f3n que se incluye en un fichero llamado flash_args que reside en el mismo directorio. Para usar otro fichero alternativo, podemos ejecutar: idf.py qemu --flash-file fichero.bin monitor Arranque seguro Nota En esta parte de la pr\u00e1ctica, se sugiere que sigas trabajando con el mismo proyecto que elegiste en la primera (se sugiere blink ). En todo caso, trabaja sobre un directorio nuevo para no perder el trabajo realizado en el apartado anterior, por ejemplo, blink_secure . Nota Revisa las diapositivas de clase para recordar el background, funcionamiento y etapas de la verificaci\u00f3n de bootloader e im\u00e1genes proporcionadas por el proceso de arranque seguro. \u00bfC\u00f3mo habilitar el arranque seguro? Tarea Sigue los siguientes pasos para configurar tu proyecto para arranque en modo seguro, documentando todos los pasos y posibles observaciones en la memoria. Selecciona como target ESP32. Abre el men\u00fa de configuraci\u00f3n del proyecto. En Security Features habilita la opci\u00f3n Enable hardware Secure Boot in Bootloader para habilitar el arranque seguro. Deber\u00e1s tambi\u00e9n especificar el esquema de firma RSA y la versi\u00f3n 2 de Secure Boot en las opciones App signing scheme y Select Secure Boot version . Si no te aparecen, pasa al punto 2 para habilitarlo y podr\u00e1s seleccionarlas. Para los ESP32, Secure Boot V2 solo est\u00e1 disponible para ESP32 revisi\u00f3n ECO3 en adelante. Para ver la opci\u00f3n \"Secure Boot V2\", la revisi\u00f3n del chip debe cambiarse a la revisi\u00f3n 3 (ESP32-ECO3). Para cambiar la revisi\u00f3n del chip, configura la opci\u00f3n Minimum Supported ESP32 Revision a Rev 3 en Hardware Settings -> Chip revision -> Minimum Supported ESP32 revision . Especifica la ruta a la clave de firma de arranque seguro, relativa al directorio del proyecto. Puedes dejar su valor por defecto (deber\u00eda ser secure_boot_signing_key.pem ) o usar otro. Importante : selecciona tambi\u00e9n la opci\u00f3n para que el bootloader forme parte del proceso de flasheo cuando se usa arranque seguro (estar\u00e1 deshabilitada por defecto). La opci\u00f3n se denomina Flash bootloader along with other artifacts using the default flash command . Selecciona el modo de descarga de ROM UART deseado en \"UART ROM download mode\". De forma predeterminada, el modo de descarga de ROM UART se ha mantenido habilitado para evitar deshabilitarlo permanentemente en la fase de desarrollo; esta opci\u00f3n es potencialmente insegura. Se recomienda deshabilitar el modo de descarga UART para mayor seguridad. Opcionalmente, puedes aumentar la informaci\u00f3n mostrada por el bootloader aumentando el valor de la opci\u00f3n Bootloader log verbosity a Info o Verbose. Ten cuidado porque esto aumentar\u00e1 el tama\u00f1o del bootloader, y probablemente debas aumentar entonces el offset de la tabla de particiones a un valor mucho mayor al establecido por defecto (opci\u00f3n Offset of partition table a 0xe000 como m\u00e1ximo para dar cabida al bootloader. Guarda la configuraci\u00f3n (a\u00f1ade si lo deseas m\u00e1s opciones), y abandona la fase de configuraci\u00f3n. La primera vez que ejecute la construcci\u00f3n con idf.py build , si no se encuentra la clave de firma, se imprimir\u00e1 un mensaje de error con un comando para generar una clave de firma a trav\u00e9s del comando: espsecure.py generate_signing_key Importante Una clave de firma generada de esta manera utilizar\u00e1 la mejor fuente de n\u00fameros aleatorios disponible para el sistema operativo y tu instalaci\u00f3n de Python ( /dev/urandom en OSX/Linux y CryptGenRandom() en Windows). Si esta fuente de n\u00fameros aleatorios es d\u00e9bil, entonces la clave privada ser\u00e1 d\u00e9bil. Importante Para entornos de producci\u00f3n, se recomienda generar el par de claves mediante openssl u otro programa de cifrado est\u00e1ndar de la industria. Tienes m\u00e1s informaci\u00f3n sobre c\u00f3mo hacer esto aqu\u00ed . De todos modos, dejamos esta parte como opcional en la pr\u00e1ctica. Tras la ejecuci\u00f3n de la orden idf.py build de forma exitosa, se habr\u00e1n creado las im\u00e1genes para el bootloader , tabla de particiones e imagen de aplicaci\u00f3n individualmente en el directorio de construcci\u00f3n. Identif\u00edcalas. La imagen final a flashear deber\u00eda generarse fusionando el bootloader , la tabla de particiones y la imagen de aplicaci\u00f3n. Una forma sencilla, si se ha seguido el paso 4, es utilizar la herramienta esptool.py de la siguiente manera: (cd build; esptool.py --chip esp32c3 merge_bin --fill-flash-size 4MB -o flash_image.bin @flash_args) Como vamos a trabajar con QEMU, tenemos ya lista la imagen que se ejecutar\u00e1 en el emulador. Si trabajasemos con una placa real, pasar\u00edamos en este punto por una fase de flasheado de la imagen. Monitoriza la ejecuci\u00f3n en QEMU siguiendo la forma de trabajar de ejemplos anteriores. Documenta lo que ves en la salida (en referencia al arranque seguro). Tarea F\u00edjate en el proceso de verificaci\u00f3n de bloques de firmas y de im\u00e1genes (incluyendo bootloader e imagen de aplicaci\u00f3n). Comprueba que concuerdan con los explicados en clase y en la documentaci\u00f3n de ESP-IDF enlazada al inicio de esta memoria. Tarea \u00bfQu\u00e9 ocurrir\u00eda si un compa\u00f1ero te pasa su imagen de aplicaci\u00f3n o su bootloader , y t\u00fa lo integras en la imagen que emulas? \u00bfY que ocurrir\u00eda si usas tus im\u00e1genes con el fichero de firma de tu compa\u00f1ero/a? Intenta ver qu\u00e9 ocurre en el proceso de verificaci\u00f3n de firmas en esos casos. De la misma forma, intenta ver qu\u00e9 ocurre si modificas un byte en la imagen firmada (no hagas esto con el bootloader ). Si has seguido el paso 4, Ejecutar para crear un cargador de arranque habilitado para arranque seguro. La salida de la compilaci\u00f3n incluir\u00e1 un mensaje para un comando de actualizaci\u00f3n, utilizando .idf.py bootloaderesptool.py write_flash Encriptaci\u00f3n de FLASH Tarea Sigue los siguientes pasos para configurar tu proyecto para integrar la encriptaci\u00f3n de flash, documentando todos los pasos y posibles observaciones en la memoria. Como en anteriores ejercicios, utiliza el mismo proyecto ( blink ) pero trabaja en una nueva carpeta, por ejemplo blink_encrypted . Parte del proyecto en blanco, no del que integra el arranque seguro. La encriptaci\u00f3n de flash tiene como objetivo encriptar los contenidos de la memoria flash del ESP32. Cuando se habilita, el firmware se flashea en claro, y se encripta al vuelo ( in-place ) en el primer arranque. As\u00ed, una simple lectura de flash deja de ser suficiente como para recuperar los datos almacenados. Esta caracter\u00edstica puede o no habilitarse junto al arranque seguro, aunque en esta pr\u00e1ctica no las combinaremos . Cuando se habilita, los siguientes tipos de partici\u00f3n se encriptan por defecto: Second stage bootloader . Tabla de particiones. NVS. OTADATA. Todas las particiones de tipo app .o Tienes una referencia sobre los eFuses a activar en la documentaci\u00f3n oficial . C\u00f3mo funciona la encriptaci\u00f3n Asumiendo que se ha activado la encriptaci\u00f3n, \u00e9sta procede de la siguiente manera: En el primer arranque, los datos en flash est\u00e1n desencriptados (almacenados en claro). El bootloader lee el eFuse FLASH_CRYPT_CNT . Si su valor es 0, configura el bloque de encriptaci\u00f3n (la activa). El bootloader chequea si hay una clave v\u00e1lida presente en eFuse. Si es el caso, no se genera una nueva. Si no lo es se procede a la generaci\u00f3n de una clave y se almacena en el eFuse flash_encryption . El hardware de encriptaci\u00f3n encripta los contenidos de la flash. Este proceso puede ser lento. El bootloader fija la activaci\u00f3n modificando el valor del eFuse FLASH_CRYPT_CNT. El dispositivo se resetea. C\u00f3mo se activa la encriptaci\u00f3n (modo development ) En el men\u00fa de configuraci\u00f3n, simplemente busca y activa la opci\u00f3n Enable Flash Encryption on Boot . Tarea Activa la encriptaci\u00f3n de FLASH en tu proyecto blink . Observa y anota las fases por las que pasa el proceso de arranque (a\u00f1ade logs al bootloader) y comprueba si coinciden con las fases anteriormente mencionadas. \u00bfNotas alguna penalizaci\u00f3n de rendimiento evidente en alguna fase? Tarea Tras observar el funcionamiento con el proyecto blink , ser\u00eda conveniente observar el efecto de la encriptaci\u00f3n en los datos almacenados en flash. Para ello, usaremos el ejemplo flash_encryption de ESP-IDF. Cl\u00f3nalo y chequea si est\u00e1 o no activa la encriptaci\u00f3n. A continuaci\u00f3n, flashea y ejecuta (en QEMU) el c\u00f3digo. Observa la salida. Cambia la funcionalidad de encriptaci\u00f3n y vuelve a observarla. \u00bfQu\u00e9 ves en pantalla? Estudia el c\u00f3digo e intenta entender qu\u00e9 est\u00e1 pasando, y por qu\u00e9 en un caso el contenido de la flash es \"entendible\", y en otro no. \u00bfQu\u00e9 funciones usa el c\u00f3digo para realizar la lectura con desencriptaci\u00f3n y en crudo? Encriptaci\u00f3n de NVS De forma independiente a la encriptaci\u00f3n de FLASH, es posible llevar a cabo un proceso de encriptaci\u00f3n \u00fanicamente de los datos almacenados en NVS en forma clave-valor. Esta soluci\u00f3n aporta cierta seguridad (en una parte de los datos), y a la vez no empeora el rendimiento como s\u00ed hace la encriptaci\u00f3n total de flash. Tarea El ejemplo nvs_encryption_hmac propone una forma muy sencilla de observar el efecto de la encriptaci\u00f3n de NVS sobre el contenido que se almacena en la partici\u00f3n NVS de la flash. Comp\u00edlalo y ejec\u00fatalo tal con NVS desactivado (busca la opci\u00f3n correspondiente en los men\u00fas de configuraci\u00f3n). \u00bfQu\u00e9 observas? A continuaci\u00f3n, activa la encriptaci\u00f3n NVS. \u00bfQu\u00e9 observas? IMPORTANTE: este proyecto debe configurarse para ESP32-C3, ya que solo \u00e9l tiene soporte para HMAC, t\u00e9cnica usada para encriptar NVS. Adem\u00e1s, la opci\u00f3n eFuse key ID storing the HMAC key debe fijarse a 3 . En todo caso, la ejecuci\u00f3n se emular\u00e1 v\u00eda QEMU. Recuerda: no conectes tu placa .","title":"Pr\u00e1ctica 8"},{"location":"ANIOT/P8/#practica-8-arranque-seguro-y-encriptacion","text":"","title":"Pr\u00e1ctica 8. Arranque seguro y encriptaci\u00f3n"},{"location":"ANIOT/P8/#objetivos","text":"El objetivo de esta pr\u00e1ctica es familiarizarse con las t\u00e9cnicas y herramientas que ofrece ESP-IDF para integrar arranque seguro y encriptaci\u00f3n de flash en nuestros proyectos. Trabajaremos los siguientes aspectos: QEMU como plataforma de emulaci\u00f3n para desarrollar aspectos relacionados con arranque seguro y encriptaci\u00f3n. Arranque seguro y firmado de binarios. Encriptaci\u00f3n de flash y NVS.","title":"Objetivos"},{"location":"ANIOT/P8/#material-de-consulta","text":"QEMU con soporte para ESP32 Secure Boot v2 Encriptaci\u00f3n FLASH Encriptaci\u00f3n NVS","title":"Material de consulta"},{"location":"ANIOT/P8/#emulador-qemu-para-esp32","text":"Debido a que, durante esta pr\u00e1tica, modificaremos algunos aspectos de nuestros proyectos que no son reversibles, es conveniente no utilizar una placa f\u00edsica para su desarrollo. Nota importante Mant\u00e9n desconectadas tus placas durante toda esta pr\u00e1ctica . No las necesitar\u00e1s y cualquier error podr\u00eda ser irreversible o dejar la placa inutilizable. Recordatorio de la nota importante Repetimos: mant\u00e9n desconectadas tus placas durante toda esta pr\u00e1ctica . No las necesitar\u00e1s y cualquier error podr\u00eda ser irreversible o dejar la placa inutilizable. QEMU es un emulador de procesadores de c\u00f3digo abierto. Proporciona multitud de soporte para hardware y dispositivos, con capacidad para ejecutar en ellos cualquier sistema operativo. En conjunci\u00f3n con KVM, QEMU es capaz de ejecutar m\u00e1quinas virtuales con un rendimiento similar al nativo. Espressif ha desarrollado y mantiene un fork del proyecto QEMU, dando soporte tanto a procesadores con arquitectura Xtensa (ESP32) como RISC-V (ESP32-C3 y similares). Adem\u00e1s, el fork de Espressif para el ESP32 proporciona no solo emulaci\u00f3n de CPU, sino de los perif\u00e9ricos m\u00e1s comunes para el ESP32. Para m\u00e1s informaci\u00f3n sobre las capacidades del fork , se sugiere consultar la documentaci\u00f3n espec\u00edfica proporcionada por Espressif. La herramienta idf.py , proporcionada en la instalaci\u00f3n por defecto de ESP-IDF, proporciona la funcionalidad necesaria para ejecutar y depurar aplicaciones en QEMU. Es la forma m\u00e1s conveniente de testear aplicaciones y funcionalidades cr\u00edticas sin necesidad de tener que flashearlas en hardware real. Nota importante Se sugiere el uso de una instalaci\u00f3n nativa, virtual o a trav\u00e9s de WSL de Linux para el desarrollo de esta pr\u00e1ctica. Tambi\u00e9n se ofrece soporte en MacOS.","title":"Emulador QEMU para ESP32"},{"location":"ANIOT/P8/#prerequisitos-e-instalacion-de-qemu","text":"Antes de comenzar, es necesario instalar ciertos prerequisitos necesarios de cara a la instalaci\u00f3n de QEMU. Dependiendo de tu distribuci\u00f3n o sistema operativo: Ubuntu/Debian: sudo apt-get install -y libgcrypt20 libglib2.0-0 libpixman-1-0 libsdl2-2.0-0 libslirp0 Arch: sudo pacman -S --needed libgcrypt glib2 pixman sdl2 libslirp macOS: brew install libgcrypt glib pixman sdl2 libslirp A continuaci\u00f3n, instala los binarios de QEMU con el siguiente comando: python $IDF_PATH/tools/idf_tools.py install qemu-xtensa qemu-riscv32 Observa que con esto instalar\u00e1s el emulador para Xtensa (ESP32) y RISC-V (ESP32-C3), por lo que podr\u00e1s emular tus dos placas generando proyectos como si fueras a utilizarlas de la forma habitual. Tras la instalaci\u00f3n, y antes de su uso en cualquier sesi\u00f3n, recuerda ejecutar . ./export.sh en el directorio de la instalaci\u00f3n de ESP-IDF.","title":"Prerequisitos e instalaci\u00f3n de QEMU"},{"location":"ANIOT/P8/#uso-de-qemu","text":"","title":"Uso de QEMU"},{"location":"ANIOT/P8/#ejecucion-de-una-aplicacion","text":"Para ejecutar una aplicaci\u00f3n IDF en QEMU, simplemente es necesario construirla de forma habitual para una de las arquitecturas soportadas por el emulador (en nuestro caso, ESP32 o ESP32-C3), y ejecutar el siguiente comando: idf.py qemu monitor Este comando construir\u00e1 la aplicaci\u00f3n (si no lo est\u00e1 ya), arrancar\u00e1 QEMU y abrir\u00e1 un monitor IDF, conect\u00e1ndolo al puerto UART emulado. As\u00ed, veremos la salida por consola igual que si se tratase de una ejecuci\u00f3n en una placa f\u00edsica. Tarea En esta pr\u00e1ctica, se sugiere trabajar con un proyecto sencillo que no incluya demasiada funcionalidad adicional (uso de perif\u00e9ricos, por ejemplo). Un buen ejemplo es blink . Clona el proyecto, constr\u00fayelo y ejec\u00fatalo con el anterior comando. Anota la salida que observas, e intenta determinar (a la vista de la invocaci\u00f3n a qemu que se realiza) cu\u00e1les son sus principales par\u00e1metros de ejecuci\u00f3n.","title":"Ejecuci\u00f3n de una aplicaci\u00f3n"},{"location":"ANIOT/P8/#depuracion-actividad-opcional","text":"Para depurar una aplicaci\u00f3n en QEMU, utiliza el siguiente comando: idf.py qemu gdb Este comando permite construir la aplicaci\u00f3n, arranca QEMU con un servidor GDB activado, y abre una terminal interactiva GDB. Este comando es muy \u00fatil para depurar un binario construido, por ejemplo, para nuestros ESP32, ya que no proporcionan capacidades de depuraci\u00f3n en chip (en el caso de los ESP32-C3, esto s\u00ed es posible). En este caso, para observar la salida del programa mientras est\u00e1s depurando, utiliza dos terminales: En la primera, ejecuta el siguiente comando, que arranca QEMU y el monitor IDF, e indica al primero que espere a una conexi\u00f3n entrante GDB: idf.py qemu --gdb monitor En la segunda, ejecuta el siguiente comando, que inicia una sesi\u00f3n GDB y la conecta a QEMU. Desde esta sesi\u00f3n puedes depurar el c\u00f3digo, y la salida ser\u00e1 visible en la primera: idf.py gdb Tarea (opcional) Depura tu proyecto blink estableciendo un breakpont en la funci\u00f3n app_main , y ejec\u00fatalo paso a paso observando la salida por pantalla.","title":"Depuraci\u00f3n (actividad opcional)"},{"location":"ANIOT/P8/#emulacion-de-efuse","text":"QEMU soporta tambi\u00e9n la emulaci\u00f3n de eFuse, clave para el desarrollo de la pr\u00e1ctica, ya que es una forma muy adecuada de probar aspectos de seguridad como arranque seguro y encriptaci\u00f3n de flash, sin dejar a las placas f\u00edsicas en estados irreversibles. La herramienta idf.py es la encargada de programar eFuses. Al ejecutar cualquiera de los siguientes comandos, se programan los eFuses del procesador emulado por QEMU a trav\u00e9s del fichero qemu_efuse.bin , que se utiliza como habr\u00e1s observado como argumento en la ejecuci\u00f3n. Por ejemplo: idf.py qemu efuse-burn FLASH_CRYPT_CNT 1 idf.py qemu efuse-burn-key flash_encryption my_flash_encryption_key.bin Para mostrar un resumen del contenido de los eFuse, ejecuta: idf.py qemu efuse-summary","title":"Emulaci\u00f3n de eFuse"},{"location":"ANIOT/P8/#especificacion-del-fichero-de-imagen","text":"Por defecto, QEMU usa un fichero de imagen llamado qemu_flash.bin que se construye en el directorio de construcci\u00f3n ( build ). Este fichero se genera en base a la informaci\u00f3n que se incluye en un fichero llamado flash_args que reside en el mismo directorio. Para usar otro fichero alternativo, podemos ejecutar: idf.py qemu --flash-file fichero.bin monitor","title":"Especificaci\u00f3n del fichero de imagen"},{"location":"ANIOT/P8/#arranque-seguro","text":"Nota En esta parte de la pr\u00e1ctica, se sugiere que sigas trabajando con el mismo proyecto que elegiste en la primera (se sugiere blink ). En todo caso, trabaja sobre un directorio nuevo para no perder el trabajo realizado en el apartado anterior, por ejemplo, blink_secure . Nota Revisa las diapositivas de clase para recordar el background, funcionamiento y etapas de la verificaci\u00f3n de bootloader e im\u00e1genes proporcionadas por el proceso de arranque seguro.","title":"Arranque seguro"},{"location":"ANIOT/P8/#como-habilitar-el-arranque-seguro","text":"Tarea Sigue los siguientes pasos para configurar tu proyecto para arranque en modo seguro, documentando todos los pasos y posibles observaciones en la memoria. Selecciona como target ESP32. Abre el men\u00fa de configuraci\u00f3n del proyecto. En Security Features habilita la opci\u00f3n Enable hardware Secure Boot in Bootloader para habilitar el arranque seguro. Deber\u00e1s tambi\u00e9n especificar el esquema de firma RSA y la versi\u00f3n 2 de Secure Boot en las opciones App signing scheme y Select Secure Boot version . Si no te aparecen, pasa al punto 2 para habilitarlo y podr\u00e1s seleccionarlas. Para los ESP32, Secure Boot V2 solo est\u00e1 disponible para ESP32 revisi\u00f3n ECO3 en adelante. Para ver la opci\u00f3n \"Secure Boot V2\", la revisi\u00f3n del chip debe cambiarse a la revisi\u00f3n 3 (ESP32-ECO3). Para cambiar la revisi\u00f3n del chip, configura la opci\u00f3n Minimum Supported ESP32 Revision a Rev 3 en Hardware Settings -> Chip revision -> Minimum Supported ESP32 revision . Especifica la ruta a la clave de firma de arranque seguro, relativa al directorio del proyecto. Puedes dejar su valor por defecto (deber\u00eda ser secure_boot_signing_key.pem ) o usar otro. Importante : selecciona tambi\u00e9n la opci\u00f3n para que el bootloader forme parte del proceso de flasheo cuando se usa arranque seguro (estar\u00e1 deshabilitada por defecto). La opci\u00f3n se denomina Flash bootloader along with other artifacts using the default flash command . Selecciona el modo de descarga de ROM UART deseado en \"UART ROM download mode\". De forma predeterminada, el modo de descarga de ROM UART se ha mantenido habilitado para evitar deshabilitarlo permanentemente en la fase de desarrollo; esta opci\u00f3n es potencialmente insegura. Se recomienda deshabilitar el modo de descarga UART para mayor seguridad. Opcionalmente, puedes aumentar la informaci\u00f3n mostrada por el bootloader aumentando el valor de la opci\u00f3n Bootloader log verbosity a Info o Verbose. Ten cuidado porque esto aumentar\u00e1 el tama\u00f1o del bootloader, y probablemente debas aumentar entonces el offset de la tabla de particiones a un valor mucho mayor al establecido por defecto (opci\u00f3n Offset of partition table a 0xe000 como m\u00e1ximo para dar cabida al bootloader. Guarda la configuraci\u00f3n (a\u00f1ade si lo deseas m\u00e1s opciones), y abandona la fase de configuraci\u00f3n. La primera vez que ejecute la construcci\u00f3n con idf.py build , si no se encuentra la clave de firma, se imprimir\u00e1 un mensaje de error con un comando para generar una clave de firma a trav\u00e9s del comando: espsecure.py generate_signing_key Importante Una clave de firma generada de esta manera utilizar\u00e1 la mejor fuente de n\u00fameros aleatorios disponible para el sistema operativo y tu instalaci\u00f3n de Python ( /dev/urandom en OSX/Linux y CryptGenRandom() en Windows). Si esta fuente de n\u00fameros aleatorios es d\u00e9bil, entonces la clave privada ser\u00e1 d\u00e9bil. Importante Para entornos de producci\u00f3n, se recomienda generar el par de claves mediante openssl u otro programa de cifrado est\u00e1ndar de la industria. Tienes m\u00e1s informaci\u00f3n sobre c\u00f3mo hacer esto aqu\u00ed . De todos modos, dejamos esta parte como opcional en la pr\u00e1ctica. Tras la ejecuci\u00f3n de la orden idf.py build de forma exitosa, se habr\u00e1n creado las im\u00e1genes para el bootloader , tabla de particiones e imagen de aplicaci\u00f3n individualmente en el directorio de construcci\u00f3n. Identif\u00edcalas. La imagen final a flashear deber\u00eda generarse fusionando el bootloader , la tabla de particiones y la imagen de aplicaci\u00f3n. Una forma sencilla, si se ha seguido el paso 4, es utilizar la herramienta esptool.py de la siguiente manera: (cd build; esptool.py --chip esp32c3 merge_bin --fill-flash-size 4MB -o flash_image.bin @flash_args) Como vamos a trabajar con QEMU, tenemos ya lista la imagen que se ejecutar\u00e1 en el emulador. Si trabajasemos con una placa real, pasar\u00edamos en este punto por una fase de flasheado de la imagen. Monitoriza la ejecuci\u00f3n en QEMU siguiendo la forma de trabajar de ejemplos anteriores. Documenta lo que ves en la salida (en referencia al arranque seguro). Tarea F\u00edjate en el proceso de verificaci\u00f3n de bloques de firmas y de im\u00e1genes (incluyendo bootloader e imagen de aplicaci\u00f3n). Comprueba que concuerdan con los explicados en clase y en la documentaci\u00f3n de ESP-IDF enlazada al inicio de esta memoria. Tarea \u00bfQu\u00e9 ocurrir\u00eda si un compa\u00f1ero te pasa su imagen de aplicaci\u00f3n o su bootloader , y t\u00fa lo integras en la imagen que emulas? \u00bfY que ocurrir\u00eda si usas tus im\u00e1genes con el fichero de firma de tu compa\u00f1ero/a? Intenta ver qu\u00e9 ocurre en el proceso de verificaci\u00f3n de firmas en esos casos. De la misma forma, intenta ver qu\u00e9 ocurre si modificas un byte en la imagen firmada (no hagas esto con el bootloader ). Si has seguido el paso 4, Ejecutar para crear un cargador de arranque habilitado para arranque seguro. La salida de la compilaci\u00f3n incluir\u00e1 un mensaje para un comando de actualizaci\u00f3n, utilizando .idf.py bootloaderesptool.py write_flash","title":"\u00bfC\u00f3mo habilitar el arranque seguro?"},{"location":"ANIOT/P8/#encriptacion-de-flash","text":"Tarea Sigue los siguientes pasos para configurar tu proyecto para integrar la encriptaci\u00f3n de flash, documentando todos los pasos y posibles observaciones en la memoria. Como en anteriores ejercicios, utiliza el mismo proyecto ( blink ) pero trabaja en una nueva carpeta, por ejemplo blink_encrypted . Parte del proyecto en blanco, no del que integra el arranque seguro. La encriptaci\u00f3n de flash tiene como objetivo encriptar los contenidos de la memoria flash del ESP32. Cuando se habilita, el firmware se flashea en claro, y se encripta al vuelo ( in-place ) en el primer arranque. As\u00ed, una simple lectura de flash deja de ser suficiente como para recuperar los datos almacenados. Esta caracter\u00edstica puede o no habilitarse junto al arranque seguro, aunque en esta pr\u00e1ctica no las combinaremos . Cuando se habilita, los siguientes tipos de partici\u00f3n se encriptan por defecto: Second stage bootloader . Tabla de particiones. NVS. OTADATA. Todas las particiones de tipo app .o Tienes una referencia sobre los eFuses a activar en la documentaci\u00f3n oficial .","title":"Encriptaci\u00f3n de FLASH"},{"location":"ANIOT/P8/#como-funciona-la-encriptacion","text":"Asumiendo que se ha activado la encriptaci\u00f3n, \u00e9sta procede de la siguiente manera: En el primer arranque, los datos en flash est\u00e1n desencriptados (almacenados en claro). El bootloader lee el eFuse FLASH_CRYPT_CNT . Si su valor es 0, configura el bloque de encriptaci\u00f3n (la activa). El bootloader chequea si hay una clave v\u00e1lida presente en eFuse. Si es el caso, no se genera una nueva. Si no lo es se procede a la generaci\u00f3n de una clave y se almacena en el eFuse flash_encryption . El hardware de encriptaci\u00f3n encripta los contenidos de la flash. Este proceso puede ser lento. El bootloader fija la activaci\u00f3n modificando el valor del eFuse FLASH_CRYPT_CNT. El dispositivo se resetea.","title":"C\u00f3mo funciona la encriptaci\u00f3n"},{"location":"ANIOT/P8/#como-se-activa-la-encriptacion-modo-development","text":"En el men\u00fa de configuraci\u00f3n, simplemente busca y activa la opci\u00f3n Enable Flash Encryption on Boot . Tarea Activa la encriptaci\u00f3n de FLASH en tu proyecto blink . Observa y anota las fases por las que pasa el proceso de arranque (a\u00f1ade logs al bootloader) y comprueba si coinciden con las fases anteriormente mencionadas. \u00bfNotas alguna penalizaci\u00f3n de rendimiento evidente en alguna fase? Tarea Tras observar el funcionamiento con el proyecto blink , ser\u00eda conveniente observar el efecto de la encriptaci\u00f3n en los datos almacenados en flash. Para ello, usaremos el ejemplo flash_encryption de ESP-IDF. Cl\u00f3nalo y chequea si est\u00e1 o no activa la encriptaci\u00f3n. A continuaci\u00f3n, flashea y ejecuta (en QEMU) el c\u00f3digo. Observa la salida. Cambia la funcionalidad de encriptaci\u00f3n y vuelve a observarla. \u00bfQu\u00e9 ves en pantalla? Estudia el c\u00f3digo e intenta entender qu\u00e9 est\u00e1 pasando, y por qu\u00e9 en un caso el contenido de la flash es \"entendible\", y en otro no. \u00bfQu\u00e9 funciones usa el c\u00f3digo para realizar la lectura con desencriptaci\u00f3n y en crudo?","title":"C\u00f3mo se activa la encriptaci\u00f3n (modo development)"},{"location":"ANIOT/P8/#encriptacion-de-nvs","text":"De forma independiente a la encriptaci\u00f3n de FLASH, es posible llevar a cabo un proceso de encriptaci\u00f3n \u00fanicamente de los datos almacenados en NVS en forma clave-valor. Esta soluci\u00f3n aporta cierta seguridad (en una parte de los datos), y a la vez no empeora el rendimiento como s\u00ed hace la encriptaci\u00f3n total de flash. Tarea El ejemplo nvs_encryption_hmac propone una forma muy sencilla de observar el efecto de la encriptaci\u00f3n de NVS sobre el contenido que se almacena en la partici\u00f3n NVS de la flash. Comp\u00edlalo y ejec\u00fatalo tal con NVS desactivado (busca la opci\u00f3n correspondiente en los men\u00fas de configuraci\u00f3n). \u00bfQu\u00e9 observas? A continuaci\u00f3n, activa la encriptaci\u00f3n NVS. \u00bfQu\u00e9 observas? IMPORTANTE: este proyecto debe configurarse para ESP32-C3, ya que solo \u00e9l tiene soporte para HMAC, t\u00e9cnica usada para encriptar NVS. Adem\u00e1s, la opci\u00f3n eFuse key ID storing the HMAC key debe fijarse a 3 . En todo caso, la ejecuci\u00f3n se emular\u00e1 v\u00eda QEMU. Recuerda: no conectes tu placa .","title":"Encriptaci\u00f3n de NVS"},{"location":"ANIOT/P9/","text":"Pr\u00e1ctica en desarrollo","title":"Pr\u00e1ctica en desarrollo"},{"location":"ANIOT/P9/#practica-en-desarrollo","text":"","title":"Pr\u00e1ctica en desarrollo"},{"location":"LSI/Bookworm/","text":"RPI-4 con RPi OS 64 bookworm Las siguientes instrucciones suponen que se ha instalado Raspberry Pi OS 64-bit en su versi\u00f3n Bookworm 2024-03-15. Y que se emplea la siguiente versi\u00f3n del LSI_Lab1_old.tgz. 1. Diferencias en la gesti\u00f3n de la c\u00e1mara libcamera La c\u00e1mara ya no se gestiona del mismo modo, ahora se hace por medio de la libcamera . Para m\u00e1s informaci\u00f3n sobre los m\u00f3dulos de c\u00e1mara de la Raspberry Pi y el software asociado consultar el siguiente enlace (mejor no buscar en Google porque la mayor parte de la informaci\u00f3n est\u00e1 obsoleta). Asociado a este nuevo interfaz se proporcionan nuevas herramientas de l\u00ednea de comandos como libcamera-hello , libcamera-still , etc. que son \u00fatiles para comprobar el correcto funcionamiento de la c\u00e1mara. Problema de OpenCV y libcamera Al usar la libcamera hay un problema de compatibilidad con OpenCV y la c\u00e1mara de la Raspberry Pi no se puede usar directamente como dispositivo 0 , es necesario usarlo a trav\u00e9s de un pipeline de Gstreamer . 2. Gstreamer \u00bfQu\u00e9 es? GStreamer es un framework de c\u00f3digo abierto para la creaci\u00f3n, manipulaci\u00f3n y reproducci\u00f3n de flujos multimedia. Instalaci\u00f3n Gstreamer Es preciso instalar los siguientes paquetes (basado este enlace y actualizado para bookworm ) # install a missing dependency $ sudo apt-get install libx264-dev libjpeg-dev # install the remaining plugins $ sudo apt-get install libgstreamer1.0-dev \\ libgstreamer-plugins-base1.0-dev \\ libgstreamer-plugins-bad1.0-dev \\ gstreamer1.0-plugins-ugly \\ gstreamer1.0-tools \\ gstreamer1.0-gl \\ gstreamer1.0-gtk3 # if you have Qt5 install this plugin $ sudo apt-get install gstreamer1.0-qt5 # install the compatibility package $ sudo apt-get install gstreamer1.0-libcamera # install if you want to work with audio $ sudo apt-get install gstreamer1.0-pulseaudio Prueba de un pipeline b\u00e1sico (640x480) $ gst-launch-1.0 libcamerasrc ! video/x-raw, width=640, height=480, framerate=30/1 ! videoconvert ! videoscale ! clockoverlay time-format=\"%D %H:%M:%S\" ! autovideosink 3. OpenCV Instalaci\u00f3n de OpenCV (4.6) Por defecto Bookworm incluye la versi\u00f3n 4.6, si se necesita una m\u00e1s reciente es preciso compilarla o buscar un binario pre-compilado. $ sudo apt-get install libopencv-dev $ sudo apt-get install python3-opencv Ejemplo C++ de OpenCV empleando libcamera+gstreamer Basado en este ejemplo para Bulleye pero retocado Bookworm : $ git clone https://github.com/Qengineering/Libcamera-OpenCV-RPi-Bullseye-64OS $ cd Libcamera-OpenCV-RPi-Bullseye-64OS Modificar el fichero GStreamer_RPi_64_Bullseye.cbp del siguiente modo: diff --git a/GStreamer_RPi_64_Bullseye.cbp b/GStreamer_RPi_64_Bullseye.cbp index 69b7181..0d27522 100644 --- a/GStreamer_RPi_64_Bullseye.cbp +++ b/GStreamer_RPi_64_Bullseye.cbp @@ -32,7 +32,7 @@ <Add option=\"-Wall\" /> <Add option=\"-fexceptions\" /> <Add option=\"-pthread\" /> - <Add directory=\"/usr/local/include/opencv4\" /> + <Add directory=\"/usr/include/opencv4\" /> <Add directory=\"/usr/include/gstreamer-1.0\" /> <Add directory=\"/usr/lib/aarch64-linux-gnu/glib-2.0/include\" /> <Add directory=\"/usr/include/glib-2.0\" /> @@ -43,7 +43,7 @@ <Add option=\"-pthread\" /> <Add library=\"/usr/lib/aarch64-linux-gnu/libgobject-2.0.so\" /> <Add library=\"/usr/lib/aarch64-linux-gnu/libgstreamer-1.0.so\" /> - <Add library=\"/usr/lib/aarch64-linux-gnu/libgstapp-1.0.so\" /> + <Add library=\"/usr/lib/aarch64-linux-gnu/libgstapp-1.0.so.0\" /> <Add directory=\"/usr/local/lib/\" /> </Linker> <Unit filename=\"main.cpp\" /> Para compilar este ejemplo es necesario instalar CodeBlocks, abrir el proyecto (fichero .cbp ) y construirlo. Se puede ejecutar tanto desde CodeBlocks como desde l\u00ednea de comando (`) $ sudo apt-get install codeblocks Esencialmente el c\u00f3digo lo que hace es abrir pipeline de Gstreamer como el visto anteriormente: std::string gstreamer_pipeline(int capture_width, int capture_height, int framerate, int display_width, int display_height) { return \" libcamerasrc ! video/x-raw, \" \" width=(int)\" + std::to_string(capture_width) + \",\" \" height=(int)\" + std::to_string(capture_height) + \",\" \" framerate=(fraction)\" + std::to_string(framerate) +\"/1 !\" \" videoconvert ! videoscale !\" \" video/x-raw,\" \" width=(int)\" + std::to_string(display_width) + \",\" \" height=(int)\" + std::to_string(display_height) + \" ! appsink\"; } //pipeline parameters int capture_width = 640; //1280 ; int capture_height = 480; //720 ; int framerate = 15 ; int display_width = 640; //1280 ; int display_height = 480; //720 ; // create pipeline string std::string pipeline = gstreamer_pipeline(capture_width, capture_height, framerate, display_width, display_height); // open pipeline cv::VideoCapture cap(pipeline, cv::CAP_GSTREAMER); Este c\u00f3digo se puede reutlizar en los laboratorios del Lab1. Ejemplo Python de OpenCV empleando libcamera+gstreamer Bastar\u00eda con substituir cap = cv2.VideoCapture(0) por la siguiente secuencia de c\u00f3digo y todo deber\u00eda funcionar correctamente: pipeline = \"libcamerasrc ! video/x-raw, width=(int)640, height=(int)480, framerate=(fraction)15/1 ! videoconvert ! videoscale ! video/x-raw, width=(int)640, height=(int)480 ! appsink\" cap = cv2.VideoCapture(pipeline,cv2.CAP_GSTREAMER) Se puede probar con el ejemplo de c\u00e1mara de Python del Lab1. 4. Tensorflow-Lite C++ Instalaci\u00f3n Lo m\u00e1s sencillo es buscar un binario reciente pre-compilado para Raspberry Pi OS 64 Bookworm como por ejemplo este: TF-Lite 2.16.1 . El proceso de instalaci\u00f3n es sencillo: $ wget https://github.com/prepkg/tensorflow-lite-raspberrypi/releases/latest/download/tensorflow-lite_64.deb $ sudo dpkg -i tensorflow-lite_64.deb Lab1/Classificacion/CPP Para probar el ejemplo C++ de clasificaci\u00f3n de im\u00e1genes del Lab1 basta con realizar las modificaciones relativas a la captura de c\u00e1mara comentadas anteriormente y compilar el c\u00f3digo con el siguiente comando en lugar del empleado originalmente: $ cd LSI_Lab1/Clasificacion/CPP $ g++ classification.cpp -I /usr/local/include -lpthread -ldl -ltensorflow-lite `pkg-config --cflags --libs opencv4` -o classification.x Para probarlo, al igual que vimos en su momento hay que descargar previamente los modelos. De momento s\u00f3lo la versi\u00f3n CPU y mejor hacerlo con los siguiente comandos: $ cd LSI_Lab1/Clasificacion/ $ curl -O https://storage.googleapis.com/download.tensorflow.org/models/tflite/mobilenet_v1_1.0_224_quant_and_labels.zip $ unzip mobilenet_v1_1.0_224_quant_and_labels.zip -d Modelos $ rm mobilenet_v1_1.0_224_quant_and_labels.zip Para ejecutar basta con los siguientes comandos: $ cd LSI_Lab1/Clasificacion/CPP $ ./classification.x 5. Runtime EdgeTPU Las fuentes de libedgetpu est\u00e1n disponibles el GitHub de Google-Coral pero lo m\u00e1s sencillo es decargar binarios pre-compilados para bookworm y arm64 (tambi\u00e9n denominado aarch64 ). Instrucciones de instalaci\u00f3n: $ wget https://github.com/feranick/libedgetpu/releases/download/16.0TF2.16.1-1/libedgetpu-dev_16.0tf2.16.1-1.bookworm_arm64.deb $ wget https://github.com/feranick/libedgetpu/releases/download/16.0TF2.16.1-1/libedgetpu1-max_16.0tf2.16.1-1.bookworm_arm64.deb $ sudo dpkg -i libedgetpu* 6. Diferencias en la gesti\u00f3n de m\u00f3dulos de Python Debian Bookworm incluye por defecto Python 3.11 que exige la utilizaci\u00f3n de entornos virtuales para la gesti\u00f3n de m\u00f3dulos. Si no se emplea un entorno virtual aparece un aviso: $ pip3 install tensorflow error: externally-managed-environment \u00d7 This environment is externally managed \u2570\u2500> To install Python packages system-wide, try apt install python3-xyz, where xyz is the package you are trying to install. If you wish to install a non-Debian-packaged Python package, create a virtual environment using python3 -m venv path/to/venv. Then use path/to/venv/bin/python and path/to/venv/bin/pip. Make sure you have python3-full installed. For more information visit http://rptl.io/venv note: If you believe this is a mistake, please contact your Python installation or OS distribution provider. You can override this, at the risk of breaking your Python installation or OS, by passing --break-system-packages. Aunque no es la manera m\u00e1s elegante, en nuestro contexto, lo m\u00e1s sencillo es deshabilitar ese chequeo mediante el siguiente comando: $ sudo mv /usr/lib/python3.11/EXTERNALLY-MANAGED /usr/lib/python3.11/EXTERNALLY-MANAGED.old 7. TF-Lite y EdgeTPU desde Python Basta con instalar los paquetes correspondientes: $ pip3 install tflite-runtime Para poder usar los ejemplos del Lab1 basta con modificar la captura de c\u00e1mara como hemos indicado previamente.","title":"RPI-4 con RPi OS 64 bookworm"},{"location":"LSI/Bookworm/#rpi-4-con-rpi-os-64-bookworm","text":"Las siguientes instrucciones suponen que se ha instalado Raspberry Pi OS 64-bit en su versi\u00f3n Bookworm 2024-03-15. Y que se emplea la siguiente versi\u00f3n del LSI_Lab1_old.tgz.","title":"RPI-4 con RPi OS 64 bookworm"},{"location":"LSI/Bookworm/#1-diferencias-en-la-gestion-de-la-camara","text":"","title":"1. Diferencias en la gesti\u00f3n de la c\u00e1mara"},{"location":"LSI/Bookworm/#libcamera","text":"La c\u00e1mara ya no se gestiona del mismo modo, ahora se hace por medio de la libcamera . Para m\u00e1s informaci\u00f3n sobre los m\u00f3dulos de c\u00e1mara de la Raspberry Pi y el software asociado consultar el siguiente enlace (mejor no buscar en Google porque la mayor parte de la informaci\u00f3n est\u00e1 obsoleta). Asociado a este nuevo interfaz se proporcionan nuevas herramientas de l\u00ednea de comandos como libcamera-hello , libcamera-still , etc. que son \u00fatiles para comprobar el correcto funcionamiento de la c\u00e1mara.","title":"libcamera"},{"location":"LSI/Bookworm/#problema-de-opencv-y-libcamera","text":"Al usar la libcamera hay un problema de compatibilidad con OpenCV y la c\u00e1mara de la Raspberry Pi no se puede usar directamente como dispositivo 0 , es necesario usarlo a trav\u00e9s de un pipeline de Gstreamer .","title":"Problema de OpenCV y libcamera"},{"location":"LSI/Bookworm/#2-gstreamer","text":"","title":"2. Gstreamer"},{"location":"LSI/Bookworm/#que-es","text":"GStreamer es un framework de c\u00f3digo abierto para la creaci\u00f3n, manipulaci\u00f3n y reproducci\u00f3n de flujos multimedia.","title":"\u00bfQu\u00e9 es?"},{"location":"LSI/Bookworm/#instalacion-gstreamer","text":"Es preciso instalar los siguientes paquetes (basado este enlace y actualizado para bookworm ) # install a missing dependency $ sudo apt-get install libx264-dev libjpeg-dev # install the remaining plugins $ sudo apt-get install libgstreamer1.0-dev \\ libgstreamer-plugins-base1.0-dev \\ libgstreamer-plugins-bad1.0-dev \\ gstreamer1.0-plugins-ugly \\ gstreamer1.0-tools \\ gstreamer1.0-gl \\ gstreamer1.0-gtk3 # if you have Qt5 install this plugin $ sudo apt-get install gstreamer1.0-qt5 # install the compatibility package $ sudo apt-get install gstreamer1.0-libcamera # install if you want to work with audio $ sudo apt-get install gstreamer1.0-pulseaudio","title":"Instalaci\u00f3n Gstreamer"},{"location":"LSI/Bookworm/#prueba-de-un-pipeline-basico-640x480","text":"$ gst-launch-1.0 libcamerasrc ! video/x-raw, width=640, height=480, framerate=30/1 ! videoconvert ! videoscale ! clockoverlay time-format=\"%D %H:%M:%S\" ! autovideosink","title":"Prueba de un pipeline b\u00e1sico (640x480)"},{"location":"LSI/Bookworm/#3-opencv","text":"","title":"3. OpenCV"},{"location":"LSI/Bookworm/#instalacion-de-opencv-46","text":"Por defecto Bookworm incluye la versi\u00f3n 4.6, si se necesita una m\u00e1s reciente es preciso compilarla o buscar un binario pre-compilado. $ sudo apt-get install libopencv-dev $ sudo apt-get install python3-opencv","title":"Instalaci\u00f3n de OpenCV (4.6)"},{"location":"LSI/Bookworm/#ejemplo-c-de-opencv-empleando-libcameragstreamer","text":"Basado en este ejemplo para Bulleye pero retocado Bookworm : $ git clone https://github.com/Qengineering/Libcamera-OpenCV-RPi-Bullseye-64OS $ cd Libcamera-OpenCV-RPi-Bullseye-64OS Modificar el fichero GStreamer_RPi_64_Bullseye.cbp del siguiente modo: diff --git a/GStreamer_RPi_64_Bullseye.cbp b/GStreamer_RPi_64_Bullseye.cbp index 69b7181..0d27522 100644 --- a/GStreamer_RPi_64_Bullseye.cbp +++ b/GStreamer_RPi_64_Bullseye.cbp @@ -32,7 +32,7 @@ <Add option=\"-Wall\" /> <Add option=\"-fexceptions\" /> <Add option=\"-pthread\" /> - <Add directory=\"/usr/local/include/opencv4\" /> + <Add directory=\"/usr/include/opencv4\" /> <Add directory=\"/usr/include/gstreamer-1.0\" /> <Add directory=\"/usr/lib/aarch64-linux-gnu/glib-2.0/include\" /> <Add directory=\"/usr/include/glib-2.0\" /> @@ -43,7 +43,7 @@ <Add option=\"-pthread\" /> <Add library=\"/usr/lib/aarch64-linux-gnu/libgobject-2.0.so\" /> <Add library=\"/usr/lib/aarch64-linux-gnu/libgstreamer-1.0.so\" /> - <Add library=\"/usr/lib/aarch64-linux-gnu/libgstapp-1.0.so\" /> + <Add library=\"/usr/lib/aarch64-linux-gnu/libgstapp-1.0.so.0\" /> <Add directory=\"/usr/local/lib/\" /> </Linker> <Unit filename=\"main.cpp\" /> Para compilar este ejemplo es necesario instalar CodeBlocks, abrir el proyecto (fichero .cbp ) y construirlo. Se puede ejecutar tanto desde CodeBlocks como desde l\u00ednea de comando (`) $ sudo apt-get install codeblocks Esencialmente el c\u00f3digo lo que hace es abrir pipeline de Gstreamer como el visto anteriormente: std::string gstreamer_pipeline(int capture_width, int capture_height, int framerate, int display_width, int display_height) { return \" libcamerasrc ! video/x-raw, \" \" width=(int)\" + std::to_string(capture_width) + \",\" \" height=(int)\" + std::to_string(capture_height) + \",\" \" framerate=(fraction)\" + std::to_string(framerate) +\"/1 !\" \" videoconvert ! videoscale !\" \" video/x-raw,\" \" width=(int)\" + std::to_string(display_width) + \",\" \" height=(int)\" + std::to_string(display_height) + \" ! appsink\"; } //pipeline parameters int capture_width = 640; //1280 ; int capture_height = 480; //720 ; int framerate = 15 ; int display_width = 640; //1280 ; int display_height = 480; //720 ; // create pipeline string std::string pipeline = gstreamer_pipeline(capture_width, capture_height, framerate, display_width, display_height); // open pipeline cv::VideoCapture cap(pipeline, cv::CAP_GSTREAMER); Este c\u00f3digo se puede reutlizar en los laboratorios del Lab1.","title":"Ejemplo C++ de OpenCV empleando libcamera+gstreamer"},{"location":"LSI/Bookworm/#ejemplo-python-de-opencv-empleando-libcameragstreamer","text":"Bastar\u00eda con substituir cap = cv2.VideoCapture(0) por la siguiente secuencia de c\u00f3digo y todo deber\u00eda funcionar correctamente: pipeline = \"libcamerasrc ! video/x-raw, width=(int)640, height=(int)480, framerate=(fraction)15/1 ! videoconvert ! videoscale ! video/x-raw, width=(int)640, height=(int)480 ! appsink\" cap = cv2.VideoCapture(pipeline,cv2.CAP_GSTREAMER) Se puede probar con el ejemplo de c\u00e1mara de Python del Lab1.","title":"Ejemplo Python de OpenCV empleando libcamera+gstreamer"},{"location":"LSI/Bookworm/#4-tensorflow-lite-c","text":"","title":"4. Tensorflow-Lite C++"},{"location":"LSI/Bookworm/#instalacion","text":"Lo m\u00e1s sencillo es buscar un binario reciente pre-compilado para Raspberry Pi OS 64 Bookworm como por ejemplo este: TF-Lite 2.16.1 . El proceso de instalaci\u00f3n es sencillo: $ wget https://github.com/prepkg/tensorflow-lite-raspberrypi/releases/latest/download/tensorflow-lite_64.deb $ sudo dpkg -i tensorflow-lite_64.deb","title":"Instalaci\u00f3n"},{"location":"LSI/Bookworm/#lab1classificacioncpp","text":"Para probar el ejemplo C++ de clasificaci\u00f3n de im\u00e1genes del Lab1 basta con realizar las modificaciones relativas a la captura de c\u00e1mara comentadas anteriormente y compilar el c\u00f3digo con el siguiente comando en lugar del empleado originalmente: $ cd LSI_Lab1/Clasificacion/CPP $ g++ classification.cpp -I /usr/local/include -lpthread -ldl -ltensorflow-lite `pkg-config --cflags --libs opencv4` -o classification.x Para probarlo, al igual que vimos en su momento hay que descargar previamente los modelos. De momento s\u00f3lo la versi\u00f3n CPU y mejor hacerlo con los siguiente comandos: $ cd LSI_Lab1/Clasificacion/ $ curl -O https://storage.googleapis.com/download.tensorflow.org/models/tflite/mobilenet_v1_1.0_224_quant_and_labels.zip $ unzip mobilenet_v1_1.0_224_quant_and_labels.zip -d Modelos $ rm mobilenet_v1_1.0_224_quant_and_labels.zip Para ejecutar basta con los siguientes comandos: $ cd LSI_Lab1/Clasificacion/CPP $ ./classification.x","title":"Lab1/Classificacion/CPP"},{"location":"LSI/Bookworm/#5-runtime-edgetpu","text":"Las fuentes de libedgetpu est\u00e1n disponibles el GitHub de Google-Coral pero lo m\u00e1s sencillo es decargar binarios pre-compilados para bookworm y arm64 (tambi\u00e9n denominado aarch64 ). Instrucciones de instalaci\u00f3n: $ wget https://github.com/feranick/libedgetpu/releases/download/16.0TF2.16.1-1/libedgetpu-dev_16.0tf2.16.1-1.bookworm_arm64.deb $ wget https://github.com/feranick/libedgetpu/releases/download/16.0TF2.16.1-1/libedgetpu1-max_16.0tf2.16.1-1.bookworm_arm64.deb $ sudo dpkg -i libedgetpu*","title":"5. Runtime EdgeTPU"},{"location":"LSI/Bookworm/#6-diferencias-en-la-gestion-de-modulos-de-python","text":"Debian Bookworm incluye por defecto Python 3.11 que exige la utilizaci\u00f3n de entornos virtuales para la gesti\u00f3n de m\u00f3dulos. Si no se emplea un entorno virtual aparece un aviso: $ pip3 install tensorflow error: externally-managed-environment \u00d7 This environment is externally managed \u2570\u2500> To install Python packages system-wide, try apt install python3-xyz, where xyz is the package you are trying to install. If you wish to install a non-Debian-packaged Python package, create a virtual environment using python3 -m venv path/to/venv. Then use path/to/venv/bin/python and path/to/venv/bin/pip. Make sure you have python3-full installed. For more information visit http://rptl.io/venv note: If you believe this is a mistake, please contact your Python installation or OS distribution provider. You can override this, at the risk of breaking your Python installation or OS, by passing --break-system-packages. Aunque no es la manera m\u00e1s elegante, en nuestro contexto, lo m\u00e1s sencillo es deshabilitar ese chequeo mediante el siguiente comando: $ sudo mv /usr/lib/python3.11/EXTERNALLY-MANAGED /usr/lib/python3.11/EXTERNALLY-MANAGED.old","title":"6. Diferencias en la gesti\u00f3n de m\u00f3dulos de Python"},{"location":"LSI/Bookworm/#7-tf-lite-y-edgetpu-desde-python","text":"Basta con instalar los paquetes correspondientes: $ pip3 install tflite-runtime Para poder usar los ejemplos del Lab1 basta con modificar la captura de c\u00e1mara como hemos indicado previamente.","title":"7. TF-Lite y EdgeTPU desde Python"},{"location":"LSI/Lab0/","text":"Laboratorio 0. Entorno experimental Objetivos Preparar el entorno experimental. Completar la configuraci\u00f3n del sistema. Probar el correcto funcionamiento tanto del Software como del Hardware. Familiarizase con la captura de im\u00e1genes mediante OpenCV 1. Introducci\u00f3n El entorno experimental que se va a emplear en esta parte de la asignatura est\u00e1 compuesto de los siguientes elementos: Hardware Kit Raspberry Pi 4 Placa Raspberry Pi 4 con un SoC Broadcom BCM2711 con las siguientes caracter\u00edsticas: Quad core de Cortex-A72, ARM v8 de 64-bit, @1.5GHz (+ info ) Alimentador USB-C Cable micro-HDMI a HDMI Tarjeta uSD de alta velocidad Kit aceleraci\u00f3n Acelerador Coral USB (+ info ) C\u00e1mara para Raspberry Pi v2 Lector de tarjetas SD No proporcionado, pero un gran n\u00famero de port\u00e1tiles lo llevan integrado. Software Raspberry Pi OS - Distribuci\u00f3n Linux basada en Debian adaptada a la Raspberry Pi en su versi\u00f3n de 64 bits OpenCV - Librer\u00eda de visi\u00f3n por computador A continuaci\u00f3n se proporcionan las instrucciones para configurar y probar el entorno experimental. 2. Preparaci\u00f3n SD Grabar el sistema operativo Raspberry Pi OS (64-bit) en una SD siguiendo las instrucciones de instalaci\u00f3n de la web oficial de Raspberry Pi. 3. Conexi\u00f3n, arranque y configuraci\u00f3n Realizar la conexi\u00f3n de los dispositivos Conectar el teclado y el rat\u00f3n a los puertos USB 2.0, dejando al menos uno de los puertos USB 3.0 libre para el acelerador Google Coral (tienen un remate azul) Conectar el monitor mediante el cable micro-HDMI a HDMI Insertar la tarjeta SD grabada previamente Conectar la c\u00e1mara \"Raspberry Pi Camera Module v2\" (sensor Sony IMX219, interfaz CSI-2, resoluci\u00f3n 3280 x 2464 p\u00edxeles, 30fps) Para informaci\u00f3n m\u00e1s precisa de la conexi\u00f3n se puede consultar el siguiente video. Conectar alimentaci\u00f3n (cable USB-C), teclado y rat\u00f3n. Comprobar el correcto arranque del equipo y proceder a la configuraci\u00f3n inicial. Configuraci\u00f3n inicial: Seleccionar pa\u00eds, lenguaje y zona horaria. Configurar usuario, contrase\u00f1a. Configurar la Wifi ( rpi-miot ). Seleccionar navegador ( Chromium ). Actualizaci\u00f3n del software. Reiniciar y comprobar la configuraci\u00f3n inicial (en especial la red). Completar la configuraci\u00f3n necesaria: Abrir una ventana de terminal y completar la configuraci\u00f3n mediante comando raspi-config : sudo raspi-config Establecer las opciones de interfaz necesarias: Activar conexi\u00f3n mediante SSH (m\u00ednimo) y recomendable por VNC. Finalizar y reiniciar el equipo 4. Comprobaciones b\u00e1sicas C\u00e1mara La c\u00e1mara ya no se gestiona del mismo modo que en versiones anteriores de Raspberrypi OS, ahora se hace por medio de la librar\u00eda libcamera . Para m\u00e1s informaci\u00f3n sobre los m\u00f3dulos de c\u00e1mara de la Raspberry Pi y el software asociado consultar el siguiente enlace (mejor no buscar en Google porque la mayor parte de la informaci\u00f3n est\u00e1 obsoleta). Comprobar la correcta detecci\u00f3n de la c\u00e1mara: $ libcamera-hello --list-cameras Available cameras ----------------- 0 : imx219 [3280x2464 10-bit RGGB] (/base/soc/i2c0mux/i2c@1/imx219@10) Modes: 'SRGGB10_CSI2P' : 640x480 [206.65 fps - (1000, 752)/1280x960 crop] 1640x1232 [41.85 fps - (0, 0)/3280x2464 crop] 1920x1080 [47.57 fps - (680, 692)/1920x1080 crop] 3280x2464 [21.19 fps - (0, 0)/3280x2464 crop] 'SRGGB8' : 640x480 [206.65 fps - (1000, 752)/1280x960 crop] 1640x1232 [83.70 fps - (0, 0)/3280x2464 crop] 1920x1080 [47.57 fps - (680, 692)/1920x1080 crop] 3280x2464 [21.19 fps - (0, 0)/3280x2464 crop] Comprobar el funcionamiento de la c\u00e1mara: $ libcamera-still Alimentaci\u00f3n y refrigeraci\u00f3n Es crucial garantizar una buena refrigeraci\u00f3n y un voltaje estable en la Raspberry Pi 4 para evitar sobrecalentamiento y fallos del sistema. Un exceso de temperatura reduce el rendimiento, por lo que se recomienda usar disipadores o ventilaci\u00f3n activa. Adem\u00e1s, un voltaje inadecuado puede causar apagones y corrupci\u00f3n de datos, por lo que es esencial un adaptador de 5V y al menos 3A. Comprobar temperatura (opcional) $ vcgencmd measure_temp temp=39.9'C Comprobar voltage y que no se est\u00e1 produciendo throttling : $ vcgencmd get_throttled throttled=0x0 Nota: Si el valor devuelto es distinto de 0x0 consutar la correspondiente p\u00e1gina de manual para identificar el problema ( man vcgencmd ) 5. Gstreamer \u00bfQu\u00e9 es? GStreamer es un framework de c\u00f3digo abierto para la creaci\u00f3n, manipulaci\u00f3n y reproducci\u00f3n de flujos multimedia. Instalaci\u00f3n Gstreamer Es preciso instalar los siguientes paquetes (basado este enlace y actualizado para bookworm ) # install a missing dependency $ sudo apt-get install libx264-dev libjpeg-dev # install the remaining plugins $ sudo apt-get install libgstreamer1.0-dev \\ libgstreamer-plugins-base1.0-dev \\ libgstreamer-plugins-bad1.0-dev \\ gstreamer1.0-plugins-ugly \\ gstreamer1.0-tools \\ gstreamer1.0-gl \\ gstreamer1.0-gtk3 # if you have Qt5 install this plugin $ sudo apt-get install gstreamer1.0-qt5 # install the compatibility package $ sudo apt-get install gstreamer1.0-libcamera # install if you want to work with audio $ sudo apt-get install gstreamer1.0-pulseaudio Prueba de un pipeline de video b\u00e1sico (640x480) $ gst-launch-1.0 libcamerasrc ! video/x-raw, width=640, height=480, framerate=30/1 ! videoconvert ! videoscale ! clockoverlay time-format=\"%D %H:%M:%S\" ! autovideosink 6. OpenCV \u00bfQu\u00e9 es? OpenCV es una biblioteca de visi\u00f3n de c\u00f3digo abierto que proporciona herramientas para procesar y analizar im\u00e1genes y videos. Entre otras cosas proporciona una interfaz completa ( Python y C++ ) para la interacci\u00f3n con c\u00e1maras que usaremos a continuaci\u00f3n. Instalaci\u00f3n de OpenCV (4.6) Por defecto Bookworm incluye la versi\u00f3n 4.6, si se necesita una m\u00e1s reciente es preciso compilarla o buscar un binario pre-compilado. $ sudo apt-get install libopencv-dev $ sudo apt-get install python3-opencv Captura de v\u00eddeos desde la c\u00e1mara (Python) En primer lugar, realizaremos una captura de flujo de v\u00eddeo desde la c\u00e1mara, utilizando la API de OpenCV en Python, realizando una transformaci\u00f3n b\u00e1sica y mostrando el flujo de v\u00eddeo transformado. Tomemos el siguiente script como ejemplo de referencia: import numpy as np import cv2 # 0. Configura camara 0. cap = cv2.VideoCapture(0) while(True): # 1. Adquisici\u00f3n de un frame ret, frame = cap.read() # 2. Operaciones sobre el frame gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) # 3. Mostrar el frame resultante. cv2.imshow('frame',gray) if cv2.waitKey(1) & 0xFF == ord('q'): break # 4. Liberar la captura y destruimos ventanas. cap.release() cv2.destroyAllWindows() Para realizar la captura de v\u00eddeo, necesitaremos un objeto de tipo VideoCapture ; su \u00fanico argumento suele ser un \u00edndice de dispositivo o un fichero de v\u00eddeo. Un \u00edndice de dispositivo es simplemente un identificador \u00fanico para cada una de las c\u00e1maras conectadas al equipo. El problema es que VideoCapture no es del todo compatible con la librer\u00eda libcamera que emplea la Raspberry Pi y es necesario hacer uso de un pipeline GStreamer y substituir la sentencia cap = cv2.VideoCapture(0) por la siguiente secuencia de c\u00f3digo: pipeline = \"libcamerasrc ! video/x-raw, width=(int)640, height=(int)480, framerate=(fraction)15/1 ! videoconvert ! videoscale ! video/x-raw, width=(int)640, height=(int)480 ! appsink\" cap = cv2.VideoCapture(pipeline,cv2.CAP_GSTREAMER) El resto del c\u00f3digo no presenta problema de compatibilidad. cap.read() devuelve un valor booleano en funci\u00f3n de si el frame fue le\u00eddo correctamente o no. Podemos, por tanto, comprobar la finalizaci\u00f3n de un flujo de v\u00eddeo utilizando dicho valor de retorno. Es posible acceder a algunas de las caracter\u00edsticas del v\u00eddeo utilizando el m\u00e9todo cap.get(propId) , donde propId es un n\u00famero entre 0 y 18. Cada n\u00famero denota una propiedad del v\u00eddeo (si dicha propiedad se puede aplicar al v\u00eddeo en cuesti\u00f3n). Para m\u00e1s informaci\u00f3n, consulta ls documentaci\u00f3n de OpenCV . Algunos de estos valores pueden ser modificados a trav\u00e9s de la funci\u00f3n cap.set(propId, value) . Por ejemplo, podemos comprobar la anchura y altura de un frame utilizando cap.get(cv.CAP_PROP_FRAME_WIDTH) y cap.get(cv.CAP_PROP_FRAME_HEIGHT) . Podemos, por ejemplo, fijar la resoluci\u00f3n de la captura utilizando ret = cap.set(cv.CAP_PROP_FRAME_WIDTH,320) y ret = cap.set(cv.CAP_PROP_FRAME_HEIGHT,240) . Tarea Ejecuta el anterior script utilizando python3 . Estudia el c\u00f3digo y modif\u00edcalo para introducir nuevas transformaciones en las im\u00e1genes capturadas (transformaci\u00f3n a otros espacios de color, redimensionado de im\u00e1genes, etc.) Para ello, deber\u00e1s consultar la documentaci\u00f3n de OpenCV . Tarea Temporiza el tiempo de adquisici\u00f3n ( cap.read() ) y rep\u00f3rtalo a trav\u00e9s de l\u00ednea de comandos, reportando no s\u00f3lo el tiempo, sino los fotogramas por segundo (FPS) obtenidos. Captura de v\u00eddeos desde la c\u00e1mara (C++) Desde C++, la l\u00f3gica de captura es muy similar, como tambi\u00e9n lo es la API utilizada: // OpenCV includes. #include <opencv2/core.hpp> #include <opencv2/videoio.hpp> #include <opencv2/highgui.hpp> // Other includes. #include <iostream> #include <stdio.h> using namespace cv; using namespace std; int main(int, char**) { // 0. Declaracion de variables (vease documentacion de Mat). Mat frame; VideoCapture cap; // 1. Configuramos camara 0. int deviceID = 0; // 0 = open default camera int apiID = cv::CAP_ANY; // 0 = autodetect default API cap.open(deviceID, apiID); // 2. Check error. if (!cap.isOpened()) { cerr << \"ERROR abriendo camara.\\n\"; return -1; } // 3. Bucle de adquisicion. cout << \"Comenzando adquisicion...\" << endl << \"Presiona cualquier tecla para terminar...\" << endl; for (;;) { // 4. Adquisicion de frame (TODO: temporizar la adquisicion y reportar Frames por Segundo (FPS)). cap.read(frame); // TODO: Investigar transformaciones en C++ (ver documentacion). // 5. Check error. if (frame.empty()) { cerr << \"ERROR! blank frame grabbed\\n\"; break; } // 6. Mostramos frame en ventana. imshow(\"Stream\", frame); if (waitKey(5) >= 0) break; } // 7. La camara se liberara en el destructor. return 0; } Para compilar y enlazar un c\u00f3digo como el anterior c\u00f3digo, nos ayudaremos de la herramienta pkg-config , que nos ayudar\u00e1 a fijar los flags de compilaci\u00f3n y enlazado para programas que utilicen OpenCV: g++ programa.cpp -o programa.x `pkg-config --cflags --libs opencv4` Ejemplo C++ con GStreamer Como hemos comentado previamente, por motivos de compatibilidad con la libcamera es necesario hacer uso de un pipeline de Gstreamer como el visto anteriormente, para lo que habr\u00eda que modificar el ejemplo de referencia del siguiente modo: std::string gstreamer_pipeline(int capture_width, int capture_height, int framerate, int display_width, int display_height) { return \" libcamerasrc ! video/x-raw, \" \" width=(int)\" + std::to_string(capture_width) + \",\" \" height=(int)\" + std::to_string(capture_height) + \",\" \" framerate=(fraction)\" + std::to_string(framerate) +\"/1 !\" \" videoconvert ! videoscale !\" \" video/x-raw,\" \" width=(int)\" + std::to_string(display_width) + \",\" \" height=(int)\" + std::to_string(display_height) + \" ! appsink\"; } //pipeline parameters int capture_width = 640; //1280 ; int capture_height = 480; //720 ; int framerate = 15 ; int display_width = 640; //1280 ; int display_height = 480; //720 ; // create pipeline string std::string pipeline = gstreamer_pipeline(capture_width, capture_height, framerate, display_width, display_height); // open pipeline cv::VideoCapture cap(pipeline, cv::CAP_GSTREAMER); El siguiente ejemplo un poco m\u00e1s completo est\u00e1 basado en este ejemplo para Bulleye pero retocado Bookworm (versi\u00f3n actual de Raspberry Pi OS): $ git clone https://github.com/Qengineering/Libcamera-OpenCV-RPi-Bullseye-64OS $ cd Libcamera-OpenCV-RPi-Bullseye-64OS Para poder usarlo es necesario modificar el fichero GStreamer_RPi_64_Bullseye.cbp del siguiente modo: diff --git a/GStreamer_RPi_64_Bullseye.cbp b/GStreamer_RPi_64_Bullseye.cbp index 69b7181..0d27522 100644 --- a/GStreamer_RPi_64_Bullseye.cbp +++ b/GStreamer_RPi_64_Bullseye.cbp @@ -32,7 +32,7 @@ <Add option=\"-Wall\" /> <Add option=\"-fexceptions\" /> <Add option=\"-pthread\" /> - <Add directory=\"/usr/local/include/opencv4\" /> + <Add directory=\"/usr/include/opencv4\" /> <Add directory=\"/usr/include/gstreamer-1.0\" /> <Add directory=\"/usr/lib/aarch64-linux-gnu/glib-2.0/include\" /> <Add directory=\"/usr/include/glib-2.0\" /> @@ -43,7 +43,7 @@ <Add option=\"-pthread\" /> <Add library=\"/usr/lib/aarch64-linux-gnu/libgobject-2.0.so\" /> <Add library=\"/usr/lib/aarch64-linux-gnu/libgstreamer-1.0.so\" /> - <Add library=\"/usr/lib/aarch64-linux-gnu/libgstapp-1.0.so\" /> + <Add library=\"/usr/lib/aarch64-linux-gnu/libgstapp-1.0.so.0\" /> <Add directory=\"/usr/local/lib/\" /> </Linker> <Unit filename=\"main.cpp\" /> Para compilar este ejemplo es necesario instalar CodeBlocks ( sudo apt-get install codeblocks ), abrir el proyecto (fichero .cbp ) y construirlo. Una vez construido se puede ejecutar tanto desde CodeBlocks como desde l\u00ednea de comando. Tarea Compila y ejecuta el anterior programa (est\u00e1 incluido en el paquete proporcionado). Estudia el c\u00f3digo y modif\u00edcalo para introducir nuevas transformaciones en las im\u00e1genes capturadas (transformaci\u00f3n a otros espacios de color, redimensionado de im\u00e1genes, etc). Para ello, deber\u00e1s consultar la documentaci\u00f3n de OpenCV . Tarea Temporiza el tiempo de adquisici\u00f3n ( cap.read(frame) ) y rep\u00f3rtalo a trav\u00e9s de l\u00ednea de comandos, mostrando no s\u00f3lo el tiempo, sino los fotogramas por segundo (FPS) obtenidos. Tanto en el caso de C++ como de Python, experimenta con distintas resoluciones de captura. \u00bfCu\u00e1l es la resoluci\u00f3n m\u00e1xima soportada por la c\u00e1mara que os proporcionamos?","title":"Pr\u00e1ctica 0"},{"location":"LSI/Lab0/#laboratorio-0-entorno-experimental","text":"","title":"Laboratorio 0. Entorno experimental"},{"location":"LSI/Lab0/#objetivos","text":"Preparar el entorno experimental. Completar la configuraci\u00f3n del sistema. Probar el correcto funcionamiento tanto del Software como del Hardware. Familiarizase con la captura de im\u00e1genes mediante OpenCV","title":"Objetivos"},{"location":"LSI/Lab0/#1-introduccion","text":"El entorno experimental que se va a emplear en esta parte de la asignatura est\u00e1 compuesto de los siguientes elementos: Hardware Kit Raspberry Pi 4 Placa Raspberry Pi 4 con un SoC Broadcom BCM2711 con las siguientes caracter\u00edsticas: Quad core de Cortex-A72, ARM v8 de 64-bit, @1.5GHz (+ info ) Alimentador USB-C Cable micro-HDMI a HDMI Tarjeta uSD de alta velocidad Kit aceleraci\u00f3n Acelerador Coral USB (+ info ) C\u00e1mara para Raspberry Pi v2 Lector de tarjetas SD No proporcionado, pero un gran n\u00famero de port\u00e1tiles lo llevan integrado. Software Raspberry Pi OS - Distribuci\u00f3n Linux basada en Debian adaptada a la Raspberry Pi en su versi\u00f3n de 64 bits OpenCV - Librer\u00eda de visi\u00f3n por computador A continuaci\u00f3n se proporcionan las instrucciones para configurar y probar el entorno experimental.","title":"1. Introducci\u00f3n"},{"location":"LSI/Lab0/#2-preparacion-sd","text":"Grabar el sistema operativo Raspberry Pi OS (64-bit) en una SD siguiendo las instrucciones de instalaci\u00f3n de la web oficial de Raspberry Pi.","title":"2. Preparaci\u00f3n SD"},{"location":"LSI/Lab0/#3-conexion-arranque-y-configuracion","text":"Realizar la conexi\u00f3n de los dispositivos Conectar el teclado y el rat\u00f3n a los puertos USB 2.0, dejando al menos uno de los puertos USB 3.0 libre para el acelerador Google Coral (tienen un remate azul) Conectar el monitor mediante el cable micro-HDMI a HDMI Insertar la tarjeta SD grabada previamente Conectar la c\u00e1mara \"Raspberry Pi Camera Module v2\" (sensor Sony IMX219, interfaz CSI-2, resoluci\u00f3n 3280 x 2464 p\u00edxeles, 30fps) Para informaci\u00f3n m\u00e1s precisa de la conexi\u00f3n se puede consultar el siguiente video. Conectar alimentaci\u00f3n (cable USB-C), teclado y rat\u00f3n. Comprobar el correcto arranque del equipo y proceder a la configuraci\u00f3n inicial. Configuraci\u00f3n inicial: Seleccionar pa\u00eds, lenguaje y zona horaria. Configurar usuario, contrase\u00f1a. Configurar la Wifi ( rpi-miot ). Seleccionar navegador ( Chromium ). Actualizaci\u00f3n del software. Reiniciar y comprobar la configuraci\u00f3n inicial (en especial la red). Completar la configuraci\u00f3n necesaria: Abrir una ventana de terminal y completar la configuraci\u00f3n mediante comando raspi-config : sudo raspi-config Establecer las opciones de interfaz necesarias: Activar conexi\u00f3n mediante SSH (m\u00ednimo) y recomendable por VNC. Finalizar y reiniciar el equipo","title":"3. Conexi\u00f3n, arranque y configuraci\u00f3n"},{"location":"LSI/Lab0/#4-comprobaciones-basicas","text":"","title":"4. Comprobaciones b\u00e1sicas"},{"location":"LSI/Lab0/#camara","text":"La c\u00e1mara ya no se gestiona del mismo modo que en versiones anteriores de Raspberrypi OS, ahora se hace por medio de la librar\u00eda libcamera . Para m\u00e1s informaci\u00f3n sobre los m\u00f3dulos de c\u00e1mara de la Raspberry Pi y el software asociado consultar el siguiente enlace (mejor no buscar en Google porque la mayor parte de la informaci\u00f3n est\u00e1 obsoleta). Comprobar la correcta detecci\u00f3n de la c\u00e1mara: $ libcamera-hello --list-cameras Available cameras ----------------- 0 : imx219 [3280x2464 10-bit RGGB] (/base/soc/i2c0mux/i2c@1/imx219@10) Modes: 'SRGGB10_CSI2P' : 640x480 [206.65 fps - (1000, 752)/1280x960 crop] 1640x1232 [41.85 fps - (0, 0)/3280x2464 crop] 1920x1080 [47.57 fps - (680, 692)/1920x1080 crop] 3280x2464 [21.19 fps - (0, 0)/3280x2464 crop] 'SRGGB8' : 640x480 [206.65 fps - (1000, 752)/1280x960 crop] 1640x1232 [83.70 fps - (0, 0)/3280x2464 crop] 1920x1080 [47.57 fps - (680, 692)/1920x1080 crop] 3280x2464 [21.19 fps - (0, 0)/3280x2464 crop] Comprobar el funcionamiento de la c\u00e1mara: $ libcamera-still","title":"C\u00e1mara"},{"location":"LSI/Lab0/#alimentacion-y-refrigeracion","text":"Es crucial garantizar una buena refrigeraci\u00f3n y un voltaje estable en la Raspberry Pi 4 para evitar sobrecalentamiento y fallos del sistema. Un exceso de temperatura reduce el rendimiento, por lo que se recomienda usar disipadores o ventilaci\u00f3n activa. Adem\u00e1s, un voltaje inadecuado puede causar apagones y corrupci\u00f3n de datos, por lo que es esencial un adaptador de 5V y al menos 3A. Comprobar temperatura (opcional) $ vcgencmd measure_temp temp=39.9'C Comprobar voltage y que no se est\u00e1 produciendo throttling : $ vcgencmd get_throttled throttled=0x0 Nota: Si el valor devuelto es distinto de 0x0 consutar la correspondiente p\u00e1gina de manual para identificar el problema ( man vcgencmd )","title":"Alimentaci\u00f3n y refrigeraci\u00f3n"},{"location":"LSI/Lab0/#5-gstreamer","text":"","title":"5. Gstreamer"},{"location":"LSI/Lab0/#que-es","text":"GStreamer es un framework de c\u00f3digo abierto para la creaci\u00f3n, manipulaci\u00f3n y reproducci\u00f3n de flujos multimedia.","title":"\u00bfQu\u00e9 es?"},{"location":"LSI/Lab0/#instalacion-gstreamer","text":"Es preciso instalar los siguientes paquetes (basado este enlace y actualizado para bookworm ) # install a missing dependency $ sudo apt-get install libx264-dev libjpeg-dev # install the remaining plugins $ sudo apt-get install libgstreamer1.0-dev \\ libgstreamer-plugins-base1.0-dev \\ libgstreamer-plugins-bad1.0-dev \\ gstreamer1.0-plugins-ugly \\ gstreamer1.0-tools \\ gstreamer1.0-gl \\ gstreamer1.0-gtk3 # if you have Qt5 install this plugin $ sudo apt-get install gstreamer1.0-qt5 # install the compatibility package $ sudo apt-get install gstreamer1.0-libcamera # install if you want to work with audio $ sudo apt-get install gstreamer1.0-pulseaudio","title":"Instalaci\u00f3n Gstreamer"},{"location":"LSI/Lab0/#prueba-de-un-pipeline-de-video-basico-640x480","text":"$ gst-launch-1.0 libcamerasrc ! video/x-raw, width=640, height=480, framerate=30/1 ! videoconvert ! videoscale ! clockoverlay time-format=\"%D %H:%M:%S\" ! autovideosink","title":"Prueba de un pipeline de video b\u00e1sico (640x480)"},{"location":"LSI/Lab0/#6-opencv","text":"","title":"6. OpenCV"},{"location":"LSI/Lab0/#que-es_1","text":"OpenCV es una biblioteca de visi\u00f3n de c\u00f3digo abierto que proporciona herramientas para procesar y analizar im\u00e1genes y videos. Entre otras cosas proporciona una interfaz completa ( Python y C++ ) para la interacci\u00f3n con c\u00e1maras que usaremos a continuaci\u00f3n.","title":"\u00bfQu\u00e9 es?"},{"location":"LSI/Lab0/#instalacion-de-opencv-46","text":"Por defecto Bookworm incluye la versi\u00f3n 4.6, si se necesita una m\u00e1s reciente es preciso compilarla o buscar un binario pre-compilado. $ sudo apt-get install libopencv-dev $ sudo apt-get install python3-opencv","title":"Instalaci\u00f3n de OpenCV (4.6)"},{"location":"LSI/Lab0/#captura-de-videos-desde-la-camara-python","text":"En primer lugar, realizaremos una captura de flujo de v\u00eddeo desde la c\u00e1mara, utilizando la API de OpenCV en Python, realizando una transformaci\u00f3n b\u00e1sica y mostrando el flujo de v\u00eddeo transformado. Tomemos el siguiente script como ejemplo de referencia: import numpy as np import cv2 # 0. Configura camara 0. cap = cv2.VideoCapture(0) while(True): # 1. Adquisici\u00f3n de un frame ret, frame = cap.read() # 2. Operaciones sobre el frame gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) # 3. Mostrar el frame resultante. cv2.imshow('frame',gray) if cv2.waitKey(1) & 0xFF == ord('q'): break # 4. Liberar la captura y destruimos ventanas. cap.release() cv2.destroyAllWindows() Para realizar la captura de v\u00eddeo, necesitaremos un objeto de tipo VideoCapture ; su \u00fanico argumento suele ser un \u00edndice de dispositivo o un fichero de v\u00eddeo. Un \u00edndice de dispositivo es simplemente un identificador \u00fanico para cada una de las c\u00e1maras conectadas al equipo. El problema es que VideoCapture no es del todo compatible con la librer\u00eda libcamera que emplea la Raspberry Pi y es necesario hacer uso de un pipeline GStreamer y substituir la sentencia cap = cv2.VideoCapture(0) por la siguiente secuencia de c\u00f3digo: pipeline = \"libcamerasrc ! video/x-raw, width=(int)640, height=(int)480, framerate=(fraction)15/1 ! videoconvert ! videoscale ! video/x-raw, width=(int)640, height=(int)480 ! appsink\" cap = cv2.VideoCapture(pipeline,cv2.CAP_GSTREAMER) El resto del c\u00f3digo no presenta problema de compatibilidad. cap.read() devuelve un valor booleano en funci\u00f3n de si el frame fue le\u00eddo correctamente o no. Podemos, por tanto, comprobar la finalizaci\u00f3n de un flujo de v\u00eddeo utilizando dicho valor de retorno. Es posible acceder a algunas de las caracter\u00edsticas del v\u00eddeo utilizando el m\u00e9todo cap.get(propId) , donde propId es un n\u00famero entre 0 y 18. Cada n\u00famero denota una propiedad del v\u00eddeo (si dicha propiedad se puede aplicar al v\u00eddeo en cuesti\u00f3n). Para m\u00e1s informaci\u00f3n, consulta ls documentaci\u00f3n de OpenCV . Algunos de estos valores pueden ser modificados a trav\u00e9s de la funci\u00f3n cap.set(propId, value) . Por ejemplo, podemos comprobar la anchura y altura de un frame utilizando cap.get(cv.CAP_PROP_FRAME_WIDTH) y cap.get(cv.CAP_PROP_FRAME_HEIGHT) . Podemos, por ejemplo, fijar la resoluci\u00f3n de la captura utilizando ret = cap.set(cv.CAP_PROP_FRAME_WIDTH,320) y ret = cap.set(cv.CAP_PROP_FRAME_HEIGHT,240) . Tarea Ejecuta el anterior script utilizando python3 . Estudia el c\u00f3digo y modif\u00edcalo para introducir nuevas transformaciones en las im\u00e1genes capturadas (transformaci\u00f3n a otros espacios de color, redimensionado de im\u00e1genes, etc.) Para ello, deber\u00e1s consultar la documentaci\u00f3n de OpenCV . Tarea Temporiza el tiempo de adquisici\u00f3n ( cap.read() ) y rep\u00f3rtalo a trav\u00e9s de l\u00ednea de comandos, reportando no s\u00f3lo el tiempo, sino los fotogramas por segundo (FPS) obtenidos.","title":"Captura de v\u00eddeos desde la c\u00e1mara (Python)"},{"location":"LSI/Lab0/#captura-de-videos-desde-la-camara-c","text":"Desde C++, la l\u00f3gica de captura es muy similar, como tambi\u00e9n lo es la API utilizada: // OpenCV includes. #include <opencv2/core.hpp> #include <opencv2/videoio.hpp> #include <opencv2/highgui.hpp> // Other includes. #include <iostream> #include <stdio.h> using namespace cv; using namespace std; int main(int, char**) { // 0. Declaracion de variables (vease documentacion de Mat). Mat frame; VideoCapture cap; // 1. Configuramos camara 0. int deviceID = 0; // 0 = open default camera int apiID = cv::CAP_ANY; // 0 = autodetect default API cap.open(deviceID, apiID); // 2. Check error. if (!cap.isOpened()) { cerr << \"ERROR abriendo camara.\\n\"; return -1; } // 3. Bucle de adquisicion. cout << \"Comenzando adquisicion...\" << endl << \"Presiona cualquier tecla para terminar...\" << endl; for (;;) { // 4. Adquisicion de frame (TODO: temporizar la adquisicion y reportar Frames por Segundo (FPS)). cap.read(frame); // TODO: Investigar transformaciones en C++ (ver documentacion). // 5. Check error. if (frame.empty()) { cerr << \"ERROR! blank frame grabbed\\n\"; break; } // 6. Mostramos frame en ventana. imshow(\"Stream\", frame); if (waitKey(5) >= 0) break; } // 7. La camara se liberara en el destructor. return 0; } Para compilar y enlazar un c\u00f3digo como el anterior c\u00f3digo, nos ayudaremos de la herramienta pkg-config , que nos ayudar\u00e1 a fijar los flags de compilaci\u00f3n y enlazado para programas que utilicen OpenCV: g++ programa.cpp -o programa.x `pkg-config --cflags --libs opencv4`","title":"Captura de v\u00eddeos desde la c\u00e1mara (C++)"},{"location":"LSI/Lab0/#ejemplo-c-con-gstreamer","text":"Como hemos comentado previamente, por motivos de compatibilidad con la libcamera es necesario hacer uso de un pipeline de Gstreamer como el visto anteriormente, para lo que habr\u00eda que modificar el ejemplo de referencia del siguiente modo: std::string gstreamer_pipeline(int capture_width, int capture_height, int framerate, int display_width, int display_height) { return \" libcamerasrc ! video/x-raw, \" \" width=(int)\" + std::to_string(capture_width) + \",\" \" height=(int)\" + std::to_string(capture_height) + \",\" \" framerate=(fraction)\" + std::to_string(framerate) +\"/1 !\" \" videoconvert ! videoscale !\" \" video/x-raw,\" \" width=(int)\" + std::to_string(display_width) + \",\" \" height=(int)\" + std::to_string(display_height) + \" ! appsink\"; } //pipeline parameters int capture_width = 640; //1280 ; int capture_height = 480; //720 ; int framerate = 15 ; int display_width = 640; //1280 ; int display_height = 480; //720 ; // create pipeline string std::string pipeline = gstreamer_pipeline(capture_width, capture_height, framerate, display_width, display_height); // open pipeline cv::VideoCapture cap(pipeline, cv::CAP_GSTREAMER); El siguiente ejemplo un poco m\u00e1s completo est\u00e1 basado en este ejemplo para Bulleye pero retocado Bookworm (versi\u00f3n actual de Raspberry Pi OS): $ git clone https://github.com/Qengineering/Libcamera-OpenCV-RPi-Bullseye-64OS $ cd Libcamera-OpenCV-RPi-Bullseye-64OS Para poder usarlo es necesario modificar el fichero GStreamer_RPi_64_Bullseye.cbp del siguiente modo: diff --git a/GStreamer_RPi_64_Bullseye.cbp b/GStreamer_RPi_64_Bullseye.cbp index 69b7181..0d27522 100644 --- a/GStreamer_RPi_64_Bullseye.cbp +++ b/GStreamer_RPi_64_Bullseye.cbp @@ -32,7 +32,7 @@ <Add option=\"-Wall\" /> <Add option=\"-fexceptions\" /> <Add option=\"-pthread\" /> - <Add directory=\"/usr/local/include/opencv4\" /> + <Add directory=\"/usr/include/opencv4\" /> <Add directory=\"/usr/include/gstreamer-1.0\" /> <Add directory=\"/usr/lib/aarch64-linux-gnu/glib-2.0/include\" /> <Add directory=\"/usr/include/glib-2.0\" /> @@ -43,7 +43,7 @@ <Add option=\"-pthread\" /> <Add library=\"/usr/lib/aarch64-linux-gnu/libgobject-2.0.so\" /> <Add library=\"/usr/lib/aarch64-linux-gnu/libgstreamer-1.0.so\" /> - <Add library=\"/usr/lib/aarch64-linux-gnu/libgstapp-1.0.so\" /> + <Add library=\"/usr/lib/aarch64-linux-gnu/libgstapp-1.0.so.0\" /> <Add directory=\"/usr/local/lib/\" /> </Linker> <Unit filename=\"main.cpp\" /> Para compilar este ejemplo es necesario instalar CodeBlocks ( sudo apt-get install codeblocks ), abrir el proyecto (fichero .cbp ) y construirlo. Una vez construido se puede ejecutar tanto desde CodeBlocks como desde l\u00ednea de comando. Tarea Compila y ejecuta el anterior programa (est\u00e1 incluido en el paquete proporcionado). Estudia el c\u00f3digo y modif\u00edcalo para introducir nuevas transformaciones en las im\u00e1genes capturadas (transformaci\u00f3n a otros espacios de color, redimensionado de im\u00e1genes, etc). Para ello, deber\u00e1s consultar la documentaci\u00f3n de OpenCV . Tarea Temporiza el tiempo de adquisici\u00f3n ( cap.read(frame) ) y rep\u00f3rtalo a trav\u00e9s de l\u00ednea de comandos, mostrando no s\u00f3lo el tiempo, sino los fotogramas por segundo (FPS) obtenidos. Tanto en el caso de C++ como de Python, experimenta con distintas resoluciones de captura. \u00bfCu\u00e1l es la resoluci\u00f3n m\u00e1xima soportada por la c\u00e1mara que os proporcionamos?","title":"Ejemplo C++ con GStreamer"},{"location":"LSI/Lab1/","text":"Laboratorio 1. Introducci\u00f3n a TFLite sobre la Raspberry Pi Objetivos Familiarizarse con TensorFlow Lite Desarrollar una aplicaci\u00f3n b\u00e1sica de clasificaci\u00f3n de im\u00e1genes combinando las APIs de OpenCV y TFLite desde Python y desde C++. Acelerar el proceso de inferencia utilizando el acelerador Google Coral. Puedes obtener los ficheros necesarios para el desarrollo de la pr\u00e1ctica aqu\u00ed . 1. TensorFlow Lite Una vez estudiados de forma b\u00e1sica los c\u00f3digos que nos permiten realizar capturas e interacci\u00f3n desde la c\u00e1mara, veremos c\u00f3mo aplicar un modelo pre-entrenado, que nos permitir\u00e1 realizar un proceso de clasificaci\u00f3n de los objetos en el flujo de v\u00eddeo. N\u00f3tese que el objetivo de esta pr\u00e1ctica no es estudiar en profundidad el proceso en s\u00ed de clasificaci\u00f3n, sino simplemente servir como una primera toma de contacto con la biblioteca TensorFlow Lite , recientemente rebautizada como LiteRT . \u00bfQu\u00e9 es TFLite/LiteRT? TFLite o LiteRT es un conjunto de herramientas que permiten ejecutar modelos entrenados en TensorFlow en dispositivos m\u00f3viles, empotrados y en entornos IoT. A diferencia de Tensorflow, TFLite permite realizar procesos de inferencia con tiempos de latencia muy reducidos, y un footprint tambi\u00e9n muy reducido. TFLite consta de dos componentes principales: El int\u00e9rprete de TFLite , que ejecuta modelos especialmente optimizados en distintos tipos de hardware , incluyendo tel\u00e9fonos m\u00f3viles, dispositivos Linux empotrados (e.g. Raspberry Pi) y microcontroladores. El conversor de TFLite , que convierte modelos TensorFlow para su posterior uso por parte del int\u00e9rprete, y que puede introducir optimizaciones para reducir el tama\u00f1o del modelo y aumentar el rendimiento. En este primer laboratorio no incidiremos ni en la creaci\u00f3n de modelos ni en su conversi\u00f3n a formato tflite propio del framework (veremos estas fases en futuros laboratorios); as\u00ed, partiremos de modelos ya entrenados y convertidos, ya que el \u00fanico objetivo en este punto es la familiarizarse con el entorno. Las principales caracter\u00edsticas de inter\u00e9s de TFLite son: Un int\u00e9rprete especialmente optimizado para tareas de Machine Learning en dispositivos de bajo rendimiento, con soporte para un amplio subconjunto de operadores disponibles en TensorFlow optimizados para aplicaciones ejecutadas en dicho tipo de dispositivos, enfocados a una reducci\u00f3n del tama\u00f1o del binario final. Soporte para m\u00faltiples plataformas, desde dispositivos Android a IOS, pasando por Linux sobre dispositivos empotrados, o microcontroladores. APIs para m\u00faltiples lenguajes, incluyendo Java, Swift, Objective-C, C++ y Python (estos dos \u00faltimos ser\u00e1n de nuestro especial inter\u00e9s). Alto rendimiento, con soporte para aceleraci\u00f3n hardware sobre dispositivos aceleradores (en nuestro caso, sobre Google Coral) y kernels optimizados para cada tipo de dispositivo. Herramientas de optimizaci\u00f3n de modelos, que incluyen cuantizaci\u00f3n , t\u00e9cnica qu estudiaremos en futuros laboratorios, imprescindible para integrar el uso de aceleradores como la Google Coral. Un formato de almacenamiento eficiente, utilizando FlatBuffer optimizado para una reducci\u00f3n de tama\u00f1o y en aras de la portabilidad entre dispositivos Un conjunto amplio de modelos pre-entrenados disponibles directamente para su uso en inferencia. El flujo b\u00e1sico de trabajo cuando estamos desarrollando una aplicaci\u00f3n basada en TFLite se basa en cuatro modelos principales: Selecci\u00f3n de modelo pre-entrenado o creaci\u00f3n/entrenamiento sobre un nuevo modelo. T\u00edpicamente utilizando frameworks existentes, como TensorFlow. Conversi\u00f3n del modelo, utilizando el conversor de TFLite desde Python para adaptarlo a las especificidades de TFLite. Despliegue en el dispositivo, utilizando las APIs del lenguaje seleccionado, e invocando al int\u00e9rprete de TFLite. Optimizaci\u00f3n del modelo (si es necesaria), utilizando el Toolkit de Optimizaci\u00f3n de Modelos , para reducir el tama\u00f1o del modelo e incrementar su eficiencia (t\u00edpicamente a cambio de cierta p\u00e9rdida en precisi\u00f3n). Instalaci\u00f3n TFLite Lo m\u00e1s sencillo es buscar un binario reciente pre-compilado para Raspberry Pi OS 64 Bookworm como por ejemplo los proporcionados por el repositorio tensorflow-lite-raspberrypi . El proceso de instalaci\u00f3n es sencillo: $ wget https://github.com/prepkg/tensorflow-lite-raspberrypi/releases/download/2.16.1/tensorflow-lite_64.deb $ sudo apt install -y ./tensorflow-lite_64.deb 2. Clasificaci\u00f3n de im\u00e1genes usando TFLite En esta parte del laboratorio, mostraremos el flujo de trabajo b\u00e1sico para aplicar un modelo de clasificaci\u00f3n (basado en la red neuronal Mobilenet ), que interact\u00fae con im\u00e1genes tomadas directamente desde la c\u00e1mara web integrada en la Raspberry Pi. Tarea Los ficheros que estudiaremos en esta parte est\u00e1n disponibles en el directorio Clasificacion del paquete proporcionado. Como hemos dicho, el objetivo del laboratorio es aplicar inferencia sobre un modelo ya pre-entrenado, por lo que no incidiremos en la estructura interna del mismo. Sin embargo, es conveniente saber que Mobilenet es una familia de redes neuronales de convoluci\u00f3n dise\u00f1adas para ser peque\u00f1as en tama\u00f1o, y de baja latencia en inferencia, aplicables a procesos de clasificaci\u00f3n, detecci\u00f3n o segmentaci\u00f3n de im\u00e1genes, entre otras muchas aplicaciones. En nuestro caso, la red Mobilenet v1 1.0_224 es una red de convoluci\u00f3n que acepta im\u00e1genes de dimensi\u00f3n 224 x 224 y tres canales (RGB), entrenada para devolver la probabilidad de pertenencia a cada una de las 1001 clases para la que ha sido pre-entrenada. Antes de comenzar, es preciso descargar el modelo, fichero de etiquetas y dem\u00e1s requisitos invocando al script download.sh proporcionado: $ sh download.sh Modelos Esta ejecuci\u00f3n, si todo ha ido bien, descargar\u00e1 en el directorio Modelos tres ficheros que utilizaremos en el resto del laboratorio: mobilenet_v1_1.0_224_quant.tflite : modelo pre-entrenado y cuantizado MobileNet. mobilenet_v1_1.0_224_quant_edgetpu.tflite : modelo pre-entrenado y cuantizado MobileNet, compilado con soporte para Google Coral. labels_mobilenet_quant_v1_224.txt : fichero de descripci\u00f3n de etiquetas (clases), con el nombre de una clase por l\u00ednea. La posici\u00f3n de estas l\u00edneas coincide con cada una de las (1001) posiciones del tensor de salida. Desarrollo utilizando Python Aviso Debian Bookworm incluye por defecto Python 3.11 que exige la utilizaci\u00f3n de entornos virtuales para la gesti\u00f3n de m\u00f3dulos. Por lo tanto antes de ejecutar alguno de los comandos siguientes es preciso crear un entorno virtual, por ejemplo con los siguientes comandos: $ python3 -m venv LSI_venv --system-site-packages $ source LSI_venv/bin/activate Aviso Al trabajar con entornos virtuales es preciso instalar los paquetes Python necesarios dentro del entorno virtual mediante ejecutando el siguiente comando desde el directorio donde se encuentre el fichero correspondiente: $ python3 -m pip install -r requirements.txt El fichero classify_opencv.py contiene el c\u00f3digo necesario para realizar inferencia (clasificaci\u00f3n) de im\u00e1genes partiendo de capturas de fotogramas desde la c\u00e1mara de la Raspberry Pi, que revisamos paso a paso a continuaci\u00f3n: Invocaci\u00f3n y argumentos Observa el inicio de la funci\u00f3n main proporcionada: def main(): parser = argparse.ArgumentParser( formatter_class=argparse.ArgumentDefaultsHelpFormatter) parser.add_argument( '--model', help='File path of .tflite file.', required=True) parser.add_argument( '--labels', help='File path of labels file.', required=True) args = parser.parse_args() El programa recibir\u00e1, de forma obligatoria, dos argumentos: El modelo a aplicar, en formato tflite (FlatBuffer), a trav\u00e9s del par\u00e1metro --model . El fichero de etiquetas, en formato texto con una etiqueta por l\u00ednea. Este fichero no es estrictamente obligatorio, pero nos permite mostrar no s\u00f3lo el n\u00famero de clase inferida, sino tambi\u00e9n su texto asociado. As\u00ed, podremos ejecutar el programa directamente utilizando la orden (suponiendo que ambos ficheros residen en el directorio ../Modelos ): python3 classify_opencv.py --model ../Modelos/mobilenet_v1_1.0_224_quant.tflite \\ --labels ../Modelos/labels_mobilenet_quant_v1_224.txt La funci\u00f3n load_labels simplemente lee el fichero de etiqueta y las almacena en memoria para su posterior procesamiento tras la inferencia. Preparaci\u00f3n del int\u00e9rprete TFLite El siguiente paso es la preparaci\u00f3n del int\u00e9rprete de TFLite: interpreter = Interpreter(args.model) Observa que el \u00fanico par\u00e1metro proporcionado es el nombre del modelo a cargar en formato TFLite. Observa tambi\u00e9n que necesitaremos cargar los m\u00f3dulos correspondientes a TFLite antes de hacer uso de esta funci\u00f3n: from tflite_runtime.interpreter import Interpreter A continuaci\u00f3n, obtenemos informaci\u00f3n sobre el tensor de entrada del modelo reci\u00e9n cargado, utilizando la funci\u00f3n get_input_details , y consultando la propiedad shape de dicha entrada. Esto nos devolver\u00e1 en las variables widght y height los tama\u00f1os de imagen esperados por el modelo. A partir de ahora, puedes consultar la forma de trabajar con la API de Python a trav\u00e9s de la documentaci\u00f3n oficial . Utilizaremos esta informaci\u00f3n para redimensionar la imagen capturada de la c\u00e1mara como paso previo a la invocaci\u00f3n del modelo. Tarea Aseg\u00farate de que ambas l\u00edneas (creaci\u00f3n del int\u00e9rprete e importaci\u00f3n de bibliotecas) son correctas. Comprueba el correcto funcionamiento del c\u00f3digo utilizando el modelo mobilenet_v1_1.0_224_quant.tflite como entrada al programa classify_opencv.py sobre tu Raspberry Pi. Si todo ha ido bien, deber\u00edas ver una ventana mostrando la salida de la c\u00e1mara con cierta informaci\u00f3n sobreimpresionada, y para cada fotograma, el resultado de la inferencia a trav\u00e9s de l\u00ednea de comandos. Inferencia En el bucle principal de captura, se invoca a la funci\u00f3n classify_image . Esta es una funci\u00f3n propia, que recibe simplemente el int\u00e9rprete TFLite construido y la imagen capturada, pero cuyo cuerpo contiene cierta funcionalidad de inter\u00e9s: ## Invoke model and process output (quantization-aware). def classify_image(interpreter, image, top_k=1): \"\"\"Returns a sorted array of classification results.\"\"\" set_input_tensor(interpreter, image) interpreter.invoke() output_details = interpreter.get_output_details()[0] output = np.squeeze(interpreter.get_tensor(output_details['index'])) # If the model is quantized (uint8 data), then dequantize the results if output_details['dtype'] == np.uint8: scale, zero_point = output_details['quantization'] output = scale * (output - zero_point) ordered = np.argpartition(-output, top_k) return [(i, output[i]) for i in ordered[:top_k]] Observa que la funci\u00f3n opera en varias fases. En primer lugar, se obtiene una referencia al tensor de entrada del modelo (invocando a la funci\u00f3n propia set_input_tensor ). En este caso, se copia, elemento a elemento, la imagen de entrada ( image ) a dicho tensor: ## Establish input tensor from an image (copying). def set_input_tensor(interpreter, image): tensor_index = interpreter.get_input_details()[0]['index'] input_tensor = interpreter.tensor(tensor_index)()[0] input_tensor[:, :] = image Volviendo a la funci\u00f3n classify_image , una vez copiada la entrada al tensor de entrada del modelo, se invoca al modelo TFLite ( interpreter.invoke() ). Este es el proceso de inferencia o aplicaci\u00f3n del modelo, y su tiempo de respuesta es cr\u00edtico. Por \u00faltimo, se procesa la salida (tensor de salida). En caso de ser una salida cuantizada (esto es, el tipo de cada elemento del array de salida es uint8_t , veremos m\u00e1s sobre cuantizaci\u00f3n en futuros laboratorios), \u00e9sta debe procesarse de forma acorde a los par\u00e1metros de cuantizaci\u00f3n utilizados. Al final, la funci\u00f3n devolver\u00e1 un array de tuplas con la posici\u00f3n/clase ( i ) y la probabilidad de pertenencia del objeto observado a dicha clase ( output[i] ). Tarea Imprime por pantalla la informaci\u00f3n sobre el tensor de entrada y el tensor de salida y analiza la salida proporcionada. Obs\u00e9rvese que, de forma previa a la invocaci\u00f3n del modelo, la im\u00e1gen capturada se ha reescalado de forma acorde al tama\u00f1o del tensor de entrada del modelo: image = cv2.resize(frame, (224, 224), interpolation = cv2.INTER_AREA) Postprocesamiento Por \u00faltimo, el programa sobreimpresiona informaci\u00f3n sobre etiqueta de clasificaci\u00f3n, probabilidad de pertenencia a la clase y tiempo de inferencia sobre el propio frame , mostrando la imagen resultante: cv2.putText(frame, '%s %.2f\\n%.1fms' % ( labels[label_id], prob, elapsed_ms ), bottomLeftCornerOfText, font, fontScale, fontColor, lineType) cv2.imshow('image',frame) Desarrollo utilizando C++ El rendimiento es un factor determinante en aplicaciones Edge computing , por lo que resultar\u00e1 interesante disponer de una base desarrollada en C++ sobre la que trabajar para el ejemplo de clasificaci\u00f3n. El fichero classification.cpp proporciona un flujo de trabajo completo para realizar una clasificaci\u00f3n de im\u00e1genes similar a la realizada anteriormente usando la API de Python. El c\u00f3digo desarrollado es similar, paso a paso, al descrito para Python, por lo que no se incidir\u00e1 en los detalles m\u00e1s all\u00e1 de la API utilizada : Ficheros de cabecera Incluiremos ficheros de cabecera gen\u00e9ricos, para OpenCV y para TFLite: #include <stdio.h> // Cabeceras TFLite #include \"tensorflow/lite/interpreter.h\" #include \"tensorflow/lite/kernels/register.h\" #include \"tensorflow/lite/model.h\" // Cabeceras OpenCV #include <opencv2/core.hpp> #include <opencv2/videoio.hpp> #include <opencv2/imgproc.hpp> #include <opencv2/highgui.hpp> #include <iostream> #include <fstream> #include <stdio.h> // Otras cabeceras C++ #include <vector> #include <numeric> // std::iota #include <algorithm> // std::sort, std::stable_sort Carga del modelo desde un fichero En este ejemplo, se realiza la carga del modelo directamente desde un fichero en disco, utilizando la rutina BuildFromFile : // 1. Cargamos modelo desde un fichero. std::unique_ptr<tflite::FlatBufferModel> model = tflite::FlatBufferModel::BuildFromFile(\"../Modelos/mobilenet_v1_1.0_224_quant.tflite\"); if(!model){ printf(\"Failed to mmap model\\n\"); exit(0); } // 2. Construimos el iterprete TFLite. tflite::ops::builtin::BuiltinOpResolver resolver; std::unique_ptr<tflite::Interpreter> interpreter; tflite::InterpreterBuilder(*model.get(), resolver)(&interpreter); // 3. Alojamos espacio para tensores. interpreter->AllocateTensors(); Observa que, en el anterior fragmento de c\u00f3digo, adem\u00e1s de la carga del modelo, se construye un int\u00e9rprete utilizando la clase InterpreterBuilder , y se aloja espacio para los tensores necesarios para aplicar el modelo. Caracaterizaci\u00f3n de tensores de entrada y salida Como hemos hecho en el c\u00f3digo Python, ser\u00e1 necesario realizar una caracterizaci\u00f3n de los tensores de entrada y salida. El primero, para copiar nuestra imagen capturada desde c\u00e1mara; el segundo, para procesar la salida obtenida: // 4. Identificamos el tensor de entrada y de salida. int input_number = interpreter->inputs()[0]; uint8_t * input_tensor = interpreter->typed_tensor<uint8_t>(input_number); int output_number = interpreter->outputs()[0]; uint8_t * output_tensor = interpreter->typed_tensor<uint8_t>(output_number); Tarea \u00bfCu\u00e1l es el \u00edndice de los tensores de entrada y salida generados? Coinciden con los observados al mostrar por pantalla la informaci\u00f3n sobre ellos en el c\u00f3digo Python. Invocaci\u00f3n del modelo TFLite Tras comenzar con la captura de v\u00eddeo y redimensionar la imagen de entrada, copiaremos al tensor de entrada la imagen capturada, pixel a pixel: // 8. Copiamos imagen al tensor de entrada. for (int i = 0; i < 224*224; ++i) { input_tensor[3*i + 0] = frame.at<cv::Vec3b>(i)[0]; input_tensor[3*i + 1] = frame.at<cv::Vec3b>(i)[1]; input_tensor[3*i + 2] = frame.at<cv::Vec3b>(i)[2]; } A continuaci\u00f3n, invocamos al modelo: // 9. Invocamos al modelo. if (interpreter->Invoke() != kTfLiteOk) { cerr << \"Failed to invoke tflite!\"; exit(-1); } Clasificaci\u00f3n y an\u00e1lisis de salida El proceso de an\u00e1lisis de salida es ligeramente distinto al usado en Python, aunque sigue una filosof\u00eda similar. En primer lugar, analizamos el tensor de salida: // 10. Analizamos el tama\u00f1o del tensor de salida. TfLiteIntArray* output_dims = interpreter->tensor(output_number)->dims; auto output_size = output_dims->data[output_dims->size - 1]; cout << output_size << endl; Como en el caso de Python, en funci\u00f3n de la cuantizaci\u00f3n de la salida, deberemos procesarla de forma acorde (trataremos la cuantizaci\u00f3n en futuros laboratorios). En cualquier caso, el array logits contiene la probabilidad de pertenencia a cada una de las 1001 clases disponibles. El c\u00f3digo que se os proporciona ordena dicho array y muestra por pantalla la clase m\u00e1s probable, junto a su probabilidad asociada. Compilaci\u00f3n y uso A continuaci\u00f3n, compila y ejecuta el programa para validar su funcionamiento: g++ classification.cpp -ltensorflow-lite -lpthread -ldl `pkg-config --cflags --libs opencv4` -o classification.x ./classification.x La salida est\u00e1 preparada para mostrar el c\u00f3digo num\u00e9rico de la clase detectada con mayor probabilidad, dicha probabilidad, y la descripci\u00f3n textual de la clase. Tarea Temporiza, utilizando la rutinas de la clase chrono de C++, el proceso de inferencia, y comp\u00e1ralo con el de la versi\u00f3n Python. Tarea De forma opcional, investiga c\u00f3mo sobreimpresionar la informaci\u00f3n asociada al proceso de inferencia (clase, probabilidad y tiempo) de forma similar a c\u00f3mo lo hicimos en Python. Uso de Google Coral Runtime EdgeTPU Para poder usar la Google Coral con TFLite es necesario instalar la librer\u00eda correspondiente ( libedgetpu ). Las fuentes de esta librer\u00eda est\u00e1n disponibles el GitHub de Google-Coral pero lo m\u00e1s sencillo es descargar binarios pre-compilados para bookworm y arm64 (tambi\u00e9n denominado aarch64 ). Instrucciones de instalaci\u00f3n: $ wget https://github.com/feranick/libedgetpu/releases/download/16.0TF2.16.1-1/libedgetpu-dev_16.0tf2.16.1-1.bookworm_arm64.deb $ wget https://github.com/feranick/libedgetpu/releases/download/16.0TF2.16.1-1/libedgetpu1-max_16.0tf2.16.1-1.bookworm_arm64.deb $ sudo dpkg -i libedgetpu* Uso de EdgeTPU desde Python Para utilizar el acelerador Google Coral (que debe estar conectado a la Raspberry Pi), realizaremos ciertas modificaciones en el c\u00f3digo, que en este caso son m\u00ednimas. En primer lugar, a\u00f1adiremos un import en nuestro fichero: from tflite_runtime.interpreter import load_delegate A continuaci\u00f3n, reemplazaremos la construcci\u00f3n del int\u00e9rprete por la especificaci\u00f3n de una biblioteca delegada para realizar la inferencia sobre la Google Coral: interpreter = Interpreter(args.model, experimental_delegates=[load_delegate('libedgetpu.so.1.0')]) Finalmente, ser\u00e1 necesario aplicar un modelo especialmente compilado para la Google Coral. Normalmente, este modelo se obtiene utilizando el compilador de la Edge TPU , pero en este caso se descarga y proporciona mediante el script download.sh . El nombre del modelo es mobilenet_v1_1.0_224_quant_edgetpu.tflite . As\u00ed, podremos ejecutar sobre la Edge TPU usando: sudo python3 classify_opencv.py \\ --model ../Modelos/mobilenet_v1_1.0_224_quant_edgetpu.tflite \\ --labels ../Modelos/labels_mobilenet_quant_v1_224.txt Obviamente, para que el anterior comando tenga \u00e9xito, la Google Coral deber\u00e1 estar conectada a la Raspberry Pi y el usuario que lo ejecuta debe tener permisos para usar el dispositivo. Estos permisos se pueden otorgar mediante la siguiente secuencia de comandos: $ lsusb -d 18d1:9302 Bus 002 Device 003: ID 18d1:9302 Google Inc. $ echo 'SUBSYSTEM==\"usb\", ATTR{idVendor}==\"18d1\", ATTR{idProduct}==\"9302\", MODE=\"0666\", GROUP=\"plugdev\"' | sudo tee /etc/udev/rules.d/99-edgetpu.rules $ sudo udevadm control --reload-rules && sudo udevadm trigger Aviso Es posible que para que el cambio surta efecto sea necesario salir y volver a entrar en la sesi\u00f3n. Tarea Compara los tiempos de ejecuci\u00f3n de la inferencia utilizando el procesdor de prop\u00f3sito general frente al rendimiento utilizando la Google Coral. \u00bfQu\u00e9 ganancia de rendimiento observas? Ajusta la configuraci\u00f3n de la captura de imagenes para que la comparaci\u00f3n sea lo m\u00e1s justa: Uso de EdgeTPU desde C++ Para usar la Google Coral desde C++ es preciso realizar algunas modificaciones al c\u00f3digo visto anteriormente ademas de incluir la correspondiente cabecera ( <edgetpu.h> ). Para m\u00e1s informaci\u00f3n consultar la documentaci\u00f3n de la API de libedgetpu . Apertura del dispositivo Antes de poder trabajar con la EdgeTPU es preciso abrir el dispositivo con la funci\u00f3n OpenDevice de la clase EdgeTpuManager : auto tpu_context = edgetpu::EdgeTpuManager::GetSingleton()->OpenDevice(); Registrar el manejador de EdgeTPU en el resolutor A continuaci\u00f3n es preciso a\u00f1adir un operador personalizado para que TensorFlow Lite lo reconozca: tflite::ops::builtin::BuiltinOpResolver resolver; resolver.AddCustom(edgetpu::kCustomOp, edgetpu::RegisterCustomOp()); Vincular el contexto de EdgeTPU con el int\u00e9rprete Por \u00faltimo es necesario vincular el contexto del dispositivo abierto previamente con el int\u00e9rprete de TFLite: interpreter->SetExternalContext(kTfLiteEdgeTpuContext,tpu_context.get()); Por lo dem\u00e1s el c\u00f3digo es esencialmente el mismo que anteriormente. Compilaci\u00f3n Para poder compilar el c\u00f3digo es preciso enlazar con la librar\u00eda libedgetpu : g++ classification.cpp -o classification.x `pkg-config --cflags --libs opencv4` -ltensorflow-lite -lpthread -ldl Tarea Compara las versiones C++ CPU vs Google Coral \u00bfQu\u00e9 ganancia de rendimiento observas? Compara el resultado con el obtenido en Python.","title":"Pr\u00e1ctica 1"},{"location":"LSI/Lab1/#laboratorio-1-introduccion-a-tflite-sobre-la-raspberry-pi","text":"","title":"Laboratorio 1. Introducci\u00f3n a TFLite sobre la Raspberry Pi"},{"location":"LSI/Lab1/#objetivos","text":"Familiarizarse con TensorFlow Lite Desarrollar una aplicaci\u00f3n b\u00e1sica de clasificaci\u00f3n de im\u00e1genes combinando las APIs de OpenCV y TFLite desde Python y desde C++. Acelerar el proceso de inferencia utilizando el acelerador Google Coral. Puedes obtener los ficheros necesarios para el desarrollo de la pr\u00e1ctica aqu\u00ed .","title":"Objetivos"},{"location":"LSI/Lab1/#1-tensorflow-lite","text":"Una vez estudiados de forma b\u00e1sica los c\u00f3digos que nos permiten realizar capturas e interacci\u00f3n desde la c\u00e1mara, veremos c\u00f3mo aplicar un modelo pre-entrenado, que nos permitir\u00e1 realizar un proceso de clasificaci\u00f3n de los objetos en el flujo de v\u00eddeo. N\u00f3tese que el objetivo de esta pr\u00e1ctica no es estudiar en profundidad el proceso en s\u00ed de clasificaci\u00f3n, sino simplemente servir como una primera toma de contacto con la biblioteca TensorFlow Lite , recientemente rebautizada como LiteRT .","title":"1. TensorFlow Lite"},{"location":"LSI/Lab1/#que-es-tflitelitert","text":"TFLite o LiteRT es un conjunto de herramientas que permiten ejecutar modelos entrenados en TensorFlow en dispositivos m\u00f3viles, empotrados y en entornos IoT. A diferencia de Tensorflow, TFLite permite realizar procesos de inferencia con tiempos de latencia muy reducidos, y un footprint tambi\u00e9n muy reducido. TFLite consta de dos componentes principales: El int\u00e9rprete de TFLite , que ejecuta modelos especialmente optimizados en distintos tipos de hardware , incluyendo tel\u00e9fonos m\u00f3viles, dispositivos Linux empotrados (e.g. Raspberry Pi) y microcontroladores. El conversor de TFLite , que convierte modelos TensorFlow para su posterior uso por parte del int\u00e9rprete, y que puede introducir optimizaciones para reducir el tama\u00f1o del modelo y aumentar el rendimiento. En este primer laboratorio no incidiremos ni en la creaci\u00f3n de modelos ni en su conversi\u00f3n a formato tflite propio del framework (veremos estas fases en futuros laboratorios); as\u00ed, partiremos de modelos ya entrenados y convertidos, ya que el \u00fanico objetivo en este punto es la familiarizarse con el entorno. Las principales caracter\u00edsticas de inter\u00e9s de TFLite son: Un int\u00e9rprete especialmente optimizado para tareas de Machine Learning en dispositivos de bajo rendimiento, con soporte para un amplio subconjunto de operadores disponibles en TensorFlow optimizados para aplicaciones ejecutadas en dicho tipo de dispositivos, enfocados a una reducci\u00f3n del tama\u00f1o del binario final. Soporte para m\u00faltiples plataformas, desde dispositivos Android a IOS, pasando por Linux sobre dispositivos empotrados, o microcontroladores. APIs para m\u00faltiples lenguajes, incluyendo Java, Swift, Objective-C, C++ y Python (estos dos \u00faltimos ser\u00e1n de nuestro especial inter\u00e9s). Alto rendimiento, con soporte para aceleraci\u00f3n hardware sobre dispositivos aceleradores (en nuestro caso, sobre Google Coral) y kernels optimizados para cada tipo de dispositivo. Herramientas de optimizaci\u00f3n de modelos, que incluyen cuantizaci\u00f3n , t\u00e9cnica qu estudiaremos en futuros laboratorios, imprescindible para integrar el uso de aceleradores como la Google Coral. Un formato de almacenamiento eficiente, utilizando FlatBuffer optimizado para una reducci\u00f3n de tama\u00f1o y en aras de la portabilidad entre dispositivos Un conjunto amplio de modelos pre-entrenados disponibles directamente para su uso en inferencia. El flujo b\u00e1sico de trabajo cuando estamos desarrollando una aplicaci\u00f3n basada en TFLite se basa en cuatro modelos principales: Selecci\u00f3n de modelo pre-entrenado o creaci\u00f3n/entrenamiento sobre un nuevo modelo. T\u00edpicamente utilizando frameworks existentes, como TensorFlow. Conversi\u00f3n del modelo, utilizando el conversor de TFLite desde Python para adaptarlo a las especificidades de TFLite. Despliegue en el dispositivo, utilizando las APIs del lenguaje seleccionado, e invocando al int\u00e9rprete de TFLite. Optimizaci\u00f3n del modelo (si es necesaria), utilizando el Toolkit de Optimizaci\u00f3n de Modelos , para reducir el tama\u00f1o del modelo e incrementar su eficiencia (t\u00edpicamente a cambio de cierta p\u00e9rdida en precisi\u00f3n).","title":"\u00bfQu\u00e9 es TFLite/LiteRT?"},{"location":"LSI/Lab1/#instalacion-tflite","text":"Lo m\u00e1s sencillo es buscar un binario reciente pre-compilado para Raspberry Pi OS 64 Bookworm como por ejemplo los proporcionados por el repositorio tensorflow-lite-raspberrypi . El proceso de instalaci\u00f3n es sencillo: $ wget https://github.com/prepkg/tensorflow-lite-raspberrypi/releases/download/2.16.1/tensorflow-lite_64.deb $ sudo apt install -y ./tensorflow-lite_64.deb","title":"Instalaci\u00f3n TFLite"},{"location":"LSI/Lab1/#2-clasificacion-de-imagenes-usando-tflite","text":"En esta parte del laboratorio, mostraremos el flujo de trabajo b\u00e1sico para aplicar un modelo de clasificaci\u00f3n (basado en la red neuronal Mobilenet ), que interact\u00fae con im\u00e1genes tomadas directamente desde la c\u00e1mara web integrada en la Raspberry Pi. Tarea Los ficheros que estudiaremos en esta parte est\u00e1n disponibles en el directorio Clasificacion del paquete proporcionado. Como hemos dicho, el objetivo del laboratorio es aplicar inferencia sobre un modelo ya pre-entrenado, por lo que no incidiremos en la estructura interna del mismo. Sin embargo, es conveniente saber que Mobilenet es una familia de redes neuronales de convoluci\u00f3n dise\u00f1adas para ser peque\u00f1as en tama\u00f1o, y de baja latencia en inferencia, aplicables a procesos de clasificaci\u00f3n, detecci\u00f3n o segmentaci\u00f3n de im\u00e1genes, entre otras muchas aplicaciones. En nuestro caso, la red Mobilenet v1 1.0_224 es una red de convoluci\u00f3n que acepta im\u00e1genes de dimensi\u00f3n 224 x 224 y tres canales (RGB), entrenada para devolver la probabilidad de pertenencia a cada una de las 1001 clases para la que ha sido pre-entrenada. Antes de comenzar, es preciso descargar el modelo, fichero de etiquetas y dem\u00e1s requisitos invocando al script download.sh proporcionado: $ sh download.sh Modelos Esta ejecuci\u00f3n, si todo ha ido bien, descargar\u00e1 en el directorio Modelos tres ficheros que utilizaremos en el resto del laboratorio: mobilenet_v1_1.0_224_quant.tflite : modelo pre-entrenado y cuantizado MobileNet. mobilenet_v1_1.0_224_quant_edgetpu.tflite : modelo pre-entrenado y cuantizado MobileNet, compilado con soporte para Google Coral. labels_mobilenet_quant_v1_224.txt : fichero de descripci\u00f3n de etiquetas (clases), con el nombre de una clase por l\u00ednea. La posici\u00f3n de estas l\u00edneas coincide con cada una de las (1001) posiciones del tensor de salida.","title":"2. Clasificaci\u00f3n de im\u00e1genes usando TFLite"},{"location":"LSI/Lab1/#desarrollo-utilizando-python","text":"Aviso Debian Bookworm incluye por defecto Python 3.11 que exige la utilizaci\u00f3n de entornos virtuales para la gesti\u00f3n de m\u00f3dulos. Por lo tanto antes de ejecutar alguno de los comandos siguientes es preciso crear un entorno virtual, por ejemplo con los siguientes comandos: $ python3 -m venv LSI_venv --system-site-packages $ source LSI_venv/bin/activate Aviso Al trabajar con entornos virtuales es preciso instalar los paquetes Python necesarios dentro del entorno virtual mediante ejecutando el siguiente comando desde el directorio donde se encuentre el fichero correspondiente: $ python3 -m pip install -r requirements.txt El fichero classify_opencv.py contiene el c\u00f3digo necesario para realizar inferencia (clasificaci\u00f3n) de im\u00e1genes partiendo de capturas de fotogramas desde la c\u00e1mara de la Raspberry Pi, que revisamos paso a paso a continuaci\u00f3n:","title":"Desarrollo utilizando Python"},{"location":"LSI/Lab1/#invocacion-y-argumentos","text":"Observa el inicio de la funci\u00f3n main proporcionada: def main(): parser = argparse.ArgumentParser( formatter_class=argparse.ArgumentDefaultsHelpFormatter) parser.add_argument( '--model', help='File path of .tflite file.', required=True) parser.add_argument( '--labels', help='File path of labels file.', required=True) args = parser.parse_args() El programa recibir\u00e1, de forma obligatoria, dos argumentos: El modelo a aplicar, en formato tflite (FlatBuffer), a trav\u00e9s del par\u00e1metro --model . El fichero de etiquetas, en formato texto con una etiqueta por l\u00ednea. Este fichero no es estrictamente obligatorio, pero nos permite mostrar no s\u00f3lo el n\u00famero de clase inferida, sino tambi\u00e9n su texto asociado. As\u00ed, podremos ejecutar el programa directamente utilizando la orden (suponiendo que ambos ficheros residen en el directorio ../Modelos ): python3 classify_opencv.py --model ../Modelos/mobilenet_v1_1.0_224_quant.tflite \\ --labels ../Modelos/labels_mobilenet_quant_v1_224.txt La funci\u00f3n load_labels simplemente lee el fichero de etiqueta y las almacena en memoria para su posterior procesamiento tras la inferencia.","title":"Invocaci\u00f3n y argumentos"},{"location":"LSI/Lab1/#preparacion-del-interprete-tflite","text":"El siguiente paso es la preparaci\u00f3n del int\u00e9rprete de TFLite: interpreter = Interpreter(args.model) Observa que el \u00fanico par\u00e1metro proporcionado es el nombre del modelo a cargar en formato TFLite. Observa tambi\u00e9n que necesitaremos cargar los m\u00f3dulos correspondientes a TFLite antes de hacer uso de esta funci\u00f3n: from tflite_runtime.interpreter import Interpreter A continuaci\u00f3n, obtenemos informaci\u00f3n sobre el tensor de entrada del modelo reci\u00e9n cargado, utilizando la funci\u00f3n get_input_details , y consultando la propiedad shape de dicha entrada. Esto nos devolver\u00e1 en las variables widght y height los tama\u00f1os de imagen esperados por el modelo. A partir de ahora, puedes consultar la forma de trabajar con la API de Python a trav\u00e9s de la documentaci\u00f3n oficial . Utilizaremos esta informaci\u00f3n para redimensionar la imagen capturada de la c\u00e1mara como paso previo a la invocaci\u00f3n del modelo. Tarea Aseg\u00farate de que ambas l\u00edneas (creaci\u00f3n del int\u00e9rprete e importaci\u00f3n de bibliotecas) son correctas. Comprueba el correcto funcionamiento del c\u00f3digo utilizando el modelo mobilenet_v1_1.0_224_quant.tflite como entrada al programa classify_opencv.py sobre tu Raspberry Pi. Si todo ha ido bien, deber\u00edas ver una ventana mostrando la salida de la c\u00e1mara con cierta informaci\u00f3n sobreimpresionada, y para cada fotograma, el resultado de la inferencia a trav\u00e9s de l\u00ednea de comandos.","title":"Preparaci\u00f3n del int\u00e9rprete TFLite"},{"location":"LSI/Lab1/#inferencia","text":"En el bucle principal de captura, se invoca a la funci\u00f3n classify_image . Esta es una funci\u00f3n propia, que recibe simplemente el int\u00e9rprete TFLite construido y la imagen capturada, pero cuyo cuerpo contiene cierta funcionalidad de inter\u00e9s: ## Invoke model and process output (quantization-aware). def classify_image(interpreter, image, top_k=1): \"\"\"Returns a sorted array of classification results.\"\"\" set_input_tensor(interpreter, image) interpreter.invoke() output_details = interpreter.get_output_details()[0] output = np.squeeze(interpreter.get_tensor(output_details['index'])) # If the model is quantized (uint8 data), then dequantize the results if output_details['dtype'] == np.uint8: scale, zero_point = output_details['quantization'] output = scale * (output - zero_point) ordered = np.argpartition(-output, top_k) return [(i, output[i]) for i in ordered[:top_k]] Observa que la funci\u00f3n opera en varias fases. En primer lugar, se obtiene una referencia al tensor de entrada del modelo (invocando a la funci\u00f3n propia set_input_tensor ). En este caso, se copia, elemento a elemento, la imagen de entrada ( image ) a dicho tensor: ## Establish input tensor from an image (copying). def set_input_tensor(interpreter, image): tensor_index = interpreter.get_input_details()[0]['index'] input_tensor = interpreter.tensor(tensor_index)()[0] input_tensor[:, :] = image Volviendo a la funci\u00f3n classify_image , una vez copiada la entrada al tensor de entrada del modelo, se invoca al modelo TFLite ( interpreter.invoke() ). Este es el proceso de inferencia o aplicaci\u00f3n del modelo, y su tiempo de respuesta es cr\u00edtico. Por \u00faltimo, se procesa la salida (tensor de salida). En caso de ser una salida cuantizada (esto es, el tipo de cada elemento del array de salida es uint8_t , veremos m\u00e1s sobre cuantizaci\u00f3n en futuros laboratorios), \u00e9sta debe procesarse de forma acorde a los par\u00e1metros de cuantizaci\u00f3n utilizados. Al final, la funci\u00f3n devolver\u00e1 un array de tuplas con la posici\u00f3n/clase ( i ) y la probabilidad de pertenencia del objeto observado a dicha clase ( output[i] ). Tarea Imprime por pantalla la informaci\u00f3n sobre el tensor de entrada y el tensor de salida y analiza la salida proporcionada. Obs\u00e9rvese que, de forma previa a la invocaci\u00f3n del modelo, la im\u00e1gen capturada se ha reescalado de forma acorde al tama\u00f1o del tensor de entrada del modelo: image = cv2.resize(frame, (224, 224), interpolation = cv2.INTER_AREA)","title":"Inferencia"},{"location":"LSI/Lab1/#postprocesamiento","text":"Por \u00faltimo, el programa sobreimpresiona informaci\u00f3n sobre etiqueta de clasificaci\u00f3n, probabilidad de pertenencia a la clase y tiempo de inferencia sobre el propio frame , mostrando la imagen resultante: cv2.putText(frame, '%s %.2f\\n%.1fms' % ( labels[label_id], prob, elapsed_ms ), bottomLeftCornerOfText, font, fontScale, fontColor, lineType) cv2.imshow('image',frame)","title":"Postprocesamiento"},{"location":"LSI/Lab1/#desarrollo-utilizando-c","text":"El rendimiento es un factor determinante en aplicaciones Edge computing , por lo que resultar\u00e1 interesante disponer de una base desarrollada en C++ sobre la que trabajar para el ejemplo de clasificaci\u00f3n. El fichero classification.cpp proporciona un flujo de trabajo completo para realizar una clasificaci\u00f3n de im\u00e1genes similar a la realizada anteriormente usando la API de Python. El c\u00f3digo desarrollado es similar, paso a paso, al descrito para Python, por lo que no se incidir\u00e1 en los detalles m\u00e1s all\u00e1 de la API utilizada :","title":"Desarrollo utilizando C++"},{"location":"LSI/Lab1/#ficheros-de-cabecera","text":"Incluiremos ficheros de cabecera gen\u00e9ricos, para OpenCV y para TFLite: #include <stdio.h> // Cabeceras TFLite #include \"tensorflow/lite/interpreter.h\" #include \"tensorflow/lite/kernels/register.h\" #include \"tensorflow/lite/model.h\" // Cabeceras OpenCV #include <opencv2/core.hpp> #include <opencv2/videoio.hpp> #include <opencv2/imgproc.hpp> #include <opencv2/highgui.hpp> #include <iostream> #include <fstream> #include <stdio.h> // Otras cabeceras C++ #include <vector> #include <numeric> // std::iota #include <algorithm> // std::sort, std::stable_sort","title":"Ficheros de cabecera"},{"location":"LSI/Lab1/#carga-del-modelo-desde-un-fichero","text":"En este ejemplo, se realiza la carga del modelo directamente desde un fichero en disco, utilizando la rutina BuildFromFile : // 1. Cargamos modelo desde un fichero. std::unique_ptr<tflite::FlatBufferModel> model = tflite::FlatBufferModel::BuildFromFile(\"../Modelos/mobilenet_v1_1.0_224_quant.tflite\"); if(!model){ printf(\"Failed to mmap model\\n\"); exit(0); } // 2. Construimos el iterprete TFLite. tflite::ops::builtin::BuiltinOpResolver resolver; std::unique_ptr<tflite::Interpreter> interpreter; tflite::InterpreterBuilder(*model.get(), resolver)(&interpreter); // 3. Alojamos espacio para tensores. interpreter->AllocateTensors(); Observa que, en el anterior fragmento de c\u00f3digo, adem\u00e1s de la carga del modelo, se construye un int\u00e9rprete utilizando la clase InterpreterBuilder , y se aloja espacio para los tensores necesarios para aplicar el modelo.","title":"Carga del modelo desde un fichero"},{"location":"LSI/Lab1/#caracaterizacion-de-tensores-de-entrada-y-salida","text":"Como hemos hecho en el c\u00f3digo Python, ser\u00e1 necesario realizar una caracterizaci\u00f3n de los tensores de entrada y salida. El primero, para copiar nuestra imagen capturada desde c\u00e1mara; el segundo, para procesar la salida obtenida: // 4. Identificamos el tensor de entrada y de salida. int input_number = interpreter->inputs()[0]; uint8_t * input_tensor = interpreter->typed_tensor<uint8_t>(input_number); int output_number = interpreter->outputs()[0]; uint8_t * output_tensor = interpreter->typed_tensor<uint8_t>(output_number); Tarea \u00bfCu\u00e1l es el \u00edndice de los tensores de entrada y salida generados? Coinciden con los observados al mostrar por pantalla la informaci\u00f3n sobre ellos en el c\u00f3digo Python.","title":"Caracaterizaci\u00f3n de tensores de entrada y salida"},{"location":"LSI/Lab1/#invocacion-del-modelo-tflite","text":"Tras comenzar con la captura de v\u00eddeo y redimensionar la imagen de entrada, copiaremos al tensor de entrada la imagen capturada, pixel a pixel: // 8. Copiamos imagen al tensor de entrada. for (int i = 0; i < 224*224; ++i) { input_tensor[3*i + 0] = frame.at<cv::Vec3b>(i)[0]; input_tensor[3*i + 1] = frame.at<cv::Vec3b>(i)[1]; input_tensor[3*i + 2] = frame.at<cv::Vec3b>(i)[2]; } A continuaci\u00f3n, invocamos al modelo: // 9. Invocamos al modelo. if (interpreter->Invoke() != kTfLiteOk) { cerr << \"Failed to invoke tflite!\"; exit(-1); }","title":"Invocaci\u00f3n del modelo TFLite"},{"location":"LSI/Lab1/#clasificacion-y-analisis-de-salida","text":"El proceso de an\u00e1lisis de salida es ligeramente distinto al usado en Python, aunque sigue una filosof\u00eda similar. En primer lugar, analizamos el tensor de salida: // 10. Analizamos el tama\u00f1o del tensor de salida. TfLiteIntArray* output_dims = interpreter->tensor(output_number)->dims; auto output_size = output_dims->data[output_dims->size - 1]; cout << output_size << endl; Como en el caso de Python, en funci\u00f3n de la cuantizaci\u00f3n de la salida, deberemos procesarla de forma acorde (trataremos la cuantizaci\u00f3n en futuros laboratorios). En cualquier caso, el array logits contiene la probabilidad de pertenencia a cada una de las 1001 clases disponibles. El c\u00f3digo que se os proporciona ordena dicho array y muestra por pantalla la clase m\u00e1s probable, junto a su probabilidad asociada.","title":"Clasificaci\u00f3n y an\u00e1lisis de salida"},{"location":"LSI/Lab1/#compilacion-y-uso","text":"A continuaci\u00f3n, compila y ejecuta el programa para validar su funcionamiento: g++ classification.cpp -ltensorflow-lite -lpthread -ldl `pkg-config --cflags --libs opencv4` -o classification.x ./classification.x La salida est\u00e1 preparada para mostrar el c\u00f3digo num\u00e9rico de la clase detectada con mayor probabilidad, dicha probabilidad, y la descripci\u00f3n textual de la clase. Tarea Temporiza, utilizando la rutinas de la clase chrono de C++, el proceso de inferencia, y comp\u00e1ralo con el de la versi\u00f3n Python. Tarea De forma opcional, investiga c\u00f3mo sobreimpresionar la informaci\u00f3n asociada al proceso de inferencia (clase, probabilidad y tiempo) de forma similar a c\u00f3mo lo hicimos en Python.","title":"Compilaci\u00f3n y uso"},{"location":"LSI/Lab1/#uso-de-google-coral","text":"","title":"Uso de Google Coral"},{"location":"LSI/Lab1/#runtime-edgetpu","text":"Para poder usar la Google Coral con TFLite es necesario instalar la librer\u00eda correspondiente ( libedgetpu ). Las fuentes de esta librer\u00eda est\u00e1n disponibles el GitHub de Google-Coral pero lo m\u00e1s sencillo es descargar binarios pre-compilados para bookworm y arm64 (tambi\u00e9n denominado aarch64 ). Instrucciones de instalaci\u00f3n: $ wget https://github.com/feranick/libedgetpu/releases/download/16.0TF2.16.1-1/libedgetpu-dev_16.0tf2.16.1-1.bookworm_arm64.deb $ wget https://github.com/feranick/libedgetpu/releases/download/16.0TF2.16.1-1/libedgetpu1-max_16.0tf2.16.1-1.bookworm_arm64.deb $ sudo dpkg -i libedgetpu*","title":"Runtime EdgeTPU"},{"location":"LSI/Lab1/#uso-de-edgetpu-desde-python","text":"Para utilizar el acelerador Google Coral (que debe estar conectado a la Raspberry Pi), realizaremos ciertas modificaciones en el c\u00f3digo, que en este caso son m\u00ednimas. En primer lugar, a\u00f1adiremos un import en nuestro fichero: from tflite_runtime.interpreter import load_delegate A continuaci\u00f3n, reemplazaremos la construcci\u00f3n del int\u00e9rprete por la especificaci\u00f3n de una biblioteca delegada para realizar la inferencia sobre la Google Coral: interpreter = Interpreter(args.model, experimental_delegates=[load_delegate('libedgetpu.so.1.0')]) Finalmente, ser\u00e1 necesario aplicar un modelo especialmente compilado para la Google Coral. Normalmente, este modelo se obtiene utilizando el compilador de la Edge TPU , pero en este caso se descarga y proporciona mediante el script download.sh . El nombre del modelo es mobilenet_v1_1.0_224_quant_edgetpu.tflite . As\u00ed, podremos ejecutar sobre la Edge TPU usando: sudo python3 classify_opencv.py \\ --model ../Modelos/mobilenet_v1_1.0_224_quant_edgetpu.tflite \\ --labels ../Modelos/labels_mobilenet_quant_v1_224.txt Obviamente, para que el anterior comando tenga \u00e9xito, la Google Coral deber\u00e1 estar conectada a la Raspberry Pi y el usuario que lo ejecuta debe tener permisos para usar el dispositivo. Estos permisos se pueden otorgar mediante la siguiente secuencia de comandos: $ lsusb -d 18d1:9302 Bus 002 Device 003: ID 18d1:9302 Google Inc. $ echo 'SUBSYSTEM==\"usb\", ATTR{idVendor}==\"18d1\", ATTR{idProduct}==\"9302\", MODE=\"0666\", GROUP=\"plugdev\"' | sudo tee /etc/udev/rules.d/99-edgetpu.rules $ sudo udevadm control --reload-rules && sudo udevadm trigger Aviso Es posible que para que el cambio surta efecto sea necesario salir y volver a entrar en la sesi\u00f3n. Tarea Compara los tiempos de ejecuci\u00f3n de la inferencia utilizando el procesdor de prop\u00f3sito general frente al rendimiento utilizando la Google Coral. \u00bfQu\u00e9 ganancia de rendimiento observas? Ajusta la configuraci\u00f3n de la captura de imagenes para que la comparaci\u00f3n sea lo m\u00e1s justa:","title":"Uso de EdgeTPU desde Python"},{"location":"LSI/Lab1/#uso-de-edgetpu-desde-c","text":"Para usar la Google Coral desde C++ es preciso realizar algunas modificaciones al c\u00f3digo visto anteriormente ademas de incluir la correspondiente cabecera ( <edgetpu.h> ). Para m\u00e1s informaci\u00f3n consultar la documentaci\u00f3n de la API de libedgetpu .","title":"Uso de EdgeTPU desde C++"},{"location":"LSI/Lab1/#apertura-del-dispositivo","text":"Antes de poder trabajar con la EdgeTPU es preciso abrir el dispositivo con la funci\u00f3n OpenDevice de la clase EdgeTpuManager : auto tpu_context = edgetpu::EdgeTpuManager::GetSingleton()->OpenDevice();","title":"Apertura del dispositivo"},{"location":"LSI/Lab1/#registrar-el-manejador-de-edgetpu-en-el-resolutor","text":"A continuaci\u00f3n es preciso a\u00f1adir un operador personalizado para que TensorFlow Lite lo reconozca: tflite::ops::builtin::BuiltinOpResolver resolver; resolver.AddCustom(edgetpu::kCustomOp, edgetpu::RegisterCustomOp());","title":"Registrar el manejador de EdgeTPU en el resolutor"},{"location":"LSI/Lab1/#vincular-el-contexto-de-edgetpu-con-el-interprete","text":"Por \u00faltimo es necesario vincular el contexto del dispositivo abierto previamente con el int\u00e9rprete de TFLite: interpreter->SetExternalContext(kTfLiteEdgeTpuContext,tpu_context.get()); Por lo dem\u00e1s el c\u00f3digo es esencialmente el mismo que anteriormente.","title":"Vincular el contexto de EdgeTPU con el int\u00e9rprete"},{"location":"LSI/Lab1/#compilacion","text":"Para poder compilar el c\u00f3digo es preciso enlazar con la librar\u00eda libedgetpu : g++ classification.cpp -o classification.x `pkg-config --cflags --libs opencv4` -ltensorflow-lite -lpthread -ldl Tarea Compara las versiones C++ CPU vs Google Coral \u00bfQu\u00e9 ganancia de rendimiento observas? Compara el resultado con el obtenido en Python.","title":"Compilaci\u00f3n"},{"location":"LSI/Lab2/","text":"Laboratorio 2. TensorFlow Lite en ESP32-S3-EYE Objetivos Familiarizarse con la placa ESP32-S3-EYE Aprender el manejo b\u00e1sico de su c\u00e1mara y su display LCD Familiarizarse con TensorFlow Lite para Microcontroladores y en especial con la version para ESP32 Conocer alg\u00fan otro framework para ejecuci\u00f3n de modelos en SoCs ESP32, como ESP-WH0. Placa ESP32-S3-EYE Descripci\u00f3n El ESP32-S3-EYE es una placa de desarrollo para AIoT de peque\u00f1o tama\u00f1o producida por Espressif y est\u00e1 orientada a aplicaciones como timbres inteligentes, sistemas de vigilancia, relojes de control de asistencia con reconocimiento facial, entre otros. Se basa en el SoC ESP32-S3 y en ESP-WHO , el framework de desarrollo de IA de Espressif y sus principales caracter\u00edsticas se recogen en la siguiente tabla. Par\u00e1metro ESP32-S3-EYE (v2.2) MCU ESP32-S3 (Dual-core Xtensa LX7 @ 240 MHz) M\u00f3dulo ESP32-S3-WROOM-1 (N8R8) PSRAM 8 MB (Octal SPI) - \u00a1Cuidado con confundirse con QSPI! Flash 8 MB (Quad SPI) Display LCD 1,3\" 240x240 pixel (ST7789) C\u00e1mara 2M Pixel, 1600x1200, ( OV2640 ) Micr\u00f3fono I2S Digital (MSM261S4030H0) Conexi\u00f3n USB/JTAG y USB/UART Sensor Aceler\u00f3metro de 3 ejes (QMA7981) Almacenamiento MicroSD Esquema Aceleraci\u00f3n de AI y DSP El ESP32-S3 incorpora una serie de nuevas instrucciones extendidas (PIE: Processor Instruction Extensions) para mejorar la eficiencia en la ejecuci\u00f3n de algoritmos espec\u00edficos de IA y DSP (Procesamiento Digital de Se\u00f1ales). Lista de caracter\u00edsticas: Registros generales de 128 bits Operaciones vectoriales de 128 bits, como multiplicaci\u00f3n compleja, suma, resta, multiplicaci\u00f3n, desplazamiento, comparaci\u00f3n, etc. Instrucciones de manejo de datos combinadas con instrucciones de carga/almacenamiento Soporte para datos vectoriales de 128 bits no alineados Operaciones con saturaci\u00f3n Las librer\u00edas ESP-DSP y ESP-NN se apoyan estas extensiones para acelerar el procesamiento de algoritmos de procesado digital de se\u00f1al y de redes neuronales. Firmware de referencia y test funcional La placa ESP32-S3-EYE viene con un firmware preinstalado por defecto basado en ESP-WHO que permite probar sus funciones, incluyendo: Activaci\u00f3n por voz Reconocimiento de comandos de voz Detecci\u00f3n y reconocimiento facial Tarea Verificar el funcionamiento del firmware de referencia siguiendo las instrucciones proporcionadas en la gu\u00eda de la ESP32-S3-EYE . \u00bfC\u00f3mo recuperar el firmware de referencia? En caso de que no est\u00e9 presente, se puede grabar el firmware de referencia del siguiente modo. Clonar el repositorio de ESP-WHO : git clone https://github.com/espressif/esp-who.git Abrir desde la carpeta en VSCode. Configurar puerto serie (ej. /dev/ttyUSB1 ) y target ( esp32s3 ) mediante la extensi\u00f3n ESP-IDF. En un ESP-IDF terminal ejecutar: esptool.py erase_flash esptool.py write_flash 0x0 default_bin/esp32-s3-eye/v2.2/esp32-s3-eye-v2.2-firmware-v0.2.0-cn.bin \u00bfProblemas con el acceso al puerto serie? La ESP32-S3-EYE no tiene un bridge USB-UART externo, lo que puede causar un problema: si el programa cargado en la placa provoca que el chip se reinicie constantemente, no podr\u00e1s cargar m\u00e1s programas en la placa. En caso de que suceda esto, debes: Mantener presionado el bot\u00f3n BOOT y pulsar el bot\u00f3n RST. Soltar primero el bot\u00f3n RST y luego el bot\u00f3n BOOT. De este modo, la placa entra en el modo de descarga de firmware y podr\u00e1s empezar a cargar el programa. Despu\u00e9s de cargarlo, presiona el bot\u00f3n RST para iniciar la ejecuci\u00f3n del programa. Manejo b\u00e1sico de la c\u00e1mara El componente esp32-camera proporciona soporte para las c\u00e1maras que usan las placas ESP32. Contiene controladores, configuraciones y ejemplos para m\u00f3dulos de c\u00e1mara como OV2640 , entre otros. Ejemplo de referencia: esp32-camera El componente proporciona un ejemplo de referencia ( espressif/esp32-camera ) que toma una foto cada 5 segundos y muestra su tama\u00f1o en el monitor serie. A continuaci\u00f3n vamos a probar este ejemplo siguiendo el procedimiento habitual, empleando la siguiente configuraci\u00f3n: Tama\u00f1o de Flash : 8MB Modo SPI RAM: Octal Mode PSRAM Frecuencia PRSAM: 80 MHz Adem\u00e1s es preciso descomentar la siguiente l\u00ednea del fichero main/take_picture.c : // 1. Board setup (Uncomment): // #define BOARD_WROVER_KIT // #define BOARD_ESP32CAM_AITHINKER #define BOARD_ESP32S3_WROOM Tarea Probar el ejemplo, variando algunos de los par\u00e1metros de la inicializaci\u00f3n de la c\u00e1mara (tama\u00f1o frame, formato, compresi\u00f3n JPEG, etc.). ESP-BSP ESP-BSP es una colecci\u00f3n de paquetes de soporte de placa ( Board Support Packages ) que facilita el desarrollo de proyectos para placas espec\u00edficas sin necesidad de buscar manualmente controladores y otros detalles. Al usar ESP-BSP, puedes: Simplificar la Integraci\u00f3n de Hardware : Facilita el c\u00f3digo y reduce la complejidad. Acelerar el Desarrollo : Configura r\u00e1pidamente tu entorno y empieza a trabajar en tus proyectos. Acceder a APIs Estandarizadas : Asegura consistencia entre tus proyectos. Entre las placas soportas se encuentra la ESP32-S3-EYE y su BSP especifico facilita el uso de sus distintos componentes: display LCD, c\u00e1mara, uSD, micr\u00f3fono y aceler\u00f3metro. Manejo b\u00e1sico del display LCD El repositorio ESP-BSP incluye componentes para diversos displays LCD , incluido el de la ESP32-S3-EYE (de 1,3 pulgadas y basado en el controlador ST7789) que es el mismo que incorpora la placa ESP32-S3-USB-OTG . La manera m\u00e1s efectiva de familiarizarse con la gesti\u00f3n de LCDs mediante ESP-BSP es explorar sus ejemplos . Ejemplo de referencia: display-camera El ejemplo display-camera captura im\u00e1genes de la c\u00e1mara y las muestra en el display LCD. Este ejemplo ademas ilustra el uso de LVGL (Light and Versatile Graphics Library), una librer\u00eda gr\u00e1fica de c\u00f3digo abierto que proporciona todo lo necesario para crear una interfaz gr\u00e1fica de usuario (GUI) con muy bajo consumo de memoria, muy adecuada para peque\u00f1os sistemas embebidos. A continuaci\u00f3n vamos a probar este ejemplo siguiendo el procedimiento habitual, empleando la siguiente configuraci\u00f3n. Modificaci\u00f3n componentes necesarios: El ejemplo est\u00e1 configurado por defecto para otra placa por lo que lo primero que hay que hacer es modificar el fichero de dependencias de componentes idf_component.yml : description: BSP Display and camera example dependencies: esp32_s3_eye: version: \"*\" override_path: \"../../../bsp/esp32_s3_eye\" Configuraci\u00f3n: Una vez modificado este fichero se puede proceder como de costumbre a la configuraci\u00f3n del proyecto: Tama\u00f1o de Flash : 8MB Modo SPI RAM: Octal Mode PSRAM Frecuencia PRSAM: 80 MHz Seleccionar dispositivo LCD: Use ST7789 LCD driver Tarea Probar el ejemplo, jugando con los par\u00e1metros de configuraci\u00f3n de LVGL para la visualizaci\u00f3n de rendimiento (por ejemplo LV_USE_PERF_MONITOR ) TensorFlow Lite para Microcontroladores (TFLM) \u00bfQu\u00e9 es? TensorFlow Lite para microcontroladores (TFLM) es una versi\u00f3n ultra ligera de TensorFlow dise\u00f1ada espec\u00edficamente para ejecutar modelos en microcontroladores con escasos recursos de c\u00f3mputo. Est\u00e1 optimizado para funcionar sin sistema operativo, con poca memoria (t\u00edpicamente menos de 256 KB de RAM), y sin requerir operaciones en coma flotante si el hardware no lo permite. TFLM permite ejecutar modelos previamente entrenados en TensorFlow Lite, adapt\u00e1ndolos a plataformas embebidas mediante cuantizaci\u00f3n (reducci\u00f3n de precisi\u00f3n num\u00e9rica) y operadores simplificados. Limitaciones Las siguientes limitaciones deben tenerse en cuenta: Soporte para un subconjunto limitado de operaciones de TensorFlow Soporte para un conjunto limitado de dispositivos API de bajo nivel en C++, que requiere gesti\u00f3n manual de memoria El entrenamiento en el dispositivo no est\u00e1 soportado TFLM para ESP32 Para mejorar el rendimiento en microcontroladores como el ESP32-S3, TFLM aprovecha las instrucciones vectoriales (PIE en este caso) para acelerar operaciones de inferencia. Para ello se basa en la librer\u00eda ESP-NN que est\u00e1 dise\u00f1ada espec\u00edficamente para este prop\u00f3sito. \u00bfC\u00f3mo se integra TFLM y ESP-NN? Durante la inicializaci\u00f3n del modelo, TFLM registra operadores que apuntan a las funciones de ESP-NN en lugar de las implementaciones gen\u00e9ricas de TFLM. Esto permite que las operaciones m\u00e1s costosas, como convoluciones 2D o capas fully connected, sean ejecutadas por el c\u00f3digo optimizado. Condiciones para aprovecharlo : El modelo debe estar cuantizado (int8) para beneficiarse de ESP-NN . Solo ciertos operadores est\u00e1n acelerados; los dem\u00e1s siguen usando las versiones de referencia de TFLM. Emplear un SoC ESP32-S3 (otros chips ESP32 no tienen PIE). Componente esp-flite-micro El componente esp-flite-micro proporciona la integraci\u00f3n de TFLM y ESP-NN necesaria para ejecutar de forma eficiente los modelos en SoCs ESP32, como el ESP32-S3 , que cuentan con soporte para instrucciones de aceleraci\u00f3n de IA (extensiones PIE). El componente proporciona versiones para tres ejemplos de referencia de TFLM: Hello World , Micro Speech y Person Detection . A continuaci\u00f3n probaremos los dos primeros. Ejemplos ESP-TLFM Hello-World Este ejemplo Hello World de TLFM est\u00e1 dise\u00f1ado para demostrar los conceptos m\u00e1s b\u00e1sicos del uso de TensorFlow Lite para Microcontroladores. Incluye todo el flujo de trabajo de principio a fin, desde el entrenamiento de un modelo hasta su conversi\u00f3n para ser utilizado con TFLM y la ejecuci\u00f3n en un microcontrolador. Modelo El modelo empleado es una red neuronal secuencial ( feed-forward ) simple con las siguientes caracter\u00edsticas: Entrada : Escalar (x) Capa 1 : 16 neuronas, activaci\u00f3n ReLU Capa 2 : 16 neuronas, activaci\u00f3n ReLU (permite aprender relaciones m\u00e1s complejas) Capa 3 (salida) : 1 neurona, salida continua (regresi\u00f3n) A continuaci\u00f3n lo mostramos gr\u00e1ficamente mediante la aplicaci\u00f3n Netron : El modelo se entrena para replicar una funci\u00f3n seno y genera un patr\u00f3n de datos que puede utilizarse para hacer parpadear LEDs o controlar una animaci\u00f3n, dependiendo de las capacidades del dispositivo. En esta pr\u00e1ctica obviaremos el entrenamiento y conversi\u00f3n del modelos y partiremos siempre de modelos .tflie ya cuantizados a int8 , por ejemplo hello_world_int8.tflite en este caso. Tarea Instanciar el ejemplo hello_world del componente esp-flite-micro para poderlo estudiar. Almacenamiento del modelo Muchos microcontroladores no tdisponen de sistema ficheros por lo que habitualmente es necesario enlazar directamente el modelo en el binario. Por ejemplo, en el ejemplo con el que estamos trabajando se emplea el fichero model.cc cuyo contenido hexadecimal se genera mediante el siguiente comando Unix (Linux/MacOS/WSL): xxd -i model.tflite > model.cc An\u00e1lisis del c\u00f3digo, uso de la API Las principales funciones est\u00e1n en el fichero main_functions.cc , setup() y loop() . setup() Esta funci\u00f3n es la responsable de la inicializaci\u00f3n y lleva a cabo las siguientes acciones: Cargar del modelo: el modelo: el modelo que est\u00e1 almacenado en const unsigned char g_model[]; se instancia en una estructura tflite::Model y se verifica que sea compatible con la versi\u00f3n del esquema que est\u00e1 usando. // Map the model into a usable data structure. This doesn't involve any // copying or parsing, it's a very lightweight operation. model = tflite::GetModel(g_model); if (model->version() != TFLITE_SCHEMA_VERSION) { MicroPrintf(\"Model provided is schema version %d not equal to supported \" \"version %d.\", model->version(), TFLITE_SCHEMA_VERSION); return; } Instanciar el resolvedor de operaciones: Se declara una instancia de MicroMutableOpResolver que ser\u00e1 utilizada por el int\u00e9rprete para registrar y acceder a los operadores que utiliza el modelo, y se registran los operadores necesarios. // Pull in only the operation implementations we need. static tflite::MicroMutableOpResolver<1> resolver; if (resolver.AddFullyConnected() != kTfLiteOk) { return; } Asignar memoria: Necesitamos preasignar una cierta cantidad de memoria para los arrays de entrada, salida e intermedios. // Allocate memory from the tensor_arena for the model's tensors. TfLiteStatus allocate_status = interpreter->AllocateTensors(); if (allocate_status != kTfLiteOk) { MicroPrintf(\"AllocateTensors() failed\"); return; } Creaci\u00f3n del int\u00e9rprete : Se declara un interprete y se le asignan los tensores de entrada y salida: // Build an interpreter to run the model with. static tflite::MicroInterpreter static_interpreter( model, resolver, tensor_arena, kTensorArenaSize); interpreter = &static_interpreter; // Obtain pointers to the model's input and output tensors. input = interpreter->input(0); output = interpreter->output(0); loop() Es funci\u00f3n proporciona el tensor de entrada al modelo (valor de x cuantizado), ejecuta el modelo (inferencia), y procesa el tensor de salida (valor de y cuantizado). Inferencia : Para ejecutar el modelo se invoca el interprete creado previamente. // Run inference, and report any error TfLiteStatus invoke_status = interpreter->Invoke(); if (invoke_status != kTfLiteOk) { MicroPrintf(\"Invoke failed on x: %f\\n\", static_cast<double>(x)); return; } Tarea Estudiar el ejemplo de referencia y probarlo en la placa ESP32-S3-EYE. Tarea Convertir el modelo de referencia ( hello_world_int8.tflite ) a hexadecimal y comprobar su correcta ejecuci\u00f3n. Person Detection El ejemplo Person Detection de TFLM ilustra un caso de clasificaci\u00f3n binaria de images, es decir si una imagen dada pertenece o no a una categor\u00eda, en este caso que aparezca o no una persona en ella. Modelo El modelo empleado es un mobilenet_v1_025 de la familia de modelos MobileNets orientados a dispositivos Edge. La MobileNet V1 es una familia de redes neuronales ligeras que utilizan convoluciones separables en profundidad ( depthwise separable convolutions ). En este enfoque, primero se aplica una convoluci\u00f3n para filtrar cada canal de la imagen por separado (depthwise), y luego se emplea una convoluci\u00f3n punto a punto (pointwise) para combinar los resultados. Esto reduce significativamente la cantidad de par\u00e1metros y c\u00e1lculos, manteniendo un alto nivel de precisi\u00f3n en la clasificaci\u00f3n de im\u00e1genes. A continuaci\u00f3n se muestran las primeras y las \u00faltimas capas del modelo empleado en el ejemplo ( mobilenet_v1_025 ). Dataset y entrenamiento El dataset empleado, Visual Wake Words Dataset , est\u00e1 especialmente orientado a crear modelos de peque\u00f1o footprint (~250KB). El proceso llevado a cabo para entrenar el modelo y convertirlo a TensorFlow Lite est\u00e1 descrito en el repositorio de GitHub de TFLM , aunque de momento no nos detendremos en su an\u00e1lisis pormenorizado. El modelo resultante puede descargarse en formato .tflite o en formato C ( person_detect_model_data.cc ) en los enlaces proporcionados. C\u00f3digo El c\u00f3digo sigue un esquema an\u00e1logo al del ejemplo anterior. Tarea Instanciar el ejemplo person_detection del componente esp-flite-micro para poderlo estudiar. Responder a las siguientes preguntas: \u00bfQu\u00e9 operadores se registran? \u00bfQu\u00e9 tama\u00f1o tiene el modelo? \u00bfC\u00f3mo se ha convertido? Tarea Probar el ejemplo y determinar el tiempo de requerido para cada inferencia. Tarea Modificarlo para crear una sencilla aplicaci\u00f3n que avise cuando detecta una persona y muestre el intervalo de tiempo que ha permanecido en c\u00e1mara. ESP-WHO \u00bfQu\u00e9 es? ESP-WHO es un framework de c\u00f3digo abierto, dise\u00f1ado por Espressif para la detecci\u00f3n y el reconocimiento facial en dispositivos basados en ESP32 (como ESP32-CAM, ESP-EYE, ESP32-S3-EYE, entre otros). Incluye funciones y ejemplos para tareas como detecci\u00f3n, alineaci\u00f3n y reconocimiento de rostros, facilitando la implementaci\u00f3n de aplicaciones de visi\u00f3n artificial. Ejemplos ESP-WHO proporciona los siguientes ejemplos, todos ellos preparados para poderse emplear en la ESP32-S3-EYE: human_face_detect : detecci\u00f3n de rostro human_face_detect_lvgl : mismo ejemplo pero haciendo uso de la librar\u00eda LVGL human_face_recognition : reconocimiento facial pedestrian_detect : detecci\u00f3n de peatones. pedestrian_detect_lvgl : mismo ejemplo pero haciendo uso de la librar\u00eda LVGL Tarea Estudiar y probar el ejemplo human_face_detect . Evaluar el tiempo de invocaci\u00f3n.","title":"Pr\u00e1ctica 2"},{"location":"LSI/Lab2/#laboratorio-2-tensorflow-lite-en-esp32-s3-eye","text":"","title":"Laboratorio 2. TensorFlow Lite en ESP32-S3-EYE"},{"location":"LSI/Lab2/#objetivos","text":"Familiarizarse con la placa ESP32-S3-EYE Aprender el manejo b\u00e1sico de su c\u00e1mara y su display LCD Familiarizarse con TensorFlow Lite para Microcontroladores y en especial con la version para ESP32 Conocer alg\u00fan otro framework para ejecuci\u00f3n de modelos en SoCs ESP32, como ESP-WH0.","title":"Objetivos"},{"location":"LSI/Lab2/#placa-esp32-s3-eye","text":"","title":"Placa ESP32-S3-EYE"},{"location":"LSI/Lab2/#descripcion","text":"El ESP32-S3-EYE es una placa de desarrollo para AIoT de peque\u00f1o tama\u00f1o producida por Espressif y est\u00e1 orientada a aplicaciones como timbres inteligentes, sistemas de vigilancia, relojes de control de asistencia con reconocimiento facial, entre otros. Se basa en el SoC ESP32-S3 y en ESP-WHO , el framework de desarrollo de IA de Espressif y sus principales caracter\u00edsticas se recogen en la siguiente tabla. Par\u00e1metro ESP32-S3-EYE (v2.2) MCU ESP32-S3 (Dual-core Xtensa LX7 @ 240 MHz) M\u00f3dulo ESP32-S3-WROOM-1 (N8R8) PSRAM 8 MB (Octal SPI) - \u00a1Cuidado con confundirse con QSPI! Flash 8 MB (Quad SPI) Display LCD 1,3\" 240x240 pixel (ST7789) C\u00e1mara 2M Pixel, 1600x1200, ( OV2640 ) Micr\u00f3fono I2S Digital (MSM261S4030H0) Conexi\u00f3n USB/JTAG y USB/UART Sensor Aceler\u00f3metro de 3 ejes (QMA7981) Almacenamiento MicroSD","title":"Descripci\u00f3n"},{"location":"LSI/Lab2/#esquema","text":"","title":"Esquema"},{"location":"LSI/Lab2/#aceleracion-de-ai-y-dsp","text":"El ESP32-S3 incorpora una serie de nuevas instrucciones extendidas (PIE: Processor Instruction Extensions) para mejorar la eficiencia en la ejecuci\u00f3n de algoritmos espec\u00edficos de IA y DSP (Procesamiento Digital de Se\u00f1ales). Lista de caracter\u00edsticas: Registros generales de 128 bits Operaciones vectoriales de 128 bits, como multiplicaci\u00f3n compleja, suma, resta, multiplicaci\u00f3n, desplazamiento, comparaci\u00f3n, etc. Instrucciones de manejo de datos combinadas con instrucciones de carga/almacenamiento Soporte para datos vectoriales de 128 bits no alineados Operaciones con saturaci\u00f3n Las librer\u00edas ESP-DSP y ESP-NN se apoyan estas extensiones para acelerar el procesamiento de algoritmos de procesado digital de se\u00f1al y de redes neuronales.","title":"Aceleraci\u00f3n de AI y DSP"},{"location":"LSI/Lab2/#firmware-de-referencia-y-test-funcional","text":"La placa ESP32-S3-EYE viene con un firmware preinstalado por defecto basado en ESP-WHO que permite probar sus funciones, incluyendo: Activaci\u00f3n por voz Reconocimiento de comandos de voz Detecci\u00f3n y reconocimiento facial Tarea Verificar el funcionamiento del firmware de referencia siguiendo las instrucciones proporcionadas en la gu\u00eda de la ESP32-S3-EYE .","title":"Firmware de referencia y test funcional"},{"location":"LSI/Lab2/#como-recuperar-el-firmware-de-referencia","text":"En caso de que no est\u00e9 presente, se puede grabar el firmware de referencia del siguiente modo. Clonar el repositorio de ESP-WHO : git clone https://github.com/espressif/esp-who.git Abrir desde la carpeta en VSCode. Configurar puerto serie (ej. /dev/ttyUSB1 ) y target ( esp32s3 ) mediante la extensi\u00f3n ESP-IDF. En un ESP-IDF terminal ejecutar: esptool.py erase_flash esptool.py write_flash 0x0 default_bin/esp32-s3-eye/v2.2/esp32-s3-eye-v2.2-firmware-v0.2.0-cn.bin","title":"\u00bfC\u00f3mo recuperar el firmware de referencia?"},{"location":"LSI/Lab2/#problemas-con-el-acceso-al-puerto-serie","text":"La ESP32-S3-EYE no tiene un bridge USB-UART externo, lo que puede causar un problema: si el programa cargado en la placa provoca que el chip se reinicie constantemente, no podr\u00e1s cargar m\u00e1s programas en la placa. En caso de que suceda esto, debes: Mantener presionado el bot\u00f3n BOOT y pulsar el bot\u00f3n RST. Soltar primero el bot\u00f3n RST y luego el bot\u00f3n BOOT. De este modo, la placa entra en el modo de descarga de firmware y podr\u00e1s empezar a cargar el programa. Despu\u00e9s de cargarlo, presiona el bot\u00f3n RST para iniciar la ejecuci\u00f3n del programa.","title":"\u00bfProblemas con el acceso al puerto serie?"},{"location":"LSI/Lab2/#manejo-basico-de-la-camara","text":"El componente esp32-camera proporciona soporte para las c\u00e1maras que usan las placas ESP32. Contiene controladores, configuraciones y ejemplos para m\u00f3dulos de c\u00e1mara como OV2640 , entre otros.","title":"Manejo b\u00e1sico de la c\u00e1mara"},{"location":"LSI/Lab2/#ejemplo-de-referencia-esp32-camera","text":"El componente proporciona un ejemplo de referencia ( espressif/esp32-camera ) que toma una foto cada 5 segundos y muestra su tama\u00f1o en el monitor serie. A continuaci\u00f3n vamos a probar este ejemplo siguiendo el procedimiento habitual, empleando la siguiente configuraci\u00f3n: Tama\u00f1o de Flash : 8MB Modo SPI RAM: Octal Mode PSRAM Frecuencia PRSAM: 80 MHz Adem\u00e1s es preciso descomentar la siguiente l\u00ednea del fichero main/take_picture.c : // 1. Board setup (Uncomment): // #define BOARD_WROVER_KIT // #define BOARD_ESP32CAM_AITHINKER #define BOARD_ESP32S3_WROOM Tarea Probar el ejemplo, variando algunos de los par\u00e1metros de la inicializaci\u00f3n de la c\u00e1mara (tama\u00f1o frame, formato, compresi\u00f3n JPEG, etc.).","title":"Ejemplo de referencia: esp32-camera"},{"location":"LSI/Lab2/#esp-bsp","text":"ESP-BSP es una colecci\u00f3n de paquetes de soporte de placa ( Board Support Packages ) que facilita el desarrollo de proyectos para placas espec\u00edficas sin necesidad de buscar manualmente controladores y otros detalles. Al usar ESP-BSP, puedes: Simplificar la Integraci\u00f3n de Hardware : Facilita el c\u00f3digo y reduce la complejidad. Acelerar el Desarrollo : Configura r\u00e1pidamente tu entorno y empieza a trabajar en tus proyectos. Acceder a APIs Estandarizadas : Asegura consistencia entre tus proyectos. Entre las placas soportas se encuentra la ESP32-S3-EYE y su BSP especifico facilita el uso de sus distintos componentes: display LCD, c\u00e1mara, uSD, micr\u00f3fono y aceler\u00f3metro.","title":"ESP-BSP"},{"location":"LSI/Lab2/#manejo-basico-del-display-lcd","text":"El repositorio ESP-BSP incluye componentes para diversos displays LCD , incluido el de la ESP32-S3-EYE (de 1,3 pulgadas y basado en el controlador ST7789) que es el mismo que incorpora la placa ESP32-S3-USB-OTG . La manera m\u00e1s efectiva de familiarizarse con la gesti\u00f3n de LCDs mediante ESP-BSP es explorar sus ejemplos .","title":"Manejo b\u00e1sico del display LCD"},{"location":"LSI/Lab2/#ejemplo-de-referencia-display-camera","text":"El ejemplo display-camera captura im\u00e1genes de la c\u00e1mara y las muestra en el display LCD. Este ejemplo ademas ilustra el uso de LVGL (Light and Versatile Graphics Library), una librer\u00eda gr\u00e1fica de c\u00f3digo abierto que proporciona todo lo necesario para crear una interfaz gr\u00e1fica de usuario (GUI) con muy bajo consumo de memoria, muy adecuada para peque\u00f1os sistemas embebidos. A continuaci\u00f3n vamos a probar este ejemplo siguiendo el procedimiento habitual, empleando la siguiente configuraci\u00f3n. Modificaci\u00f3n componentes necesarios: El ejemplo est\u00e1 configurado por defecto para otra placa por lo que lo primero que hay que hacer es modificar el fichero de dependencias de componentes idf_component.yml : description: BSP Display and camera example dependencies: esp32_s3_eye: version: \"*\" override_path: \"../../../bsp/esp32_s3_eye\" Configuraci\u00f3n: Una vez modificado este fichero se puede proceder como de costumbre a la configuraci\u00f3n del proyecto: Tama\u00f1o de Flash : 8MB Modo SPI RAM: Octal Mode PSRAM Frecuencia PRSAM: 80 MHz Seleccionar dispositivo LCD: Use ST7789 LCD driver Tarea Probar el ejemplo, jugando con los par\u00e1metros de configuraci\u00f3n de LVGL para la visualizaci\u00f3n de rendimiento (por ejemplo LV_USE_PERF_MONITOR )","title":"Ejemplo de referencia: display-camera"},{"location":"LSI/Lab2/#tensorflow-lite-para-microcontroladores-tflm","text":"","title":"TensorFlow Lite para Microcontroladores (TFLM)"},{"location":"LSI/Lab2/#que-es","text":"TensorFlow Lite para microcontroladores (TFLM) es una versi\u00f3n ultra ligera de TensorFlow dise\u00f1ada espec\u00edficamente para ejecutar modelos en microcontroladores con escasos recursos de c\u00f3mputo. Est\u00e1 optimizado para funcionar sin sistema operativo, con poca memoria (t\u00edpicamente menos de 256 KB de RAM), y sin requerir operaciones en coma flotante si el hardware no lo permite. TFLM permite ejecutar modelos previamente entrenados en TensorFlow Lite, adapt\u00e1ndolos a plataformas embebidas mediante cuantizaci\u00f3n (reducci\u00f3n de precisi\u00f3n num\u00e9rica) y operadores simplificados.","title":"\u00bfQu\u00e9 es?"},{"location":"LSI/Lab2/#limitaciones","text":"Las siguientes limitaciones deben tenerse en cuenta: Soporte para un subconjunto limitado de operaciones de TensorFlow Soporte para un conjunto limitado de dispositivos API de bajo nivel en C++, que requiere gesti\u00f3n manual de memoria El entrenamiento en el dispositivo no est\u00e1 soportado","title":"Limitaciones"},{"location":"LSI/Lab2/#tflm-para-esp32","text":"Para mejorar el rendimiento en microcontroladores como el ESP32-S3, TFLM aprovecha las instrucciones vectoriales (PIE en este caso) para acelerar operaciones de inferencia. Para ello se basa en la librer\u00eda ESP-NN que est\u00e1 dise\u00f1ada espec\u00edficamente para este prop\u00f3sito.","title":"TFLM para ESP32"},{"location":"LSI/Lab2/#como-se-integra-tflm-y-esp-nn","text":"Durante la inicializaci\u00f3n del modelo, TFLM registra operadores que apuntan a las funciones de ESP-NN en lugar de las implementaciones gen\u00e9ricas de TFLM. Esto permite que las operaciones m\u00e1s costosas, como convoluciones 2D o capas fully connected, sean ejecutadas por el c\u00f3digo optimizado. Condiciones para aprovecharlo : El modelo debe estar cuantizado (int8) para beneficiarse de ESP-NN . Solo ciertos operadores est\u00e1n acelerados; los dem\u00e1s siguen usando las versiones de referencia de TFLM. Emplear un SoC ESP32-S3 (otros chips ESP32 no tienen PIE).","title":"\u00bfC\u00f3mo se integra TFLM y ESP-NN?"},{"location":"LSI/Lab2/#componente-esp-flite-micro","text":"El componente esp-flite-micro proporciona la integraci\u00f3n de TFLM y ESP-NN necesaria para ejecutar de forma eficiente los modelos en SoCs ESP32, como el ESP32-S3 , que cuentan con soporte para instrucciones de aceleraci\u00f3n de IA (extensiones PIE). El componente proporciona versiones para tres ejemplos de referencia de TFLM: Hello World , Micro Speech y Person Detection . A continuaci\u00f3n probaremos los dos primeros.","title":"Componente esp-flite-micro"},{"location":"LSI/Lab2/#ejemplos-esp-tlfm","text":"","title":"Ejemplos ESP-TLFM"},{"location":"LSI/Lab2/#hello-world","text":"Este ejemplo Hello World de TLFM est\u00e1 dise\u00f1ado para demostrar los conceptos m\u00e1s b\u00e1sicos del uso de TensorFlow Lite para Microcontroladores. Incluye todo el flujo de trabajo de principio a fin, desde el entrenamiento de un modelo hasta su conversi\u00f3n para ser utilizado con TFLM y la ejecuci\u00f3n en un microcontrolador.","title":"Hello-World"},{"location":"LSI/Lab2/#modelo","text":"El modelo empleado es una red neuronal secuencial ( feed-forward ) simple con las siguientes caracter\u00edsticas: Entrada : Escalar (x) Capa 1 : 16 neuronas, activaci\u00f3n ReLU Capa 2 : 16 neuronas, activaci\u00f3n ReLU (permite aprender relaciones m\u00e1s complejas) Capa 3 (salida) : 1 neurona, salida continua (regresi\u00f3n) A continuaci\u00f3n lo mostramos gr\u00e1ficamente mediante la aplicaci\u00f3n Netron : El modelo se entrena para replicar una funci\u00f3n seno y genera un patr\u00f3n de datos que puede utilizarse para hacer parpadear LEDs o controlar una animaci\u00f3n, dependiendo de las capacidades del dispositivo. En esta pr\u00e1ctica obviaremos el entrenamiento y conversi\u00f3n del modelos y partiremos siempre de modelos .tflie ya cuantizados a int8 , por ejemplo hello_world_int8.tflite en este caso. Tarea Instanciar el ejemplo hello_world del componente esp-flite-micro para poderlo estudiar.","title":"Modelo"},{"location":"LSI/Lab2/#almacenamiento-del-modelo","text":"Muchos microcontroladores no tdisponen de sistema ficheros por lo que habitualmente es necesario enlazar directamente el modelo en el binario. Por ejemplo, en el ejemplo con el que estamos trabajando se emplea el fichero model.cc cuyo contenido hexadecimal se genera mediante el siguiente comando Unix (Linux/MacOS/WSL): xxd -i model.tflite > model.cc","title":"Almacenamiento del modelo"},{"location":"LSI/Lab2/#analisis-del-codigo-uso-de-la-api","text":"Las principales funciones est\u00e1n en el fichero main_functions.cc , setup() y loop() . setup() Esta funci\u00f3n es la responsable de la inicializaci\u00f3n y lleva a cabo las siguientes acciones: Cargar del modelo: el modelo: el modelo que est\u00e1 almacenado en const unsigned char g_model[]; se instancia en una estructura tflite::Model y se verifica que sea compatible con la versi\u00f3n del esquema que est\u00e1 usando. // Map the model into a usable data structure. This doesn't involve any // copying or parsing, it's a very lightweight operation. model = tflite::GetModel(g_model); if (model->version() != TFLITE_SCHEMA_VERSION) { MicroPrintf(\"Model provided is schema version %d not equal to supported \" \"version %d.\", model->version(), TFLITE_SCHEMA_VERSION); return; } Instanciar el resolvedor de operaciones: Se declara una instancia de MicroMutableOpResolver que ser\u00e1 utilizada por el int\u00e9rprete para registrar y acceder a los operadores que utiliza el modelo, y se registran los operadores necesarios. // Pull in only the operation implementations we need. static tflite::MicroMutableOpResolver<1> resolver; if (resolver.AddFullyConnected() != kTfLiteOk) { return; } Asignar memoria: Necesitamos preasignar una cierta cantidad de memoria para los arrays de entrada, salida e intermedios. // Allocate memory from the tensor_arena for the model's tensors. TfLiteStatus allocate_status = interpreter->AllocateTensors(); if (allocate_status != kTfLiteOk) { MicroPrintf(\"AllocateTensors() failed\"); return; } Creaci\u00f3n del int\u00e9rprete : Se declara un interprete y se le asignan los tensores de entrada y salida: // Build an interpreter to run the model with. static tflite::MicroInterpreter static_interpreter( model, resolver, tensor_arena, kTensorArenaSize); interpreter = &static_interpreter; // Obtain pointers to the model's input and output tensors. input = interpreter->input(0); output = interpreter->output(0); loop() Es funci\u00f3n proporciona el tensor de entrada al modelo (valor de x cuantizado), ejecuta el modelo (inferencia), y procesa el tensor de salida (valor de y cuantizado). Inferencia : Para ejecutar el modelo se invoca el interprete creado previamente. // Run inference, and report any error TfLiteStatus invoke_status = interpreter->Invoke(); if (invoke_status != kTfLiteOk) { MicroPrintf(\"Invoke failed on x: %f\\n\", static_cast<double>(x)); return; } Tarea Estudiar el ejemplo de referencia y probarlo en la placa ESP32-S3-EYE. Tarea Convertir el modelo de referencia ( hello_world_int8.tflite ) a hexadecimal y comprobar su correcta ejecuci\u00f3n.","title":"An\u00e1lisis del c\u00f3digo, uso de la API"},{"location":"LSI/Lab2/#person-detection","text":"El ejemplo Person Detection de TFLM ilustra un caso de clasificaci\u00f3n binaria de images, es decir si una imagen dada pertenece o no a una categor\u00eda, en este caso que aparezca o no una persona en ella.","title":"Person Detection"},{"location":"LSI/Lab2/#modelo_1","text":"El modelo empleado es un mobilenet_v1_025 de la familia de modelos MobileNets orientados a dispositivos Edge. La MobileNet V1 es una familia de redes neuronales ligeras que utilizan convoluciones separables en profundidad ( depthwise separable convolutions ). En este enfoque, primero se aplica una convoluci\u00f3n para filtrar cada canal de la imagen por separado (depthwise), y luego se emplea una convoluci\u00f3n punto a punto (pointwise) para combinar los resultados. Esto reduce significativamente la cantidad de par\u00e1metros y c\u00e1lculos, manteniendo un alto nivel de precisi\u00f3n en la clasificaci\u00f3n de im\u00e1genes. A continuaci\u00f3n se muestran las primeras y las \u00faltimas capas del modelo empleado en el ejemplo ( mobilenet_v1_025 ).","title":"Modelo"},{"location":"LSI/Lab2/#dataset-y-entrenamiento","text":"El dataset empleado, Visual Wake Words Dataset , est\u00e1 especialmente orientado a crear modelos de peque\u00f1o footprint (~250KB). El proceso llevado a cabo para entrenar el modelo y convertirlo a TensorFlow Lite est\u00e1 descrito en el repositorio de GitHub de TFLM , aunque de momento no nos detendremos en su an\u00e1lisis pormenorizado. El modelo resultante puede descargarse en formato .tflite o en formato C ( person_detect_model_data.cc ) en los enlaces proporcionados.","title":"Dataset y entrenamiento"},{"location":"LSI/Lab2/#codigo","text":"El c\u00f3digo sigue un esquema an\u00e1logo al del ejemplo anterior. Tarea Instanciar el ejemplo person_detection del componente esp-flite-micro para poderlo estudiar. Responder a las siguientes preguntas: \u00bfQu\u00e9 operadores se registran? \u00bfQu\u00e9 tama\u00f1o tiene el modelo? \u00bfC\u00f3mo se ha convertido? Tarea Probar el ejemplo y determinar el tiempo de requerido para cada inferencia. Tarea Modificarlo para crear una sencilla aplicaci\u00f3n que avise cuando detecta una persona y muestre el intervalo de tiempo que ha permanecido en c\u00e1mara.","title":"C\u00f3digo"},{"location":"LSI/Lab2/#esp-who","text":"","title":"ESP-WHO"},{"location":"LSI/Lab2/#que-es_1","text":"ESP-WHO es un framework de c\u00f3digo abierto, dise\u00f1ado por Espressif para la detecci\u00f3n y el reconocimiento facial en dispositivos basados en ESP32 (como ESP32-CAM, ESP-EYE, ESP32-S3-EYE, entre otros). Incluye funciones y ejemplos para tareas como detecci\u00f3n, alineaci\u00f3n y reconocimiento de rostros, facilitando la implementaci\u00f3n de aplicaciones de visi\u00f3n artificial.","title":"\u00bfQu\u00e9 es?"},{"location":"LSI/Lab2/#ejemplos","text":"ESP-WHO proporciona los siguientes ejemplos, todos ellos preparados para poderse emplear en la ESP32-S3-EYE: human_face_detect : detecci\u00f3n de rostro human_face_detect_lvgl : mismo ejemplo pero haciendo uso de la librar\u00eda LVGL human_face_recognition : reconocimiento facial pedestrian_detect : detecci\u00f3n de peatones. pedestrian_detect_lvgl : mismo ejemplo pero haciendo uso de la librar\u00eda LVGL Tarea Estudiar y probar el ejemplo human_face_detect . Evaluar el tiempo de invocaci\u00f3n.","title":"Ejemplos"},{"location":"LSI/Lab2_old/","text":"Laboratorio 2. Entrenamiento e inferencia para clasificaci\u00f3n de im\u00e1genes sobre Google Coral Objetivos Entender, de forma intuitiva, la estructura general de una red neuronal de convoluci\u00f3n (CNN) para clasificaci\u00f3n de im\u00e1genes separando sus capas en dos clases: extracci\u00f3n de caracter\u00edsticas y clasificaci\u00f3n. Entender el proceso y las ventajas de transfer learning para obtener una red adaptada a un conjunto de datos de entrada. Practicar el proceso de transfer learning utilizando TensorFlow. Exportar los modelos entrenados a formato TFLite. Experimentar y evaluar el proceso de cuantizaci\u00f3n sobre un modelo real. Desplegar un modelo preentrenado mediante transfer learning sobre la Raspberry Pi + Edge TPU para una aplicaci\u00f3n concreta. Gran parte del trabajo de este laboratorio se centra en el uso de Google Colab. Deber\u00e1s crear una copia y trabajar en el siguiente cuaderno . Modelos TensorFlow sobre Edge TPU (Google Coral) El dispositivo Google Coral (que equipa un acelerador Edge TPU) es un hardware de prop\u00f3sito espec\u00edfico que puede ejecutar redes neuronales profundas (esto es, con m\u00faltiples capas), y es espec\u00edficamente eficiente ejecutando redes neuronales de convoluci\u00f3n (CNN), donde una o m\u00e1s de sus capas est\u00e1n formadas por operaciones de convoluci\u00f3n sobre im\u00e1genes de entrada. Este tipo de redes combina una serie de capas iniciales de convoluci\u00f3n dedicadas a la extracci\u00f3n de caracter\u00edsticas, y una o m\u00e1s capas finalles fully connected (totalmente conectadas), cuyo cometido es espec\u00edfico del problema que pretenden resolver (por ejemplo, clasificaci\u00f3n de im\u00e1genes). En problemas de aprendizaje supervisado, el proceso de entrenamiento es un procedimiento iterativo (cuyas bases te\u00f3ricas quedan fuera del alcance de esta asignatura), que persigue fijar, en base a observaci\u00f3n de datos de entrada ( datasets ) etiquetados, unos pesos para cada una de las neuronas que componen cada capa (bien sea de convoluci\u00f3n o bien totalmente conectada) que permitan ajustar la salida de la red neuronal, con un determinado grado de error, a la salida esperada. Tomemos una red neuronal sencilla de ejemplo como la que se muestra a continuaci\u00f3n: En primer lugar, observa la estructura general de la red: Los datos (tensor) proporcionados a la capa de entrada tienen un tama\u00f1o fijo, en este caso un \u00fanico canal de dimensiones 28 x 28 p\u00edxeles. El tensor (capa) de salida contiene 10 neuronas, que finalmente, en este caso, clasificar\u00e1n la imagen de entrada como perteneciente a una de 10 clases posibles (una por d\u00edgito). A grandes rasgos, la estructura de la red se divide en dos partes (esta simplificaci\u00f3n nos servir\u00e1 en el resto del laboratorio): Un conjunto de capas de convoluci\u00f3n y otras operaciones, englobadas en lo que llamaremos extractor de caracter\u00edsticas . Un conjunto de capas donde todas las neuronas est\u00e1n conectadas entre s\u00ed, que llamaremos clasificador . Estructura de capas Las capas de convoluci\u00f3n son el principal elemento que permite extraer caracter\u00edsticas de una imagen. En \u00faltima instancia, se basan en la aplicaci\u00f3n de un conjunto de filtros a cada p\u00edxel de la imagen de entrada a la capa correspondiente, cuyos valores son realmente los pesos entrenables de la red neuronal. Las capas de convoluci\u00f3 son configurables (en el momento de dise\u00f1ar la red); algunas de estas caracter\u00edsticas se listan a continuaci\u00f3n. Nota La siguiente explicaci\u00f3n pretende ser intuitiva m\u00e1s que cient\u00edfica, por lo que se emplaza al estudiante a los conocimientos adquiridos en otras asignaturas para una descripci\u00f3n m\u00e1s detallada del funcionamiento de cada uno de los elementos que componen una CNN. Convoluci\u00f3n La aplicaci\u00f3n de un filtro de convoluci\u00f3n toma como entrada una imagen o fragmento de la misma (en nuestro caso, un fragmento de dimensiones 5 x 5 ), y aplica en ella, de forma ordenada, un conjunto de pesos en forma de filtro o kernel . El resultado final de la operaci\u00f3n se llama caracter\u00edstica y comprende, para cada p\u00edxel de la caracter\u00edstica, una suma ponderada a trav\u00e9s del filtro de cada uno de los elementos de la vecindad de la imagen anterior para el p\u00edxel correspondiente: Padding Al aplicar convoluciones, las dimensiones de la caracter\u00edstica de salida no coinciden con las de la entrada, por lo que es posible \"perder\" cierta informaci\u00f3n. Para ello, los bordes de la imagen de entrada suelen rellenarse con un valor (en el ejemplo siguiente, con ceros), mediante la operaci\u00f3n llamada padding : Striding En ocasiones, no es deseable aplicar un filtro de convoluci\u00f3n a todos los p\u00edxeles de entrada. En esos casos, la capa de convoluci\u00f3n puede configurarse para que \"salte\" algunos de los p\u00edxeles (en el ejemplo siguiente, esta separaci\u00f3n o stride es de dos unidades): Pooling La operaci\u00f3n de pooling persigue resumir la informaci\u00f3n en una determinada imagen o caracter\u00edstica, agrupando los valores de la vecindad mediante una operaci\u00f3n de tipo max o avg . Por ejemplo, podemos obtener \u00fanicamente el valor m\u00e1ximo de una vecindad de 2 x 2 p\u00edxeles: Funci\u00f3n de activaci\u00f3n Una funci\u00f3n de activaci\u00f3n es un nodo situado a la salida de una determinada neurona, que permite determinar si dicha neurona se activar\u00e1 o no, por ejemplo: La funci\u00f3n ReLU ( rectified linear unit ) se utiliza t\u00edpicamente en redes neuronales por su car\u00e1cter no lineal: simplemente devuelve 0 si el valor de entrada es negativo, y dicho valor en caso contrario. Capas fully-connected Finalmente, las \u00faltimas capas (de clasificaci\u00f3n) de la anterior red pasan por dos capas cuyas neuronas simplemente realizan una combinaci\u00f3n lineal de sus entradas, ponderadas con unos pesos que tambi\u00e9n se fijar\u00e1n en el proceso de entrenamiento y que, en \u00faltima instancia, determinar\u00e1n la clase a la que pertenece cada est\u00edmulo de entrada tras extraer las correspondientes caracter\u00edsticas. Un ejemplo de las tres \u00faltimas capas fully-connected podr\u00eda ser, por ejemplo: donde en \u00faltima instancia, la capa de salida es un tensor unidimensional de 10 elementos al que est\u00e1n conectadas cada una de las neuronas de la capa anterior (lo mismo ocurre con la pen\u00faltima capa). Flujo de trabajo t\u00edpoco para el desarrollo de un modelo TensorFlow Lite para Edge TPU Como se vio en el anterior laboratorio, TensorFlow Lite es una versi\u00f3n reducida del framework Tensorflow dise\u00f1ada espec\u00edficamente para dispositivos m\u00f3viles y sistemas empotrados. Su objetivo es proporcionar alto rendimiento (b\u00e1sicamente, baja latencia o tiempo de respuesta) en procesos de inferencia o aplicaci\u00f3n de una red neuronal a unos datos de entrada. Los modelos TensorFlow Lite pueden, adem\u00e1s, reducir todav\u00eda m\u00e1s su tama\u00f1o (y por tanto aumentar su eficiencia) a trav\u00e9s de un proceso llamado cuantizaci\u00f3n, que convierte los pesos (y otros par\u00e1metros) del modelo, t\u00edpicamente representados mediante n\u00fameros en punto flotante de 32 bits, en una representaci\u00f3n entera de 8 bits. Aunque en ocasiones este proceso simplemente persigue mayor eficiencia, en el caso del acelerador Edge TPU es obligatorio, ya que \u00e9ste s\u00f3lo soporta modelos Tensorflow Lite cuantizados (y, como veremos, compilados de forma espec\u00edfica para el dispositivo). El proceso de entrenamiento no se realiza directamente con TensorFlow Lite, sino utilizando TensorFlow y a continuaci\u00f3n convirtiendo el modelo entrenado resultante (en formato .pb ) en un modelo TFLite (con extensi\u00f3n .tflite ). El proceso general de transformaci\u00f3n de un modelo TensorFlow en un modelo compatible con el dispositivo Edge TPU se muestra a continuaci\u00f3n: Sin embargo, no es estrictamente necesario seguir de forma completa este flujo de trabajo para obtener un buen modelo compatible con la Edge TPU. Una alternativa reside en aprovechar modelos TensorFlow ya entrenados mediante un proceso de reentrenamiento en base a tus propios datasets de entrada. Transfer learning Como hemos mencionado anteriormente, en lugar de construir un modelo propio y realizar un proceso de entrenamiento del mismo desde cero, es posible reentrenar un modelo ya compatible con el dispositivo Edge TPU, usando una t\u00e9cnica denominada transfer learning (o fine tuning ). Esta t\u00e9cnica permite comenzar con un modelo entrenado para una tarea similar a la que deseamos resolver, ense\u00f1ando de nuevo al modelo a, por ejemplo, clasificar otro tipo de objetos mediante un proceso de entrenamiento utilizando un dataset de menores dimensiones. En este punto, existen dos mecanismos distintos para realizar el reentrenamiento: Reentrenar el modelo completo, ajustando los pesos de toda la red neuronal. Eliminando la(s) capa(s) final(es) de la red, t\u00edpicamente dedicada, por ejemplo, al proceso de clasificaci\u00f3n, y entrenando una nueva capa que reconozca las nuevas clases objetivo. En cualquier caso, si se parte de un modelo compatible con la Edge TPU, cualquiera de las dos estrategias ofrecer\u00e1 buenos resultados (siendo la segunda mucho m\u00e1s eficiente desde el punto de vista del tiempo de entrenamiento). El fabricante proporciona un conjunto de modelos base preentrenados que puedes utilizar para crear modelos personalizados. Requisitos de los modelos Para explotar al m\u00e1ximo las capacidades del Edge TPU, es necesario que el modelo desarrollado cumpla con ciertas caracter\u00edsticas: Los tensores que se utilicen est\u00e1n cuantizados (usando punto fijo de 8 bits: int8 o uint8 ). Las dimensiones de los tensores son constantes (no din\u00e1micas). Los tensores son 1-D, 2-D o 3-D. El modelo s\u00f3lo usa operaciones soportadas por la Edge TPU (v\u00e9ase siguiente secci\u00f3n). Operaciones soportadas Al construir un modelo propio, es necesario tener en mente que s\u00f3lo ciertas operaciones ser\u00e1n soportadas de forma nativa por la Edge TPU. Si el modelo est\u00e1 formado por alguna operaci\u00f3n no compatible, s\u00f3lo se ejecutar\u00e1 en la TPU una porci\u00f3n del mismo (v\u00e9ase secci\u00f3n Compilaci\u00f3n ). La documentaci\u00f3n de Google Coral y de TensorFlow contienen listas detalladas de las operaciones compatibles en ambos casos. Cuantizaci\u00f3n Cuantizar un modelo significa convertir todos los valores que \u00e9ste almacena (por ejemplo, pesos y salidas de funciones de activaci\u00f3n) desde valores en punto flotante de 32 bits a sus representaciones en punto fijo de 8 bits m\u00e1s cercanas. Esto, obviamente, hace que el modelo sea m\u00e1s peque\u00f1o en tama\u00f1o, y m\u00e1s r\u00e1pido en respuesta. Adem\u00e1s, aunque las representaciones en 8 bits son menos precisas, su precisi\u00f3n en el proceso de inferencia no se ve significativamente afectado. Existen dos mecanismos principales para llevar a cabo la cuantizaci\u00f3n: Entrenamiento consciente de la cuantizaci\u00f3n ( Quantization-aware training ). Esta t\u00e9cnica inserta nodos (neuronas) artificiales en la red para simular el efecto de usar valores de 8 bits en el entrenamiento. Por tanto, requiere modificar la red antes de comenzar con el entrenamiento inicial. Normalmente, esto repercute en un modelo con mayor precisi\u00f3n (comparado con la segunda t\u00e9cnica), porque los pesos de 8 bits se aprenden en el propio proceso de entrenamiento. Cuantizaci\u00f3n post-entrenamiento ( Full integer post-training quantization ). No requiere ninguna modificaci\u00f3n en la red, por lo que puede tomar como entrada una red ya entrenada para convertirla en un modelo cuantizado. Sin embargo, el proceso de cuantizaci\u00f3n requiere que se proporcione un conjunto de datos de entrada representativo (formateado de la misma manera que el conjunto de datos original). Este conjunto representativo permite que el proceso de cuantizaci\u00f3n determine el rango din\u00e1mico de las entradas, pesos y activaciones, factor cr\u00edtico a la hora de encontrar una representaci\u00f3n en 8 bits de cada peso y valor de activaci\u00f3n. Compilaci\u00f3n Tras entrenar y convertir el modelo a TFlite (con cuantizaci\u00f3n), el paso final es compilarlo utilizando el compilador de Edge TPU. El proceso de compilaci\u00f3n puede completarse incluso si el modelo del que se parte no es 100% compatible con el dispositivo, pero en este caso, s\u00f3lo una porci\u00f3n del modelo se ejecutar\u00e1 en el Edge TPU. En el primer punto en el que el grafo resultante incluya una operaci\u00f3n no soportada, \u00e9ste se dividir\u00e1 en dos partes: la primera contendr\u00e1 s\u00f3lo las opreraciones soportadas por la Edge TPU, y la segunda, con las operaciones no soportadas, ser\u00e1 ejecutada exclusivamente en la CPU, con la penalizaci\u00f3n de rendimiento que ello conlleva: Tareas a desarrollar Tarea El siguiente cuaderno permite la creaci\u00f3n de un modelo TFlite a partir de un modelo preexistente, usando la t\u00e9cnica de cuantizaci\u00f3n post-entrenamiento. Compl\u00e9talo y obt\u00e9n un modelo TFLite listo para ejecutar en la Edge TPU. A continuaci\u00f3n, util\u00edzalo en los c\u00f3digos que desarrollaste (para clasificaci\u00f3n) en el anterior laboratorio y comprueba su correcto funcionamiento tanto desde el punto de vista del rendimiento comparado con la CPU, como de la precisi\u00f3n observada. Tarea Utilizando la misma filosof\u00eda que la seguida en el anterior cuaderno, se pide desarrollar una aplicaci\u00f3n que realice la clasificaci\u00f3n de im\u00e1genes de entrada en tiempo real, tomadas desde la c\u00e1mara de la Raspberry Pi, utilizando un modelo preentrenado con conjuntos de datos de im\u00e1genes etiquetadas que representen caras portando o no mascarilla . Para resolver el laboratorio, se pide dise\u00f1ar y seguir el flujo completo de trabajo propuesto, bas\u00e1ndose en el mismo modelo base ( Mobilenetv2 ), pero reentren\u00e1ndolo con conjuntos de datos apropiados (puedes buscarlos por internet) y usando la Edge TPU como plataforma aceleradora. Se entregar\u00e1 una memoria del trabajo desarrollado, junto con los c\u00f3digos y modelos obtenidos, as\u00ed como una breve demostraci\u00f3n de funcionamiento de la soluci\u00f3n.","title":"Laboratorio 2. Entrenamiento e inferencia para clasificaci\u00f3n de im\u00e1genes sobre Google Coral"},{"location":"LSI/Lab2_old/#laboratorio-2-entrenamiento-e-inferencia-para-clasificacion-de-imagenes-sobre-google-coral","text":"","title":"Laboratorio 2. Entrenamiento e inferencia para clasificaci\u00f3n de im\u00e1genes sobre Google Coral"},{"location":"LSI/Lab2_old/#objetivos","text":"Entender, de forma intuitiva, la estructura general de una red neuronal de convoluci\u00f3n (CNN) para clasificaci\u00f3n de im\u00e1genes separando sus capas en dos clases: extracci\u00f3n de caracter\u00edsticas y clasificaci\u00f3n. Entender el proceso y las ventajas de transfer learning para obtener una red adaptada a un conjunto de datos de entrada. Practicar el proceso de transfer learning utilizando TensorFlow. Exportar los modelos entrenados a formato TFLite. Experimentar y evaluar el proceso de cuantizaci\u00f3n sobre un modelo real. Desplegar un modelo preentrenado mediante transfer learning sobre la Raspberry Pi + Edge TPU para una aplicaci\u00f3n concreta. Gran parte del trabajo de este laboratorio se centra en el uso de Google Colab. Deber\u00e1s crear una copia y trabajar en el siguiente cuaderno .","title":"Objetivos"},{"location":"LSI/Lab2_old/#modelos-tensorflow-sobre-edge-tpu-google-coral","text":"El dispositivo Google Coral (que equipa un acelerador Edge TPU) es un hardware de prop\u00f3sito espec\u00edfico que puede ejecutar redes neuronales profundas (esto es, con m\u00faltiples capas), y es espec\u00edficamente eficiente ejecutando redes neuronales de convoluci\u00f3n (CNN), donde una o m\u00e1s de sus capas est\u00e1n formadas por operaciones de convoluci\u00f3n sobre im\u00e1genes de entrada. Este tipo de redes combina una serie de capas iniciales de convoluci\u00f3n dedicadas a la extracci\u00f3n de caracter\u00edsticas, y una o m\u00e1s capas finalles fully connected (totalmente conectadas), cuyo cometido es espec\u00edfico del problema que pretenden resolver (por ejemplo, clasificaci\u00f3n de im\u00e1genes). En problemas de aprendizaje supervisado, el proceso de entrenamiento es un procedimiento iterativo (cuyas bases te\u00f3ricas quedan fuera del alcance de esta asignatura), que persigue fijar, en base a observaci\u00f3n de datos de entrada ( datasets ) etiquetados, unos pesos para cada una de las neuronas que componen cada capa (bien sea de convoluci\u00f3n o bien totalmente conectada) que permitan ajustar la salida de la red neuronal, con un determinado grado de error, a la salida esperada. Tomemos una red neuronal sencilla de ejemplo como la que se muestra a continuaci\u00f3n: En primer lugar, observa la estructura general de la red: Los datos (tensor) proporcionados a la capa de entrada tienen un tama\u00f1o fijo, en este caso un \u00fanico canal de dimensiones 28 x 28 p\u00edxeles. El tensor (capa) de salida contiene 10 neuronas, que finalmente, en este caso, clasificar\u00e1n la imagen de entrada como perteneciente a una de 10 clases posibles (una por d\u00edgito). A grandes rasgos, la estructura de la red se divide en dos partes (esta simplificaci\u00f3n nos servir\u00e1 en el resto del laboratorio): Un conjunto de capas de convoluci\u00f3n y otras operaciones, englobadas en lo que llamaremos extractor de caracter\u00edsticas . Un conjunto de capas donde todas las neuronas est\u00e1n conectadas entre s\u00ed, que llamaremos clasificador .","title":"Modelos TensorFlow sobre Edge TPU (Google Coral)"},{"location":"LSI/Lab2_old/#estructura-de-capas","text":"Las capas de convoluci\u00f3n son el principal elemento que permite extraer caracter\u00edsticas de una imagen. En \u00faltima instancia, se basan en la aplicaci\u00f3n de un conjunto de filtros a cada p\u00edxel de la imagen de entrada a la capa correspondiente, cuyos valores son realmente los pesos entrenables de la red neuronal. Las capas de convoluci\u00f3 son configurables (en el momento de dise\u00f1ar la red); algunas de estas caracter\u00edsticas se listan a continuaci\u00f3n. Nota La siguiente explicaci\u00f3n pretende ser intuitiva m\u00e1s que cient\u00edfica, por lo que se emplaza al estudiante a los conocimientos adquiridos en otras asignaturas para una descripci\u00f3n m\u00e1s detallada del funcionamiento de cada uno de los elementos que componen una CNN.","title":"Estructura de capas"},{"location":"LSI/Lab2_old/#convolucion","text":"La aplicaci\u00f3n de un filtro de convoluci\u00f3n toma como entrada una imagen o fragmento de la misma (en nuestro caso, un fragmento de dimensiones 5 x 5 ), y aplica en ella, de forma ordenada, un conjunto de pesos en forma de filtro o kernel . El resultado final de la operaci\u00f3n se llama caracter\u00edstica y comprende, para cada p\u00edxel de la caracter\u00edstica, una suma ponderada a trav\u00e9s del filtro de cada uno de los elementos de la vecindad de la imagen anterior para el p\u00edxel correspondiente:","title":"Convoluci\u00f3n"},{"location":"LSI/Lab2_old/#padding","text":"Al aplicar convoluciones, las dimensiones de la caracter\u00edstica de salida no coinciden con las de la entrada, por lo que es posible \"perder\" cierta informaci\u00f3n. Para ello, los bordes de la imagen de entrada suelen rellenarse con un valor (en el ejemplo siguiente, con ceros), mediante la operaci\u00f3n llamada padding :","title":"Padding"},{"location":"LSI/Lab2_old/#striding","text":"En ocasiones, no es deseable aplicar un filtro de convoluci\u00f3n a todos los p\u00edxeles de entrada. En esos casos, la capa de convoluci\u00f3n puede configurarse para que \"salte\" algunos de los p\u00edxeles (en el ejemplo siguiente, esta separaci\u00f3n o stride es de dos unidades):","title":"Striding"},{"location":"LSI/Lab2_old/#pooling","text":"La operaci\u00f3n de pooling persigue resumir la informaci\u00f3n en una determinada imagen o caracter\u00edstica, agrupando los valores de la vecindad mediante una operaci\u00f3n de tipo max o avg . Por ejemplo, podemos obtener \u00fanicamente el valor m\u00e1ximo de una vecindad de 2 x 2 p\u00edxeles:","title":"Pooling"},{"location":"LSI/Lab2_old/#funcion-de-activacion","text":"Una funci\u00f3n de activaci\u00f3n es un nodo situado a la salida de una determinada neurona, que permite determinar si dicha neurona se activar\u00e1 o no, por ejemplo: La funci\u00f3n ReLU ( rectified linear unit ) se utiliza t\u00edpicamente en redes neuronales por su car\u00e1cter no lineal: simplemente devuelve 0 si el valor de entrada es negativo, y dicho valor en caso contrario.","title":"Funci\u00f3n de activaci\u00f3n"},{"location":"LSI/Lab2_old/#capas-fully-connected","text":"Finalmente, las \u00faltimas capas (de clasificaci\u00f3n) de la anterior red pasan por dos capas cuyas neuronas simplemente realizan una combinaci\u00f3n lineal de sus entradas, ponderadas con unos pesos que tambi\u00e9n se fijar\u00e1n en el proceso de entrenamiento y que, en \u00faltima instancia, determinar\u00e1n la clase a la que pertenece cada est\u00edmulo de entrada tras extraer las correspondientes caracter\u00edsticas. Un ejemplo de las tres \u00faltimas capas fully-connected podr\u00eda ser, por ejemplo: donde en \u00faltima instancia, la capa de salida es un tensor unidimensional de 10 elementos al que est\u00e1n conectadas cada una de las neuronas de la capa anterior (lo mismo ocurre con la pen\u00faltima capa).","title":"Capas fully-connected"},{"location":"LSI/Lab2_old/#flujo-de-trabajo-tipoco-para-el-desarrollo-de-un-modelo-tensorflow-lite-para-edge-tpu","text":"Como se vio en el anterior laboratorio, TensorFlow Lite es una versi\u00f3n reducida del framework Tensorflow dise\u00f1ada espec\u00edficamente para dispositivos m\u00f3viles y sistemas empotrados. Su objetivo es proporcionar alto rendimiento (b\u00e1sicamente, baja latencia o tiempo de respuesta) en procesos de inferencia o aplicaci\u00f3n de una red neuronal a unos datos de entrada. Los modelos TensorFlow Lite pueden, adem\u00e1s, reducir todav\u00eda m\u00e1s su tama\u00f1o (y por tanto aumentar su eficiencia) a trav\u00e9s de un proceso llamado cuantizaci\u00f3n, que convierte los pesos (y otros par\u00e1metros) del modelo, t\u00edpicamente representados mediante n\u00fameros en punto flotante de 32 bits, en una representaci\u00f3n entera de 8 bits. Aunque en ocasiones este proceso simplemente persigue mayor eficiencia, en el caso del acelerador Edge TPU es obligatorio, ya que \u00e9ste s\u00f3lo soporta modelos Tensorflow Lite cuantizados (y, como veremos, compilados de forma espec\u00edfica para el dispositivo). El proceso de entrenamiento no se realiza directamente con TensorFlow Lite, sino utilizando TensorFlow y a continuaci\u00f3n convirtiendo el modelo entrenado resultante (en formato .pb ) en un modelo TFLite (con extensi\u00f3n .tflite ). El proceso general de transformaci\u00f3n de un modelo TensorFlow en un modelo compatible con el dispositivo Edge TPU se muestra a continuaci\u00f3n: Sin embargo, no es estrictamente necesario seguir de forma completa este flujo de trabajo para obtener un buen modelo compatible con la Edge TPU. Una alternativa reside en aprovechar modelos TensorFlow ya entrenados mediante un proceso de reentrenamiento en base a tus propios datasets de entrada.","title":"Flujo de trabajo t\u00edpoco para el desarrollo de un modelo TensorFlow Lite para Edge TPU"},{"location":"LSI/Lab2_old/#transfer-learning","text":"Como hemos mencionado anteriormente, en lugar de construir un modelo propio y realizar un proceso de entrenamiento del mismo desde cero, es posible reentrenar un modelo ya compatible con el dispositivo Edge TPU, usando una t\u00e9cnica denominada transfer learning (o fine tuning ). Esta t\u00e9cnica permite comenzar con un modelo entrenado para una tarea similar a la que deseamos resolver, ense\u00f1ando de nuevo al modelo a, por ejemplo, clasificar otro tipo de objetos mediante un proceso de entrenamiento utilizando un dataset de menores dimensiones. En este punto, existen dos mecanismos distintos para realizar el reentrenamiento: Reentrenar el modelo completo, ajustando los pesos de toda la red neuronal. Eliminando la(s) capa(s) final(es) de la red, t\u00edpicamente dedicada, por ejemplo, al proceso de clasificaci\u00f3n, y entrenando una nueva capa que reconozca las nuevas clases objetivo. En cualquier caso, si se parte de un modelo compatible con la Edge TPU, cualquiera de las dos estrategias ofrecer\u00e1 buenos resultados (siendo la segunda mucho m\u00e1s eficiente desde el punto de vista del tiempo de entrenamiento). El fabricante proporciona un conjunto de modelos base preentrenados que puedes utilizar para crear modelos personalizados.","title":"Transfer learning"},{"location":"LSI/Lab2_old/#requisitos-de-los-modelos","text":"Para explotar al m\u00e1ximo las capacidades del Edge TPU, es necesario que el modelo desarrollado cumpla con ciertas caracter\u00edsticas: Los tensores que se utilicen est\u00e1n cuantizados (usando punto fijo de 8 bits: int8 o uint8 ). Las dimensiones de los tensores son constantes (no din\u00e1micas). Los tensores son 1-D, 2-D o 3-D. El modelo s\u00f3lo usa operaciones soportadas por la Edge TPU (v\u00e9ase siguiente secci\u00f3n).","title":"Requisitos de los modelos"},{"location":"LSI/Lab2_old/#operaciones-soportadas","text":"Al construir un modelo propio, es necesario tener en mente que s\u00f3lo ciertas operaciones ser\u00e1n soportadas de forma nativa por la Edge TPU. Si el modelo est\u00e1 formado por alguna operaci\u00f3n no compatible, s\u00f3lo se ejecutar\u00e1 en la TPU una porci\u00f3n del mismo (v\u00e9ase secci\u00f3n Compilaci\u00f3n ). La documentaci\u00f3n de Google Coral y de TensorFlow contienen listas detalladas de las operaciones compatibles en ambos casos.","title":"Operaciones soportadas"},{"location":"LSI/Lab2_old/#cuantizacion","text":"Cuantizar un modelo significa convertir todos los valores que \u00e9ste almacena (por ejemplo, pesos y salidas de funciones de activaci\u00f3n) desde valores en punto flotante de 32 bits a sus representaciones en punto fijo de 8 bits m\u00e1s cercanas. Esto, obviamente, hace que el modelo sea m\u00e1s peque\u00f1o en tama\u00f1o, y m\u00e1s r\u00e1pido en respuesta. Adem\u00e1s, aunque las representaciones en 8 bits son menos precisas, su precisi\u00f3n en el proceso de inferencia no se ve significativamente afectado. Existen dos mecanismos principales para llevar a cabo la cuantizaci\u00f3n: Entrenamiento consciente de la cuantizaci\u00f3n ( Quantization-aware training ). Esta t\u00e9cnica inserta nodos (neuronas) artificiales en la red para simular el efecto de usar valores de 8 bits en el entrenamiento. Por tanto, requiere modificar la red antes de comenzar con el entrenamiento inicial. Normalmente, esto repercute en un modelo con mayor precisi\u00f3n (comparado con la segunda t\u00e9cnica), porque los pesos de 8 bits se aprenden en el propio proceso de entrenamiento. Cuantizaci\u00f3n post-entrenamiento ( Full integer post-training quantization ). No requiere ninguna modificaci\u00f3n en la red, por lo que puede tomar como entrada una red ya entrenada para convertirla en un modelo cuantizado. Sin embargo, el proceso de cuantizaci\u00f3n requiere que se proporcione un conjunto de datos de entrada representativo (formateado de la misma manera que el conjunto de datos original). Este conjunto representativo permite que el proceso de cuantizaci\u00f3n determine el rango din\u00e1mico de las entradas, pesos y activaciones, factor cr\u00edtico a la hora de encontrar una representaci\u00f3n en 8 bits de cada peso y valor de activaci\u00f3n.","title":"Cuantizaci\u00f3n"},{"location":"LSI/Lab2_old/#compilacion","text":"Tras entrenar y convertir el modelo a TFlite (con cuantizaci\u00f3n), el paso final es compilarlo utilizando el compilador de Edge TPU. El proceso de compilaci\u00f3n puede completarse incluso si el modelo del que se parte no es 100% compatible con el dispositivo, pero en este caso, s\u00f3lo una porci\u00f3n del modelo se ejecutar\u00e1 en el Edge TPU. En el primer punto en el que el grafo resultante incluya una operaci\u00f3n no soportada, \u00e9ste se dividir\u00e1 en dos partes: la primera contendr\u00e1 s\u00f3lo las opreraciones soportadas por la Edge TPU, y la segunda, con las operaciones no soportadas, ser\u00e1 ejecutada exclusivamente en la CPU, con la penalizaci\u00f3n de rendimiento que ello conlleva:","title":"Compilaci\u00f3n"},{"location":"LSI/Lab2_old/#tareas-a-desarrollar","text":"Tarea El siguiente cuaderno permite la creaci\u00f3n de un modelo TFlite a partir de un modelo preexistente, usando la t\u00e9cnica de cuantizaci\u00f3n post-entrenamiento. Compl\u00e9talo y obt\u00e9n un modelo TFLite listo para ejecutar en la Edge TPU. A continuaci\u00f3n, util\u00edzalo en los c\u00f3digos que desarrollaste (para clasificaci\u00f3n) en el anterior laboratorio y comprueba su correcto funcionamiento tanto desde el punto de vista del rendimiento comparado con la CPU, como de la precisi\u00f3n observada. Tarea Utilizando la misma filosof\u00eda que la seguida en el anterior cuaderno, se pide desarrollar una aplicaci\u00f3n que realice la clasificaci\u00f3n de im\u00e1genes de entrada en tiempo real, tomadas desde la c\u00e1mara de la Raspberry Pi, utilizando un modelo preentrenado con conjuntos de datos de im\u00e1genes etiquetadas que representen caras portando o no mascarilla . Para resolver el laboratorio, se pide dise\u00f1ar y seguir el flujo completo de trabajo propuesto, bas\u00e1ndose en el mismo modelo base ( Mobilenetv2 ), pero reentren\u00e1ndolo con conjuntos de datos apropiados (puedes buscarlos por internet) y usando la Edge TPU como plataforma aceleradora. Se entregar\u00e1 una memoria del trabajo desarrollado, junto con los c\u00f3digos y modelos obtenidos, as\u00ed como una breve demostraci\u00f3n de funcionamiento de la soluci\u00f3n.","title":"Tareas a desarrollar"},{"location":"LSI/Lab3/","text":"Detecci\u00f3n de objetos Objetivos Entender el funcionamiento b\u00e1sico de los extractores de caracter\u00edsticas MobileNet y de los detectores de objetos SSD. Integrar un detector de objetos con funcionalidades de tracking en un entorno de monitorizaci\u00f3n IoT. C\u00f3digo necesario El c\u00f3digo necesario para el desarrollo de la pr\u00e1ctica puede obtenerse descargando el c\u00f3digo de la URL . Detecci\u00f3n b\u00e1sica de objetos. Mobilenets y SSD La detecci\u00f3n de objetos es a d\u00eda de hoy uno de los campos m\u00e1s importantes dentro de la visi\u00f3n por computador. Se trata de una extensi\u00f3n de la clasificaci\u00f3n de im\u00e1genes, donde el objetivo es identificar una o m\u00e1s clases de objetos en una imagen y localizar su presencia mediante cajas (en adelante, bounding boxes ) que la delimitan. La detecci\u00f3n de objetos juega un papel fundamental en campos como la videovigilancia, por ejemplo. Al igual que en los problemas de clasificaci\u00f3n de objetos, algunas de las soluciones m\u00e1s eficientes para la detecci\u00f3n de objetos se basan en dos fases: Fase de extracci\u00f3n de caracter\u00edsticas, en base a una red neuronal gen\u00e9rica (por ejemplo, MobileNet). Fase de detecci\u00f3n de objetos, en base a una segunda red neuronal espec\u00edfica (por ejemplo, SSD). Extracci\u00f3n de caracter\u00edsticas. Mobilenet v1 La idea principal tras MobileNet se basa en el uso intensivo de las llamadas depthwise separable convolutions , o DWCs, para construir redes neuronales profundas muy ligeras desde el punto de vista computacional. Una capa de convoluci\u00f3n convencional t\u00edpica aplica un kernel de convoluci\u00f3n (o \"filtro\") a cada uno de los canales de la imagen de entrada. Este kernel se desplaza a trav\u00e9s de la imagen y en cada paso lleva a cabo una suma ponderada de los p\u00edxeles de entrada \"cubiertos\" por el kernel, para todos los canales de dicha imagen de entrada. La idea a destacar aqu\u00ed es que esta operaci\u00f3n de convoluci\u00f3n combina los valores de todos los canales de entrada. Si la imagen tiene 3 canales, la aplicaci\u00f3n de un \u00fanico kernel de convoluci\u00f3n sobre la imagen resulta en una imagen de salida de un \u00fanico canal: En MobileNet v1 tambi\u00e9n se usa, aunque muy puntualmente, este tipo de convoluci\u00f3n: \u00fanicamente en su primera capa. El resto de capas usan la llamada convoluci\u00f3n depthwise separable (DWC). Realmente, esta es una combinaci\u00f3n de dos operacioens de convoluci\u00f3n: una depthwise y otra pointwise . Una convoluci\u00f3n depthwise opera de la siguiente manera: Como puedes ver, no combina los canales de entrada, sino que realiza una convoluci\u00f3n para cada canal de forma separada. As\u00ed, para una imagen de tres canales, crea una imagen de salida de 3 canales. El objetivo de este tipo de convoluci\u00f3n es filtrar los canales de entrada. En MobileNet v1, la convoluci\u00f3n depthwise siempre va seguida de una convoluci\u00f3n pointwise . Una convoluci\u00f3n pointwise es realmente una convoluci\u00f3n \"tradicional\", pero con un kernel 1x1: Como puedes observar, simplemente combina los canales de salida de una convoluci\u00f3n depthwise para crear nuevas caracter\u00edsticas. Poniendo ambas cosas juntas ( depthwise + pointwise ), se consigue el mismo efecto que con una convoluci\u00f3n tradicional, que realiza ambas operaciones en una sola pasada. \u00bfPor qu\u00e9 realizar esta separaci\u00f3n? Desde el punto de vista computacional, una convoluci\u00f3n tradicional realiza m\u00e1s operaciones aritm\u00e9ticas y necesita entrenar mayor cantidad de pesos (el art\u00edculo original de presentaci\u00f3n de Mobilenet v1 cifra esta mejora en 9x para convoluciones 3x3). As\u00ed, el bloque b\u00e1sico de MobileNet v1 ser\u00eda: Existen en total 13 de estos bloques, precedidos por una primera capa de convoluci\u00f3n tradicional 3x3. No existen capas de pooling , pero algunas de las capas depthwise presentan un stride 2 para reducir la dimensionalidad; en estos casos, la correspondiente capa pointwise dobla el n\u00famero de canales: si la imagen de entrada es 224x224x3, la salida de la red es 7x7x1024. Mobilenet v1 usa una funci\u00f3n de activaci\u00f3n ReLU6 a la salida de cada bloque, que previene activaciones demasiado grandes: y = min(max(0, x), 6) Si trabajamos con un clasificador basado en MobileNet, todas estas capas desembocan en una capa de pooling average , seguida de una capa totalmente conectada ( fully connected ), y una capa final de clasificaci\u00f3n softmax obteniendo un valor de probabilidad por clase. Capas totalmente conectadas A modo de recordatorio, recuerda que una capa totalmente conectada (FC, de fully connected ) tomar\u00eda la siguiente forma: La entrada a esta capa es un vector de n\u00fameros. Cada entrada est\u00e1 conectada a cada una de las salidas (de ah\u00ed su nombre). Estas conexiones poseen pesos asociados que determinan cuan importantes son. La salida es tambi\u00e9n un vector de n\u00fameros. Cada capa transorma los datos. En el caso de FC, para cada elemento de salida, tomamos una suma ponderada de todos los elementos de entrada, a\u00f1adiendo una desviaci\u00f3n o bias : in1*w1 + in2*w2 + in3*w3 + ... + in7*w7 + b1 En otras palabras, lo que calculamos es una funci\u00f3n lineal sobre las entradas, en m\u00faltiples dimensiones. Adem\u00e1s, aplicamos una funci\u00f3n de activaci\u00f3n a la suma ponderada: out1 = f(in1*w1 + in2*w2 + in3*w3 + ... + in7*w7 + b1) Representando los pesos en forma de matriz, y las entradas y desviaciones como vectores, podemos computar la salida de una capa FC como: Observa que esto es en realidad un producto matriz-vector. Si el n\u00famero de entradas crece por encima de 1 (es decir, tenemos un grupo o batch de entradas), esta operaci\u00f3n se convierte en un producto de matrices, para la cual muchas arquitecturas, incluyendo nuestra Google Coral, est\u00e1n ampliamente optimizadas. Observa tambi\u00e9n que la matriz de pesos es un producto del proceso de aprendizaje o entrenamiento, y que esta matriz puede contener miles (o millones) de elementos a entrenar en redes t\u00edpicas. Hiperpar\u00e1metros MobileNet fue dise\u00f1ada no para ser una red neuronal concreta, sino una familia de redes neuronales, simplemente variando un conjunto de par\u00e1metros (llamados hiperpar\u00e1metros). El m\u00e1s importante de estos hiperpar\u00e1metros es el llamado depth multiplier ; este hiperpar\u00e1metro modifica la cantidad de canales por capa. As\u00ed, un valor de 0.5 reducir\u00e1 a la mitad el n\u00famero de canales usados en cada capa, reduciendo el n\u00famero de operacioens en un factor 4 y el n\u00famero de par\u00e1metros entrenables en un factor 3. As\u00ed, el modelo es m\u00e1s liviano, pero menos predciso. Mobilenet v2 MobileNet v2 , al igual que su versi\u00f3n anterior, utiliza DWCs, pero su bloque de trabajo principal se ha visto modificado: En este caso, por cada bloque existen tres capas convolucionales. Las dos \u00faltimas son las ya conocidas: DWCs que filtran las entradas, seguidas por una capa pointwise 1x1. En este caso, sin embargo, esta \u00faltima capa tiene otro cometido. En la versi\u00f3n 1 del modelo, la capa pointwise manten\u00eda el n\u00famero de canales o lo doblaba. En la versi\u00f3n 2, en cambio, su cometido es exclusivamente reducir el n\u00famero de canales. Es por esto que, normalmente, a esta capa se le conoce como projection layer o capa de proyecci\u00f3n: proyecta datos con un n\u00famero elevado de dimensiones (canales) en un tensor con mucho menor n\u00famero de dimensiones. Por ejemplo, esta capa podr\u00eda trabajar con un tensor con 144 canales, reduci\u00e9ndolo a s\u00f3lo 24 canales. En ocasiones, a este tipo de capa se le conoce como \"cuello de botella\" ( bottleneck \"), ya que reduce la cantidad de datos que \"fluyen\" por la red. En cuanto a la primera capa, tambi\u00e9n es una convoluci\u00f3n 1x1. Su objetivo es expandir el n\u00famero de canales antes de la DWC. As\u00ed, esta capa de expansi\u00f3n siempre presenta m\u00e1s canales de salida que de entrada, al contrario que en la capa de proyecci\u00f3n. La cantidad exacta de expansi\u00f3n viene dada por el llamado factor de expansi\u00f3n , uno de los hiperpar\u00e1metros (par\u00e1metros personalizables de la red) t\u00edpicos en Mobilenet v2 (por defecto, el valor de este factor es 6): Por ejemplo, si se proporciona un tensor de 24 canales a un bloque, la primera capa lo convierte a un nuevo tensor de 144 canales (por defecto), sobre el que se aplica la capa DWC. Finalmente, la capa de proyecci\u00f3n proyecta estos canales a un n\u00famero menor, v\u00e9ase 24 (por ejemplo). El resultado es que la entrada y salida a un bloque son tensores de dimensi\u00f3n reducida, mientras que el filtrado intermedio ocurre sobre un tensor de dimensionalidad alta. Como puedes observar en la anterior imagen, otra novedad en Mobilenet v2 es la denominada residual connection , que conecta la entrada y la salida de un bloque (siempre que estos mantengan su dimensionalidad). La arquitectura Mobilenet v2 consta de 17 de estos bloques conectados uno tras otro, seguidos de una \u00fanica convoluci\u00f3n est\u00e1ndar 1x1, y una capa de clasificaci\u00f3n (si lo que se desea es utilizarla para tareas de clasificaci\u00f3n). Si observamos los datos que fluyen por la red, veremos como el n\u00famero de canales se mantiene relativamente reducido: Como es normal en este tipo de modelos, el n\u00famero de canaes se incrementa a medida que avanzamos en la red (mientras la dimensi\u00f3n espacial disminuye). Sin embargo, en general, los tensores se mantienen relativamente peque\u00f1os, gracias a las capas bottleneck entre bloques (en la v1, los tensores llegan a ser hasta 7x7x1024, por ejemplo). El uso de tensores de baja dimensionalidad es clave para reducir el n\u00famero de operaciones aritm\u00e9ticas, y por tanto aumenta la adecuaci\u00f3n de este tipo de modelos para trabajar sobre dispositivos m\u00f3viles. Sin embargo, trabajar s\u00f3lo con tensores de baja dimensionalidad no permite, tras aplicar una capa de convoluci\u00f3n sobre ellos, extraer demasiada informaci\u00f3n. As\u00ed, el filtrado deber\u00eda trabajar sobre datos de alta dimensionalidad. Mobilenet v2, por tanto, une lo mejor de ambos mundos: Detecci\u00f3n de objetos. SSD ( Single Shot Multi-Box Detector ) El framework SSD ( Single Shot MultiBox Detector ) es uno de los principales mecanismos para llevar a cabo tareas de detecci\u00f3n de objetos. Tradicionalmente, estas tareas se realizaban con costosos m\u00e9todos de ventana deslizante (detectando potenciales im\u00e1genes en m\u00faltiples ventanas de tama\u00f1os variables que se desplazaban por la imagen). Este enfoque de fuerza bruta fue mejorado por las llamadas R-CNN ( Region-CNN ), que se basaban en la extracci\u00f3n previa de Region Proposal (propuestas de regiones de la imagen en las que potencialmente pod\u00edan existir objetos), para despu\u00e9s extraer caracter\u00edsticas de cada una de ellas a trav\u00e9s de redes de convoluci\u00f3n y realizar una tarea de clasificaci\u00f3n de dichas caracter\u00edsticas y extracci\u00f3n de las bounding boxes correspondientes. Las R-CNN adolecen de ciertos defectos que las hacen ineficientes (a d\u00eda de hoy) en la vida real, v\u00e9ase: El proceso de entrenamiento de las redes es largo. El proceso de entrenamiento se desarrolla en m\u00faltiples etapas (por ejemplo, para proponer regiones o para clasificar). La red es lenta en la fase de inferencia. En respuesta a esta ineficiencia, se han propuesto m\u00faltiples soluciones en los \u00faltimos a\u00f1os; las m\u00e1s populares son YOLO ( You Only Look Once ) y SSD MultiBox ( Single Shot Detector ). SSD rebaja el coste computacional de las R-CNN sin necesidad de propuestas de regiones, operando en dos grandes fases: Extracci\u00f3n de mapas de caracter\u00edsticas. Aplicaci\u00f3n de filtros de convoluci\u00f3n para detectar objetos. La primera fase (extracci\u00f3n de caracter\u00edsticas), se lleva a cabo mediante una red neuronal espec\u00edfica, llamada gen\u00e9ricamente backbone network . En el dise\u00f1o inicial de SSD, esta red fue la red VGG16, aunque en esta pr\u00e1ctica trabajar\u00e1s con una implementaci\u00f3n en la que se usa Mobilenet v1 y v2 (anteriormente descritas) para mejorar la eficiencia del proceso de detecci\u00f3n. El an\u00e1lisis del propio nombre proporciona informaci\u00f3n sobre las ventajas y modo de operaci\u00f3n de SSD MultiBox: Single Shot : Las tareas de localizaci\u00f3n de objetos y clasificaci\u00f3n se realizan en una \u00fanica pasada (ejecuci\u00f3n) de la red. MultiBox : T\u00e9cnica de regresi\u00f3n para bounding boxes desarrollada por los autores. Detector : La red es un detector de objetos que adem\u00e1s los clasifica. Extracci\u00f3n de caracter\u00edsticas Por defecto, SSD utiliza la red neuronal de convoluci\u00f3n VGG16 para extraer mapas de caracter\u00edsticas. A continuaci\u00f3n, detecta objetos utilizando una de sus capas de convoluci\u00f3n (concretamente, la capa Conv4_3 ). Suponiendo que esta capa es de dimension espacial 8x8 (realmente, es 38x38 ), para cada celda, se realizan 4 predicciones de objeto: Cada predicci\u00f3n est\u00e1 compuesta por una boundary box y una puntuaci\u00f3n o score para cada clase disponible (m\u00e1s una clase extra si no se detecta objeto); para cada objeto detectado, se escoge la clase con mayor puntuaci\u00f3n. As\u00ed, la capa de convoluci\u00f3n Conv4_3 realiza realmente 38x38x4 predicciones: Predictores convolucionales SSD utiliza peque\u00f1os filtros de convoluci\u00f3n de dimensi\u00f3n 3x3 para predecir la localizaci\u00f3n y puntuaci\u00f3n asociada a cada objeto a detectar. As\u00ed por ejemplo, en un escenario con 20 clases, cada filtro de convoluci\u00f3n devolver\u00e1 25 canales: 21 para cada clase m\u00e1s la informaci\u00f3n asociada a una bounding box : Mapas de caracter\u00edsticas multi-escala Aunque se ha descrito el trabajo de SSD con una \u00fanica capa de la red neuronal de extracci\u00f3n de caracter\u00edsticas, realmente SSD utiliza m\u00faltiples capas para detectar objetos de forma independiente. SSD usa las capas de menor resoluci\u00f3n para detectar objetos de mayor tama\u00f1o, y las capas de mayor resoluci\u00f3n para detectar objetos de menor tama\u00f1o. Por ejemplo, los mapas de caracter\u00edsticas de dimensi\u00f3n 4x4 se usar\u00edan para detectar objetos mayores que aquellos de dimensi\u00f3n 8x8: Predicci\u00f3n de bounding boxes Como en cualquier otra red neuronal de convoluci\u00f3n, la predicci\u00f3n de bounding boxes comienza con predicciones aleatorias que se refinan durante la fase de entrenamiento v\u00eda descenso de gradiente. Sin embargo, estos valores iniciales pueden ser conflictivos si no son suficientemente diversos desde el comienzo, principalmente en im\u00e1genes con distintos tipos de objetos: Si las predicciones iniciales cubren m\u00e1s variedad de formas, el modelo podr\u00e1 detectar m\u00e1s objetos: En la vida real, las boundary boxes no presentan formas y tama\u00f1os arbitrarios, sino que, por ejemplo, presentan dimensiones o proporciones similares que pueden ser tomadas como base para el entrenamiento del modelo SSD. Normalmente, para un determinado objeto y conjunto de entrenamiento, se consideran todas las bounding boxes en el conjunto, y se toma como representativa el centroide del cluster que representar\u00eda a todas ellas. As\u00ed, para cada mapa de caracter\u00edsticas extra\u00eddas por la red backbone , se utiliza un conjunto \u00fanico de bounding boxes por defecto centradas en la celda correspondiente, por ejemplo: Estimaci\u00f3n de similitud Las predicciones de SSD se clasifican como positivas o negativas. Esta evaluaci\u00f3n se basa en la m\u00e9trica IoU ( Intersection over Union ): Realmente, las estimaciones iniciales de bounding boxes se escogen para que presenten un valor de IoU mayor a 0.5. Esta es una mala predicci\u00f3n todav\u00eda, pero una buena base para comenzar con el proceso de regresi\u00f3n (refinamiento) hacia las bounding boxes definitivas. Data augmentation Para mejorar la precisi\u00f3n del modelo, se utiliza la t\u00e9cnica de aumento de datos o data augmentation . El objetivo de esta t\u00e9cnica es exponer nuevas \"variantes\" de la imagen original para enriquecer la informaci\u00f3n almacenada. Estas transformaciones incluyen recortes ( cropping ), modificaci\u00f3n de orientaci\u00f3n ( flipping ) y distorsiones de color. Por ejemplo: Conjuntos de entrenamiento Es necesario un conjuno de entrenamiento y test etiquetado y con bounding boxes reales (en el art\u00edculo descriptivo de SSD, se les conoce como ground truth ), con una etiqueta por bounding box . Por ejemplo: Detecci\u00f3n de objetos en TFLite En este laboratorio, utilizaremos el c\u00f3digo proporcionado como base para desarrollar una aplicaci\u00f3n de monitorizaci\u00f3n de aforo en un recinto (por ejemplo, en un aula). En primer lugar, desempaqueta el fichero proporcionado e instala los requisitos necesarios. En primer lugar, descarga los modelos que utilizar\u00e1s para realizar la inferencia, ejecutando el script download_models.sh . Adem\u00e1s, descarga tambi\u00e9n los modelos para Mobilenet SSD disponibles en la web de Google Coral (concretamente, los modelos MobileNet SSD v1 y v2 (COCO) ). A continuaci\u00f3n, en el directorio gstreamer , ejecuta el script install_requirements.sh para instalar los requisitos necesarios para el desarrollo del laboratorio. Si todo ha ido bien, podr\u00e1s ejecutar el c\u00f3digo, que es totalmente funcional, mediante la orden: python3 tracking.py Observa que la salida, en forma de ventana de v\u00eddeo, mostrar\u00e1 una bounding box y clase asociada para cada objeto detectado en la escena. Por defecto, el modelo que se toma es Mobilenet v2 SSD . Desde el punto de vista del c\u00f3digo, la estructura es muy similar a la vista para la clasificaci\u00f3n de objetos. Observa que, se realiza la inferencia mediante la invocaci\u00f3n a detect_objects y se analizan los resultados obtenidos (objetos detectados) en tracker_annotate dibujando las cajas en draw_objects_tracked . Tarea Temporiza el tiempo de respuesta (inferencia) para la red por defecto y para cada una de las dos redes descargadas desde la p\u00e1gina de modelos de Google Coral . Tarea Modifica el c\u00f3digo para mostrar por pantalla (por la terminal) el n\u00famero de objetos detectado en cada frame en la variable tracks , as\u00ed como la posici\u00f3n y clase a la que pertenecen. Intenta determinar qu\u00e9 significa cada uno de los campos asociados a cada box y c\u00f3mo estos valores var\u00edan al mover un objeto por la pantalla, tal y como hace la funci\u00f3n logger.debug(f'trackes: {tracks}')` Tracking de objetos en TFLite El c\u00f3digo proporcionado integra un tracker o seguidor de objetos, que no solo detecta objetos en un fotograma determinado, sino que los identifica y sigue mientras aparezcan en pantalla. Esta implementaci\u00f3n est\u00e1 basada en el motpy ( enlace ). Para instalar el tracker es necesario instalar el paquete motpy : pip3 install motpy Observa que, al ejecutar el script , se asocia no s\u00f3lo un bounding box y clase a cada objeto, sino tambi\u00e9n un identificador que (idealmente), deber\u00eda mantenerse mientras el objeto siga en la imagen. El tracker Sort devuelve, en su funci\u00f3n update , un array Numpy en el que cada fila contiene un bounding box v\u00e1lido, y un identificador de objeto \u00fanico en su \u00faltima columna. Tarea Modifica el c\u00f3digo para que se muestre para cada fotograma los bounding boxes e identificadores \u00fanicos asociados a cada objeto. Tarea entregable (80% de la nota) Se pide modificar el script inicial para que, peri\u00f3dicamente, se realice un conteo del n\u00famero de personas detectadas en una determinada escena. Este valor (n\u00famero de personas) ser\u00e1 exportado a un panel de control (bajo tu elecci\u00f3n) utilizando alg\u00fan protocolo de entre los vistos en la asignatura RPI-II (por ejemplo, MQTT). El protocolo y el panel de control a utilizar queda bajo elecci\u00f3n del alumno/a. Se establecer\u00e1 un umbral de alarma en forma de aforo m\u00e1ximo autorizado, al cual se reaccionar\u00e1 enviando una se\u00f1al de aviso al usuario desde el panel de control. Toda la infraestructura necesaria se puede implementar en la Raspberry Pi o en un servicio externo, pero en cualquier caso, la inferencia se realizar\u00e1 siempre en la Raspberry Pi, y se acelerar\u00e1 mediante el uso del dispositivo Google Coral. Ejemplos relacionados sobre el uso de MQTT para la creaci\u00f3n de un \"publicador\" en python pueden encontrarse en los ejemplos de la implementaci\u00f3n de MQTT Paho Tarea entregable (20% de la nota) Haciendo uso de las capacidades de tracking del script original, se pide dise\u00f1ar e implementar una soluci\u00f3n para monitorizar el paso de personas en sentido entrada y salida en una entrada a un recinto. As\u00ed, se supondr\u00e1 una c\u00e1mara situada de forma perpendicular a la entrada al recinto, de modo que las personas que accedan al mismo ingresar\u00e1n en la escena por uno de los extremos y saldr\u00e1n por el opuesto. Las personas que salgan del recinto discurrir\u00e1n por la imagen en sentido contrario. Se pide que el sistema almacene el n\u00famero de personas que han entrado y salido del recinto, as\u00ed como el momento en el que lo han hecho.","title":"Detecci\u00f3n de objetos"},{"location":"LSI/Lab3/#deteccion-de-objetos","text":"","title":"Detecci\u00f3n de objetos"},{"location":"LSI/Lab3/#objetivos","text":"Entender el funcionamiento b\u00e1sico de los extractores de caracter\u00edsticas MobileNet y de los detectores de objetos SSD. Integrar un detector de objetos con funcionalidades de tracking en un entorno de monitorizaci\u00f3n IoT.","title":"Objetivos"},{"location":"LSI/Lab3/#codigo-necesario","text":"El c\u00f3digo necesario para el desarrollo de la pr\u00e1ctica puede obtenerse descargando el c\u00f3digo de la URL .","title":"C\u00f3digo necesario"},{"location":"LSI/Lab3/#deteccion-basica-de-objetos-mobilenets-y-ssd","text":"La detecci\u00f3n de objetos es a d\u00eda de hoy uno de los campos m\u00e1s importantes dentro de la visi\u00f3n por computador. Se trata de una extensi\u00f3n de la clasificaci\u00f3n de im\u00e1genes, donde el objetivo es identificar una o m\u00e1s clases de objetos en una imagen y localizar su presencia mediante cajas (en adelante, bounding boxes ) que la delimitan. La detecci\u00f3n de objetos juega un papel fundamental en campos como la videovigilancia, por ejemplo. Al igual que en los problemas de clasificaci\u00f3n de objetos, algunas de las soluciones m\u00e1s eficientes para la detecci\u00f3n de objetos se basan en dos fases: Fase de extracci\u00f3n de caracter\u00edsticas, en base a una red neuronal gen\u00e9rica (por ejemplo, MobileNet). Fase de detecci\u00f3n de objetos, en base a una segunda red neuronal espec\u00edfica (por ejemplo, SSD).","title":"Detecci\u00f3n b\u00e1sica de objetos. Mobilenets y SSD"},{"location":"LSI/Lab3/#extraccion-de-caracteristicas-mobilenet-v1","text":"La idea principal tras MobileNet se basa en el uso intensivo de las llamadas depthwise separable convolutions , o DWCs, para construir redes neuronales profundas muy ligeras desde el punto de vista computacional. Una capa de convoluci\u00f3n convencional t\u00edpica aplica un kernel de convoluci\u00f3n (o \"filtro\") a cada uno de los canales de la imagen de entrada. Este kernel se desplaza a trav\u00e9s de la imagen y en cada paso lleva a cabo una suma ponderada de los p\u00edxeles de entrada \"cubiertos\" por el kernel, para todos los canales de dicha imagen de entrada. La idea a destacar aqu\u00ed es que esta operaci\u00f3n de convoluci\u00f3n combina los valores de todos los canales de entrada. Si la imagen tiene 3 canales, la aplicaci\u00f3n de un \u00fanico kernel de convoluci\u00f3n sobre la imagen resulta en una imagen de salida de un \u00fanico canal: En MobileNet v1 tambi\u00e9n se usa, aunque muy puntualmente, este tipo de convoluci\u00f3n: \u00fanicamente en su primera capa. El resto de capas usan la llamada convoluci\u00f3n depthwise separable (DWC). Realmente, esta es una combinaci\u00f3n de dos operacioens de convoluci\u00f3n: una depthwise y otra pointwise . Una convoluci\u00f3n depthwise opera de la siguiente manera: Como puedes ver, no combina los canales de entrada, sino que realiza una convoluci\u00f3n para cada canal de forma separada. As\u00ed, para una imagen de tres canales, crea una imagen de salida de 3 canales. El objetivo de este tipo de convoluci\u00f3n es filtrar los canales de entrada. En MobileNet v1, la convoluci\u00f3n depthwise siempre va seguida de una convoluci\u00f3n pointwise . Una convoluci\u00f3n pointwise es realmente una convoluci\u00f3n \"tradicional\", pero con un kernel 1x1: Como puedes observar, simplemente combina los canales de salida de una convoluci\u00f3n depthwise para crear nuevas caracter\u00edsticas. Poniendo ambas cosas juntas ( depthwise + pointwise ), se consigue el mismo efecto que con una convoluci\u00f3n tradicional, que realiza ambas operaciones en una sola pasada. \u00bfPor qu\u00e9 realizar esta separaci\u00f3n? Desde el punto de vista computacional, una convoluci\u00f3n tradicional realiza m\u00e1s operaciones aritm\u00e9ticas y necesita entrenar mayor cantidad de pesos (el art\u00edculo original de presentaci\u00f3n de Mobilenet v1 cifra esta mejora en 9x para convoluciones 3x3). As\u00ed, el bloque b\u00e1sico de MobileNet v1 ser\u00eda: Existen en total 13 de estos bloques, precedidos por una primera capa de convoluci\u00f3n tradicional 3x3. No existen capas de pooling , pero algunas de las capas depthwise presentan un stride 2 para reducir la dimensionalidad; en estos casos, la correspondiente capa pointwise dobla el n\u00famero de canales: si la imagen de entrada es 224x224x3, la salida de la red es 7x7x1024. Mobilenet v1 usa una funci\u00f3n de activaci\u00f3n ReLU6 a la salida de cada bloque, que previene activaciones demasiado grandes: y = min(max(0, x), 6) Si trabajamos con un clasificador basado en MobileNet, todas estas capas desembocan en una capa de pooling average , seguida de una capa totalmente conectada ( fully connected ), y una capa final de clasificaci\u00f3n softmax obteniendo un valor de probabilidad por clase.","title":"Extracci\u00f3n de caracter\u00edsticas. Mobilenet v1"},{"location":"LSI/Lab3/#capas-totalmente-conectadas","text":"A modo de recordatorio, recuerda que una capa totalmente conectada (FC, de fully connected ) tomar\u00eda la siguiente forma: La entrada a esta capa es un vector de n\u00fameros. Cada entrada est\u00e1 conectada a cada una de las salidas (de ah\u00ed su nombre). Estas conexiones poseen pesos asociados que determinan cuan importantes son. La salida es tambi\u00e9n un vector de n\u00fameros. Cada capa transorma los datos. En el caso de FC, para cada elemento de salida, tomamos una suma ponderada de todos los elementos de entrada, a\u00f1adiendo una desviaci\u00f3n o bias : in1*w1 + in2*w2 + in3*w3 + ... + in7*w7 + b1 En otras palabras, lo que calculamos es una funci\u00f3n lineal sobre las entradas, en m\u00faltiples dimensiones. Adem\u00e1s, aplicamos una funci\u00f3n de activaci\u00f3n a la suma ponderada: out1 = f(in1*w1 + in2*w2 + in3*w3 + ... + in7*w7 + b1) Representando los pesos en forma de matriz, y las entradas y desviaciones como vectores, podemos computar la salida de una capa FC como: Observa que esto es en realidad un producto matriz-vector. Si el n\u00famero de entradas crece por encima de 1 (es decir, tenemos un grupo o batch de entradas), esta operaci\u00f3n se convierte en un producto de matrices, para la cual muchas arquitecturas, incluyendo nuestra Google Coral, est\u00e1n ampliamente optimizadas. Observa tambi\u00e9n que la matriz de pesos es un producto del proceso de aprendizaje o entrenamiento, y que esta matriz puede contener miles (o millones) de elementos a entrenar en redes t\u00edpicas.","title":"Capas totalmente conectadas"},{"location":"LSI/Lab3/#hiperparametros","text":"MobileNet fue dise\u00f1ada no para ser una red neuronal concreta, sino una familia de redes neuronales, simplemente variando un conjunto de par\u00e1metros (llamados hiperpar\u00e1metros). El m\u00e1s importante de estos hiperpar\u00e1metros es el llamado depth multiplier ; este hiperpar\u00e1metro modifica la cantidad de canales por capa. As\u00ed, un valor de 0.5 reducir\u00e1 a la mitad el n\u00famero de canales usados en cada capa, reduciendo el n\u00famero de operacioens en un factor 4 y el n\u00famero de par\u00e1metros entrenables en un factor 3. As\u00ed, el modelo es m\u00e1s liviano, pero menos predciso.","title":"Hiperpar\u00e1metros"},{"location":"LSI/Lab3/#mobilenet-v2","text":"MobileNet v2 , al igual que su versi\u00f3n anterior, utiliza DWCs, pero su bloque de trabajo principal se ha visto modificado: En este caso, por cada bloque existen tres capas convolucionales. Las dos \u00faltimas son las ya conocidas: DWCs que filtran las entradas, seguidas por una capa pointwise 1x1. En este caso, sin embargo, esta \u00faltima capa tiene otro cometido. En la versi\u00f3n 1 del modelo, la capa pointwise manten\u00eda el n\u00famero de canales o lo doblaba. En la versi\u00f3n 2, en cambio, su cometido es exclusivamente reducir el n\u00famero de canales. Es por esto que, normalmente, a esta capa se le conoce como projection layer o capa de proyecci\u00f3n: proyecta datos con un n\u00famero elevado de dimensiones (canales) en un tensor con mucho menor n\u00famero de dimensiones. Por ejemplo, esta capa podr\u00eda trabajar con un tensor con 144 canales, reduci\u00e9ndolo a s\u00f3lo 24 canales. En ocasiones, a este tipo de capa se le conoce como \"cuello de botella\" ( bottleneck \"), ya que reduce la cantidad de datos que \"fluyen\" por la red. En cuanto a la primera capa, tambi\u00e9n es una convoluci\u00f3n 1x1. Su objetivo es expandir el n\u00famero de canales antes de la DWC. As\u00ed, esta capa de expansi\u00f3n siempre presenta m\u00e1s canales de salida que de entrada, al contrario que en la capa de proyecci\u00f3n. La cantidad exacta de expansi\u00f3n viene dada por el llamado factor de expansi\u00f3n , uno de los hiperpar\u00e1metros (par\u00e1metros personalizables de la red) t\u00edpicos en Mobilenet v2 (por defecto, el valor de este factor es 6): Por ejemplo, si se proporciona un tensor de 24 canales a un bloque, la primera capa lo convierte a un nuevo tensor de 144 canales (por defecto), sobre el que se aplica la capa DWC. Finalmente, la capa de proyecci\u00f3n proyecta estos canales a un n\u00famero menor, v\u00e9ase 24 (por ejemplo). El resultado es que la entrada y salida a un bloque son tensores de dimensi\u00f3n reducida, mientras que el filtrado intermedio ocurre sobre un tensor de dimensionalidad alta. Como puedes observar en la anterior imagen, otra novedad en Mobilenet v2 es la denominada residual connection , que conecta la entrada y la salida de un bloque (siempre que estos mantengan su dimensionalidad). La arquitectura Mobilenet v2 consta de 17 de estos bloques conectados uno tras otro, seguidos de una \u00fanica convoluci\u00f3n est\u00e1ndar 1x1, y una capa de clasificaci\u00f3n (si lo que se desea es utilizarla para tareas de clasificaci\u00f3n). Si observamos los datos que fluyen por la red, veremos como el n\u00famero de canales se mantiene relativamente reducido: Como es normal en este tipo de modelos, el n\u00famero de canaes se incrementa a medida que avanzamos en la red (mientras la dimensi\u00f3n espacial disminuye). Sin embargo, en general, los tensores se mantienen relativamente peque\u00f1os, gracias a las capas bottleneck entre bloques (en la v1, los tensores llegan a ser hasta 7x7x1024, por ejemplo). El uso de tensores de baja dimensionalidad es clave para reducir el n\u00famero de operaciones aritm\u00e9ticas, y por tanto aumenta la adecuaci\u00f3n de este tipo de modelos para trabajar sobre dispositivos m\u00f3viles. Sin embargo, trabajar s\u00f3lo con tensores de baja dimensionalidad no permite, tras aplicar una capa de convoluci\u00f3n sobre ellos, extraer demasiada informaci\u00f3n. As\u00ed, el filtrado deber\u00eda trabajar sobre datos de alta dimensionalidad. Mobilenet v2, por tanto, une lo mejor de ambos mundos:","title":"Mobilenet v2"},{"location":"LSI/Lab3/#deteccion-de-objetos-ssd-single-shot-multi-box-detector","text":"El framework SSD ( Single Shot MultiBox Detector ) es uno de los principales mecanismos para llevar a cabo tareas de detecci\u00f3n de objetos. Tradicionalmente, estas tareas se realizaban con costosos m\u00e9todos de ventana deslizante (detectando potenciales im\u00e1genes en m\u00faltiples ventanas de tama\u00f1os variables que se desplazaban por la imagen). Este enfoque de fuerza bruta fue mejorado por las llamadas R-CNN ( Region-CNN ), que se basaban en la extracci\u00f3n previa de Region Proposal (propuestas de regiones de la imagen en las que potencialmente pod\u00edan existir objetos), para despu\u00e9s extraer caracter\u00edsticas de cada una de ellas a trav\u00e9s de redes de convoluci\u00f3n y realizar una tarea de clasificaci\u00f3n de dichas caracter\u00edsticas y extracci\u00f3n de las bounding boxes correspondientes. Las R-CNN adolecen de ciertos defectos que las hacen ineficientes (a d\u00eda de hoy) en la vida real, v\u00e9ase: El proceso de entrenamiento de las redes es largo. El proceso de entrenamiento se desarrolla en m\u00faltiples etapas (por ejemplo, para proponer regiones o para clasificar). La red es lenta en la fase de inferencia. En respuesta a esta ineficiencia, se han propuesto m\u00faltiples soluciones en los \u00faltimos a\u00f1os; las m\u00e1s populares son YOLO ( You Only Look Once ) y SSD MultiBox ( Single Shot Detector ). SSD rebaja el coste computacional de las R-CNN sin necesidad de propuestas de regiones, operando en dos grandes fases: Extracci\u00f3n de mapas de caracter\u00edsticas. Aplicaci\u00f3n de filtros de convoluci\u00f3n para detectar objetos. La primera fase (extracci\u00f3n de caracter\u00edsticas), se lleva a cabo mediante una red neuronal espec\u00edfica, llamada gen\u00e9ricamente backbone network . En el dise\u00f1o inicial de SSD, esta red fue la red VGG16, aunque en esta pr\u00e1ctica trabajar\u00e1s con una implementaci\u00f3n en la que se usa Mobilenet v1 y v2 (anteriormente descritas) para mejorar la eficiencia del proceso de detecci\u00f3n. El an\u00e1lisis del propio nombre proporciona informaci\u00f3n sobre las ventajas y modo de operaci\u00f3n de SSD MultiBox: Single Shot : Las tareas de localizaci\u00f3n de objetos y clasificaci\u00f3n se realizan en una \u00fanica pasada (ejecuci\u00f3n) de la red. MultiBox : T\u00e9cnica de regresi\u00f3n para bounding boxes desarrollada por los autores. Detector : La red es un detector de objetos que adem\u00e1s los clasifica.","title":"Detecci\u00f3n de objetos. SSD (Single Shot Multi-Box Detector)"},{"location":"LSI/Lab3/#extraccion-de-caracteristicas","text":"Por defecto, SSD utiliza la red neuronal de convoluci\u00f3n VGG16 para extraer mapas de caracter\u00edsticas. A continuaci\u00f3n, detecta objetos utilizando una de sus capas de convoluci\u00f3n (concretamente, la capa Conv4_3 ). Suponiendo que esta capa es de dimension espacial 8x8 (realmente, es 38x38 ), para cada celda, se realizan 4 predicciones de objeto: Cada predicci\u00f3n est\u00e1 compuesta por una boundary box y una puntuaci\u00f3n o score para cada clase disponible (m\u00e1s una clase extra si no se detecta objeto); para cada objeto detectado, se escoge la clase con mayor puntuaci\u00f3n. As\u00ed, la capa de convoluci\u00f3n Conv4_3 realiza realmente 38x38x4 predicciones:","title":"Extracci\u00f3n de caracter\u00edsticas"},{"location":"LSI/Lab3/#predictores-convolucionales","text":"SSD utiliza peque\u00f1os filtros de convoluci\u00f3n de dimensi\u00f3n 3x3 para predecir la localizaci\u00f3n y puntuaci\u00f3n asociada a cada objeto a detectar. As\u00ed por ejemplo, en un escenario con 20 clases, cada filtro de convoluci\u00f3n devolver\u00e1 25 canales: 21 para cada clase m\u00e1s la informaci\u00f3n asociada a una bounding box :","title":"Predictores convolucionales"},{"location":"LSI/Lab3/#mapas-de-caracteristicas-multi-escala","text":"Aunque se ha descrito el trabajo de SSD con una \u00fanica capa de la red neuronal de extracci\u00f3n de caracter\u00edsticas, realmente SSD utiliza m\u00faltiples capas para detectar objetos de forma independiente. SSD usa las capas de menor resoluci\u00f3n para detectar objetos de mayor tama\u00f1o, y las capas de mayor resoluci\u00f3n para detectar objetos de menor tama\u00f1o. Por ejemplo, los mapas de caracter\u00edsticas de dimensi\u00f3n 4x4 se usar\u00edan para detectar objetos mayores que aquellos de dimensi\u00f3n 8x8:","title":"Mapas de caracter\u00edsticas multi-escala"},{"location":"LSI/Lab3/#prediccion-de-bounding-boxes","text":"Como en cualquier otra red neuronal de convoluci\u00f3n, la predicci\u00f3n de bounding boxes comienza con predicciones aleatorias que se refinan durante la fase de entrenamiento v\u00eda descenso de gradiente. Sin embargo, estos valores iniciales pueden ser conflictivos si no son suficientemente diversos desde el comienzo, principalmente en im\u00e1genes con distintos tipos de objetos: Si las predicciones iniciales cubren m\u00e1s variedad de formas, el modelo podr\u00e1 detectar m\u00e1s objetos: En la vida real, las boundary boxes no presentan formas y tama\u00f1os arbitrarios, sino que, por ejemplo, presentan dimensiones o proporciones similares que pueden ser tomadas como base para el entrenamiento del modelo SSD. Normalmente, para un determinado objeto y conjunto de entrenamiento, se consideran todas las bounding boxes en el conjunto, y se toma como representativa el centroide del cluster que representar\u00eda a todas ellas. As\u00ed, para cada mapa de caracter\u00edsticas extra\u00eddas por la red backbone , se utiliza un conjunto \u00fanico de bounding boxes por defecto centradas en la celda correspondiente, por ejemplo:","title":"Predicci\u00f3n de bounding boxes"},{"location":"LSI/Lab3/#estimacion-de-similitud","text":"Las predicciones de SSD se clasifican como positivas o negativas. Esta evaluaci\u00f3n se basa en la m\u00e9trica IoU ( Intersection over Union ): Realmente, las estimaciones iniciales de bounding boxes se escogen para que presenten un valor de IoU mayor a 0.5. Esta es una mala predicci\u00f3n todav\u00eda, pero una buena base para comenzar con el proceso de regresi\u00f3n (refinamiento) hacia las bounding boxes definitivas.","title":"Estimaci\u00f3n de similitud"},{"location":"LSI/Lab3/#data-augmentation","text":"Para mejorar la precisi\u00f3n del modelo, se utiliza la t\u00e9cnica de aumento de datos o data augmentation . El objetivo de esta t\u00e9cnica es exponer nuevas \"variantes\" de la imagen original para enriquecer la informaci\u00f3n almacenada. Estas transformaciones incluyen recortes ( cropping ), modificaci\u00f3n de orientaci\u00f3n ( flipping ) y distorsiones de color. Por ejemplo:","title":"Data augmentation"},{"location":"LSI/Lab3/#conjuntos-de-entrenamiento","text":"Es necesario un conjuno de entrenamiento y test etiquetado y con bounding boxes reales (en el art\u00edculo descriptivo de SSD, se les conoce como ground truth ), con una etiqueta por bounding box . Por ejemplo:","title":"Conjuntos de entrenamiento"},{"location":"LSI/Lab3/#deteccion-de-objetos-en-tflite","text":"En este laboratorio, utilizaremos el c\u00f3digo proporcionado como base para desarrollar una aplicaci\u00f3n de monitorizaci\u00f3n de aforo en un recinto (por ejemplo, en un aula). En primer lugar, desempaqueta el fichero proporcionado e instala los requisitos necesarios. En primer lugar, descarga los modelos que utilizar\u00e1s para realizar la inferencia, ejecutando el script download_models.sh . Adem\u00e1s, descarga tambi\u00e9n los modelos para Mobilenet SSD disponibles en la web de Google Coral (concretamente, los modelos MobileNet SSD v1 y v2 (COCO) ). A continuaci\u00f3n, en el directorio gstreamer , ejecuta el script install_requirements.sh para instalar los requisitos necesarios para el desarrollo del laboratorio. Si todo ha ido bien, podr\u00e1s ejecutar el c\u00f3digo, que es totalmente funcional, mediante la orden: python3 tracking.py Observa que la salida, en forma de ventana de v\u00eddeo, mostrar\u00e1 una bounding box y clase asociada para cada objeto detectado en la escena. Por defecto, el modelo que se toma es Mobilenet v2 SSD . Desde el punto de vista del c\u00f3digo, la estructura es muy similar a la vista para la clasificaci\u00f3n de objetos. Observa que, se realiza la inferencia mediante la invocaci\u00f3n a detect_objects y se analizan los resultados obtenidos (objetos detectados) en tracker_annotate dibujando las cajas en draw_objects_tracked . Tarea Temporiza el tiempo de respuesta (inferencia) para la red por defecto y para cada una de las dos redes descargadas desde la p\u00e1gina de modelos de Google Coral . Tarea Modifica el c\u00f3digo para mostrar por pantalla (por la terminal) el n\u00famero de objetos detectado en cada frame en la variable tracks , as\u00ed como la posici\u00f3n y clase a la que pertenecen. Intenta determinar qu\u00e9 significa cada uno de los campos asociados a cada box y c\u00f3mo estos valores var\u00edan al mover un objeto por la pantalla, tal y como hace la funci\u00f3n logger.debug(f'trackes: {tracks}')`","title":"Detecci\u00f3n de objetos en TFLite"},{"location":"LSI/Lab3/#tracking-de-objetos-en-tflite","text":"El c\u00f3digo proporcionado integra un tracker o seguidor de objetos, que no solo detecta objetos en un fotograma determinado, sino que los identifica y sigue mientras aparezcan en pantalla. Esta implementaci\u00f3n est\u00e1 basada en el motpy ( enlace ). Para instalar el tracker es necesario instalar el paquete motpy : pip3 install motpy Observa que, al ejecutar el script , se asocia no s\u00f3lo un bounding box y clase a cada objeto, sino tambi\u00e9n un identificador que (idealmente), deber\u00eda mantenerse mientras el objeto siga en la imagen. El tracker Sort devuelve, en su funci\u00f3n update , un array Numpy en el que cada fila contiene un bounding box v\u00e1lido, y un identificador de objeto \u00fanico en su \u00faltima columna. Tarea Modifica el c\u00f3digo para que se muestre para cada fotograma los bounding boxes e identificadores \u00fanicos asociados a cada objeto. Tarea entregable (80% de la nota) Se pide modificar el script inicial para que, peri\u00f3dicamente, se realice un conteo del n\u00famero de personas detectadas en una determinada escena. Este valor (n\u00famero de personas) ser\u00e1 exportado a un panel de control (bajo tu elecci\u00f3n) utilizando alg\u00fan protocolo de entre los vistos en la asignatura RPI-II (por ejemplo, MQTT). El protocolo y el panel de control a utilizar queda bajo elecci\u00f3n del alumno/a. Se establecer\u00e1 un umbral de alarma en forma de aforo m\u00e1ximo autorizado, al cual se reaccionar\u00e1 enviando una se\u00f1al de aviso al usuario desde el panel de control. Toda la infraestructura necesaria se puede implementar en la Raspberry Pi o en un servicio externo, pero en cualquier caso, la inferencia se realizar\u00e1 siempre en la Raspberry Pi, y se acelerar\u00e1 mediante el uso del dispositivo Google Coral. Ejemplos relacionados sobre el uso de MQTT para la creaci\u00f3n de un \"publicador\" en python pueden encontrarse en los ejemplos de la implementaci\u00f3n de MQTT Paho Tarea entregable (20% de la nota) Haciendo uso de las capacidades de tracking del script original, se pide dise\u00f1ar e implementar una soluci\u00f3n para monitorizar el paso de personas en sentido entrada y salida en una entrada a un recinto. As\u00ed, se supondr\u00e1 una c\u00e1mara situada de forma perpendicular a la entrada al recinto, de modo que las personas que accedan al mismo ingresar\u00e1n en la escena por uno de los extremos y saldr\u00e1n por el opuesto. Las personas que salgan del recinto discurrir\u00e1n por la imagen en sentido contrario. Se pide que el sistema almacene el n\u00famero de personas que han entrado y salido del recinto, as\u00ed como el momento en el que lo han hecho.","title":"Tracking de objetos en TFLite"},{"location":"LSI/Lab4/","text":"Laboratorio 4. Segmentaci\u00f3n de im\u00e1genes Objetivos Conocer una herramienta de segmentaci\u00f3n de personas y partes corporales, as\u00ed como su funcionamiento b\u00e1sico. Evaluar el rendimiento de la herramienta utilizando modelos acelerados, y observar tanto su rendimiento como precisi\u00f3n obtenida. Modificar la soluci\u00f3n propuesta para integrarla en un entorno IoT para la gesti\u00f3n de un escenario real (calidad postural en conducci\u00f3n). Bodypix. Estructura y funcionamiento Bodypix es una infraestructura de c\u00f3digo abierto (realmente, un conjunto de modelos) basada en redes neuronales de convoluci\u00f3n y enfocada en dos tareas b\u00e1sicas: segmentaci\u00f3n de personas y partes corporales , y extracci\u00f3n de posicionamiento de partes corporales . Bodypix est\u00e1 espec\u00edficamente dise\u00f1ado para obtener buenos rendimientos en plataformas de bajo rendimiento, y ser altamente parametrizable para adaptarse tanto a otro tipo de plataformas como a distintos niveles de precisi\u00f3n y rendimiento. En este laboratorio utilizaremos los modelos de Bodypix, partiendo de la librer\u00eda tf-bodypix . Tarea Instalar la librer\u00eda y probar los ejemplos b\u00e1sicos para familiarizarse con la API. Tarea Adaptar alguno de los ejemplos para eliminar el fondo de una imagen capturada por la c\u00e1mara en tiempo real. Tarea Probar a usar un modelo .tflite . Informaci\u00f3n complementaria Blog Tensorflow C\u00f3digo original bodypix ( readme y repositorio ). Coral bodypix ( modelos TFLite y EdgeTPU ) Segmentaci\u00f3n de personas A un nivel b\u00e1sico, la segmentaci\u00f3n de personas consiste en realizar una segmentaci\u00f3n de una o m\u00e1s im\u00e1genes de entrada en p\u00edxeles que son parte de una persona, y p\u00edxeles que no lo son. En Bodypix, tras proporcionar una imagen al modelo para inferencia, \u00e9sta se devuelve comen forma de matriz bidimensional con valores flotantes entre 0 y 1 para cada posici\u00f3n (pixel), indicando la probabilidad de que una persona ocupe dicho p\u00edxel. Un valor t\u00edpicamente denominado umbral de segmentaci\u00f3n decidir\u00e1 en \u00faltimo t\u00e9rmino el valor m\u00ednimo de probabilidad para que dicho p\u00edxel se considere como parte de una persona. Este valor puede utilizarse, por ejemplo, para eliminar el fondo de una imagen (o sustituirlo por otro): El proceso de segmentaci\u00f3n de personas procede mediante una decisi\u00f3n binaria para cada pixel de la imagen de entrada, estimando, para dicho p\u00edxel, si \u00e9ste pertenece o no a una persona: En cualquier caso, se proporciona una imagen de dimensiones determinadas a la red neuronal extractora de caracter\u00edsticas (MobileNet o ResNet), y se utiliza una funci\u00f3n de activaci\u00f3n sigmoide para transformar su salida en un valor entre 0 y 1, que puede ser interpretado como la probabilidad de pertenencia a una persona o no para cada uno de los p\u00edxeles de la imagen. Normalmente, se utiliza un valor umbral (por ejemplo, 0.5) para convertir dicha segmentaci\u00f3n en una decisi\u00f3n binaria. Segmentaci\u00f3n de partes corporales Para estimar una correcta segmentaci\u00f3n de partes individuales del cuerpo, se utiliza la misma red extractora de caracter\u00edsticas, pero en este caso se repite el proceso de inferencia anterior prediciendo adicionalmente 24 canales extra a trav\u00e9s de un tensor de salida adicional (siendo 24 el n\u00famero de partes del cuerpo distintas que se desean predecir, valor por defecto en el c\u00f3digo proporcionado). Cada uno de estos canales codifica la probabilidad de pertenencia de un pixel a una parte concreta del cuerpo. Por ejemplo, la siguiente imagen mostrar\u00eda el contenido de dos canales: uno para la detecci\u00f3n de la parte derecha de la cara, y otro para la detecci\u00f3n de la parte izquierda: La siguiente imagen muestra el proceso esquem\u00e1tico de procesamiento de una imagen de entrada en una salida multi-dimensional para la detecci\u00f3n de partes corporales usando el extractor MobileNet: Como para cada posici\u00f3n de la imagen disponemos de 24 canales en el tensor de salida P , es necesario encontrar la parte del cuerpo \u00f3ptima de entre dichos 24 canales. Tras la inferencia, se realiza un proceso de post-procesado para realizar dicha detecci\u00f3n, siguiendo la expresi\u00f3n: Esto redunda en una \u00fanica imagen bidimensional (del mismo tama\u00f1o que la imagen original), en la que cada pixel contiene un entero indicando a qu\u00e9 parte del cuerpo pertenece (asignando un valor especial, por ejemplo -1 si el pixel correspondiente no corresponde a ninguna parte corporal, es decir, no se ha detectado persona en \u00e9l: Una posible combinaci\u00f3n y representaci\u00f3n final de la imagen con informaci\u00f3n detallada de segmentaci\u00f3n podr\u00eda ser: Tarea entregable Se pide que, bas\u00e1ndote en el c\u00f3digo de esta librer\u00eda, desarrollar una aplicaci\u00f3n que, utilizando la Raspberry Pi y mediante el uso del acelerador Google Coral, implemente un sistema que eval\u00fae la calidad postural de un conductor. Para ello, supondremos que el conductor de un veh\u00edculo dispone de una c\u00e1mara frontal en la que visualiza la parte superior de su cuerpo (incluido el torso) mientras conduce. As\u00ed, el sistema desarrollado deber\u00e1, en tiempo real, enviar v\u00eda MQTT (o cualquier otro protocolo) los siguientes par\u00e1metros a un panel de control: Porcentaje de p\u00edxeles detectados para la parte izquierda y derecha de la cara en la imagen. Este par\u00e1metro indicar\u00e1 que el conductor est\u00e1 mirando al frente, y deber\u00eda desvirtuarse si \u00e9ste gira su cabeza a izquierda o derecha. Porcentaje de p\u00edxeles detectados como cara no superior ni inferior a un umbral, lo que indicar\u00e1 que la cabeza se encuentra a una profundidad adecuada. Porcentaje de p\u00edxeles detectados como manos aproximadamente similar y no superior ni inferior a un umbral, lo que indicar\u00e1 que ambas manos est\u00e1n a la misma profundidad. Posici\u00f3n de las manos a la misma altura, y siempre por debajo de la cabeza. Este valor indicar\u00e1 que las manos est\u00e1n situadas en posici\u00f3n correcta en el volante. Posici\u00f3n de los ojos aproximadamente a la misma altura, lo que indicar\u00e1 una posici\u00f3n correcta de la cabeza. Hombros a la misma altura. El panel de control combinar\u00e1 (en el porcentaje que desees) dichas m\u00e9tricas, para obtener un valor de calidad unificado. Si se supera por debajo el valor de calidad considerado umbral, se emitir\u00e1 una alarma utilizando el mecanismo de aviso que consideres adecuado. ( Nota: puedes proponer escenarios distintos al propuesto si son de tu inter\u00e9s, siempre que la dificultad sea similar a la propuesta, y que se utilice el mismo tipo de informaci\u00f3n ).","title":"Laboratorio 4. Segmentaci\u00f3n de im\u00e1genes"},{"location":"LSI/Lab4/#laboratorio-4-segmentacion-de-imagenes","text":"","title":"Laboratorio 4. Segmentaci\u00f3n de im\u00e1genes"},{"location":"LSI/Lab4/#objetivos","text":"Conocer una herramienta de segmentaci\u00f3n de personas y partes corporales, as\u00ed como su funcionamiento b\u00e1sico. Evaluar el rendimiento de la herramienta utilizando modelos acelerados, y observar tanto su rendimiento como precisi\u00f3n obtenida. Modificar la soluci\u00f3n propuesta para integrarla en un entorno IoT para la gesti\u00f3n de un escenario real (calidad postural en conducci\u00f3n).","title":"Objetivos"},{"location":"LSI/Lab4/#bodypix-estructura-y-funcionamiento","text":"Bodypix es una infraestructura de c\u00f3digo abierto (realmente, un conjunto de modelos) basada en redes neuronales de convoluci\u00f3n y enfocada en dos tareas b\u00e1sicas: segmentaci\u00f3n de personas y partes corporales , y extracci\u00f3n de posicionamiento de partes corporales . Bodypix est\u00e1 espec\u00edficamente dise\u00f1ado para obtener buenos rendimientos en plataformas de bajo rendimiento, y ser altamente parametrizable para adaptarse tanto a otro tipo de plataformas como a distintos niveles de precisi\u00f3n y rendimiento. En este laboratorio utilizaremos los modelos de Bodypix, partiendo de la librer\u00eda tf-bodypix . Tarea Instalar la librer\u00eda y probar los ejemplos b\u00e1sicos para familiarizarse con la API. Tarea Adaptar alguno de los ejemplos para eliminar el fondo de una imagen capturada por la c\u00e1mara en tiempo real. Tarea Probar a usar un modelo .tflite .","title":"Bodypix. Estructura y funcionamiento"},{"location":"LSI/Lab4/#informacion-complementaria","text":"Blog Tensorflow C\u00f3digo original bodypix ( readme y repositorio ). Coral bodypix ( modelos TFLite y EdgeTPU )","title":"Informaci\u00f3n complementaria"},{"location":"LSI/Lab4/#segmentacion-de-personas","text":"A un nivel b\u00e1sico, la segmentaci\u00f3n de personas consiste en realizar una segmentaci\u00f3n de una o m\u00e1s im\u00e1genes de entrada en p\u00edxeles que son parte de una persona, y p\u00edxeles que no lo son. En Bodypix, tras proporcionar una imagen al modelo para inferencia, \u00e9sta se devuelve comen forma de matriz bidimensional con valores flotantes entre 0 y 1 para cada posici\u00f3n (pixel), indicando la probabilidad de que una persona ocupe dicho p\u00edxel. Un valor t\u00edpicamente denominado umbral de segmentaci\u00f3n decidir\u00e1 en \u00faltimo t\u00e9rmino el valor m\u00ednimo de probabilidad para que dicho p\u00edxel se considere como parte de una persona. Este valor puede utilizarse, por ejemplo, para eliminar el fondo de una imagen (o sustituirlo por otro): El proceso de segmentaci\u00f3n de personas procede mediante una decisi\u00f3n binaria para cada pixel de la imagen de entrada, estimando, para dicho p\u00edxel, si \u00e9ste pertenece o no a una persona: En cualquier caso, se proporciona una imagen de dimensiones determinadas a la red neuronal extractora de caracter\u00edsticas (MobileNet o ResNet), y se utiliza una funci\u00f3n de activaci\u00f3n sigmoide para transformar su salida en un valor entre 0 y 1, que puede ser interpretado como la probabilidad de pertenencia a una persona o no para cada uno de los p\u00edxeles de la imagen. Normalmente, se utiliza un valor umbral (por ejemplo, 0.5) para convertir dicha segmentaci\u00f3n en una decisi\u00f3n binaria.","title":"Segmentaci\u00f3n de personas"},{"location":"LSI/Lab4/#segmentacion-de-partes-corporales","text":"Para estimar una correcta segmentaci\u00f3n de partes individuales del cuerpo, se utiliza la misma red extractora de caracter\u00edsticas, pero en este caso se repite el proceso de inferencia anterior prediciendo adicionalmente 24 canales extra a trav\u00e9s de un tensor de salida adicional (siendo 24 el n\u00famero de partes del cuerpo distintas que se desean predecir, valor por defecto en el c\u00f3digo proporcionado). Cada uno de estos canales codifica la probabilidad de pertenencia de un pixel a una parte concreta del cuerpo. Por ejemplo, la siguiente imagen mostrar\u00eda el contenido de dos canales: uno para la detecci\u00f3n de la parte derecha de la cara, y otro para la detecci\u00f3n de la parte izquierda: La siguiente imagen muestra el proceso esquem\u00e1tico de procesamiento de una imagen de entrada en una salida multi-dimensional para la detecci\u00f3n de partes corporales usando el extractor MobileNet: Como para cada posici\u00f3n de la imagen disponemos de 24 canales en el tensor de salida P , es necesario encontrar la parte del cuerpo \u00f3ptima de entre dichos 24 canales. Tras la inferencia, se realiza un proceso de post-procesado para realizar dicha detecci\u00f3n, siguiendo la expresi\u00f3n: Esto redunda en una \u00fanica imagen bidimensional (del mismo tama\u00f1o que la imagen original), en la que cada pixel contiene un entero indicando a qu\u00e9 parte del cuerpo pertenece (asignando un valor especial, por ejemplo -1 si el pixel correspondiente no corresponde a ninguna parte corporal, es decir, no se ha detectado persona en \u00e9l: Una posible combinaci\u00f3n y representaci\u00f3n final de la imagen con informaci\u00f3n detallada de segmentaci\u00f3n podr\u00eda ser: Tarea entregable Se pide que, bas\u00e1ndote en el c\u00f3digo de esta librer\u00eda, desarrollar una aplicaci\u00f3n que, utilizando la Raspberry Pi y mediante el uso del acelerador Google Coral, implemente un sistema que eval\u00fae la calidad postural de un conductor. Para ello, supondremos que el conductor de un veh\u00edculo dispone de una c\u00e1mara frontal en la que visualiza la parte superior de su cuerpo (incluido el torso) mientras conduce. As\u00ed, el sistema desarrollado deber\u00e1, en tiempo real, enviar v\u00eda MQTT (o cualquier otro protocolo) los siguientes par\u00e1metros a un panel de control: Porcentaje de p\u00edxeles detectados para la parte izquierda y derecha de la cara en la imagen. Este par\u00e1metro indicar\u00e1 que el conductor est\u00e1 mirando al frente, y deber\u00eda desvirtuarse si \u00e9ste gira su cabeza a izquierda o derecha. Porcentaje de p\u00edxeles detectados como cara no superior ni inferior a un umbral, lo que indicar\u00e1 que la cabeza se encuentra a una profundidad adecuada. Porcentaje de p\u00edxeles detectados como manos aproximadamente similar y no superior ni inferior a un umbral, lo que indicar\u00e1 que ambas manos est\u00e1n a la misma profundidad. Posici\u00f3n de las manos a la misma altura, y siempre por debajo de la cabeza. Este valor indicar\u00e1 que las manos est\u00e1n situadas en posici\u00f3n correcta en el volante. Posici\u00f3n de los ojos aproximadamente a la misma altura, lo que indicar\u00e1 una posici\u00f3n correcta de la cabeza. Hombros a la misma altura. El panel de control combinar\u00e1 (en el porcentaje que desees) dichas m\u00e9tricas, para obtener un valor de calidad unificado. Si se supera por debajo el valor de calidad considerado umbral, se emitir\u00e1 una alarma utilizando el mecanismo de aviso que consideres adecuado. ( Nota: puedes proponer escenarios distintos al propuesto si son de tu inter\u00e9s, siempre que la dificultad sea similar a la propuesta, y que se utilice el mismo tipo de informaci\u00f3n ).","title":"Segmentaci\u00f3n de partes corporales"},{"location":"LSI/Lab4_old/","text":"Laboratorio 4. Segmentaci\u00f3n de im\u00e1genes Objetivos Conocer una herramienta de segmentaci\u00f3n de personas y partes corporales, as\u00ed como su fucnionamiento b\u00e1sico. Evaluar el rendimiento de la herramienta utilizando modelos acelerados, y observar tanto su rendimiento como precisi\u00f3n obtenida. Modificar la soluci\u00f3n propuesta para integrarla en un entorno IoT para la gesti\u00f3n de un esceneario real (calidad postural en conducci\u00f3n). Bodypix. Estructura y funcionamiento Bodypix es una infraestructura de c\u00f3digo abierto (realmente, un conjunto de modelos) basada en redes neuronales de convoluci\u00f3n y enfocada en dos tareas b\u00e1sicas: segmentaci\u00f3n de personas y partes corporales , y extracci\u00f3n de posicionamiento de partes corporales . Bodypix est\u00e1 espec\u00edficamente dise\u00f1ado para obtener buenos rendimientos en plataformas de bajo rendimiento, y ser altamente parametrizable para adaptarse tanto a otro tipo de plataformas como a distintos niveles de precisi\u00f3n y rendimiento. En este laboratorio utilizaremos los modelos desarrollados en el marco del proyecto Bodypix, pero utilizando una infraestructura aligerada, as\u00ed como variantes cuantizadas de los modelos originales, que nos permitir\u00e1n ejecutar la infraestructura en nuestra Raspberry Pi acelerada mediante el uso de Edge TPU. En primer lugar, clona en tu Raspberry Pi el proyecto Bodypix proporcionado como parte de la infraestructura Google Coral: git clone https://github.com/google-coral/project-bodypix En el directorio que se crear\u00e1 dispones de un fichero denominado install_requirements.sh , que deber\u00e1s ejecutar para instalar los requisitos necesarios para el correcto funcionamiento del proyecto. Una vez instalados, realiza una primera prueba de funcionamiento preliminar para comprobar que todo ha funcionado como se espera (aseg\u00farate de que tanto tu c\u00e1mara como la Google Coral est\u00e1n conectados a la Raspberry Pi antes de ejecutar el ejemplo): python3 bodypix.py En pantalla deber\u00edas observar una captura en tiempo real de c\u00e1mara, aplicando un proceso de segmentaci\u00f3n de zonas de la imagen que corresponden a distintas partes de cada persona detectada. Adem\u00e1s, la infraestructura integra por defecto una sobreimpresi\u00f3n de los principales puntos de inter\u00e9s corporales, siguiendo las ideas del proyecto Posenet . El proyecto sobre el que trabajaremos dispone de m\u00faltiples modificadores u opciones que simplemente trabajan o modifican la parte gr\u00e1fica de la respuesta (es decir, no realizan c\u00f3mputos adicionales o restringidos). Algunos de los m\u00e1s interesantes son: Selecci\u00f3n de partes corporales Las opciones --bodyparts y --nobodyparts diferenciar\u00e1n o no las distintas partes corporales detectadas en el proceso de segmentaci\u00f3n. Si esta opci\u00f3n est\u00e1 desactivada, simplemente se realiza la segmentaci\u00f3n de personas, no de partes corporales para cada individuo. Observa que las partes corporales no se colorean de distinta forma totalmente, sino que se agrupan en funci\u00f3n del tipo de parte corporal detectada. Esta caracter\u00edstica se considera meramente de representaci\u00f3n, ya que los modelos que se utilizan s\u00ed soportan (y de hecho, ejecutan constantenente) un proceso de segmentaci\u00f3n completo. Anonimizaci\u00f3n de im\u00e1genes Las opciones --anonymize y --noanoymize permiten mostrar u ocultar la persona detectada. En este \u00faltimo caso, se realiza un proceso de generaci\u00f3n de fondo artificial, y no se muestra a la persona o personas que se est\u00e1n detectando. Selecci\u00f3n del tama\u00f1o de imagen de entrada Aunque cada modelo espec\u00edfico est\u00e1 dise\u00f1ado para tomar un determinado tama\u00f1o de imagen de entrada, es posible preseleccionar dicho tama\u00f1o (que por defecto se escala en el c\u00f3digo) externamente. Para ello, basta con utilizar las opciones --height y --width , que realizan dicho proceso de escalado. En general, se recomienda que la resoluci\u00f3n sea la misma, o exceda lo menor posible, la resoluci\u00f3n de entrada de la red a utilizar. Modo espejo En la fase de pruebas, si tanto la c\u00e1mara como el monitor utilizado est\u00e1n enfocados hacia la persona, se recomienda utilizar el modo espejo ( -mirror ) para un mejor entendimiento de la escena. Selecci\u00f3n de la red neuronal El proyecto proporciona un conjunto de modelos preentrenados que permiten un equilibrio entre rendimiento y precisi\u00f3n, adem\u00e1s de soportar distintas resoluciones de im\u00e1genes de entrada. Estos modelos est\u00e1n basados en dos infraestructuras distintas para la extracci\u00f3n de caracter\u00edsticas: Mobilenet, m\u00e1s ligera y menos precisa; y ResNet, menos liviana, pero que ofrece una mayor precisi\u00f3n en el proceso de inferencia. La selecci\u00f3n del modelo concreto puede realizarse a trav\u00e9s del argumento que acompa\u00f1a a la opci\u00f3n --model , y puede seleccionarse de entre los siguientes (todos residentes en el directorio models ): models/bodypix_mobilenet_v1_075_1024_768_16_quant_edgetpu_decoder.tflite models/bodypix_mobilenet_v1_075_1280_720_16_quant_edgetpu_decoder.tflite models/bodypix_mobilenet_v1_075_480_352_16_quant_edgetpu_decoder.tflite models/bodypix_mobilenet_v1_075_640_480_16_quant_edgetpu_decoder.tflite models/bodypix_mobilenet_v1_075_768_576_16_quant_edgetpu_decoder.tflite models/bodypix_resnet_50_416_288_16_quant_edgetpu_decoder.tflite models/bodypix_resnet_50_640_480_16_quant_edgetpu_decoder.tflite models/bodypix_resnet_50_768_496_32_quant_edgetpu_decoder.tflite models/bodypix_resnet_50_864_624_32_quant_edgetpu_decoder.tflite models/bodypix_resnet_50_928_672_16_quant_edgetpu_decoder.tflite models/bodypix_resnet_50_960_736_32_quant_edgetpu_decoder.tflite Tarea Experimenta con las diferentes opciones descritas anteriormente. Realiza una evaluaci\u00f3n del rendimiento de cada uno de los modelos proporcionados en base a los FPS obtenidos, y describe si efectivamente observas alguna diferencia en t\u00e9rminos de calidad percibida en el proceso de segmentaci\u00f3n. Segmentaci\u00f3n de personas A un nivel b\u00e1sico, la segmentaci\u00f3n de personas consiste en realizar una segmentaci\u00f3n de una o m\u00e1s im\u00e1genes de entrada en p\u00edxeles que son parte de una persona, y p\u00edxeles que no lo son. En Bodypix, tras proporcionar una imagen al modelo para inferencia, \u00e9sta se devuelve comen forma de matriz bidimensional con valores flotantes entre 0 y 1 para cada posici\u00f3n (pixel), indicando la probabilidad de que una persona ocupe dicho p\u00edxel. Un valor t\u00edpicamente denominado umbral de segmentaci\u00f3n decidir\u00e1 en \u00faltimo t\u00e9rmino el valor m\u00ednimo de probabilidad para que dicho p\u00edxel se considere como parte de una persona. Este valor puede utilizarse, por ejemplo, para eliminar el fondo de una imagen (o sustituirlo por otro): El proceso de segmentaci\u00f3n de personas procede mediante una decisi\u00f3n binaria para cada pixel de la imagen de entrada, estimando, para dicho p\u00edxel, si \u00e9ste pertenece o no a una persona: En cualquier caso, se proporciona una imagen de dimensiones determinadas a la red neuronal extractora de caracter\u00edsticas (MobileNet o ResNet), y se utiliza una funci\u00f3n de activaci\u00f3n sigmoide para transformar su salida en un valor entre 0 y 1, que puede ser interpretado como la probabilidad de pertenenecia a una persona o no para cada uno de los p\u00edxeles de la imagen. Normalmente, se utiliza un valor umbral (por ejemplo, 0.5) para convertir dicha segmentaci\u00f3n en una decisi\u00f3n binaria. Normalmente, se utiliza un valor umbral (por ejemplo, 0.5) para convertir dicha segmentaci\u00f3n en una decisi\u00f3n binaria, como se ha dicho anteriormente. Segmentaci\u00f3n de partes corporales Para estimar una correcta segmentaci\u00f3n de partes individuales del cuerpo, se utiliza la misma red extractora de caracter\u00edsticas, pero en este caso se repite el proceso de inferencia anterior prediciendo adicionalemnte 24 canales extra a trav\u00e9s de un tensor de salida adicional (siendo 24 el n\u00famero de partes del cuerpo distintas que se desean predecir, valor por defecto en el c\u00f3digo proporcionado). Cada uno de estos canales codifica la probabilidad de pertenencia de un pixel a una parte concreta del cuerpo. Por ejemplo, la siguiente imagen mostrar\u00eda el contenido de dos canales: uno para la detecci\u00f3n de la parte derecha de la cara, y otro para la detecci\u00f3n de la parte izquierda: La siguiente imagen muestra el proceso esquem\u00e1tico de procesamiento de una imagen de entrada en una salida multi-dimensional para la detecci\u00f3n de partes corporales usando el extractor MobileNet: Como para cada posici\u00f3n de la imagen disponemos de 24 canales en el tensor de salida P , es necesario encontrar la parte del cuerpo \u00f3ptima de entre dichos 24 canales. Tras la inferencia, se realiza un proceso de postprocesado para realizar dicha detecci\u00f3n, siguiendo la expresi\u00f3n: Esto redunda en una \u00fanica imagen bidimensional (del mismo tama\u00f1o que la imagen original), en la que cada pixel contiene un entero indicando a qu\u00e9 parte del cuerpo pertenece (asignando un valor especial, por ejemplo -1 si el pixel correspondiente no corresponde a ninguna parte corporal, es decir, no se ha detectado persona en \u00e9l: Una posible combinaci\u00f3n y representaci\u00f3n final de la imagen con informaci\u00f3n detallada de segmentaci\u00f3n podr\u00eda ser: An\u00e1lisis del c\u00f3digo En el c\u00f3digo proporcionado (fichero pose_engine.py ), el desarrollo orbita alrededor de la clase PoseEngine , encargada de realizar el proceso de inferencia sobre el modelo proporcionado a partir de una imagen de entrada. Concretamente, su m\u00e9todo DetectPosesInImage , al que se proporciona precisamente una sola imagen de entrada, ser\u00e1 el encargado de realizar el proceso de segmentaci\u00f3n. El retorno de dicha funci\u00f3n, de hecho, incluir\u00e1 informaci\u00f3n tanto a nivel de detecci\u00f3n de personas (en la estructura heatmap ) como de partes corporales (en la estructura bodyparts ). Tarea Determina tanto las dimensiones como el contenido tentativo de las estructuras heatmap y bodyparts . Para ello, observa en detalle m\u00e9todo __parse_heatmaps de la clase PoseEngine , que realiza la gesti\u00f3n de entradas, salidas e inferencia para el modelo a utilizar. \u00bfQu\u00e9 tensores de salida se procesan en esta funci\u00f3n tras la inferencia? \u00bfEst\u00e1n cuantizadas dichas salidas? \u00bfCu\u00e1les son las dimensiones de los mapas de calor obtenidos? \u00bfPor qu\u00e9? \u00bfA qu\u00e9 tipo de informaci\u00f3n corresponde cada canal de los tensores de salida (identif\u00edcalos en la parte inicial del mismo fichero) Adicionalmente, la funci\u00f3n __parse_poses realiza un proceso de inferencia sobre el mismo modelo, pero recogiendo en este caso informaci\u00f3n sobre puntos clave ( keypoints ) que describen la posici\u00f3n del sujeto. Tarea Responde a las mismas preguntas que anteriormente se te han planteado, pero en este caso bas\u00e1ndote en la funci\u00f3n __parse_poses y su implementaci\u00f3n. En cualquier caso, la informaci\u00f3n de las tres estructuras devueltas por la funi\u00f3n DetectPosesInImage te permitir\u00e1 desarrollar el ejercicio propuesto, calculando, por ejemplo, el n\u00famero de p\u00edxeles o su porcentaje con respecto al total de la imagen para cada parte del cuerpo, su posici\u00f3n relativa o absoluta en la imagen, o su detecci\u00f3n o ausencia. Es importante, pues, que estudies y determines correctamente el significado y contenido de cada una de estas estrcucturas . El proceso de representaci\u00f3n gr\u00e1fica de la imagen resultante se realiza en la fucni\u00f3n Callback del flujo de datos de gstreamer . Aunque la representaci\u00f3n gr\u00e1fica no es en nuestro caso clave, en este caso observa que las distintas partes del cuerpo se agrupan en tres grandes grupos (l\u00edneas 32, 33 y 34 del fichero bodypix.py ), que son coloreadas de igual forma en funci\u00f3n del resultado de la inferencia. Tarea Modifica el c\u00f3digo proporcionado para que s\u00f3lo una determinada parte del cuerpo, seleccionada por ti, se coloree en la fase de detecci\u00f3n de partes corporales. Tarea entregable Se pide que, bas\u00e1ndote en el proyecto proporcionado, desarrolles una aplicaci\u00f3n que, utilizando la Raspberry Pi y mediante el uso del acelerador Google Coral, implemente un sistema que eval\u00fae la calidad postural de un conductor. Para ello, supondremos que el conductor de un veh\u00edculo dispone de una c\u00e1mara frontal en la que visualiza la parte superior de su cuerpo (incluido el torso) mientras conduce. As\u00ed, el sistema desarrollado deber\u00e1, en tiempo real, enviar v\u00eda MQTT (o cualquier otro protocolo) los siguientes par\u00e1metros a un panel de control: Porcentaje de p\u00edxeles detectados para la parte izquierda y derecha de la cara en la imagen. Este par\u00e1metro indicar\u00e1 que el conductor est\u00e1 mirando al frente, y deber\u00eda desvirtuarse si \u00e9ste gira su cabeza a izquierda o derecha. Porcentaje de p\u00edxeles detectados como cara no superior ni inferior a un umbral, lo que indicar\u00e1 que la cabeza se encuentra a una profundidad adecuada. Porcentaje de p\u00edxeles detectados como manos aproximadamente similar y no superior ni inferior a un umbral, lo que indicar\u00e1 que ambas manos est\u00e1n a la misma profundidad. Posici\u00f3n de las manos a la misma altura, y siempre por debajo de la cabeza. Este valor indicar\u00e1 que las manos est\u00e1n situadas en posici\u00f3n correcta en el volante. Posici\u00f3n de los ojos aproximadamente a la misma altura, lo que indicar\u00e1 una posici\u00f3n correcta de la cabeza. Hombros a la misma altura. El panel de control combinar\u00e1 (en el porcentaje que desees) dichas m\u00e9tricas, para obtener un valor de calidad unificado. Si se supera por debajo el valor de calidad considerado umbral, se emitir\u00e1 una alarma utilizando el mecanismo de aviso que consideres adecuado. ( Nota: puedes proponer escenarios distintos al propuesto si son de tu inter\u00e9s, siempre que la dificultad sea similar a la propuesta, y que se utilice el mismo tipo de informaci\u00f3n ).","title":"Laboratorio 4. Segmentaci\u00f3n de im\u00e1genes"},{"location":"LSI/Lab4_old/#laboratorio-4-segmentacion-de-imagenes","text":"","title":"Laboratorio 4. Segmentaci\u00f3n de im\u00e1genes"},{"location":"LSI/Lab4_old/#objetivos","text":"Conocer una herramienta de segmentaci\u00f3n de personas y partes corporales, as\u00ed como su fucnionamiento b\u00e1sico. Evaluar el rendimiento de la herramienta utilizando modelos acelerados, y observar tanto su rendimiento como precisi\u00f3n obtenida. Modificar la soluci\u00f3n propuesta para integrarla en un entorno IoT para la gesti\u00f3n de un esceneario real (calidad postural en conducci\u00f3n).","title":"Objetivos"},{"location":"LSI/Lab4_old/#bodypix-estructura-y-funcionamiento","text":"Bodypix es una infraestructura de c\u00f3digo abierto (realmente, un conjunto de modelos) basada en redes neuronales de convoluci\u00f3n y enfocada en dos tareas b\u00e1sicas: segmentaci\u00f3n de personas y partes corporales , y extracci\u00f3n de posicionamiento de partes corporales . Bodypix est\u00e1 espec\u00edficamente dise\u00f1ado para obtener buenos rendimientos en plataformas de bajo rendimiento, y ser altamente parametrizable para adaptarse tanto a otro tipo de plataformas como a distintos niveles de precisi\u00f3n y rendimiento. En este laboratorio utilizaremos los modelos desarrollados en el marco del proyecto Bodypix, pero utilizando una infraestructura aligerada, as\u00ed como variantes cuantizadas de los modelos originales, que nos permitir\u00e1n ejecutar la infraestructura en nuestra Raspberry Pi acelerada mediante el uso de Edge TPU. En primer lugar, clona en tu Raspberry Pi el proyecto Bodypix proporcionado como parte de la infraestructura Google Coral: git clone https://github.com/google-coral/project-bodypix En el directorio que se crear\u00e1 dispones de un fichero denominado install_requirements.sh , que deber\u00e1s ejecutar para instalar los requisitos necesarios para el correcto funcionamiento del proyecto. Una vez instalados, realiza una primera prueba de funcionamiento preliminar para comprobar que todo ha funcionado como se espera (aseg\u00farate de que tanto tu c\u00e1mara como la Google Coral est\u00e1n conectados a la Raspberry Pi antes de ejecutar el ejemplo): python3 bodypix.py En pantalla deber\u00edas observar una captura en tiempo real de c\u00e1mara, aplicando un proceso de segmentaci\u00f3n de zonas de la imagen que corresponden a distintas partes de cada persona detectada. Adem\u00e1s, la infraestructura integra por defecto una sobreimpresi\u00f3n de los principales puntos de inter\u00e9s corporales, siguiendo las ideas del proyecto Posenet . El proyecto sobre el que trabajaremos dispone de m\u00faltiples modificadores u opciones que simplemente trabajan o modifican la parte gr\u00e1fica de la respuesta (es decir, no realizan c\u00f3mputos adicionales o restringidos). Algunos de los m\u00e1s interesantes son: Selecci\u00f3n de partes corporales Las opciones --bodyparts y --nobodyparts diferenciar\u00e1n o no las distintas partes corporales detectadas en el proceso de segmentaci\u00f3n. Si esta opci\u00f3n est\u00e1 desactivada, simplemente se realiza la segmentaci\u00f3n de personas, no de partes corporales para cada individuo. Observa que las partes corporales no se colorean de distinta forma totalmente, sino que se agrupan en funci\u00f3n del tipo de parte corporal detectada. Esta caracter\u00edstica se considera meramente de representaci\u00f3n, ya que los modelos que se utilizan s\u00ed soportan (y de hecho, ejecutan constantenente) un proceso de segmentaci\u00f3n completo. Anonimizaci\u00f3n de im\u00e1genes Las opciones --anonymize y --noanoymize permiten mostrar u ocultar la persona detectada. En este \u00faltimo caso, se realiza un proceso de generaci\u00f3n de fondo artificial, y no se muestra a la persona o personas que se est\u00e1n detectando. Selecci\u00f3n del tama\u00f1o de imagen de entrada Aunque cada modelo espec\u00edfico est\u00e1 dise\u00f1ado para tomar un determinado tama\u00f1o de imagen de entrada, es posible preseleccionar dicho tama\u00f1o (que por defecto se escala en el c\u00f3digo) externamente. Para ello, basta con utilizar las opciones --height y --width , que realizan dicho proceso de escalado. En general, se recomienda que la resoluci\u00f3n sea la misma, o exceda lo menor posible, la resoluci\u00f3n de entrada de la red a utilizar. Modo espejo En la fase de pruebas, si tanto la c\u00e1mara como el monitor utilizado est\u00e1n enfocados hacia la persona, se recomienda utilizar el modo espejo ( -mirror ) para un mejor entendimiento de la escena. Selecci\u00f3n de la red neuronal El proyecto proporciona un conjunto de modelos preentrenados que permiten un equilibrio entre rendimiento y precisi\u00f3n, adem\u00e1s de soportar distintas resoluciones de im\u00e1genes de entrada. Estos modelos est\u00e1n basados en dos infraestructuras distintas para la extracci\u00f3n de caracter\u00edsticas: Mobilenet, m\u00e1s ligera y menos precisa; y ResNet, menos liviana, pero que ofrece una mayor precisi\u00f3n en el proceso de inferencia. La selecci\u00f3n del modelo concreto puede realizarse a trav\u00e9s del argumento que acompa\u00f1a a la opci\u00f3n --model , y puede seleccionarse de entre los siguientes (todos residentes en el directorio models ): models/bodypix_mobilenet_v1_075_1024_768_16_quant_edgetpu_decoder.tflite models/bodypix_mobilenet_v1_075_1280_720_16_quant_edgetpu_decoder.tflite models/bodypix_mobilenet_v1_075_480_352_16_quant_edgetpu_decoder.tflite models/bodypix_mobilenet_v1_075_640_480_16_quant_edgetpu_decoder.tflite models/bodypix_mobilenet_v1_075_768_576_16_quant_edgetpu_decoder.tflite models/bodypix_resnet_50_416_288_16_quant_edgetpu_decoder.tflite models/bodypix_resnet_50_640_480_16_quant_edgetpu_decoder.tflite models/bodypix_resnet_50_768_496_32_quant_edgetpu_decoder.tflite models/bodypix_resnet_50_864_624_32_quant_edgetpu_decoder.tflite models/bodypix_resnet_50_928_672_16_quant_edgetpu_decoder.tflite models/bodypix_resnet_50_960_736_32_quant_edgetpu_decoder.tflite Tarea Experimenta con las diferentes opciones descritas anteriormente. Realiza una evaluaci\u00f3n del rendimiento de cada uno de los modelos proporcionados en base a los FPS obtenidos, y describe si efectivamente observas alguna diferencia en t\u00e9rminos de calidad percibida en el proceso de segmentaci\u00f3n.","title":"Bodypix. Estructura y funcionamiento"},{"location":"LSI/Lab4_old/#segmentacion-de-personas","text":"A un nivel b\u00e1sico, la segmentaci\u00f3n de personas consiste en realizar una segmentaci\u00f3n de una o m\u00e1s im\u00e1genes de entrada en p\u00edxeles que son parte de una persona, y p\u00edxeles que no lo son. En Bodypix, tras proporcionar una imagen al modelo para inferencia, \u00e9sta se devuelve comen forma de matriz bidimensional con valores flotantes entre 0 y 1 para cada posici\u00f3n (pixel), indicando la probabilidad de que una persona ocupe dicho p\u00edxel. Un valor t\u00edpicamente denominado umbral de segmentaci\u00f3n decidir\u00e1 en \u00faltimo t\u00e9rmino el valor m\u00ednimo de probabilidad para que dicho p\u00edxel se considere como parte de una persona. Este valor puede utilizarse, por ejemplo, para eliminar el fondo de una imagen (o sustituirlo por otro): El proceso de segmentaci\u00f3n de personas procede mediante una decisi\u00f3n binaria para cada pixel de la imagen de entrada, estimando, para dicho p\u00edxel, si \u00e9ste pertenece o no a una persona: En cualquier caso, se proporciona una imagen de dimensiones determinadas a la red neuronal extractora de caracter\u00edsticas (MobileNet o ResNet), y se utiliza una funci\u00f3n de activaci\u00f3n sigmoide para transformar su salida en un valor entre 0 y 1, que puede ser interpretado como la probabilidad de pertenenecia a una persona o no para cada uno de los p\u00edxeles de la imagen. Normalmente, se utiliza un valor umbral (por ejemplo, 0.5) para convertir dicha segmentaci\u00f3n en una decisi\u00f3n binaria. Normalmente, se utiliza un valor umbral (por ejemplo, 0.5) para convertir dicha segmentaci\u00f3n en una decisi\u00f3n binaria, como se ha dicho anteriormente.","title":"Segmentaci\u00f3n de personas"},{"location":"LSI/Lab4_old/#segmentacion-de-partes-corporales","text":"Para estimar una correcta segmentaci\u00f3n de partes individuales del cuerpo, se utiliza la misma red extractora de caracter\u00edsticas, pero en este caso se repite el proceso de inferencia anterior prediciendo adicionalemnte 24 canales extra a trav\u00e9s de un tensor de salida adicional (siendo 24 el n\u00famero de partes del cuerpo distintas que se desean predecir, valor por defecto en el c\u00f3digo proporcionado). Cada uno de estos canales codifica la probabilidad de pertenencia de un pixel a una parte concreta del cuerpo. Por ejemplo, la siguiente imagen mostrar\u00eda el contenido de dos canales: uno para la detecci\u00f3n de la parte derecha de la cara, y otro para la detecci\u00f3n de la parte izquierda: La siguiente imagen muestra el proceso esquem\u00e1tico de procesamiento de una imagen de entrada en una salida multi-dimensional para la detecci\u00f3n de partes corporales usando el extractor MobileNet: Como para cada posici\u00f3n de la imagen disponemos de 24 canales en el tensor de salida P , es necesario encontrar la parte del cuerpo \u00f3ptima de entre dichos 24 canales. Tras la inferencia, se realiza un proceso de postprocesado para realizar dicha detecci\u00f3n, siguiendo la expresi\u00f3n: Esto redunda en una \u00fanica imagen bidimensional (del mismo tama\u00f1o que la imagen original), en la que cada pixel contiene un entero indicando a qu\u00e9 parte del cuerpo pertenece (asignando un valor especial, por ejemplo -1 si el pixel correspondiente no corresponde a ninguna parte corporal, es decir, no se ha detectado persona en \u00e9l: Una posible combinaci\u00f3n y representaci\u00f3n final de la imagen con informaci\u00f3n detallada de segmentaci\u00f3n podr\u00eda ser:","title":"Segmentaci\u00f3n de partes corporales"},{"location":"LSI/Lab4_old/#analisis-del-codigo","text":"En el c\u00f3digo proporcionado (fichero pose_engine.py ), el desarrollo orbita alrededor de la clase PoseEngine , encargada de realizar el proceso de inferencia sobre el modelo proporcionado a partir de una imagen de entrada. Concretamente, su m\u00e9todo DetectPosesInImage , al que se proporciona precisamente una sola imagen de entrada, ser\u00e1 el encargado de realizar el proceso de segmentaci\u00f3n. El retorno de dicha funci\u00f3n, de hecho, incluir\u00e1 informaci\u00f3n tanto a nivel de detecci\u00f3n de personas (en la estructura heatmap ) como de partes corporales (en la estructura bodyparts ). Tarea Determina tanto las dimensiones como el contenido tentativo de las estructuras heatmap y bodyparts . Para ello, observa en detalle m\u00e9todo __parse_heatmaps de la clase PoseEngine , que realiza la gesti\u00f3n de entradas, salidas e inferencia para el modelo a utilizar. \u00bfQu\u00e9 tensores de salida se procesan en esta funci\u00f3n tras la inferencia? \u00bfEst\u00e1n cuantizadas dichas salidas? \u00bfCu\u00e1les son las dimensiones de los mapas de calor obtenidos? \u00bfPor qu\u00e9? \u00bfA qu\u00e9 tipo de informaci\u00f3n corresponde cada canal de los tensores de salida (identif\u00edcalos en la parte inicial del mismo fichero) Adicionalmente, la funci\u00f3n __parse_poses realiza un proceso de inferencia sobre el mismo modelo, pero recogiendo en este caso informaci\u00f3n sobre puntos clave ( keypoints ) que describen la posici\u00f3n del sujeto. Tarea Responde a las mismas preguntas que anteriormente se te han planteado, pero en este caso bas\u00e1ndote en la funci\u00f3n __parse_poses y su implementaci\u00f3n. En cualquier caso, la informaci\u00f3n de las tres estructuras devueltas por la funi\u00f3n DetectPosesInImage te permitir\u00e1 desarrollar el ejercicio propuesto, calculando, por ejemplo, el n\u00famero de p\u00edxeles o su porcentaje con respecto al total de la imagen para cada parte del cuerpo, su posici\u00f3n relativa o absoluta en la imagen, o su detecci\u00f3n o ausencia. Es importante, pues, que estudies y determines correctamente el significado y contenido de cada una de estas estrcucturas . El proceso de representaci\u00f3n gr\u00e1fica de la imagen resultante se realiza en la fucni\u00f3n Callback del flujo de datos de gstreamer . Aunque la representaci\u00f3n gr\u00e1fica no es en nuestro caso clave, en este caso observa que las distintas partes del cuerpo se agrupan en tres grandes grupos (l\u00edneas 32, 33 y 34 del fichero bodypix.py ), que son coloreadas de igual forma en funci\u00f3n del resultado de la inferencia. Tarea Modifica el c\u00f3digo proporcionado para que s\u00f3lo una determinada parte del cuerpo, seleccionada por ti, se coloree en la fase de detecci\u00f3n de partes corporales. Tarea entregable Se pide que, bas\u00e1ndote en el proyecto proporcionado, desarrolles una aplicaci\u00f3n que, utilizando la Raspberry Pi y mediante el uso del acelerador Google Coral, implemente un sistema que eval\u00fae la calidad postural de un conductor. Para ello, supondremos que el conductor de un veh\u00edculo dispone de una c\u00e1mara frontal en la que visualiza la parte superior de su cuerpo (incluido el torso) mientras conduce. As\u00ed, el sistema desarrollado deber\u00e1, en tiempo real, enviar v\u00eda MQTT (o cualquier otro protocolo) los siguientes par\u00e1metros a un panel de control: Porcentaje de p\u00edxeles detectados para la parte izquierda y derecha de la cara en la imagen. Este par\u00e1metro indicar\u00e1 que el conductor est\u00e1 mirando al frente, y deber\u00eda desvirtuarse si \u00e9ste gira su cabeza a izquierda o derecha. Porcentaje de p\u00edxeles detectados como cara no superior ni inferior a un umbral, lo que indicar\u00e1 que la cabeza se encuentra a una profundidad adecuada. Porcentaje de p\u00edxeles detectados como manos aproximadamente similar y no superior ni inferior a un umbral, lo que indicar\u00e1 que ambas manos est\u00e1n a la misma profundidad. Posici\u00f3n de las manos a la misma altura, y siempre por debajo de la cabeza. Este valor indicar\u00e1 que las manos est\u00e1n situadas en posici\u00f3n correcta en el volante. Posici\u00f3n de los ojos aproximadamente a la misma altura, lo que indicar\u00e1 una posici\u00f3n correcta de la cabeza. Hombros a la misma altura. El panel de control combinar\u00e1 (en el porcentaje que desees) dichas m\u00e9tricas, para obtener un valor de calidad unificado. Si se supera por debajo el valor de calidad considerado umbral, se emitir\u00e1 una alarma utilizando el mecanismo de aviso que consideres adecuado. ( Nota: puedes proponer escenarios distintos al propuesto si son de tu inter\u00e9s, siempre que la dificultad sea similar a la propuesta, y que se utilice el mismo tipo de informaci\u00f3n ).","title":"An\u00e1lisis del c\u00f3digo"},{"location":"LSI/Lab5/","text":"Laboratorio 5. Comandos por voz Objetivos Familiarizarse con el procesamiento de voz en nodos AI-IoT Configurar un interfaz por voz offline/on-device para detecci\u00f3n de comandos de voz Usar el acelerador Coral USB para dicho procesamiento Integrar procesamiento con voz en una soluci\u00f3n IoT gen\u00e9rica Introducci\u00f3n Procesamiento de voz Hoy en d\u00eda el procesamiento digital de la voz es empleado en m\u00faltiples \u00e1mbitos, siendo tal vez uno de los m\u00e1s extendidos el de los asistentes de voz virtuales (Amazon Alexa, Google Assitant, Apple Siri, ...). En su mayor\u00eda estos sistemas combinan diversas t\u00e9cnicas de inteligencia artificial para proporcionar un dialogo hablado con el usuario (ver esquema). La complejidad computacional y el tama\u00f1o de los modelos empleados por estos algoritmos son elevados, por lo que en su mayor\u00eda se ejecutan ( online ) en servidores Cloud . No obstante, debido a razones de eficiencia energ\u00e9tica, ancho de banda, latencia y privacidad se est\u00e1 tendiendo actualmente a trasladar parte de este procesamiento a los propios nodos. Wake-Up Word (WUW) Por ejemplo, para llevar a cabo el reconocimiento de habla, los asistentes virtuales utilizan, en su mayor\u00eda, algoritmos de detecci\u00f3n de palabras clave despertador (Wake-Up Word) para detectar el comienzo de un enunciado por parte del usuario. Estos algoritmos, de menor complejidad que otros, se ejecutan offline en el propio dispositivo ( smartphone , altavoz inteligente, etc.) lo que permite una mayor eficiencia y privacidad, ya que no es necesario transferir todo el audio al Cloud . Es preciso se\u00f1alar que, puesto que se est\u00e1n ejecutando constantemente, la complejidad computacional y la energ\u00eda requeridas por estos algoritmos debe ser las menores posibles. Esto se consigue limitando su capacidad de identificaci\u00f3n a una sola palabra o como m\u00e1ximo una \u00fanica frase, generalmente corta. Reconocimiento del habla (ASR/STT) El reconocimiento del habla, tambi\u00e9n denominado reconocimiento autom\u00e1tico de voz, o en ingl\u00e9s Automatic Speech Recognition ( ASR ) o tambi\u00e9n Speech To Text ( STT ) consiste en, dado un enunciado delimitado por WUW o por otro evento (como la pulsaci\u00f3n de un bot\u00f3n en el caso de push to talk ), transcribirlo a texto para su posterior procesamiento (transcripci\u00f3n, traducci\u00f3n, sistemas de respuesta autom\u00e1tica, etc.). La complejidad computacional y el tama\u00f1o de los modelos empleados suponen un obst\u00e1culo para su procesamiento offline en la mayor parte de nodos IoT, exceptuando smartphones o dispositivos de similares prestaciones aparte para los que existen algunas implementaciones viables. Wordspotting En determinados contextos, como los dispositivos controlados por comandos de voz ( voice command device , VCD) no es necesario llevar a cabo un reconocimiento completo del habla y tan s\u00f3lo es necesario identificar un peque\u00f1o conjunto de palabras clave (comandos), lo que se conoce con el t\u00e9rmino gen\u00e9rico de wordspotting o keyword spotting . Este tipo algoritmos, aunque m\u00e1s complejos que la detecci\u00f3n de WUW , son mucho m\u00e1s sencillos que los ASR / STT y con frecuencia pueden ejecutarse offline incluso en peque\u00f1os microcontroladores. Espectrogramas y MFCCs Todos los algoritmos de procesamiento de voz se basan en el uso de espectrogramas que son una representaci\u00f3n gr\u00e1fica (3D) del contenido frecuencial de una se\u00f1al a lo largo del tiempo. El proceso de obtenci\u00f3n de un espectrograma adecuado para el procesamiento de voz ser\u00eda el siguiente: Pre-emphasis : pre-amplificaci\u00f3n (opcional) de las componentes de alta frecuencia de la se\u00f1al de audio. Framing : divisi\u00f3n de la se\u00f1al en un cierto n\u00famero ( nFrames ) de ventanas temporales, habitualmente de entre 20 y 40 ms de duraci\u00f3n. Windowing : consiste en la aplicaci\u00f3n de una funci\u00f3n ventana a cada frame . Transformaci\u00f3n y c\u00e1lculo de la densidad espectral : consiste en el c\u00e1lculo de la Transformada de Fourier de Tiempo Reducido ( Short-Time Fourier-Transform o STFT ) para cada frame . MEL scale mapping : aplicaci\u00f3n de un banco de filtros ( nFilters ) correspondientes a la Escala de Mel al espectro obtenido en el paso anterior. Normalizaci\u00f3n : aplicaci\u00f3n de la Transformada Discreta de Coseno ( DCT ) y normalizaci\u00f3n mediante la resta de la media. El espectrograma resultante es lo que se conoce como Coe\ufb01cientes Cepstrales en las Frecuencias de Mel o MFCCs (Mel Frequency Cepstral Coe\ufb03cients) y es la entrada que suelen emplear los algoritmos de procesamiento de voz. Nota Cabe mencionar que dependiendo de algoritmo empleado es posible usar directamente el espectrograma resultante del paso 5. Tarea (opcional) Para entender este proceso seguir el ejemplo del art\u00edculo \"Speech Processing for Machine Learning: Filter banks, Mel-Frequency Cepstral Coefficients (MFCCs) and What's In-Between\" de Haytham M. Fayek Reconocimiento de palabras clave y redes neuronales Como hemos visto previamente los espectrogramas proporcionan una representaci\u00f3n gr\u00e1fica 3D a partir de una se\u00f1al de audio, lo que ofrece la posibilidad de llevar a cabo el reconocimiento de palabras clave mediante CNNs similares a las empleadas en el reconocimiento de im\u00e1genes. Ejemplo sencillo de CNN para el reconocimiento de palabras clave El siguiente tutorial ilustra el proceso construcci\u00f3n de una CNN sencilla para el reconocimiento de 10 palabras, empleando para el entrenamiento un subconjunto de la base de datos \"Speech Commands: A Dataset for Limited-Vocabulary Speech Recognition\" y empleado las utilidades propias de Tensorflow para la decodificaci\u00f3n de los ficheros audio y la generaci\u00f3n de los espectrogramas. Tarea (opcional) Seguir el tutorial. Tarea (opcional) Convertir el modelo entrenado a TFLite, cuantizarlo y ejecutarlo en el acelerador Coral USB. Coral KWS El proyecto Coral Keyword Spotter (KWS) proporciona un modelo pre-entrenado de un reconocedor de 140 palabras clave listo para su uso con Edge TPU as\u00ed como scripts que ilustran su uso. Tarea Siguiendo la documentaci\u00f3n del proyecto probar el modelo y medir los tiempo de inferencia. Tarea Adaptar los scripts de Coral KWS para enviar los comandos a un broker MQTT y posteriormente visualizarlos en un dashboard (por ejemplo, hacer subir o bajar un curva, cambiar iluminaci\u00f3n, girar las manecillas de un reloj, etc. todo controlado por voz a distancia). Algunas herramientas A continuaci\u00f3n se enumeran algunas de las principales opciones para procesamiento de voz offline. Keyword spotting / Wake-Up-Word Pocketsphinx Porcupine Snowboy Mycroft Precise Speech to text Pocketsphinx Kaldi DeepSpeech Tarea (opcional) Probar algunas de estas herramientas en la Raspberry Pi 4. Algunas referencias Santosh Singh, \"How speech-to-text/voice recognition is making an impact on IoT development\" , Featured, Internet Of Things, 2018. Yuan Shangguan, Jian Li, Qiao Liang, Raziel Alvarez, Ian McGraw, \"Optimizing Speech Recognition For The Edge\" , https://arxiv.org/abs/1909.12408 Thibault Gisselbrecht, Joseph Dureau, \"Machine Learning on Voice: a gentle introduction with Snips Personal Wake Word Detector\" , Snips Blog, May 2 2018. Haytham M. Fayek, \"Speech Processing for Machine Learning: Filter banks, Mel-Frequency Cepstral Coefficients (MFCCs) and What's In-Between\" , 2016.","title":"Laboratorio 5. Comandos por voz"},{"location":"LSI/Lab5/#laboratorio-5-comandos-por-voz","text":"","title":"Laboratorio 5. Comandos por voz"},{"location":"LSI/Lab5/#objetivos","text":"Familiarizarse con el procesamiento de voz en nodos AI-IoT Configurar un interfaz por voz offline/on-device para detecci\u00f3n de comandos de voz Usar el acelerador Coral USB para dicho procesamiento Integrar procesamiento con voz en una soluci\u00f3n IoT gen\u00e9rica","title":"Objetivos"},{"location":"LSI/Lab5/#introduccion","text":"","title":"Introducci\u00f3n"},{"location":"LSI/Lab5/#procesamiento-de-voz","text":"Hoy en d\u00eda el procesamiento digital de la voz es empleado en m\u00faltiples \u00e1mbitos, siendo tal vez uno de los m\u00e1s extendidos el de los asistentes de voz virtuales (Amazon Alexa, Google Assitant, Apple Siri, ...). En su mayor\u00eda estos sistemas combinan diversas t\u00e9cnicas de inteligencia artificial para proporcionar un dialogo hablado con el usuario (ver esquema). La complejidad computacional y el tama\u00f1o de los modelos empleados por estos algoritmos son elevados, por lo que en su mayor\u00eda se ejecutan ( online ) en servidores Cloud . No obstante, debido a razones de eficiencia energ\u00e9tica, ancho de banda, latencia y privacidad se est\u00e1 tendiendo actualmente a trasladar parte de este procesamiento a los propios nodos.","title":"Procesamiento de voz"},{"location":"LSI/Lab5/#wake-up-word-wuw","text":"Por ejemplo, para llevar a cabo el reconocimiento de habla, los asistentes virtuales utilizan, en su mayor\u00eda, algoritmos de detecci\u00f3n de palabras clave despertador (Wake-Up Word) para detectar el comienzo de un enunciado por parte del usuario. Estos algoritmos, de menor complejidad que otros, se ejecutan offline en el propio dispositivo ( smartphone , altavoz inteligente, etc.) lo que permite una mayor eficiencia y privacidad, ya que no es necesario transferir todo el audio al Cloud . Es preciso se\u00f1alar que, puesto que se est\u00e1n ejecutando constantemente, la complejidad computacional y la energ\u00eda requeridas por estos algoritmos debe ser las menores posibles. Esto se consigue limitando su capacidad de identificaci\u00f3n a una sola palabra o como m\u00e1ximo una \u00fanica frase, generalmente corta.","title":"Wake-Up Word (WUW)"},{"location":"LSI/Lab5/#reconocimiento-del-habla-asrstt","text":"El reconocimiento del habla, tambi\u00e9n denominado reconocimiento autom\u00e1tico de voz, o en ingl\u00e9s Automatic Speech Recognition ( ASR ) o tambi\u00e9n Speech To Text ( STT ) consiste en, dado un enunciado delimitado por WUW o por otro evento (como la pulsaci\u00f3n de un bot\u00f3n en el caso de push to talk ), transcribirlo a texto para su posterior procesamiento (transcripci\u00f3n, traducci\u00f3n, sistemas de respuesta autom\u00e1tica, etc.). La complejidad computacional y el tama\u00f1o de los modelos empleados suponen un obst\u00e1culo para su procesamiento offline en la mayor parte de nodos IoT, exceptuando smartphones o dispositivos de similares prestaciones aparte para los que existen algunas implementaciones viables.","title":"Reconocimiento del habla (ASR/STT)"},{"location":"LSI/Lab5/#wordspotting","text":"En determinados contextos, como los dispositivos controlados por comandos de voz ( voice command device , VCD) no es necesario llevar a cabo un reconocimiento completo del habla y tan s\u00f3lo es necesario identificar un peque\u00f1o conjunto de palabras clave (comandos), lo que se conoce con el t\u00e9rmino gen\u00e9rico de wordspotting o keyword spotting . Este tipo algoritmos, aunque m\u00e1s complejos que la detecci\u00f3n de WUW , son mucho m\u00e1s sencillos que los ASR / STT y con frecuencia pueden ejecutarse offline incluso en peque\u00f1os microcontroladores.","title":"Wordspotting"},{"location":"LSI/Lab5/#espectrogramas-y-mfccs","text":"Todos los algoritmos de procesamiento de voz se basan en el uso de espectrogramas que son una representaci\u00f3n gr\u00e1fica (3D) del contenido frecuencial de una se\u00f1al a lo largo del tiempo. El proceso de obtenci\u00f3n de un espectrograma adecuado para el procesamiento de voz ser\u00eda el siguiente: Pre-emphasis : pre-amplificaci\u00f3n (opcional) de las componentes de alta frecuencia de la se\u00f1al de audio. Framing : divisi\u00f3n de la se\u00f1al en un cierto n\u00famero ( nFrames ) de ventanas temporales, habitualmente de entre 20 y 40 ms de duraci\u00f3n. Windowing : consiste en la aplicaci\u00f3n de una funci\u00f3n ventana a cada frame . Transformaci\u00f3n y c\u00e1lculo de la densidad espectral : consiste en el c\u00e1lculo de la Transformada de Fourier de Tiempo Reducido ( Short-Time Fourier-Transform o STFT ) para cada frame . MEL scale mapping : aplicaci\u00f3n de un banco de filtros ( nFilters ) correspondientes a la Escala de Mel al espectro obtenido en el paso anterior. Normalizaci\u00f3n : aplicaci\u00f3n de la Transformada Discreta de Coseno ( DCT ) y normalizaci\u00f3n mediante la resta de la media. El espectrograma resultante es lo que se conoce como Coe\ufb01cientes Cepstrales en las Frecuencias de Mel o MFCCs (Mel Frequency Cepstral Coe\ufb03cients) y es la entrada que suelen emplear los algoritmos de procesamiento de voz. Nota Cabe mencionar que dependiendo de algoritmo empleado es posible usar directamente el espectrograma resultante del paso 5. Tarea (opcional) Para entender este proceso seguir el ejemplo del art\u00edculo \"Speech Processing for Machine Learning: Filter banks, Mel-Frequency Cepstral Coefficients (MFCCs) and What's In-Between\" de Haytham M. Fayek","title":"Espectrogramas y MFCCs"},{"location":"LSI/Lab5/#reconocimiento-de-palabras-clave-y-redes-neuronales","text":"Como hemos visto previamente los espectrogramas proporcionan una representaci\u00f3n gr\u00e1fica 3D a partir de una se\u00f1al de audio, lo que ofrece la posibilidad de llevar a cabo el reconocimiento de palabras clave mediante CNNs similares a las empleadas en el reconocimiento de im\u00e1genes.","title":"Reconocimiento de palabras clave y redes neuronales"},{"location":"LSI/Lab5/#ejemplo-sencillo-de-cnn-para-el-reconocimiento-de-palabras-clave","text":"El siguiente tutorial ilustra el proceso construcci\u00f3n de una CNN sencilla para el reconocimiento de 10 palabras, empleando para el entrenamiento un subconjunto de la base de datos \"Speech Commands: A Dataset for Limited-Vocabulary Speech Recognition\" y empleado las utilidades propias de Tensorflow para la decodificaci\u00f3n de los ficheros audio y la generaci\u00f3n de los espectrogramas. Tarea (opcional) Seguir el tutorial. Tarea (opcional) Convertir el modelo entrenado a TFLite, cuantizarlo y ejecutarlo en el acelerador Coral USB.","title":"Ejemplo sencillo de CNN para el reconocimiento de palabras clave"},{"location":"LSI/Lab5/#coral-kws","text":"El proyecto Coral Keyword Spotter (KWS) proporciona un modelo pre-entrenado de un reconocedor de 140 palabras clave listo para su uso con Edge TPU as\u00ed como scripts que ilustran su uso. Tarea Siguiendo la documentaci\u00f3n del proyecto probar el modelo y medir los tiempo de inferencia. Tarea Adaptar los scripts de Coral KWS para enviar los comandos a un broker MQTT y posteriormente visualizarlos en un dashboard (por ejemplo, hacer subir o bajar un curva, cambiar iluminaci\u00f3n, girar las manecillas de un reloj, etc. todo controlado por voz a distancia).","title":"Coral KWS"},{"location":"LSI/Lab5/#algunas-herramientas","text":"A continuaci\u00f3n se enumeran algunas de las principales opciones para procesamiento de voz offline. Keyword spotting / Wake-Up-Word Pocketsphinx Porcupine Snowboy Mycroft Precise Speech to text Pocketsphinx Kaldi DeepSpeech Tarea (opcional) Probar algunas de estas herramientas en la Raspberry Pi 4.","title":"Algunas herramientas"},{"location":"LSI/Lab5/#algunas-referencias","text":"Santosh Singh, \"How speech-to-text/voice recognition is making an impact on IoT development\" , Featured, Internet Of Things, 2018. Yuan Shangguan, Jian Li, Qiao Liang, Raziel Alvarez, Ian McGraw, \"Optimizing Speech Recognition For The Edge\" , https://arxiv.org/abs/1909.12408 Thibault Gisselbrecht, Joseph Dureau, \"Machine Learning on Voice: a gentle introduction with Snips Personal Wake Word Detector\" , Snips Blog, May 2 2018. Haytham M. Fayek, \"Speech Processing for Machine Learning: Filter banks, Mel-Frequency Cepstral Coefficients (MFCCs) and What's In-Between\" , 2016.","title":"Algunas referencias"},{"location":"RPI-I/P1/","text":"Pr\u00e1ctica 1. Introducci\u00f3n al entorno de desarrollo ESP-IDF Objetivos Conocer el entorno de desarrollo para el ESP32 Ser capaz de compilar, flashear y monitorizar proyectos sencillos basados en ESP-IDF Entender el funcionamiento b\u00e1sico de una aplicaci\u00f3n ESP-IDF que haga uso de las capacidades WiFi del ESP32 Personalizar variables de configuraci\u00f3n de proyectos ESP-IDF Responder a eventos b\u00e1sicos de red en ESP-IDF Entregable Se entregar\u00e1 un zip (o similar) con: Un breve informe en pdf describiendo el trabajo realizado y los resultados observados/obtenidos. El c\u00f3digo desarrollado para cada uno de los ejercicos de la pr\u00e1ctica. Introducci\u00f3n ESP-IDF ( Espressif IoT Development Framework ) es el entorno de desarrollo oficial de Espressif para los SoCs ESP32 y ESP32-S. Este entorno de desarrollo y conjunto de herramientas permite desarrollar firmwares eficientes para dichas placas utilizando las interfaces de comunicaci\u00f3n WiFi y Bluetooth, as\u00ed como gestionar m\u00faltiples caracter\u00edsticas de los SoCs que iremos desgranando en futuras pr\u00e1cticas. ESP-IDF utiliza como base FreeRTOS pero a\u00f1ade multitud de componentes que, por ejemplo, implementan los protocolos de comunicaci\u00f3n de bajo y alto nivel, usados en los proyectos de Internet de las Cosas. \u00c9sta pr\u00e1ctica es una introducci\u00f3n b\u00e1sica a la puesta en marcha del entorno de desarrollo ESP-IDF. Adem\u00e1s, veremos de forma superficial la estructura b\u00e1sica de un programa sencillo desarrollado usando ESP-IDF, as\u00ed como ejemplos b\u00e1sicos para la puesta en marcha de la interfaz WiFi sobre una placa ESP32. VSCode y plugin de Espressif para ESP-IDF Utilizaremos Visual Studio Code como entorno de desarrollo integrado. Este entorno tiene una organizaci\u00f3n sencilla, como un editor de textos simple, pero es ampliamente configurable con un sistema de plugins f\u00e1ciles de instalar y configurar. Lo primero que tendremos que hacer es instalar en nuestro equipo el Visual Studio Code (en los puestos de laboratorio ya est\u00e1 instalado). Una vez instalado, pulsaremos el bot\u00f3n de extensiones en el panel izquierdo: o pulsaremos Ctrl+Shift+X. En el cuadro de texto que nos muestra escribiremos el nombre de la extensi\u00f3n que queremos instalar, en este caso Espressif ESP-IDF. Seleccionamos la extensi\u00f3n y la instalamos (en los puestos de laboratorio ya est\u00e1 instalado). Esto tardar\u00e1 un poco porque nos instalar\u00e1 tambi\u00e9n el toolchain de espressif. Asimismo, deberemos seguir las instrucciones para instalar las herramientas adicionales necesarias en nuestro equipo. Para ello, pulsando en la extensi\u00f3n que acabamos de instalar se abrir\u00e1 otra pesata\u00f1a, buscamos el apartado How to use y seguimos las instrucciones para la instalaci\u00f3n de las herramientas necesarias en nuestro sistema operativo. En los sistemas Linux, es necesario, en todo caso, que el usuario que est\u00e9s utilizando pertenezca al grupo dialout . Para ello puedes editar el fichero /etc/group a\u00f1adiendo a tu usuario a la l\u00ednea que indica el grupo correspondiente, e iniciando de nuevo tu sesi\u00f3n, o puedes utilizar el comando adduser: sudo adduser ubuntu dialout Despu\u00e9s tendr\u00e1s que salir de la sesi\u00f3n y volver a entrar para que el nuevo grupo est\u00e9 tenido en cuenta. En los sistemas Windows es necesario seguir estas instrucciones si queremos poder depurar en circuito usando el controlador jtag integrado en las placas esp devkit rust con esp32c3. Instalaci\u00f3n manual de las herramientas de ESP-IDF y uso desde terminal Otra opci\u00f3n es instalar manualmente las herramientas de Espressif siguiendo las instrucciones de su Gu\u00eda de inicio . Si queremos usar las herramientas de espressif dir\u00e9ctamente desde el terminal de comandos debemos recordar que tenemos que importar las variables de entorno antes de usar las herramientas. Para ello se proporciona un script ( export.sh ) disponible en la ruta en la que hayas instalado las herramientas (~/esp/esp-idf por defecto). Entonces, desde dicho directorio ejecutamos: source export.sh Puedes a\u00f1adir esta l\u00ednea en cualquier fichero de inicio de sesi\u00f3n para no tener que ejecutar el comando cada vez. Por ejemplo, puedes editar el fichero $HOME/.bashrc, y a\u00f1adir al final de dicho fichero la l\u00ednea: source $HOME/esp/esp-idf/export.sh Si has seguido todos estos pasos correctamente deber\u00edas tener acceso a un programa llamado idf.py . Compru\u00e9balo por ejemplo pidiendo la versi\u00f3n del comando (el n\u00famero de subversi\u00f3n podr\u00eda variar en tu salida): $ idf.py --version ESP-IDF v4.1-332-g7b7c64107 Proyecto de ejemplo En esta primera parte, nos basaremos en un ejemplo sencillo de c\u00f3digo desarrollado en base a ESP-IDF. No es el objetivo de esta pr\u00e1ctica analizar en detalle la estructura de dicho c\u00f3digo, sino utilizarlo para ilustrar el flujo de trabajo t\u00edpico en un proyecto ESP-IDF. Para empezar crearemos en nuestro sistema una carpeta para almacenar nuestros proyectos y abriremos dicha carpeta con Visual Studio Code. Despu\u00e9s crearemos en esta carpeta un proyecto a partir de uno de los ejemplos que vienen con el sdk de espressif, concretamente el ejemplo hello_world . Desde Visual Studio Code podemos pulsar la combinaci\u00f3n de teclas Shift+Ctrl+P, lo que nos abre la paleta de comandos en la parte central superior de la ventana. En ella escribiremos ESP-IDF, para filtrar las opciones de ESP-IDF, y buscaremos la entrada ESP-IDF: Show Examples Projects . Al seleccionarla nos abrir\u00e1 una pesta\u00f1a con los ejemplos que vienen con el SDK. Seleccionamos el ejemplo Hello World y, cuando nos pregunte, la carpeta donde queremos guardar el proyecto. Esto copiar\u00e1 el ejemplo que viene con las herramientas (~/esp/esp-idf/examples por defecto) a nuestra carpeta de trabajo. Compilaci\u00f3n Para compilar el proyecto desde Visual Studio Code basta con pulsar el bot\u00f3n de compilaci\u00f3n en la barra inferior de comandos: Otras opciones son seleccionar la opci\u00f3n ESP-IDF: Build Project en la paleta de comandos o usar la combinaci\u00f3n Ctrl+E seguido de B. Finalmente, otra opci\u00f3n es utilizar el comando idf.py desde cualquier terminal: idf.py build Si todo ha ido bien, en el directorio build se habr\u00e1n generado los objetos y binarios listos para ser flasheados en el ESP32. Volcado a memoria flash ( Flasheado ) Para programar la placa del ESP32 podemos pulsar el bot\u00f3n de flash de la barra de comandos, seleccionar la opci\u00f3n ESP-IDF: Flash your project o pulsar Ctrl+E seguido de F. Asimismo, podemos usar la herramienta idf.py desde un terminal: idf.py -p PUERTO flash En este punto, el ESP32 debe estar conectado utilizando el cable microUSB, y si est\u00e1s trabajando en una m\u00e1quina virtual, debe haberse hecho visible a la misma (por ejemplo, en VirtualBox, a trav\u00e9s del men\u00fa Dispositivos->USB->Silicon Labs USB to UART Bridge Controller ). En un sistema Linux la salida del comando dmesg tras la conexi\u00f3n del dispositivo te proporcionar\u00e1 informaci\u00f3n sobre el PUERTO que debes utilizar en el proceso de flasheado y montorizaci\u00f3n posterior. Monitorizaci\u00f3n Podemos monitorizar la salida est\u00e1ndar del programa que se est\u00e1 ejecutando en el ESP32, utilizando el puerto serie virtual creado al conectar el dispositivo al equipo. Desde el Visual Studio Code podemos pulsar el bot\u00f3n de monitorizaci\u00f3n en la barra de comandos de IDF (el que parece una pantalla) para comenzar a ver la salida est\u00e1ndar en el terminal integrado. Alternativamente podemos ejecutar el comando ESP-IDF: Monitor your device en la paleta de comandos o ejecutar en el terminal el comando: idf.py -p PUERTO monitor An\u00e1lisis de un proyecto sencillo ( Hola, mundo ) en ESP-IDF Observa la estructura general del directorio hello_world que compilaste anteriormente. Espec\u00edficamente, nos interesar\u00e1 inspeccionar la estructura b\u00e1sica de un programa principal para ESP-IDF, en este caso hello_world_main.c . #include <stdio.h> #include \"sdkconfig.h\" #include \"freertos/FreeRTOS.h\" #include \"freertos/task.h\" #include \"esp_system.h\" #include \"esp_spi_flash.h\" void app_main(void) { printf(\"Hello world!\\n\"); /* Print chip information */ esp_chip_info_t chip_info; esp_chip_info(&chip_info); printf(\"This is %s chip with %d CPU cores, WiFi%s%s, \", CONFIG_IDF_TARGET, chip_info.cores, (chip_info.features & CHIP_FEATURE_BT) ? \"/BT\" : \"\", (chip_info.features & CHIP_FEATURE_BLE) ? \"/BLE\" : \"\"); printf(\"silicon revision %d, \", chip_info.revision); printf(\"%dMB %s flash\\n\", spi_flash_get_chip_size() / (1024 * 1024), (chip_info.features & CHIP_FEATURE_EMB_FLASH) ? \"embedded\" : \"external\"); printf(\"Minimum free heap size: %d bytes\\n\", esp_get_minimum_free_heap_size()); for (int i = 10; i >= 0; i--) { printf(\"Restarting in %d seconds...\\n\", i); vTaskDelay(1000 / portTICK_PERIOD_MS); } printf(\"Restarting now.\\n\"); fflush(stdout); esp_restart(); } A alto nivel, la funci\u00f3n app_main es el punto de entrada a todo programa desarrollado usando ESP-IDF. De modo m\u00e1s espec\u00edfico, tras la carga del sistema , la llamada tarea principal ( main task ) ejecuta el c\u00f3digo proporcionado por el usuario e implementado en la funci\u00f3n app_main . Tanto el tama\u00f1o de pila asignado como la prioridad de esta tarea puede ser configuradas por el desarrollador a trav\u00e9s del sistema de configuraci\u00f3n de ESP-IDF (lo veremos m\u00e1s adelante). Normalmente, esta funci\u00f3n se utiliza para llevar a cabo tareas iniciales de configuraci\u00f3n o para crear y lanzar a ejecuci\u00f3n otras tareas. Se puede implementar cualquier funcionalidad dentro de la funci\u00f3n app_main o invocar a otras funciones que la implementen. En este ejemplo, se muestra en primer lugar informaci\u00f3n gen\u00e9rica sobre el SoC que est\u00e1 ejecutando el firmware : /* Print chip information */ esp_chip_info_t chip_info; esp_chip_info(&chip_info); printf(\"This is %s chip with %d CPU cores, WiFi%s%s, \", CONFIG_IDF_TARGET, chip_info.cores, (chip_info.features & CHIP_FEATURE_BT) ? \"/BT\" : \"\", (chip_info.features & CHIP_FEATURE_BLE) ? \"/BLE\" : \"\"); printf(\"silicon revision %d, \", chip_info.revision); printf(\"%dMB %s flash\\n\", spi_flash_get_chip_size() / (1024 * 1024), (chip_info.features & CHIP_FEATURE_EMB_FLASH) ? \"embedded\" : \"external\"); printf(\"Minimum free heap size: %d bytes\\n\", esp_get_minimum_free_heap_size()); A continuaci\u00f3n, dentro de un bucle sencillo, el sistema muestra un mensaje y despu\u00e9s suspende su ejecuci\u00f3n por un determinado per\u00edodo de tiempo utilizando la funci\u00f3n de FreeRTOS vTaskDelay . Esta funci\u00f3n recibe como par\u00e1metro el n\u00famero de ticks de reloj que se desea suspender la ejecuci\u00f3n de la tarea, que puede calcularse dividiendo el tiempo que deseamos suspender la tarea por lo que la duraci\u00f3n de un tick . FreeRTOS proporciona la constante portTIC_PERIOD_MS , que nos da la duraci\u00f3n en milisegundos de un tick : for (int i = 10; i >= 0; i--) { printf(\"Restarting in %d seconds...\\n\", i); vTaskDelay(1000 / portTICK_PERIOD_MS); } Finalmente, la tarea reinicia el sistema tras la finalizaci\u00f3n de la tarea principal: printf(\"Restarting now.\\n\"); fflush(stdout); esp_restart(); Ejercicio 1 Modifica el per\u00edodo de suspensi\u00f3n de la tarea para que sea mayor o menor, y comprueba que efectivamente esto modifica el comportamiento del firmware cargado. Ejercicio 2 Modifica el programa para que se compruebe debidamente si el SoC tiene capacidades WiFi y muestre la informaci\u00f3n correspondiente por la salida est\u00e1ndar (para ello, puedes consultar la siguiente p\u00e1gina ). Creaci\u00f3n de tareas El anterior proyecto puede replantearse para que no sea la tarea principal la que ejecute la l\u00f3gica del programa. Para ello, es necesario introducir brevemente la API b\u00e1sica para la gesti\u00f3n de tareas (en nuestro caso s\u00f3lo necesitamos crear una tarea). Ver\u00e1s muchos m\u00e1s detalles sobre esta API en la asignatura ANIOT, por lo que no veremos aqu\u00ed m\u00e1s detalles de los estrictamente necesarios. La funci\u00f3n xTaskCreate (incluida en task.h ) permite la creaci\u00f3n de nuevas tareas: BaseType_t xTaskCreate( TaskFunction_t pvTaskCode, const char * const pcName, configSTACK_DEPTH_TYPE usStackDepth, void *pvParameters, UBaseType_t uxPriority, TaskHandle_t *pxCreatedTask ); Concretamente, crea una nueva tarea y la a\u00f1ade a la lista de tareas listas para ejecuci\u00f3n, recibiendo como par\u00e1metros: pvTaskCode : La direcci\u00f3n de la funci\u00f3n de entrada para la tarea. Las tareas suelen implementarse como un bucle infinito. No deberen retornar de la funci\u00f3n de entrada ni finalizar abruptamente. Para finalizar correctamente una tarea \u00e9sta debe ejecutar la funci\u00f3n vTaskDelete con el par\u00e1metro NULL. Alternativamente, puede usarse esta funci\u00f3n para matar otra tarea, pas\u00e1ndo como argumento a vTaskDelete la direcci\u00f3n del manejador inicializado en el proceso de creaci\u00f3n (\u00faltimo par\u00e1metro en la creaci\u00f3n). Por ejemplo, la siguiente funci\u00f3n presenta un esquema de c\u00f3digo correcto para la funci\u00f3n de entrada de una tarea en FreeRTOS. void vATaskFunction( void *pvParameters ) { for( ;; ) { -- Task application code here. -- } /* Tasks must not attempt to return from their implementing function or otherwise exit. In newer FreeRTOS ports attempting to do so will result in an configASSERT() being called if it is defined. If it is necessary for a task to exit then have the task call vTaskDelete( NULL ) to ensure its exit is clean. */ vTaskDelete( NULL ); } pcName : Nombre (en forma de cadena) descriptivo de la tarea a ejecutar, t\u00edpicamente usado en tiempo de depuraci\u00f3n. usStackDepth : N\u00famero de palabras a alojar para utilizar como pila para la tarea. pvParameters : Par\u00e1metros a proporcionar a la funci\u00f3n de entrada para la tarea. uxPriority : Prioridad asignada a la tarea. pxCreatedTask : Manejador opcional para la tarea. As\u00ed, la funcionalidad del programa Hola, mundo que hemos analizado anteriormente, podr\u00eda reestrcturarse en base a una \u00fanica tarea, cuya funci\u00f3n de entrada podr\u00eda ser (al reiniciar el sistema no necesitamos terminar correctamente la tarea ejecutando vTaskDelete ): void hello_task(void *pvParameter) { printf(\"Hello world!\\n\"); for (int i = 10; i >= 0; i--) { printf(\"Restarting in %d seconds...\\n\", i); vTaskDelay(1000 / portTICK_RATE_MS); } printf(\"Restarting now.\\n\"); fflush(stdout); esp_restart(); } La funci\u00f3n app_main se limitar\u00eda entonces a crear la tarea: void app_main() { nvs_flash_init(); xTaskCreate( &hello_task, \"hello_task\", 2048, NULL, 5, NULL ); } Ejercicio 3 Implementa una modificaci\u00f3n del programa hello_world que implemente y planifique dos tareas independientes con distinta funcionalidad (en este caso, es suficiente con mostrar por pantalla alg\u00fan mensaje) y distintos tiempos de suspensi\u00f3n. Comprueba que, efectivamente, ambas tareas se ejecutan concurrentemente. Personalizaci\u00f3n del proyecto ESP-IDF utiliza la biblioteca kconfiglib para proporcionar un sistema de configuracion de proyectos en tiempo de compilaci\u00f3n sencillo y extensible. Para ilustrar su funcionamiento, utilizaremos el ejemplo blink que puedes encontrar en la distribuci\u00f3n de ESP-IDF. Crea un nuevo proyecto a partir de dicho ejemplo. Para configurar un proyecto ESP-IDF se puede pulsar el bot\u00f3n ESP-IDF SDC Configuration Editor en la barra de comandos de IDF, o bien ejecutando dicho comando en la paleta de comandos de VSCode o ejecutando el comando menuconfig en el terminal: idf.py menuconfig Al ejecutar el comando se nos mostrar\u00e1 un men\u00fan por el que podremos navegar usando el rat\u00f3n (o las teclas del cursor si lo ejecutamos desde terminal). El men\u00fa nos presenta unas opciones de car\u00e1cter general, que permitir\u00e1n configurar las caracter\u00edsticas espec\u00edficas del proyecto a compilar (por ejemplo, seleccionando los componentes que deseemos habilitar en la construcci\u00f3n del mismo). Nota Navega por las opciones que aparecen en los men\u00fas de configuraci\u00f3n para familiarizarte con ellos. Aprende a utilizar el men\u00fa de configuraci\u00f3n, pues lo utilizar\u00e1s en futuras pr\u00e1cticas. En el proyecto blink , observa que una de las opciones del men\u00fa de navegaci\u00f3n, llamada Example configuration , incluye una opci\u00f3n llamada Blink GPIO number . Esta entrada define el n\u00famero de pin GPIO al que se conecta el LED que el programa har\u00e1 parpadear. Esta opci\u00f3n de configuraci\u00f3n definir\u00e1 en tiempo de compilaci\u00f3n el valor de una constante llamada CONFIG_BLINK_GPIO , que podemos utilizar en el c\u00f3digo para obtener el valor que le haya asignado el usuario durante la configuraci\u00f3n del proyecto. Nota Observa el uso que da el c\u00f3digo del proyecto blink a la constante CONFIG_BLINK_GPIO . Esta opci\u00f3n de configuraci\u00f3n no forma parte de las opciones por defecto de ESP-IDF, sino que ha sido a\u00f1adida por los desarrolladores del proyecto blink . Observa y estudia el formato y contenido del fichero main/Kconfig.projbuild que se proporciona como parte del fichero. En \u00e9l, se definen las caracter\u00edsticas (nombre, rango, valor por defecto y descripcion) de la opci\u00f3n de configuraci\u00f3n a definir. Ejercicio 4 Modifica el proyecto hello_world para que defina dos opciones de configuraci\u00f3n que permit\u00e1n definir el tiempo de espera de cada una de las dos tareas que hayas definido en tu anterior soluci\u00f3n. Haz uso de ellas en tu c\u00f3digo y comprueba que efectivamente su modificaci\u00f3n a trav\u00e9s del sistema de men\u00fas permite una personalizaci\u00f3n del comportamiento de tus c\u00f3digos. Escaneado de redes WiFi A modo de ejemplo, y en preparaci\u00f3n para los c\u00f3digos con los que trabajaremos en futuras pr\u00e1cticas, vamos a analizar a continuaci\u00f3n un ejemplo concreto de firmware cuya tarea es el escaneado de redes inal\u00e1mbricas al alcance del ESP32, y su reporte a trav\u00e9s de su salida est\u00e1ndar (que podremos ver gracias a la facilidad de monitorizaci\u00f3n del programa). Para cada red escaneada, se reportar\u00e1n sus caracter\u00edsticas principales. Tarea Compila, flashea y monitoriza el ejemplo scan situado en el directorio examples/wifi/scan . Crea un nuevo proyecto a partir de este ejemplo y amplia el n\u00famero m\u00e1ximo de redes a escanear a 20 a trav\u00e9s del men\u00fa de configuraci\u00f3n del ejemplo. Crea un punto de acceso WiFi con tu tel\u00e9fono m\u00f3vil y observa que, efectivamente, es escaneado por el ejemplo. Observa su funcionamiento. El firmware simplemente escanea un subconjunto de las redes disponibles, reportando algunas de sus caracter\u00edsticas (por ejemplo, SSID, modo de autenticaci\u00f3n o canal primario). Tarea Analiza el c\u00f3digo de la funci\u00f3n wifi_scan (tarea principal). C\u00e9ntrate especialmente en las l\u00edneas que permiten activar y configurar el escaneado de redes. Intenta entender el funcionamiento general del programa, consultando y apuntando el cometido de cada l\u00ednea, con especial inter\u00e9s a aquellas funciones con prefijo esp_wifi_* . Si tienes dudas puede consultar la documentaci\u00f3n oficial de ESP-IDF . Gesti\u00f3n de eventos de red El segundo ejemplo que estudiaremos es un programa para la conexi\u00f3n del ESP32 a un punto de acceso existente. Este ejemplo nos permitir\u00e1 observar, a grandes rasgos, el sistema de gesti\u00f3n de eventos en FreeRTOS/ESP-IDF, que permite gestionar la respuestas a eventos de red, como por ejemplo la obtenci\u00f3n de direcci\u00f3n IP o la conexi\u00f3n exitosa a un punto de acceso. Nota Crea un proyecto a partir del ejempl station situado en el directorio examples/wifi/getting_started . Compilalo, flashealo y monitoriza su salida est\u00e1ndar. Acuerdate de modificar el SSID de la red al que conectar\u00e1, as\u00ed como la contrase\u00f1a elegida a trav\u00e9s del sistema de men\u00fas de configuraci\u00f3n. Observa su funcionamiento. El firmware simplemente inicializa el dispositivo en modo station (en contraposici\u00f3n al modo Access Point , que veremos en la pr\u00f3xima sesi\u00f3n), realizando una conexi\u00f3n al punto de acceso preconfigurado a trav\u00e9s del men\u00fa de configuraci\u00f3n. Analiza el c\u00f3digo de la funci\u00f3n wifi_init_sta . Esta funci\u00f3n, que implementa la tarea principal, se divide b\u00e1sicamente en dos partes: Gesti\u00f3n de eventos . Observa el mecanismo mediante el cual se registra y se asocia la recepci\u00f3n de un evento a la ejecuci\u00f3n de un manejador o funci\u00f3n determinada. Nota Responde a la siguiente pregunta de forma razonada: \u00bfQu\u00e9 eventos se asocian a la ejecuci\u00f3n de qu\u00e9 funci\u00f3n en el firmware que est\u00e1s estudiando? Configuraci\u00f3n de la conexi\u00f3n a un punto de acceso . La configuraci\u00f3n de la conexi\u00f3n se realiza a trav\u00e9s de los campos correspondientes de una estructura de tipo wifi_config_t . Observa los campos b\u00e1sicos que necesita, c\u00f3mo fuerza el uso de WPA2 y c\u00f3mo recoge los datos de conexi\u00f3n (SSID y contrase\u00f1a) a trav\u00e9s del sistema de configuraci\u00f3n. Observa tambi\u00e9n c\u00f3mo, una vez realizadas dichas personalizaciones, inicializa el sistema de comunicaci\u00f3n inal\u00e1mbrica a trav\u00e9s de esp_wifi_start() . Consulta la documentaci\u00f3n relativa a dichas funciones y toma nota de aquellos aspectos que consideres m\u00e1s relevantes. Ejercicio 7 Modifica el firmware para que el handler de tratamiento de la obtenci\u00f3n de una direcci\u00f3n IP sea independiente del tratamiento del resto de eventos del sistema WiFi que ya se est\u00e1n considerando. Comprueba que, efectivamente sigue observ\u00e1ndose la salida asociada a dicho evento, aun cuando ambas funciones sean independientes. Entrega el c\u00f3digo modificado.","title":"Pr\u00e1ctica 1"},{"location":"RPI-I/P1/#practica-1-introduccion-al-entorno-de-desarrollo-esp-idf","text":"","title":"Pr\u00e1ctica 1. Introducci\u00f3n al entorno de desarrollo ESP-IDF"},{"location":"RPI-I/P1/#objetivos","text":"Conocer el entorno de desarrollo para el ESP32 Ser capaz de compilar, flashear y monitorizar proyectos sencillos basados en ESP-IDF Entender el funcionamiento b\u00e1sico de una aplicaci\u00f3n ESP-IDF que haga uso de las capacidades WiFi del ESP32 Personalizar variables de configuraci\u00f3n de proyectos ESP-IDF Responder a eventos b\u00e1sicos de red en ESP-IDF","title":"Objetivos"},{"location":"RPI-I/P1/#entregable","text":"Se entregar\u00e1 un zip (o similar) con: Un breve informe en pdf describiendo el trabajo realizado y los resultados observados/obtenidos. El c\u00f3digo desarrollado para cada uno de los ejercicos de la pr\u00e1ctica.","title":"Entregable"},{"location":"RPI-I/P1/#introduccion","text":"ESP-IDF ( Espressif IoT Development Framework ) es el entorno de desarrollo oficial de Espressif para los SoCs ESP32 y ESP32-S. Este entorno de desarrollo y conjunto de herramientas permite desarrollar firmwares eficientes para dichas placas utilizando las interfaces de comunicaci\u00f3n WiFi y Bluetooth, as\u00ed como gestionar m\u00faltiples caracter\u00edsticas de los SoCs que iremos desgranando en futuras pr\u00e1cticas. ESP-IDF utiliza como base FreeRTOS pero a\u00f1ade multitud de componentes que, por ejemplo, implementan los protocolos de comunicaci\u00f3n de bajo y alto nivel, usados en los proyectos de Internet de las Cosas. \u00c9sta pr\u00e1ctica es una introducci\u00f3n b\u00e1sica a la puesta en marcha del entorno de desarrollo ESP-IDF. Adem\u00e1s, veremos de forma superficial la estructura b\u00e1sica de un programa sencillo desarrollado usando ESP-IDF, as\u00ed como ejemplos b\u00e1sicos para la puesta en marcha de la interfaz WiFi sobre una placa ESP32.","title":"Introducci\u00f3n"},{"location":"RPI-I/P1/#vscode-y-plugin-de-espressif-para-esp-idf","text":"Utilizaremos Visual Studio Code como entorno de desarrollo integrado. Este entorno tiene una organizaci\u00f3n sencilla, como un editor de textos simple, pero es ampliamente configurable con un sistema de plugins f\u00e1ciles de instalar y configurar. Lo primero que tendremos que hacer es instalar en nuestro equipo el Visual Studio Code (en los puestos de laboratorio ya est\u00e1 instalado). Una vez instalado, pulsaremos el bot\u00f3n de extensiones en el panel izquierdo: o pulsaremos Ctrl+Shift+X. En el cuadro de texto que nos muestra escribiremos el nombre de la extensi\u00f3n que queremos instalar, en este caso Espressif ESP-IDF. Seleccionamos la extensi\u00f3n y la instalamos (en los puestos de laboratorio ya est\u00e1 instalado). Esto tardar\u00e1 un poco porque nos instalar\u00e1 tambi\u00e9n el toolchain de espressif. Asimismo, deberemos seguir las instrucciones para instalar las herramientas adicionales necesarias en nuestro equipo. Para ello, pulsando en la extensi\u00f3n que acabamos de instalar se abrir\u00e1 otra pesata\u00f1a, buscamos el apartado How to use y seguimos las instrucciones para la instalaci\u00f3n de las herramientas necesarias en nuestro sistema operativo. En los sistemas Linux, es necesario, en todo caso, que el usuario que est\u00e9s utilizando pertenezca al grupo dialout . Para ello puedes editar el fichero /etc/group a\u00f1adiendo a tu usuario a la l\u00ednea que indica el grupo correspondiente, e iniciando de nuevo tu sesi\u00f3n, o puedes utilizar el comando adduser: sudo adduser ubuntu dialout Despu\u00e9s tendr\u00e1s que salir de la sesi\u00f3n y volver a entrar para que el nuevo grupo est\u00e9 tenido en cuenta. En los sistemas Windows es necesario seguir estas instrucciones si queremos poder depurar en circuito usando el controlador jtag integrado en las placas esp devkit rust con esp32c3.","title":"VSCode y plugin de Espressif para ESP-IDF"},{"location":"RPI-I/P1/#instalacion-manual-de-las-herramientas-de-esp-idf-y-uso-desde-terminal","text":"Otra opci\u00f3n es instalar manualmente las herramientas de Espressif siguiendo las instrucciones de su Gu\u00eda de inicio . Si queremos usar las herramientas de espressif dir\u00e9ctamente desde el terminal de comandos debemos recordar que tenemos que importar las variables de entorno antes de usar las herramientas. Para ello se proporciona un script ( export.sh ) disponible en la ruta en la que hayas instalado las herramientas (~/esp/esp-idf por defecto). Entonces, desde dicho directorio ejecutamos: source export.sh Puedes a\u00f1adir esta l\u00ednea en cualquier fichero de inicio de sesi\u00f3n para no tener que ejecutar el comando cada vez. Por ejemplo, puedes editar el fichero $HOME/.bashrc, y a\u00f1adir al final de dicho fichero la l\u00ednea: source $HOME/esp/esp-idf/export.sh Si has seguido todos estos pasos correctamente deber\u00edas tener acceso a un programa llamado idf.py . Compru\u00e9balo por ejemplo pidiendo la versi\u00f3n del comando (el n\u00famero de subversi\u00f3n podr\u00eda variar en tu salida): $ idf.py --version ESP-IDF v4.1-332-g7b7c64107","title":"Instalaci\u00f3n manual de las herramientas de ESP-IDF y uso desde terminal"},{"location":"RPI-I/P1/#proyecto-de-ejemplo","text":"En esta primera parte, nos basaremos en un ejemplo sencillo de c\u00f3digo desarrollado en base a ESP-IDF. No es el objetivo de esta pr\u00e1ctica analizar en detalle la estructura de dicho c\u00f3digo, sino utilizarlo para ilustrar el flujo de trabajo t\u00edpico en un proyecto ESP-IDF. Para empezar crearemos en nuestro sistema una carpeta para almacenar nuestros proyectos y abriremos dicha carpeta con Visual Studio Code. Despu\u00e9s crearemos en esta carpeta un proyecto a partir de uno de los ejemplos que vienen con el sdk de espressif, concretamente el ejemplo hello_world . Desde Visual Studio Code podemos pulsar la combinaci\u00f3n de teclas Shift+Ctrl+P, lo que nos abre la paleta de comandos en la parte central superior de la ventana. En ella escribiremos ESP-IDF, para filtrar las opciones de ESP-IDF, y buscaremos la entrada ESP-IDF: Show Examples Projects . Al seleccionarla nos abrir\u00e1 una pesta\u00f1a con los ejemplos que vienen con el SDK. Seleccionamos el ejemplo Hello World y, cuando nos pregunte, la carpeta donde queremos guardar el proyecto. Esto copiar\u00e1 el ejemplo que viene con las herramientas (~/esp/esp-idf/examples por defecto) a nuestra carpeta de trabajo.","title":"Proyecto de ejemplo"},{"location":"RPI-I/P1/#compilacion","text":"Para compilar el proyecto desde Visual Studio Code basta con pulsar el bot\u00f3n de compilaci\u00f3n en la barra inferior de comandos: Otras opciones son seleccionar la opci\u00f3n ESP-IDF: Build Project en la paleta de comandos o usar la combinaci\u00f3n Ctrl+E seguido de B. Finalmente, otra opci\u00f3n es utilizar el comando idf.py desde cualquier terminal: idf.py build Si todo ha ido bien, en el directorio build se habr\u00e1n generado los objetos y binarios listos para ser flasheados en el ESP32.","title":"Compilaci\u00f3n"},{"location":"RPI-I/P1/#volcado-a-memoria-flash-flasheado","text":"Para programar la placa del ESP32 podemos pulsar el bot\u00f3n de flash de la barra de comandos, seleccionar la opci\u00f3n ESP-IDF: Flash your project o pulsar Ctrl+E seguido de F. Asimismo, podemos usar la herramienta idf.py desde un terminal: idf.py -p PUERTO flash En este punto, el ESP32 debe estar conectado utilizando el cable microUSB, y si est\u00e1s trabajando en una m\u00e1quina virtual, debe haberse hecho visible a la misma (por ejemplo, en VirtualBox, a trav\u00e9s del men\u00fa Dispositivos->USB->Silicon Labs USB to UART Bridge Controller ). En un sistema Linux la salida del comando dmesg tras la conexi\u00f3n del dispositivo te proporcionar\u00e1 informaci\u00f3n sobre el PUERTO que debes utilizar en el proceso de flasheado y montorizaci\u00f3n posterior.","title":"Volcado a memoria flash (Flasheado)"},{"location":"RPI-I/P1/#monitorizacion","text":"Podemos monitorizar la salida est\u00e1ndar del programa que se est\u00e1 ejecutando en el ESP32, utilizando el puerto serie virtual creado al conectar el dispositivo al equipo. Desde el Visual Studio Code podemos pulsar el bot\u00f3n de monitorizaci\u00f3n en la barra de comandos de IDF (el que parece una pantalla) para comenzar a ver la salida est\u00e1ndar en el terminal integrado. Alternativamente podemos ejecutar el comando ESP-IDF: Monitor your device en la paleta de comandos o ejecutar en el terminal el comando: idf.py -p PUERTO monitor","title":"Monitorizaci\u00f3n"},{"location":"RPI-I/P1/#analisis-de-un-proyecto-sencillo-hola-mundo-en-esp-idf","text":"Observa la estructura general del directorio hello_world que compilaste anteriormente. Espec\u00edficamente, nos interesar\u00e1 inspeccionar la estructura b\u00e1sica de un programa principal para ESP-IDF, en este caso hello_world_main.c . #include <stdio.h> #include \"sdkconfig.h\" #include \"freertos/FreeRTOS.h\" #include \"freertos/task.h\" #include \"esp_system.h\" #include \"esp_spi_flash.h\" void app_main(void) { printf(\"Hello world!\\n\"); /* Print chip information */ esp_chip_info_t chip_info; esp_chip_info(&chip_info); printf(\"This is %s chip with %d CPU cores, WiFi%s%s, \", CONFIG_IDF_TARGET, chip_info.cores, (chip_info.features & CHIP_FEATURE_BT) ? \"/BT\" : \"\", (chip_info.features & CHIP_FEATURE_BLE) ? \"/BLE\" : \"\"); printf(\"silicon revision %d, \", chip_info.revision); printf(\"%dMB %s flash\\n\", spi_flash_get_chip_size() / (1024 * 1024), (chip_info.features & CHIP_FEATURE_EMB_FLASH) ? \"embedded\" : \"external\"); printf(\"Minimum free heap size: %d bytes\\n\", esp_get_minimum_free_heap_size()); for (int i = 10; i >= 0; i--) { printf(\"Restarting in %d seconds...\\n\", i); vTaskDelay(1000 / portTICK_PERIOD_MS); } printf(\"Restarting now.\\n\"); fflush(stdout); esp_restart(); } A alto nivel, la funci\u00f3n app_main es el punto de entrada a todo programa desarrollado usando ESP-IDF. De modo m\u00e1s espec\u00edfico, tras la carga del sistema , la llamada tarea principal ( main task ) ejecuta el c\u00f3digo proporcionado por el usuario e implementado en la funci\u00f3n app_main . Tanto el tama\u00f1o de pila asignado como la prioridad de esta tarea puede ser configuradas por el desarrollador a trav\u00e9s del sistema de configuraci\u00f3n de ESP-IDF (lo veremos m\u00e1s adelante). Normalmente, esta funci\u00f3n se utiliza para llevar a cabo tareas iniciales de configuraci\u00f3n o para crear y lanzar a ejecuci\u00f3n otras tareas. Se puede implementar cualquier funcionalidad dentro de la funci\u00f3n app_main o invocar a otras funciones que la implementen. En este ejemplo, se muestra en primer lugar informaci\u00f3n gen\u00e9rica sobre el SoC que est\u00e1 ejecutando el firmware : /* Print chip information */ esp_chip_info_t chip_info; esp_chip_info(&chip_info); printf(\"This is %s chip with %d CPU cores, WiFi%s%s, \", CONFIG_IDF_TARGET, chip_info.cores, (chip_info.features & CHIP_FEATURE_BT) ? \"/BT\" : \"\", (chip_info.features & CHIP_FEATURE_BLE) ? \"/BLE\" : \"\"); printf(\"silicon revision %d, \", chip_info.revision); printf(\"%dMB %s flash\\n\", spi_flash_get_chip_size() / (1024 * 1024), (chip_info.features & CHIP_FEATURE_EMB_FLASH) ? \"embedded\" : \"external\"); printf(\"Minimum free heap size: %d bytes\\n\", esp_get_minimum_free_heap_size()); A continuaci\u00f3n, dentro de un bucle sencillo, el sistema muestra un mensaje y despu\u00e9s suspende su ejecuci\u00f3n por un determinado per\u00edodo de tiempo utilizando la funci\u00f3n de FreeRTOS vTaskDelay . Esta funci\u00f3n recibe como par\u00e1metro el n\u00famero de ticks de reloj que se desea suspender la ejecuci\u00f3n de la tarea, que puede calcularse dividiendo el tiempo que deseamos suspender la tarea por lo que la duraci\u00f3n de un tick . FreeRTOS proporciona la constante portTIC_PERIOD_MS , que nos da la duraci\u00f3n en milisegundos de un tick : for (int i = 10; i >= 0; i--) { printf(\"Restarting in %d seconds...\\n\", i); vTaskDelay(1000 / portTICK_PERIOD_MS); } Finalmente, la tarea reinicia el sistema tras la finalizaci\u00f3n de la tarea principal: printf(\"Restarting now.\\n\"); fflush(stdout); esp_restart(); Ejercicio 1 Modifica el per\u00edodo de suspensi\u00f3n de la tarea para que sea mayor o menor, y comprueba que efectivamente esto modifica el comportamiento del firmware cargado. Ejercicio 2 Modifica el programa para que se compruebe debidamente si el SoC tiene capacidades WiFi y muestre la informaci\u00f3n correspondiente por la salida est\u00e1ndar (para ello, puedes consultar la siguiente p\u00e1gina ).","title":"An\u00e1lisis de un proyecto sencillo (Hola, mundo) en ESP-IDF"},{"location":"RPI-I/P1/#creacion-de-tareas","text":"El anterior proyecto puede replantearse para que no sea la tarea principal la que ejecute la l\u00f3gica del programa. Para ello, es necesario introducir brevemente la API b\u00e1sica para la gesti\u00f3n de tareas (en nuestro caso s\u00f3lo necesitamos crear una tarea). Ver\u00e1s muchos m\u00e1s detalles sobre esta API en la asignatura ANIOT, por lo que no veremos aqu\u00ed m\u00e1s detalles de los estrictamente necesarios. La funci\u00f3n xTaskCreate (incluida en task.h ) permite la creaci\u00f3n de nuevas tareas: BaseType_t xTaskCreate( TaskFunction_t pvTaskCode, const char * const pcName, configSTACK_DEPTH_TYPE usStackDepth, void *pvParameters, UBaseType_t uxPriority, TaskHandle_t *pxCreatedTask ); Concretamente, crea una nueva tarea y la a\u00f1ade a la lista de tareas listas para ejecuci\u00f3n, recibiendo como par\u00e1metros: pvTaskCode : La direcci\u00f3n de la funci\u00f3n de entrada para la tarea. Las tareas suelen implementarse como un bucle infinito. No deberen retornar de la funci\u00f3n de entrada ni finalizar abruptamente. Para finalizar correctamente una tarea \u00e9sta debe ejecutar la funci\u00f3n vTaskDelete con el par\u00e1metro NULL. Alternativamente, puede usarse esta funci\u00f3n para matar otra tarea, pas\u00e1ndo como argumento a vTaskDelete la direcci\u00f3n del manejador inicializado en el proceso de creaci\u00f3n (\u00faltimo par\u00e1metro en la creaci\u00f3n). Por ejemplo, la siguiente funci\u00f3n presenta un esquema de c\u00f3digo correcto para la funci\u00f3n de entrada de una tarea en FreeRTOS. void vATaskFunction( void *pvParameters ) { for( ;; ) { -- Task application code here. -- } /* Tasks must not attempt to return from their implementing function or otherwise exit. In newer FreeRTOS ports attempting to do so will result in an configASSERT() being called if it is defined. If it is necessary for a task to exit then have the task call vTaskDelete( NULL ) to ensure its exit is clean. */ vTaskDelete( NULL ); } pcName : Nombre (en forma de cadena) descriptivo de la tarea a ejecutar, t\u00edpicamente usado en tiempo de depuraci\u00f3n. usStackDepth : N\u00famero de palabras a alojar para utilizar como pila para la tarea. pvParameters : Par\u00e1metros a proporcionar a la funci\u00f3n de entrada para la tarea. uxPriority : Prioridad asignada a la tarea. pxCreatedTask : Manejador opcional para la tarea. As\u00ed, la funcionalidad del programa Hola, mundo que hemos analizado anteriormente, podr\u00eda reestrcturarse en base a una \u00fanica tarea, cuya funci\u00f3n de entrada podr\u00eda ser (al reiniciar el sistema no necesitamos terminar correctamente la tarea ejecutando vTaskDelete ): void hello_task(void *pvParameter) { printf(\"Hello world!\\n\"); for (int i = 10; i >= 0; i--) { printf(\"Restarting in %d seconds...\\n\", i); vTaskDelay(1000 / portTICK_RATE_MS); } printf(\"Restarting now.\\n\"); fflush(stdout); esp_restart(); } La funci\u00f3n app_main se limitar\u00eda entonces a crear la tarea: void app_main() { nvs_flash_init(); xTaskCreate( &hello_task, \"hello_task\", 2048, NULL, 5, NULL ); } Ejercicio 3 Implementa una modificaci\u00f3n del programa hello_world que implemente y planifique dos tareas independientes con distinta funcionalidad (en este caso, es suficiente con mostrar por pantalla alg\u00fan mensaje) y distintos tiempos de suspensi\u00f3n. Comprueba que, efectivamente, ambas tareas se ejecutan concurrentemente.","title":"Creaci\u00f3n de tareas"},{"location":"RPI-I/P1/#personalizacion-del-proyecto","text":"ESP-IDF utiliza la biblioteca kconfiglib para proporcionar un sistema de configuracion de proyectos en tiempo de compilaci\u00f3n sencillo y extensible. Para ilustrar su funcionamiento, utilizaremos el ejemplo blink que puedes encontrar en la distribuci\u00f3n de ESP-IDF. Crea un nuevo proyecto a partir de dicho ejemplo. Para configurar un proyecto ESP-IDF se puede pulsar el bot\u00f3n ESP-IDF SDC Configuration Editor en la barra de comandos de IDF, o bien ejecutando dicho comando en la paleta de comandos de VSCode o ejecutando el comando menuconfig en el terminal: idf.py menuconfig Al ejecutar el comando se nos mostrar\u00e1 un men\u00fan por el que podremos navegar usando el rat\u00f3n (o las teclas del cursor si lo ejecutamos desde terminal). El men\u00fa nos presenta unas opciones de car\u00e1cter general, que permitir\u00e1n configurar las caracter\u00edsticas espec\u00edficas del proyecto a compilar (por ejemplo, seleccionando los componentes que deseemos habilitar en la construcci\u00f3n del mismo). Nota Navega por las opciones que aparecen en los men\u00fas de configuraci\u00f3n para familiarizarte con ellos. Aprende a utilizar el men\u00fa de configuraci\u00f3n, pues lo utilizar\u00e1s en futuras pr\u00e1cticas. En el proyecto blink , observa que una de las opciones del men\u00fa de navegaci\u00f3n, llamada Example configuration , incluye una opci\u00f3n llamada Blink GPIO number . Esta entrada define el n\u00famero de pin GPIO al que se conecta el LED que el programa har\u00e1 parpadear. Esta opci\u00f3n de configuraci\u00f3n definir\u00e1 en tiempo de compilaci\u00f3n el valor de una constante llamada CONFIG_BLINK_GPIO , que podemos utilizar en el c\u00f3digo para obtener el valor que le haya asignado el usuario durante la configuraci\u00f3n del proyecto. Nota Observa el uso que da el c\u00f3digo del proyecto blink a la constante CONFIG_BLINK_GPIO . Esta opci\u00f3n de configuraci\u00f3n no forma parte de las opciones por defecto de ESP-IDF, sino que ha sido a\u00f1adida por los desarrolladores del proyecto blink . Observa y estudia el formato y contenido del fichero main/Kconfig.projbuild que se proporciona como parte del fichero. En \u00e9l, se definen las caracter\u00edsticas (nombre, rango, valor por defecto y descripcion) de la opci\u00f3n de configuraci\u00f3n a definir. Ejercicio 4 Modifica el proyecto hello_world para que defina dos opciones de configuraci\u00f3n que permit\u00e1n definir el tiempo de espera de cada una de las dos tareas que hayas definido en tu anterior soluci\u00f3n. Haz uso de ellas en tu c\u00f3digo y comprueba que efectivamente su modificaci\u00f3n a trav\u00e9s del sistema de men\u00fas permite una personalizaci\u00f3n del comportamiento de tus c\u00f3digos.","title":"Personalizaci\u00f3n del proyecto"},{"location":"RPI-I/P1/#escaneado-de-redes-wifi","text":"A modo de ejemplo, y en preparaci\u00f3n para los c\u00f3digos con los que trabajaremos en futuras pr\u00e1cticas, vamos a analizar a continuaci\u00f3n un ejemplo concreto de firmware cuya tarea es el escaneado de redes inal\u00e1mbricas al alcance del ESP32, y su reporte a trav\u00e9s de su salida est\u00e1ndar (que podremos ver gracias a la facilidad de monitorizaci\u00f3n del programa). Para cada red escaneada, se reportar\u00e1n sus caracter\u00edsticas principales. Tarea Compila, flashea y monitoriza el ejemplo scan situado en el directorio examples/wifi/scan . Crea un nuevo proyecto a partir de este ejemplo y amplia el n\u00famero m\u00e1ximo de redes a escanear a 20 a trav\u00e9s del men\u00fa de configuraci\u00f3n del ejemplo. Crea un punto de acceso WiFi con tu tel\u00e9fono m\u00f3vil y observa que, efectivamente, es escaneado por el ejemplo. Observa su funcionamiento. El firmware simplemente escanea un subconjunto de las redes disponibles, reportando algunas de sus caracter\u00edsticas (por ejemplo, SSID, modo de autenticaci\u00f3n o canal primario). Tarea Analiza el c\u00f3digo de la funci\u00f3n wifi_scan (tarea principal). C\u00e9ntrate especialmente en las l\u00edneas que permiten activar y configurar el escaneado de redes. Intenta entender el funcionamiento general del programa, consultando y apuntando el cometido de cada l\u00ednea, con especial inter\u00e9s a aquellas funciones con prefijo esp_wifi_* . Si tienes dudas puede consultar la documentaci\u00f3n oficial de ESP-IDF .","title":"Escaneado de redes WiFi"},{"location":"RPI-I/P1/#gestion-de-eventos-de-red","text":"El segundo ejemplo que estudiaremos es un programa para la conexi\u00f3n del ESP32 a un punto de acceso existente. Este ejemplo nos permitir\u00e1 observar, a grandes rasgos, el sistema de gesti\u00f3n de eventos en FreeRTOS/ESP-IDF, que permite gestionar la respuestas a eventos de red, como por ejemplo la obtenci\u00f3n de direcci\u00f3n IP o la conexi\u00f3n exitosa a un punto de acceso. Nota Crea un proyecto a partir del ejempl station situado en el directorio examples/wifi/getting_started . Compilalo, flashealo y monitoriza su salida est\u00e1ndar. Acuerdate de modificar el SSID de la red al que conectar\u00e1, as\u00ed como la contrase\u00f1a elegida a trav\u00e9s del sistema de men\u00fas de configuraci\u00f3n. Observa su funcionamiento. El firmware simplemente inicializa el dispositivo en modo station (en contraposici\u00f3n al modo Access Point , que veremos en la pr\u00f3xima sesi\u00f3n), realizando una conexi\u00f3n al punto de acceso preconfigurado a trav\u00e9s del men\u00fa de configuraci\u00f3n. Analiza el c\u00f3digo de la funci\u00f3n wifi_init_sta . Esta funci\u00f3n, que implementa la tarea principal, se divide b\u00e1sicamente en dos partes: Gesti\u00f3n de eventos . Observa el mecanismo mediante el cual se registra y se asocia la recepci\u00f3n de un evento a la ejecuci\u00f3n de un manejador o funci\u00f3n determinada. Nota Responde a la siguiente pregunta de forma razonada: \u00bfQu\u00e9 eventos se asocian a la ejecuci\u00f3n de qu\u00e9 funci\u00f3n en el firmware que est\u00e1s estudiando? Configuraci\u00f3n de la conexi\u00f3n a un punto de acceso . La configuraci\u00f3n de la conexi\u00f3n se realiza a trav\u00e9s de los campos correspondientes de una estructura de tipo wifi_config_t . Observa los campos b\u00e1sicos que necesita, c\u00f3mo fuerza el uso de WPA2 y c\u00f3mo recoge los datos de conexi\u00f3n (SSID y contrase\u00f1a) a trav\u00e9s del sistema de configuraci\u00f3n. Observa tambi\u00e9n c\u00f3mo, una vez realizadas dichas personalizaciones, inicializa el sistema de comunicaci\u00f3n inal\u00e1mbrica a trav\u00e9s de esp_wifi_start() . Consulta la documentaci\u00f3n relativa a dichas funciones y toma nota de aquellos aspectos que consideres m\u00e1s relevantes. Ejercicio 7 Modifica el firmware para que el handler de tratamiento de la obtenci\u00f3n de una direcci\u00f3n IP sea independiente del tratamiento del resto de eventos del sistema WiFi que ya se est\u00e1n considerando. Comprueba que, efectivamente sigue observ\u00e1ndose la salida asociada a dicho evento, aun cuando ambas funciones sean independientes. Entrega el c\u00f3digo modificado.","title":"Gesti\u00f3n de eventos de red"},{"location":"RPI-I/P10/","text":"Pr\u00e1ctica 10. LoRa y LoRaWAN Introducci\u00f3n y objetivos En esta pr\u00e1ctica vamos a utilizar la tecnolog\u00eda LoRa para comunicar nuestros nodos esp32 entre ellos, as\u00ed como con el Router de Red LoRaWAN y los servicios del cloud de The Things Network (TTN). El nodo esp32 con el que hemos venido trabajando no dispone de radio LoRa incorporada, por lo que deberemos conectar un transceptor externo antes de poder utilizar esta tecnolog\u00eda para nuestras comunicaciones. Asimismo, para la conexi\u00f3n con los servidores de TTN necesitaremos un gateway LoRa. Por motivos pr\u00e1cticos usaremos un \u00fanico Gateway para toda la clase, que ser\u00e1 configurado por el profesor, aunque la memoria de la pr\u00e1ctica detalla los pasos a seguir para su configuraci\u00f3n y registro en TTN. Tarea Escribe un informe en el que describas cada una de las tareas propuestas, su desarrollo y los resultados obeservados, as\u00ed como tus observaciones o comentarios personales. LoRaWAN. The Things Network En la arquitectura LoRaWAN los nodos env\u00edan mensajes al aire, cualquier gateway al alcance recibe el mensaje y lo env\u00eda por Internet al servidor de red configurado, que elimina los duplicados y reenv\u00eda a su vez el mensaje al servidor de aplicaci\u00f3n configurado. The Things Network (TTN) es una red abierta en la que cualquier persona puede crear una cuenta y dar de alta gateways y/o nodos. Los paquetes capturados por cualquier gateway de la red TTN son enviados a su servidor de red, que los env\u00eda a su servidor de aplicaci\u00f3n, que ofrece un dashboard al usuario donde puede ver los paquetes recibidos. Las siguientes subsecciones describen los elementos que necesitamos para montar una red LoRaWAN, con nodos esp32, que env\u00eden datos a un gateway LoRa conectado a la red TTN. Registro de Gateway en TTN Para poder desplegar nuestra red lo primero que debemos hacer es dar de alta un gateway en TTN. Esto no podemos hacerlo todos porque no habr\u00e1 un gateway por alumno, pero aqu\u00ed se documentan los pasos a seguir. Primero nos conectamos a TTN, nos registramos si no tenemos cuenta, y entramos en el sistema. Una vez conectados, se nos muestra el dashboard: En el panel izquierdo pulsamos en Gateways y luego en el bot\u00f3n Create Gateway del lado derecho de la ventana. Nos aparecer\u00e1 una ventana en la que tendremos que introducir el identificador universal del gateway (EUI) que vendr\u00e1 en la pegatina de la tapa inferior del mismo (marcado como M2 EUI): Damos entonces a Register Gateway y el quedr\u00e1 registrado en nuestro dashboard: S\u00f3lo nos falta crear un API key para permitir la conexi\u00f3n del gateway. Para ello seleccionamos API keys en el panel izquierdo del dashboard del gateway que hemos creado y pulsamos el bot\u00f3n Add API Key en el lado derecho de la ventana. Rellenamos los datos y pulsamos Create API Key: Se nos abrir\u00e1 una ventana que nos permitir\u00e1 copiar el API key generado. Es importante hacer la copia y guardarla porque la necesitarmos para configurar nuestro el Gateway. Gateway Laird Sentrinus RG1xx Este proceso no podemos hacerlo todos puesto que no disponemos m\u00e1s que de un gateway LoRa comercial, concretamente el modelo Sentrinus RG1xx de Laird. A continuaci\u00f3n se describe el proceso que debemos seguir para configurar dicho gateway para trabajar con TTN. Empezaremos por conectarnos a la web de configuraci\u00f3n del gateway usando su interfaz wifi. Para ello pulsaremos el bot\u00f3n de usuario (parte trasera) durante unos 10 segundos y luego lo soltamos. Esto configurar\u00e1 un punto de acceso wifi con SSID rg1xx294c1f al que nos conectaremos. Una vez conectados abriremos un navegador web y nos conectaremos a la direcci\u00f3n 192.168.1.1 e introducimos el usuario y contrase\u00f1a (consultar manual si no se ha cambiado). Entonces selecionamos la opci\u00f3n LoRa en el men\u00fa superior y se abrir\u00e1 una p\u00e1gina. En el panel izquierdo pulsaremos en Forwarder y en el panel central seleccionaremos el modo Semtech Basics Stations. Adem\u00e1s tendremos que proporcionar la url del servidor de red (LNS server), el certificado del servidor y el Key File , siguiendo las instrucciones de la p\u00e1gina de TTN y usando el API key generado en TTN en el paso anterior para el gateway. Podemos entonces conectar el gateway a la red por su interfaz ethernet (que podemos configurar previamente) o activar su interfaz wifi para el acceso a internet (que debemos configurar en esta misma web). Si todo ha ido bien, veremos en el dashboard de TTN que nuestro gateway se ha conectado: Registro de Aplicaci\u00f3n en TTN Una vez registrado el Gateway debemos registrar una aplicaci\u00f3n en TTN a la que podremos vincular nodos. Esto podemos hacerlo cada uno por nuestra cuenta. Para ello pulsaremos en Applications en el panel izquierdo del dashboard, y acto seguido en el bot\u00f3n Add Application de la parte derecha de la ventana, y rellenamos los datos para la aplicaci\u00f3n: Pulsamos a Create Application y nos mostrar\u00e1 el dashboard de la aplicaci\u00f3n, que nos permitir\u00e1 a\u00f1adir nodos a la aplicaci\u00f3n, como se indica en la siguiente subsecci\u00f3n. Registro de End-Devices El dashboard de la aplicaci\u00f3n est\u00e1 actualmente vaci\u00f3: Para a\u00f1adir un nodo pulsamos en Register End Device. Como vamos a crear un end device a partir de una placa esp32 debemos seleccionar Enter end device specifics manually ; si tuvieramos un nodo comercial podr\u00edamos darlo de alta escaneando un QR o seleccionandolo en el men\u00fa desplegable. Introducimos los datos como muestra la figura siguiente, seleccionando como JoinEUI/AppEUI el identificador que queramos: Al pulsar en Confirm se nos mostrar\u00e1n nuevos campos para introducir o generar el identificador del dispositivo (devEUI) y la clave de la aplicaci\u00f3n (AppKey). Pulsaremos el bot\u00f3n generar en ambos casos y copiaremos los valores generados porque luego tendremos que usarlos en el firmware del nodo que desarrollemos. Finalmente pondremos un nombre a nuestro dispositivo: Pulsaremos Register End Device para completar el proceso. Transceptor HopeRFM95 El dispositvo HopeRFM95 es un peque\u00f1o trasceptor LoRa que puede conectarse por SPI a cualquier microcontrolador para dotarle de conectividad LoRa. Han salido al mercado varios modelos de breakout boards que nos permiten adaptar este transceptor a una breadboard y as\u00ed poder usar cables est\u00e1ndar para conectar el transceptor a nuestro nodo esp32. La siguiente figura muestra el esquema de una de estas placas de breakout , fabricada por adafruit: Para conectar este transceptor al esp32 dev kit rust, debemos poner ambos sobre una breadboard. Debido a la anchura del transceptor no tendremos acceso a los pines por los dos lados, por lo que deberemos utilizar cable de puente ( jumper wire ) para sacar las conexiones de uno de los lados, dejando el otro accesible para conexiones directas. Lo m\u00e1s sencillo es sacar el pin G1, ya que es el \u00fanico pin que necesitamos de ese lado. El pinout del dev kit rust es el siguiente: Una posible conexi\u00f3n entre el transceptor y la esp32 dev kit rust ser\u00eda la siguiente: Adafruit 3070 esp32 dev kit rust Funci\u00f3n RST 5 Reset CS 6 SPI SS MOSI 2 SPI MOSI MISO 3 SPI MISO SCK 4 SPI CLK G0 0 DIO0 GND GND GND Vin 3.3 V 3.3 V G1 1 DIO1 La siguiente figura muestra como las dos placas conectadas con las conexiones indicadas en la tabla anterior: Codigo del nodo: librer\u00eda ttn-esp32 La librer\u00eda ttn-esp32 es un componente para esp-idf que proporciona comunicaci\u00f3n LoRaWAN con The Things Network. Soporta dispositivos conectados a transceptores Semtech SX127x. Esta librer\u00eda soporta las siguientes caracter\u00edsticas de TTN: OTAA (activaci\u00f3n remota, over the air activation ) Mensajes uplink y downlink Guardado los EUIs y la clave en memoria no vol\u00e1til Deep sleep y apagado sin necesidad de reincorporaci\u00f3n Comandos AT para el aprovisionamiento de EUIs y clave (de modo que el mismo c\u00f3digo puede ser flasheado a varios dispositivos) Compatibilidad con las regiones de Europa, Am\u00e9rica del Norte y del Sur, Australia, Corea, Asia e India API en C y C++ Este componente usa por debajo la librer\u00eda LMIC de IBM (espec\u00edficamente la versi\u00f3n mantenida por MCCI) y proporciona una API de alto nivel espec\u00edficamente dirigida a The Things Network. Para crear un proyecto que use esta librer\u00eda lo primero que haremos es clonar el repositorio en nuestro equipo o descargar el zip de la rama master: git clone https://github.com/manuelbl/ttn-esp32.git o wget https://github.com/manuelbl/ttn-esp32/archive/master.zip unzip master.zip Despu\u00e9s copiaremos el ejemplo que viene con la librer\u00eda en examples/hello_world a un nuevo directorio. Dentro de la copia creamos un directorio components y dentro copiaremos toda la librer\u00eda ttn-esp32. La estructura que tendr\u00e1 el proyecto ser\u00e1: hello_world/ +- CMakeLists.txt +- components/ | +- ttn-esp32 | +- ... +- main/ | - CMakeLists.txt | - component.mk | - main.cpp +- Makefile Si echamos un vistazo al fichero main.cpp veremos que el programa se conectar\u00e1 a TTN, y despu\u00e9s el nodo se pondr\u00e1 a enviar mensajes \"hello world\" uplink (hacia el servidor de aplicaci\u00f3n) al ritmo de uno por segundo. El programa debe ser configurado definiendo los valores de una serie de macros, que determinan por un lado los identificadores del nodo para TTN y por otro lado los pines usados para la conexi\u00f3n del esp32 con el transceptor LoRa. Para los identificadores del nodo en TTN usaremos los datos obtenidos en el registro del end device en TTN: // AppEUI (sometimes called JoinEUI) const char *appEui = \"0101010101010101\"; // DevEUI const char *devEui = \"70B3D57ED006B7B2\"; // AppKey const char *appKey = \"8427407CC943D5B188160CC89F176846\"; Para la conexi\u00f3n entre ambos chips indicada, arriba en la secci\u00f3n del transceptor HopeRFM95, la configuraci\u00f3n de pines ser\u00eda como sigue: #define TTN_SPI_HOST SPI2_HOST #define TTN_SPI_DMA_CHAN SPI_DMA_DISABLED #define TTN_PIN_SPI_SCLK 4 #define TTN_PIN_SPI_MOSI 2 #define TTN_PIN_SPI_MISO 3 #define TTN_PIN_NSS 6 #define TTN_PIN_RXTX TTN_NOT_CONNECTED #define TTN_PIN_RST 5 #define TTN_PIN_DIO0 0 #define TTN_PIN_DIO1 1 Una vez configurado el fichero fuente main.cpp, haremos un menuconfig para configurar la librer\u00eda ttn-esp32. En la parte final (abajo) del men\u00fa principal encontraremos la entrada The Things Network, y seleccionaremos en ella las entradas como en la figura siguiente: Despu\u00e9s podemos compilar el proyecto y descargarlo en la placa (flash). Lo monitorizaremos, y si todo ha ido bien iremos viendo en el dashboard de nuestra aplicaci\u00f3n TTN c\u00f3mo se van recibiendo los mensajes. La aplicaci\u00f3n env\u00eda el mensaje hello world, pero el dashboard nos muestra el payload del mensaje en hexadecimal. Podemos usar el servicio de RapidTable para traducir el payload hexadecimal a ascii y comprobar as\u00ed que el payload recibido es correcto. tarea Modificar el c\u00f3digo para que se env\u00eden mensajes con payload {0xAA, 0xBB, 0xCC, 0xDD} y comprobar en el dashboard que se reciben correctamente. Incluir en el informe las capturas de pantalla apropiadas. Comunicaci\u00f3n LoRa raw Podemos tambi\u00e9n hacer comunicaciones LoRa dir\u00e9ctamente entre los nodos sin necesidad de utilizar la infrastructura de red LoRaWAN. Para ello podemos hacer uso de la librer\u00eda esp32-lora-library que es un componente de esp-idf que podemos a\u00f1adir a un proyecto para tener comunicaciones LoRa usando transceptores de la familia Semtech SX127x. Tarea opcional Clonar el repositorio de la librer\u00eda. Crear un proyecto de esp-idf que use esta librer\u00eda como componente. Programar dos nodos con el c\u00f3digo de ejemplo que viene en el README.md de la librer\u00eda, acord\u00e1ndonos de configurar los pines usados para la conexi\u00f3n con el transceptor a trav\u00e9s del menuconfig. Monitorizar ambos nodos y comprobar que los paquetes enviados por uno son recibidos por el otro. A\u00f1adir a la memoria las capturas de pantalla apropiadas que muestren el correcto funcionamiento de los nodos.","title":"Pr\u00e1ctica 10. LoRa y LoRaWAN"},{"location":"RPI-I/P10/#practica-10-lora-y-lorawan","text":"","title":"Pr\u00e1ctica 10. LoRa y LoRaWAN"},{"location":"RPI-I/P10/#introduccion-y-objetivos","text":"En esta pr\u00e1ctica vamos a utilizar la tecnolog\u00eda LoRa para comunicar nuestros nodos esp32 entre ellos, as\u00ed como con el Router de Red LoRaWAN y los servicios del cloud de The Things Network (TTN). El nodo esp32 con el que hemos venido trabajando no dispone de radio LoRa incorporada, por lo que deberemos conectar un transceptor externo antes de poder utilizar esta tecnolog\u00eda para nuestras comunicaciones. Asimismo, para la conexi\u00f3n con los servidores de TTN necesitaremos un gateway LoRa. Por motivos pr\u00e1cticos usaremos un \u00fanico Gateway para toda la clase, que ser\u00e1 configurado por el profesor, aunque la memoria de la pr\u00e1ctica detalla los pasos a seguir para su configuraci\u00f3n y registro en TTN. Tarea Escribe un informe en el que describas cada una de las tareas propuestas, su desarrollo y los resultados obeservados, as\u00ed como tus observaciones o comentarios personales.","title":"Introducci\u00f3n y objetivos"},{"location":"RPI-I/P10/#lorawan-the-things-network","text":"En la arquitectura LoRaWAN los nodos env\u00edan mensajes al aire, cualquier gateway al alcance recibe el mensaje y lo env\u00eda por Internet al servidor de red configurado, que elimina los duplicados y reenv\u00eda a su vez el mensaje al servidor de aplicaci\u00f3n configurado. The Things Network (TTN) es una red abierta en la que cualquier persona puede crear una cuenta y dar de alta gateways y/o nodos. Los paquetes capturados por cualquier gateway de la red TTN son enviados a su servidor de red, que los env\u00eda a su servidor de aplicaci\u00f3n, que ofrece un dashboard al usuario donde puede ver los paquetes recibidos. Las siguientes subsecciones describen los elementos que necesitamos para montar una red LoRaWAN, con nodos esp32, que env\u00eden datos a un gateway LoRa conectado a la red TTN.","title":"LoRaWAN. The Things Network"},{"location":"RPI-I/P10/#registro-de-gateway-en-ttn","text":"Para poder desplegar nuestra red lo primero que debemos hacer es dar de alta un gateway en TTN. Esto no podemos hacerlo todos porque no habr\u00e1 un gateway por alumno, pero aqu\u00ed se documentan los pasos a seguir. Primero nos conectamos a TTN, nos registramos si no tenemos cuenta, y entramos en el sistema. Una vez conectados, se nos muestra el dashboard: En el panel izquierdo pulsamos en Gateways y luego en el bot\u00f3n Create Gateway del lado derecho de la ventana. Nos aparecer\u00e1 una ventana en la que tendremos que introducir el identificador universal del gateway (EUI) que vendr\u00e1 en la pegatina de la tapa inferior del mismo (marcado como M2 EUI): Damos entonces a Register Gateway y el quedr\u00e1 registrado en nuestro dashboard: S\u00f3lo nos falta crear un API key para permitir la conexi\u00f3n del gateway. Para ello seleccionamos API keys en el panel izquierdo del dashboard del gateway que hemos creado y pulsamos el bot\u00f3n Add API Key en el lado derecho de la ventana. Rellenamos los datos y pulsamos Create API Key: Se nos abrir\u00e1 una ventana que nos permitir\u00e1 copiar el API key generado. Es importante hacer la copia y guardarla porque la necesitarmos para configurar nuestro el Gateway.","title":"Registro de Gateway en TTN"},{"location":"RPI-I/P10/#gateway-laird-sentrinus-rg1xx","text":"Este proceso no podemos hacerlo todos puesto que no disponemos m\u00e1s que de un gateway LoRa comercial, concretamente el modelo Sentrinus RG1xx de Laird. A continuaci\u00f3n se describe el proceso que debemos seguir para configurar dicho gateway para trabajar con TTN. Empezaremos por conectarnos a la web de configuraci\u00f3n del gateway usando su interfaz wifi. Para ello pulsaremos el bot\u00f3n de usuario (parte trasera) durante unos 10 segundos y luego lo soltamos. Esto configurar\u00e1 un punto de acceso wifi con SSID rg1xx294c1f al que nos conectaremos. Una vez conectados abriremos un navegador web y nos conectaremos a la direcci\u00f3n 192.168.1.1 e introducimos el usuario y contrase\u00f1a (consultar manual si no se ha cambiado). Entonces selecionamos la opci\u00f3n LoRa en el men\u00fa superior y se abrir\u00e1 una p\u00e1gina. En el panel izquierdo pulsaremos en Forwarder y en el panel central seleccionaremos el modo Semtech Basics Stations. Adem\u00e1s tendremos que proporcionar la url del servidor de red (LNS server), el certificado del servidor y el Key File , siguiendo las instrucciones de la p\u00e1gina de TTN y usando el API key generado en TTN en el paso anterior para el gateway. Podemos entonces conectar el gateway a la red por su interfaz ethernet (que podemos configurar previamente) o activar su interfaz wifi para el acceso a internet (que debemos configurar en esta misma web). Si todo ha ido bien, veremos en el dashboard de TTN que nuestro gateway se ha conectado:","title":"Gateway Laird Sentrinus RG1xx"},{"location":"RPI-I/P10/#registro-de-aplicacion-en-ttn","text":"Una vez registrado el Gateway debemos registrar una aplicaci\u00f3n en TTN a la que podremos vincular nodos. Esto podemos hacerlo cada uno por nuestra cuenta. Para ello pulsaremos en Applications en el panel izquierdo del dashboard, y acto seguido en el bot\u00f3n Add Application de la parte derecha de la ventana, y rellenamos los datos para la aplicaci\u00f3n: Pulsamos a Create Application y nos mostrar\u00e1 el dashboard de la aplicaci\u00f3n, que nos permitir\u00e1 a\u00f1adir nodos a la aplicaci\u00f3n, como se indica en la siguiente subsecci\u00f3n.","title":"Registro de Aplicaci\u00f3n en TTN"},{"location":"RPI-I/P10/#registro-de-end-devices","text":"El dashboard de la aplicaci\u00f3n est\u00e1 actualmente vaci\u00f3: Para a\u00f1adir un nodo pulsamos en Register End Device. Como vamos a crear un end device a partir de una placa esp32 debemos seleccionar Enter end device specifics manually ; si tuvieramos un nodo comercial podr\u00edamos darlo de alta escaneando un QR o seleccionandolo en el men\u00fa desplegable. Introducimos los datos como muestra la figura siguiente, seleccionando como JoinEUI/AppEUI el identificador que queramos: Al pulsar en Confirm se nos mostrar\u00e1n nuevos campos para introducir o generar el identificador del dispositivo (devEUI) y la clave de la aplicaci\u00f3n (AppKey). Pulsaremos el bot\u00f3n generar en ambos casos y copiaremos los valores generados porque luego tendremos que usarlos en el firmware del nodo que desarrollemos. Finalmente pondremos un nombre a nuestro dispositivo: Pulsaremos Register End Device para completar el proceso.","title":"Registro de End-Devices"},{"location":"RPI-I/P10/#transceptor-hoperfm95","text":"El dispositvo HopeRFM95 es un peque\u00f1o trasceptor LoRa que puede conectarse por SPI a cualquier microcontrolador para dotarle de conectividad LoRa. Han salido al mercado varios modelos de breakout boards que nos permiten adaptar este transceptor a una breadboard y as\u00ed poder usar cables est\u00e1ndar para conectar el transceptor a nuestro nodo esp32. La siguiente figura muestra el esquema de una de estas placas de breakout , fabricada por adafruit: Para conectar este transceptor al esp32 dev kit rust, debemos poner ambos sobre una breadboard. Debido a la anchura del transceptor no tendremos acceso a los pines por los dos lados, por lo que deberemos utilizar cable de puente ( jumper wire ) para sacar las conexiones de uno de los lados, dejando el otro accesible para conexiones directas. Lo m\u00e1s sencillo es sacar el pin G1, ya que es el \u00fanico pin que necesitamos de ese lado. El pinout del dev kit rust es el siguiente: Una posible conexi\u00f3n entre el transceptor y la esp32 dev kit rust ser\u00eda la siguiente: Adafruit 3070 esp32 dev kit rust Funci\u00f3n RST 5 Reset CS 6 SPI SS MOSI 2 SPI MOSI MISO 3 SPI MISO SCK 4 SPI CLK G0 0 DIO0 GND GND GND Vin 3.3 V 3.3 V G1 1 DIO1 La siguiente figura muestra como las dos placas conectadas con las conexiones indicadas en la tabla anterior:","title":"Transceptor HopeRFM95"},{"location":"RPI-I/P10/#codigo-del-nodo-libreria-ttn-esp32","text":"La librer\u00eda ttn-esp32 es un componente para esp-idf que proporciona comunicaci\u00f3n LoRaWAN con The Things Network. Soporta dispositivos conectados a transceptores Semtech SX127x. Esta librer\u00eda soporta las siguientes caracter\u00edsticas de TTN: OTAA (activaci\u00f3n remota, over the air activation ) Mensajes uplink y downlink Guardado los EUIs y la clave en memoria no vol\u00e1til Deep sleep y apagado sin necesidad de reincorporaci\u00f3n Comandos AT para el aprovisionamiento de EUIs y clave (de modo que el mismo c\u00f3digo puede ser flasheado a varios dispositivos) Compatibilidad con las regiones de Europa, Am\u00e9rica del Norte y del Sur, Australia, Corea, Asia e India API en C y C++ Este componente usa por debajo la librer\u00eda LMIC de IBM (espec\u00edficamente la versi\u00f3n mantenida por MCCI) y proporciona una API de alto nivel espec\u00edficamente dirigida a The Things Network. Para crear un proyecto que use esta librer\u00eda lo primero que haremos es clonar el repositorio en nuestro equipo o descargar el zip de la rama master: git clone https://github.com/manuelbl/ttn-esp32.git o wget https://github.com/manuelbl/ttn-esp32/archive/master.zip unzip master.zip Despu\u00e9s copiaremos el ejemplo que viene con la librer\u00eda en examples/hello_world a un nuevo directorio. Dentro de la copia creamos un directorio components y dentro copiaremos toda la librer\u00eda ttn-esp32. La estructura que tendr\u00e1 el proyecto ser\u00e1: hello_world/ +- CMakeLists.txt +- components/ | +- ttn-esp32 | +- ... +- main/ | - CMakeLists.txt | - component.mk | - main.cpp +- Makefile Si echamos un vistazo al fichero main.cpp veremos que el programa se conectar\u00e1 a TTN, y despu\u00e9s el nodo se pondr\u00e1 a enviar mensajes \"hello world\" uplink (hacia el servidor de aplicaci\u00f3n) al ritmo de uno por segundo. El programa debe ser configurado definiendo los valores de una serie de macros, que determinan por un lado los identificadores del nodo para TTN y por otro lado los pines usados para la conexi\u00f3n del esp32 con el transceptor LoRa. Para los identificadores del nodo en TTN usaremos los datos obtenidos en el registro del end device en TTN: // AppEUI (sometimes called JoinEUI) const char *appEui = \"0101010101010101\"; // DevEUI const char *devEui = \"70B3D57ED006B7B2\"; // AppKey const char *appKey = \"8427407CC943D5B188160CC89F176846\"; Para la conexi\u00f3n entre ambos chips indicada, arriba en la secci\u00f3n del transceptor HopeRFM95, la configuraci\u00f3n de pines ser\u00eda como sigue: #define TTN_SPI_HOST SPI2_HOST #define TTN_SPI_DMA_CHAN SPI_DMA_DISABLED #define TTN_PIN_SPI_SCLK 4 #define TTN_PIN_SPI_MOSI 2 #define TTN_PIN_SPI_MISO 3 #define TTN_PIN_NSS 6 #define TTN_PIN_RXTX TTN_NOT_CONNECTED #define TTN_PIN_RST 5 #define TTN_PIN_DIO0 0 #define TTN_PIN_DIO1 1 Una vez configurado el fichero fuente main.cpp, haremos un menuconfig para configurar la librer\u00eda ttn-esp32. En la parte final (abajo) del men\u00fa principal encontraremos la entrada The Things Network, y seleccionaremos en ella las entradas como en la figura siguiente: Despu\u00e9s podemos compilar el proyecto y descargarlo en la placa (flash). Lo monitorizaremos, y si todo ha ido bien iremos viendo en el dashboard de nuestra aplicaci\u00f3n TTN c\u00f3mo se van recibiendo los mensajes. La aplicaci\u00f3n env\u00eda el mensaje hello world, pero el dashboard nos muestra el payload del mensaje en hexadecimal. Podemos usar el servicio de RapidTable para traducir el payload hexadecimal a ascii y comprobar as\u00ed que el payload recibido es correcto. tarea Modificar el c\u00f3digo para que se env\u00eden mensajes con payload {0xAA, 0xBB, 0xCC, 0xDD} y comprobar en el dashboard que se reciben correctamente. Incluir en el informe las capturas de pantalla apropiadas.","title":"Codigo del nodo: librer\u00eda ttn-esp32"},{"location":"RPI-I/P10/#comunicacion-lora-raw","text":"Podemos tambi\u00e9n hacer comunicaciones LoRa dir\u00e9ctamente entre los nodos sin necesidad de utilizar la infrastructura de red LoRaWAN. Para ello podemos hacer uso de la librer\u00eda esp32-lora-library que es un componente de esp-idf que podemos a\u00f1adir a un proyecto para tener comunicaciones LoRa usando transceptores de la familia Semtech SX127x. Tarea opcional Clonar el repositorio de la librer\u00eda. Crear un proyecto de esp-idf que use esta librer\u00eda como componente. Programar dos nodos con el c\u00f3digo de ejemplo que viene en el README.md de la librer\u00eda, acord\u00e1ndonos de configurar los pines usados para la conexi\u00f3n con el transceptor a trav\u00e9s del menuconfig. Monitorizar ambos nodos y comprobar que los paquetes enviados por uno son recibidos por el otro. A\u00f1adir a la memoria las capturas de pantalla apropiadas que muestren el correcto funcionamiento de los nodos.","title":"Comunicaci\u00f3n LoRa raw"},{"location":"RPI-I/P2/","text":"Pr\u00e1ctica 2. WiFi en el ESP32 Objetivos Conocer el flujo de trabajo del driver WiFi en ESP-IDF. Analizar las diferencias entre un firmware desarrollado para trabajar en modo station y en modo AP . Desarrollar un firmware combinado para que funcione en modo AP y station de forma simult\u00e1nea. Conocer los mecanismos de escaneado de redes en ESP-IDF. Conectar a redes v\u00eda WPA2 Enterprise desde el ESP32 ( eduroam ). Introducci\u00f3n Las bibliotecas y componentes de soporte WiFi en ESP-IDF proporcionan soporte para configurar y monitorizar la conexi\u00f3n 802.11 sobre placas ESP32. Este soporte incluye configuraciones para: Modo station (modo cliente WiFi, o STA ). En este caso, el ESP32 conecta con un punto de acceso preconfigurado. Modo AP (tambi\u00e9n denominado softAP o modo Punto de Acceso ). En este caso, son las estaciones las que conectan al ESP32. Modo combinado AP-STA, donde el ESP32 act\u00faa de forma concurrente como punto de acceso (AP) y cliente WiFi conectado a otro punto de acceso (STA). Varios modos de seguridad tanto en modo cliente como en modo AP (WPA, WPA2, WEP, etc.) Escaneado de puntos de acceso (activo y pasivo). Provisionamiento de claves y modo WPS. Modo promiscuo para monitorizaci\u00f3n de paquetes IEEE 802.11. En la presente pr\u00e1ctica, a trav\u00e9s de ejemplos b\u00e1sicos, estudiaremos las caracter\u00edsticas principales soportadas por el driver WiFi sobre el ESP32. Todas estas caracter\u00edsticas pueden ser utilizadas a posteriori para el desarrollo de c\u00f3digos y proyectos m\u00e1s complejos con m\u00ednimas modificaciones. Modelo de programaci\u00f3n del driver WiFi en ESP-IDF El modelo de programaci\u00f3n del driver WiFi en ESP-IDF sigue un modelo de programaci\u00f3n sencillo que se puede resumir en la siguiente imagen: Puede considerarse que el driver WiFi es una caja negra independiente del resto de la aplicaci\u00f3n, como la pila TCP/IP, las tareas de aplicaci\u00f3n y los eventos. El c\u00f3digo de las tareas de aplicaci\u00f3n generalmente invoca a la API WiFi para inicializar el dispositivo inal\u00e1mbrico y tratar eventos espec\u00edficos cuando resulta necesario. El driver WiFi recibe invocaciones a su API, las procesa y emite eventos a la aplicaci\u00f3n. El tratamiento de eventos WiFi se basa en la biblioteca de eventos esp_event ; los eventos se env\u00edan por parte del driver al bucle de tratamiento de eventos por defecto . La aplicaci\u00f3n registra una serie de funciones callback , a trav\u00e9s de la funci\u00f3n esp_event_handler_register() , que ser\u00e1n las responsables de tratar estos eventos. Alg\u00fan tipo de eventos es tambi\u00e9n procesado por el componente esp_netif para proporcionar reacciones por defecto ante su recepci\u00f3n. Por ejemplo, cuando un dispositivo se conecta a un AP el esp_netif arranca un cliente DHCP para obtener una direcci\u00f3n IP sin intervenci\u00f3n del c\u00f3digo de usuario (aunque este comportamiento por defecto puede ser personalizado para, por ejemplo, asignar una direcci\u00f3n IP est\u00e1ticamente). Nota Toda la API mencionada a continuaci\u00f3n se encuentra descrita en profundidad aqu\u00ed . Se aconseja disponer de esta informaci\u00f3n durante el proceso de desarrollo y tambi\u00e9n en el propio desarrollo de la pr\u00e1ctica. Eventos WiFi Se listan a continuaci\u00f3n algunos de los ejemplos m\u00e1s utilizados en la gesti\u00f3n de conexiones WiFi, que utilizaremos en los ejemplos posteriores. WIFI_EVENT_SCAN_DONE Este evento se env\u00eda autom\u00e1ticamente en la invocaci\u00f3n de esp_wifi_scan_start() , en los siguientes escenarios: El escaneado de redes se completa, es decir, se ha encontrado el punto de acceso (AP) objetivo. El escaneado de redes finaliza tras la invocaci\u00f3n de esp_wifi_scan_stop() . Se invoca al inicio de un nuevo escaneo (mediante la rutina esp_wifi_scan_start() ) antes de finalizar un escaneado previo. Este nuevo escaneado se superpondr\u00e1 al anterior y se emitir\u00e1 el evento. El evento no se emite cuando el escaneado se fuerza mediante la invocaci\u00f3n a esp_wifi_connect() . Ante la recepci\u00f3n de este evento, no se lanza ning\u00fan proceso espec\u00edfico como respuesta. La aplicaci\u00f3n necesitar\u00e1 invocar normalmente a esp_wifi_scan_get_ap_num() y a esp_wifi_scan_get_ap_records() para recoger la lista de APs escaneados y liberar los recursos (memoria) que se aloja en el proceso de escaneado. WIFI_EVENT_STA_START Este evento se env\u00eda cuando, tras la invocaci\u00f3n a esp_wifi_start() , \u00e9sta devuelve ESP_OK . Tras la recepci\u00f3n de este evento, se inicializa la interfaz de red, por lo que normalmente, tras la recepci\u00f3n de este evento se est\u00e1 listo para invocar a esp_wifi_connect() para comenzar el proceso de conexi\u00f3n con un punto de acceso (AP). WIFI_EVENT_STA_STOP Este evento se env\u00eda cuando, tras la invocaci\u00f3n a esp_wifi_stop() , \u00e9sta devuelve ESP_OK . Tras la recepci\u00f3n de este evento, se libera la direcci\u00f3n IP, se detiene el cliente DHCP y se liberan las conexiones TCP/UDP existentes. Normalmente no se trata desde el punto de vista de la aplicaci\u00f3n. WIFI_EVENT_STA_CONNECTED Este evento se env\u00eda cuando, tras la invocaci\u00f3n a esp_wifi_connect() , \u00e9sta devuelve ESP_OK . Tras la recepci\u00f3n de este evento, arranca un cliente DHCP para la obtenci\u00f3n de una direcci\u00f3n IP. A continuaci\u00f3n, si todo ha ido bien, el driver WiFi est\u00e1 listo para enviar y recibir datos. Dicho instante es el adecuado para comenzar con la l\u00f3gica de la aplicaci\u00f3n, siempre que \u00e9sta no dependa de la correcta obtenci\u00f3n de una direcci\u00f3n IP. Si este es el caso, ser\u00e1 necesario esperar a la obtenci\u00f3n de la misma esperando al evento WIFI_EVENT_STA_GOT_IP . WIFI_EVENT_STA_DISCONNECTED Este evento se genera en los siguientes escenarios: Cuando se invoca a las funciones esp_wifi_disconnect() , esp_wifi_stop() , esp_wifi_deinit() o esp_wifi_restart() y la estaci\u00f3n est\u00e1 conectada al punto de acceso. Cuando se invoca a esp_wifi_connect() , pero el driver WiFi no consigue configurar una conexi\u00f3n con el AP debido a cualquier raz\u00f3n (por ejemplo, el escaneo no puede encontrar el AP objetivo, el proceso de autenticaci\u00f3n no tiene \u00e9xito, etc). Si hay m\u00e1s de un AP con el mismo SSID, el evento se emite s\u00f3lo cuando el dispositivo no puede conectar a ninguno de los APs encontrados. Cuando la conexi\u00f3n WiFi se interrumpe, por ejemplo porque el dispositivo pierde N beacons emitidos por el AP, el AP expulsa al dispositivo, el modo de autenticaci\u00f3n cambia, etc. Resulta com\u00fan que la rutina de tratamiento del evento trate de invocar de nuevo a la funci\u00f3n esp_wifi_connect() para reintentar la conexi\u00f3n. WIFI_EVENT_STA_GOT_IP Este evento se emite cuando el cliente DHCP obtiene una direcci\u00f3n IPv4 desde un servidor DHCP, o cuando se modifica su direcci\u00f3n IPv4. El evento significa que todo est\u00e1 listo y que la aplicaci\u00f3n puede continuar con sus tareas (por ejemplo, creaci\u00f3n de sockets, inicializaci\u00f3n de protocolos, etc.) La direcci\u00f3n IPv4 podr\u00eda modificarse por alguna de las siguientes razones: El cliente DHCP no puede renovar la direcci\u00f3n IPv4 tras su expiraci\u00f3n (los servidores DHCP suelen conceder direcciones IP durante un tiempo limitado). El cliente DHCP se asocia a otra direcci\u00f3n. Se modifica la direcci\u00f3n IPv4 asignada est\u00e1ticamente (no v\u00eda DHCP). Normalmente, cuando la IP cambia, todos los sockets asociados a ella quedar\u00e1n en un estado no utilizable. As\u00ed, la recepci\u00f3n de este evento se suele aprovechar para cerrar y a continuaci\u00f3n recrear todos los sockets abiertos. WIFI_EVENT_STA_LOST_IP Evento emitido cuando una direcci\u00f3n IPv4 se convierte en una direcci\u00f3n inv\u00e1lida. El evento no se emite inmediatamente tras la desconexi\u00f3n WiFi, sino que inicializa un temporizador de tipo address lost . Si se obtiene una IP antes de su expiraci\u00f3n, el evento no se emite. En otro caso, se emite justo en el instante de expirci\u00f3n del temporizador. Normalmente, las aplicaciones no deben tratar este evento (suele usarse en tareas de depuraci\u00f3n). WIFI_EVENT_AP_START Emitido en el inicio de un AP (punto de acceso). WIFI_EVENT_AP_STACONNECTED Cuando un dispositivo ( station ) se conecta a un AP, \u00e9ste emite el event WIFI_EVENT_AP_STACONNECTED . Es posible ignorarlo, o aprovecharlo para obtener informaci\u00f3n sobre la estaci\u00f3n conectada, por ejemplo. WIFI_EVENT_AP_STADISCONNECTED Este evento se genera en los siguientes escenarios: La aplicaci\u00f3n invoca a esp_wifi_disconnect() o esp_wifi_deauth_sta() para desconectarla manualmente del punto de acceso. El driver WiFi expulsa al dispositivo ( station ), por ejemplo en una situaci\u00f3n en la que el AP no ha recibido paquetes en los \u00faltimos minutos. Cuando ocurre este evento, la aplicaci\u00f3n necesitar\u00eda (idealmente) tomar las medidas necesarias asociadas al mismo, por ejemplo, cerrar los sockets abiertos. Modo Station La siguiente figura describe, a grandes rasgos, algunos de los escenarios principales que pueden darse en modo station : Se analizan a continuaci\u00f3n las fases principales en este tipo de firmware (no todas tienen que estar necesariamente presentes en cualquier escenario). Fase 1: inicializaci\u00f3n WiFi La tarea principal invoca a esp_netif_init() para crear la pila IP y realizar las tareas de inicializaci\u00f3n pertinentes. La tarea principal invoca a esp_event_loop_create() para crear e inicializar el sistema de eventos. La tarea principal invoca a esp_netif_create_default_wifi_sta() para crear la interfaz de red que asocia el dispositivo con la pila TCP/IP. La tarea principal invoca a esp_wifi_init() para crear la tarea que manejar\u00e1 la conexi\u00f3n WiFi e inicializa el driver WiFi. Por \u00faltimo, se invoca (si as\u00ed se desea, aunque es lo m\u00e1s com\u00fan) a la API para la creaci\u00f3n de la tarea o tareas de aplicaci\u00f3n. Esta secuencia es la recomendada para la inicializaci\u00f3n del sistema de comunicaci\u00f3n WiFi, pero no es estrictamente obligatorio seguirla en dicho orden o en su totalidad. Por ejemplo, se podr\u00eda crear directamente una tarea de aplicaci\u00f3n (paso 5) y realizar la configuraci\u00f3n en su cuerpo, o se puede diferir su creaci\u00f3n hasta la obtenci\u00f3n de una direcci\u00f3n IP. Fase 2: configuraci\u00f3n WiFi Una vez inicializado el driver WiFi, comienza su configuraci\u00f3n. En este escenario, el modo debe fijarse a station a trav\u00e9s de una invocaci\u00f3n a esp_wifi_set_mode(WIFI_MODE_STA) . Es posible invocar a continuaci\u00f3n a otras rutinas de tipo esp_wifi_set_xxx() para configurar par\u00e1metros adicionales (pa\u00eds, ancho de banda, modo de protocolo, ...). Para m\u00e1s informaci\u00f3n sobre los modos de operaci\u00f3n ( station , AP o modo combinado station/AP , consulta el siguiente enlace ). Generalmente, es necesario configurar el driver WiFi antes de establecer una conexi\u00f3n, pero no es obligatorio: es posible reconfigurarlo en cualquier momento, siempre que el driver est\u00e9 correctamente incializado. En cualquier caso, si la configuraci\u00f3n no tiene que modificarse tras la conexi\u00f3n, es mejor realizarla en este punto, porque algunos de los par\u00e1metros que pueden variar forzar\u00e1n una reconexi\u00f3n WiFi, aspecto que es mejor evitar. La rutina esp_wifi_set_config() permite configurar los aspectos b\u00e1sicos de la conexi\u00f3n WiFi. Por ejemplo, el c\u00f3digo: wifi_config_t wifi_config = { .sta = { .ssid = EXAMPLE_ESP_WIFI_SSID, .password = EXAMPLE_ESP_WIFI_PASS, .threshold.authmode = WIFI_AUTH_WPA2_PSK, .pmf_cfg = { .capable = true, .required = false }, }, }; ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA) ); ESP_ERROR_CHECK(esp_wifi_set_config(ESP_IF_WIFI_STA, &wifi_config) ); Realiza una configuraci\u00f3n b\u00e1sica WiFi proporcionando SSID, contrase\u00f1a y modo de autenticaci\u00f3n antes de configurar la conexi\u00f3n. Fase 3: inicio WiFi Invocaci\u00f3n a esp_wifi_start() para iniciar el driver WiFi. El driver WiFi envia un evento WIFI_EVENT_STA_START , que ser\u00e1 tratado por la tarea de gesti\u00f3n de eventos por defecto para realizar las tareas necesarias e invocar\u00e1 a la runtina de tratamiento del evento a nivel de aplicaci\u00f3n. La aplicaci\u00f3n deber\u00e1 tratar el evento WIFI_EVENT_STA_START , invocando (se recomienda) a esp_wifi_connect() . Fase 4: conexi\u00f3n WiFi Una vez invocada esp_wifi_connect() , el dirver WiFi comienza un proceso interno de escaneado/conexi\u00f3n. Si dicho proceso tiene \u00e9xito, se genera un evento WIFI_EVENT_STA_CONNECTED . Autom\u00e1ticamente se invoca al cliente DHCP y comienza el proceso de obtenci\u00f3n de direcci\u00f3n IP. Generalmente, la aplicaci\u00f3n no suele responder a este evento, pero podr\u00eda por ejemplo imprimirse un mensaje por pantalla a modo de depuraci\u00f3n. En el segundo paso, la conexi\u00f3n podr\u00eda fallar, por ejemplo, si la contrase\u00f1a proporcionada es incorrecta. En dicho caso, se env\u00eda un evento de tipo WIFI_EVENT_STA_DISCONNECTED y se proporcionar\u00e1 la causa del error. En el paso 6 se trata este aspecto. Fase 5: obtenci\u00f3n de IP Una vez inicializado el cliente DHCP (paso 4.2) comienza la fase de obtenci\u00f3n de IP. Si se recibe con \u00e9xito una IP desde el servidor DHCP, se emite un evento de tipo IP_EVENT_STA_GOT_IP . La aplicaci\u00f3n tratar\u00e1 este evento. Realmente, en este punto puede comenzar la l\u00f3gica de red de la aplicaci\u00f3n, incluyendo, por ejemplo, la creaci\u00f3n de sockets TCP/UDP. Es imprescindible la recepci\u00f3n de una direcci\u00f3n IP antes de la inicializaci\u00f3n de sockets. Fase 6: desconexi\u00f3n WiFi Cuando finaliza de forma abrupta una conexi\u00f3n WiFi, por ejemplo al apagar el punto de acceso (AP), si la calidad de recepci\u00f3n (RSSI) es baja, etc. se emite un evento WIFI_EVENT_STA_DISCONNECTED . La tarea de aplicaci\u00f3n deber\u00eda tratar este evento para, t\u00edpicamente, reintentar la conexi\u00f3n a trav\u00e9s de una invocaci\u00f3n a esp_wifi_reconnect() . Fase 7: cambio de IP Cuando la direcci\u00f3n IP asignada a un dispositivo cambia, se emite un evento de tipo IP_EVENT_STA_GOT_IP . Por defecto, y de forma autom\u00e1tica, se activa el campo ip_change de la estructura de tipo ip_event_got_ip_t que acompa\u00f1a al evento. La aplicaci\u00f3n deber\u00eda tomar las medidas necesarias (por ejemplo, recreaci\u00f3n de sockets) para mantenerse en un estado consistente. Fase 8: terminaci\u00f3n WiFi Invocaci\u00f3n a esp_wifi_disconnect() para desconectar la conexi\u00f3n en marcha. Invocaci\u00f3n a esp_wifi_stop() para parar el driver WiFi. Invocaci\u00f3n a esp_wifi_deinit() para descargar el driver WiFi. An\u00e1lisis de un ejemplo ( wifi/getting_started/station ) Tarea Analiza el ejemplo station , comp\u00edlalo y flashealo. Estudia el tratamiento de eventos que realiza, y c\u00f3mo estos son emitidos para casos reales. Para ello, conecta tu ESP32 con un punto de acceso existente, otro inexistente, apaga el punto de acceso mientras la IP est\u00e1 concedida, y analiza los eventos generados y su respuesta. Entregable 1 Revisa el tratamiento de eventos del c\u00f3digo anterior, a\u00f1ade el tratamiento de los eventos que falten por tratar. Entrega tu c\u00f3digo con comentarios explicando el c\u00f3digo a\u00f1adido. Modo Punto de Acceso La siguiente figura describe, a grandes rasgos, algunos de los escenarios principales que pueden darse en modo AP (access point) : El flujo de trabajo es muy similar al del modo station , con la diferencia b\u00e1sica del tipo de configuraci\u00f3n WiFi a realizar ( WIFI_MODE_AP ) y obviamente los par\u00e1metros de configuraci\u00f3n. Observa el siguiente ejemplo de configuraci\u00f3n: wifi_config_t wifi_config = { .ap = { .ssid = EXAMPLE_ESP_WIFI_SSID, .ssid_len = strlen(EXAMPLE_ESP_WIFI_SSID), .channel = EXAMPLE_ESP_WIFI_CHANNEL, .password = EXAMPLE_ESP_WIFI_PASS, .max_connection = EXAMPLE_MAX_STA_CONN, .authmode = WIFI_AUTH_WPA_WPA2_PSK }, }; if (strlen(EXAMPLE_ESP_WIFI_PASS) == 0) { wifi_config.ap.authmode = WIFI_AUTH_OPEN; } ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_AP)); ESP_ERROR_CHECK(esp_wifi_set_config(ESP_IF_WIFI_AP, &wifi_config)); Para m\u00e1s informaci\u00f3n sobre los par\u00e1metros de configuraci\u00f3n de un punto de acceso, consulta este enlace . An\u00e1lisis de un ejemplo ( wifi/getting_started/softAP ) Tarea Analiza el ejemplo softAP , comp\u00edlalo y flashealo. Estudia el tratamiento de eventos que realiza, y c\u00f3mo estos son emitidos para casos reales. Para ello, conecta distintos clientes ( stations ), bien sean ESP32 o cualquier otro dispositivo, y analiza los eventos generados y su respuesta. Entregable 2 Revisa el tratamiento de eventos del c\u00f3digo anterior, a\u00f1ade el tratamiento de los eventos que falten por tratar. A\u00f1ade en tu c\u00f3digo un comentario explicando el c\u00f3digo a\u00f1adido. Modo combinado Station/Punto de Acceso ESP-IDF soporta un modo mixto de conexi\u00f3n, en el que el ESP32 es a la vez un punto de acceso (AP) y una estaci\u00f3n ( station ). Este modo se configura utilizando el par\u00e1metro ESP_MODE_APSTA en la invocaci\u00f3n a la rutina esp_wifi_set_mode() . Adem\u00e1s, obviamente el firmware combinado requerir\u00e1 la creaci\u00f3n de dos estructuras de tipo wifi_config_t , una con los datos asociados al punto de acceso (campo .ap ) y otra con los campos asociados a la station (campo .sta ). A continuaci\u00f3n, ser\u00e1 necesario invocar a la rutina de configuraci\u00f3n ( esp_wifi_set_config ) con cada una de dichas estructuras (por \u00faltimo, tambi\u00e9n es necesario invocar a la inicializaci\u00f3n de netif tanto en modo station -- esp_netif_create_default_wifi_sta() -- como en modo AP -- esp_netif_create_default_wifi_ap() ). Ejercicio: desarrollo de un nodo mixto station/AP Entregable 3 Modifica el ejemplo station para que el ESP32 se comporte a la vez como estaci\u00f3n y como punto de acceso. A\u00f1ade las opciones de configuraci\u00f3n necesarias para que todos los par\u00e1metros se puedan modificar v\u00eda menuconfig . Comprueba que el ESP32 efectivamente se conecta al punto de acceso y que a la vez es posible conectar otro dispositivo al mismo (por ejemplo, tu tel\u00e9fono m\u00f3vil). Entrega el c\u00f3digo. Escaneado de redes WiFi Modos de escaneado de redes WiFi El modo de escaneo de redes WiFi (es decir, la invocaci\u00f3n de la rutina esp_wifi_scan_start() ) s\u00f3lo est\u00e1 soportada en la actualidad en modo station o station+AP . En este modo, se da soporte a distintos tipos de escaneado de redes, v\u00e9ase: Escaneado activo: El escaneado se desarrolla mediante el env\u00edo de paquetes probe y esperando respuesta, de forma activa. Escaneado pasivo: El escaneado se desarrolla simplemente escuchando en cada canal y esperando el env\u00edo por parte de los APs de paquetes baliza ( beacons ). El modo activo o pasivo puede configurarse desde la aplicaci\u00f3n, mediante el campo scan_type de la estrcutura wifi_scan_config_t (lo ver\u00e1s en el siguiente ejemplo). Escaneado en primer plano: : Se utiliza cuando no hay conexi\u00f3n WiFi activa en el momento del escaneado. No es, por tanto, directamente configurable. Escaneado en segundo plano: Se utiliza cuando hay conexi\u00f3n WiFi activa en el momento del escaneado. No es, por tanto, directamente configurable. Escaneado de todos los canales: Escanea SSIDs en todos los canales. La forma de activarlo es mediante el valor 0 en el campo correspondiente de wifi_scan_config_t . Escaneado de canal espec\u00edfico: Escanea \u00fanicamente en un canal. As\u00ed, existen 8 modos distintos de escaneado de red WiFi, resultantes de la combinaci\u00f3n de los anteriores modos, llamados: All-Channel Background Active Scan. All-Channel Background Passive Scan. All-Channel Foreground Active Scan. All-Channel Foreground Passive Scan. Specific-Channel Background Active Scan. Specific-Channel Background Passive Scan. Specific-Channel Foreground Active Scan. Specific-Channel Foreground Passive Scan. Configuraci\u00f3n de escaneado de redes WiFi Para configurar una sesi\u00f3n de escaneado, se utilizan los campos correspondientes de la estructura de tipo wifi_scan_config_t , proporcionada a la rutina esp_wifi_scan_start() , que es la encargada de iniciar la sesi\u00f3n. Los campos de dicha estructura son: ssid : Si SSID no es NULL, s\u00f3lo se escanea en b\u00fasqueda de este ssid . channel : Si es 0, se realiza un escaneado de todos los canales. En caso contrario, s\u00f3lo se escanea el canal especificado. show_hidden : Si es 0, se ignoran los AP con SSID oculto. En caso contrario se consideran SSIDs normales, y por tanto se muestran. scan_type : Si toma el valor WIFI_SCAN_TYPE_ACTIVE realiza un escaneado activo. En cualquier otro caso, el escaneado es pasivo. scan_time : Especifica el tiempo de escaneado por canal. Escaneado de todos los canales en primer plano. Ejemplo de flujo El siguiente escenario describe un escaneado b\u00e1sico sobre todos los canales en primer plano (recuerda que \u00fanicamente puede ocurrir en modo station si todav\u00eda no hay conexi\u00f3n a un AP). Fase 1: Configuraci\u00f3n del escaneado Se invoca a la rutina esp_wifi_set_country() para establecer el pa\u00eds donde se est\u00e1 desarrollando el escaneado (opcional). Se invoca a esp_wifi_scan_start() para configurar el escaneado. Para ello, se utilizan los par\u00e1metros por defecto o se configuran tal y como se ha especificado en la secci\u00f3n anterior. Fase 2: Fase de escaneado El driver WiFi cambia al canal 1 y emite (en caso de escaneado activo) en modo broadcast un paquete de tipo probe request . En caso de escaneado pasivo, seguir\u00e1 escuchando en el canal 1 durante un tiempo determinado a la espera de beacons . En cualquier caso, el valor por defecto de espera es de 120 milisengundos. El driver cambia al canal 2 y repite el proceso. El proceso se repite para N canales, donde N viene configurado seg\u00fan el pa\u00eds en el que se lleva a cabo el an\u00e1lisis. Fase 3: Fase de an\u00e1lisis de resultados Cuando todos los canales se han escaneado, se emite un evento de tipo WIFI_EVENT_SCAN_DONE . La aplicaci\u00f3n, a trav\u00e9s del callback correspondiente, recibe y procesa los resultados. Se invoca a esp_wifi_scan_get_ap_num() para obtener el n\u00famero de APs que se han encontrado. A continuaci\u00f3n, reserva memoria para este n\u00famero de entradas e invoca a esp_wifi_scan_get_ap_records() para obtener la informaci\u00f3n de cada AP. An\u00e1lisis de un ejemplo ( wifi/scan ) Analiza el ejemplo de escaneado wifi/scan , e intenta observar el flujo de trabajo detallado anteriormente. Tarea Compila, flashea y ejecuta el ejemplo de escaneado. Observa si los resultados son los esperados en el laboratorio o en un entorno dom\u00e9stico. Modifica el c\u00f3digo para conseguir distintos tipos de escaneado, asegur\u00e1ndote, por ejemplo, de que si fijas un canal espec\u00edfico en el que tu punto de acceso est\u00e1 trabajando, \u00e9ste es detectado corretamente. Estudia y modifica los tiempos de espera en el escaneado y observa su efecto en el tiempo total de escaneado. Entregable 4 Dise\u00f1a un firmware de nodo que realice un escaneado de las redes disponibles. Si el nodo detecta la presencia de una o m\u00e1s de las redes conocidas , se conectar\u00e1 en modo STA a la red de mayor prioridad entre las conocidas. Probadlo usando como redes conocidas la del laboratorio, vuestro m\u00f3vil y vuestro domicilio. Entregable 5 Codificar el c\u00f3digo de la tarea anterior para que la lista de redes conocidas y la prioridad relativa se puedan configurar con menuconfig. Conexi\u00f3n a una red WPA2 Enterprise ( eduroam ) Las \u00faltimas versiones de ESP-IDF permiten la conexi\u00f3n a redes con autenticaci\u00f3n RADIUS, como por ejemplo eduroam . Aunque los detalles de configuraci\u00f3n y desarrollo de un ejemplo concreto van m\u00e1s all\u00e1 del objetivo de la pr\u00e1ctica, es deseable realizar una prueba de conexi\u00f3n a eduroam en el laboratorio, ya que nos resultar\u00e1 de utilidad de cara a futuras pr\u00e1cticas. Para conectar a eduroam nuestro ESP32, necesitaremos seguir los siguientes pasos: Descarga el certificado de la CA de la UCM desde este enlace . Copia el fichero descargado, con nombre eduroam.crt al directorio main , y as\u00edgnale el nombre wpa2_ca.pem . Configura el proyecto a trav\u00e9s de idf.py menuconfig con los siguientes par\u00e1metros: SSID: eduroam Validate server: activo EAP method: TTLS Phase2 method for TTLS: PAP EAP ID: anonymous@ucm.es EAP USERNAME: (tu correo UCM) EAP PASSWORD: (tu contrase\u00f1a UCM) Entregable 6 Configura el ejemplo de autenticaci\u00f3n para WPA2 Enterprise con tus credenciales de eduroam. Compila y ejecuta el ejemplo de autenticaci\u00f3n y adjunta una captura de pantalla que demuestre la correcta conexi\u00f3n del nodo a eduroam .","title":"Pr\u00e1ctica 2"},{"location":"RPI-I/P2/#practica-2-wifi-en-el-esp32","text":"","title":"Pr\u00e1ctica 2. WiFi en el ESP32"},{"location":"RPI-I/P2/#objetivos","text":"Conocer el flujo de trabajo del driver WiFi en ESP-IDF. Analizar las diferencias entre un firmware desarrollado para trabajar en modo station y en modo AP . Desarrollar un firmware combinado para que funcione en modo AP y station de forma simult\u00e1nea. Conocer los mecanismos de escaneado de redes en ESP-IDF. Conectar a redes v\u00eda WPA2 Enterprise desde el ESP32 ( eduroam ).","title":"Objetivos"},{"location":"RPI-I/P2/#introduccion","text":"Las bibliotecas y componentes de soporte WiFi en ESP-IDF proporcionan soporte para configurar y monitorizar la conexi\u00f3n 802.11 sobre placas ESP32. Este soporte incluye configuraciones para: Modo station (modo cliente WiFi, o STA ). En este caso, el ESP32 conecta con un punto de acceso preconfigurado. Modo AP (tambi\u00e9n denominado softAP o modo Punto de Acceso ). En este caso, son las estaciones las que conectan al ESP32. Modo combinado AP-STA, donde el ESP32 act\u00faa de forma concurrente como punto de acceso (AP) y cliente WiFi conectado a otro punto de acceso (STA). Varios modos de seguridad tanto en modo cliente como en modo AP (WPA, WPA2, WEP, etc.) Escaneado de puntos de acceso (activo y pasivo). Provisionamiento de claves y modo WPS. Modo promiscuo para monitorizaci\u00f3n de paquetes IEEE 802.11. En la presente pr\u00e1ctica, a trav\u00e9s de ejemplos b\u00e1sicos, estudiaremos las caracter\u00edsticas principales soportadas por el driver WiFi sobre el ESP32. Todas estas caracter\u00edsticas pueden ser utilizadas a posteriori para el desarrollo de c\u00f3digos y proyectos m\u00e1s complejos con m\u00ednimas modificaciones.","title":"Introducci\u00f3n"},{"location":"RPI-I/P2/#modelo-de-programacion-del-driver-wifi-en-esp-idf","text":"El modelo de programaci\u00f3n del driver WiFi en ESP-IDF sigue un modelo de programaci\u00f3n sencillo que se puede resumir en la siguiente imagen: Puede considerarse que el driver WiFi es una caja negra independiente del resto de la aplicaci\u00f3n, como la pila TCP/IP, las tareas de aplicaci\u00f3n y los eventos. El c\u00f3digo de las tareas de aplicaci\u00f3n generalmente invoca a la API WiFi para inicializar el dispositivo inal\u00e1mbrico y tratar eventos espec\u00edficos cuando resulta necesario. El driver WiFi recibe invocaciones a su API, las procesa y emite eventos a la aplicaci\u00f3n. El tratamiento de eventos WiFi se basa en la biblioteca de eventos esp_event ; los eventos se env\u00edan por parte del driver al bucle de tratamiento de eventos por defecto . La aplicaci\u00f3n registra una serie de funciones callback , a trav\u00e9s de la funci\u00f3n esp_event_handler_register() , que ser\u00e1n las responsables de tratar estos eventos. Alg\u00fan tipo de eventos es tambi\u00e9n procesado por el componente esp_netif para proporcionar reacciones por defecto ante su recepci\u00f3n. Por ejemplo, cuando un dispositivo se conecta a un AP el esp_netif arranca un cliente DHCP para obtener una direcci\u00f3n IP sin intervenci\u00f3n del c\u00f3digo de usuario (aunque este comportamiento por defecto puede ser personalizado para, por ejemplo, asignar una direcci\u00f3n IP est\u00e1ticamente). Nota Toda la API mencionada a continuaci\u00f3n se encuentra descrita en profundidad aqu\u00ed . Se aconseja disponer de esta informaci\u00f3n durante el proceso de desarrollo y tambi\u00e9n en el propio desarrollo de la pr\u00e1ctica.","title":"Modelo de programaci\u00f3n del driver WiFi en ESP-IDF"},{"location":"RPI-I/P2/#eventos-wifi","text":"Se listan a continuaci\u00f3n algunos de los ejemplos m\u00e1s utilizados en la gesti\u00f3n de conexiones WiFi, que utilizaremos en los ejemplos posteriores. WIFI_EVENT_SCAN_DONE Este evento se env\u00eda autom\u00e1ticamente en la invocaci\u00f3n de esp_wifi_scan_start() , en los siguientes escenarios: El escaneado de redes se completa, es decir, se ha encontrado el punto de acceso (AP) objetivo. El escaneado de redes finaliza tras la invocaci\u00f3n de esp_wifi_scan_stop() . Se invoca al inicio de un nuevo escaneo (mediante la rutina esp_wifi_scan_start() ) antes de finalizar un escaneado previo. Este nuevo escaneado se superpondr\u00e1 al anterior y se emitir\u00e1 el evento. El evento no se emite cuando el escaneado se fuerza mediante la invocaci\u00f3n a esp_wifi_connect() . Ante la recepci\u00f3n de este evento, no se lanza ning\u00fan proceso espec\u00edfico como respuesta. La aplicaci\u00f3n necesitar\u00e1 invocar normalmente a esp_wifi_scan_get_ap_num() y a esp_wifi_scan_get_ap_records() para recoger la lista de APs escaneados y liberar los recursos (memoria) que se aloja en el proceso de escaneado. WIFI_EVENT_STA_START Este evento se env\u00eda cuando, tras la invocaci\u00f3n a esp_wifi_start() , \u00e9sta devuelve ESP_OK . Tras la recepci\u00f3n de este evento, se inicializa la interfaz de red, por lo que normalmente, tras la recepci\u00f3n de este evento se est\u00e1 listo para invocar a esp_wifi_connect() para comenzar el proceso de conexi\u00f3n con un punto de acceso (AP). WIFI_EVENT_STA_STOP Este evento se env\u00eda cuando, tras la invocaci\u00f3n a esp_wifi_stop() , \u00e9sta devuelve ESP_OK . Tras la recepci\u00f3n de este evento, se libera la direcci\u00f3n IP, se detiene el cliente DHCP y se liberan las conexiones TCP/UDP existentes. Normalmente no se trata desde el punto de vista de la aplicaci\u00f3n. WIFI_EVENT_STA_CONNECTED Este evento se env\u00eda cuando, tras la invocaci\u00f3n a esp_wifi_connect() , \u00e9sta devuelve ESP_OK . Tras la recepci\u00f3n de este evento, arranca un cliente DHCP para la obtenci\u00f3n de una direcci\u00f3n IP. A continuaci\u00f3n, si todo ha ido bien, el driver WiFi est\u00e1 listo para enviar y recibir datos. Dicho instante es el adecuado para comenzar con la l\u00f3gica de la aplicaci\u00f3n, siempre que \u00e9sta no dependa de la correcta obtenci\u00f3n de una direcci\u00f3n IP. Si este es el caso, ser\u00e1 necesario esperar a la obtenci\u00f3n de la misma esperando al evento WIFI_EVENT_STA_GOT_IP . WIFI_EVENT_STA_DISCONNECTED Este evento se genera en los siguientes escenarios: Cuando se invoca a las funciones esp_wifi_disconnect() , esp_wifi_stop() , esp_wifi_deinit() o esp_wifi_restart() y la estaci\u00f3n est\u00e1 conectada al punto de acceso. Cuando se invoca a esp_wifi_connect() , pero el driver WiFi no consigue configurar una conexi\u00f3n con el AP debido a cualquier raz\u00f3n (por ejemplo, el escaneo no puede encontrar el AP objetivo, el proceso de autenticaci\u00f3n no tiene \u00e9xito, etc). Si hay m\u00e1s de un AP con el mismo SSID, el evento se emite s\u00f3lo cuando el dispositivo no puede conectar a ninguno de los APs encontrados. Cuando la conexi\u00f3n WiFi se interrumpe, por ejemplo porque el dispositivo pierde N beacons emitidos por el AP, el AP expulsa al dispositivo, el modo de autenticaci\u00f3n cambia, etc. Resulta com\u00fan que la rutina de tratamiento del evento trate de invocar de nuevo a la funci\u00f3n esp_wifi_connect() para reintentar la conexi\u00f3n. WIFI_EVENT_STA_GOT_IP Este evento se emite cuando el cliente DHCP obtiene una direcci\u00f3n IPv4 desde un servidor DHCP, o cuando se modifica su direcci\u00f3n IPv4. El evento significa que todo est\u00e1 listo y que la aplicaci\u00f3n puede continuar con sus tareas (por ejemplo, creaci\u00f3n de sockets, inicializaci\u00f3n de protocolos, etc.) La direcci\u00f3n IPv4 podr\u00eda modificarse por alguna de las siguientes razones: El cliente DHCP no puede renovar la direcci\u00f3n IPv4 tras su expiraci\u00f3n (los servidores DHCP suelen conceder direcciones IP durante un tiempo limitado). El cliente DHCP se asocia a otra direcci\u00f3n. Se modifica la direcci\u00f3n IPv4 asignada est\u00e1ticamente (no v\u00eda DHCP). Normalmente, cuando la IP cambia, todos los sockets asociados a ella quedar\u00e1n en un estado no utilizable. As\u00ed, la recepci\u00f3n de este evento se suele aprovechar para cerrar y a continuaci\u00f3n recrear todos los sockets abiertos. WIFI_EVENT_STA_LOST_IP Evento emitido cuando una direcci\u00f3n IPv4 se convierte en una direcci\u00f3n inv\u00e1lida. El evento no se emite inmediatamente tras la desconexi\u00f3n WiFi, sino que inicializa un temporizador de tipo address lost . Si se obtiene una IP antes de su expiraci\u00f3n, el evento no se emite. En otro caso, se emite justo en el instante de expirci\u00f3n del temporizador. Normalmente, las aplicaciones no deben tratar este evento (suele usarse en tareas de depuraci\u00f3n). WIFI_EVENT_AP_START Emitido en el inicio de un AP (punto de acceso). WIFI_EVENT_AP_STACONNECTED Cuando un dispositivo ( station ) se conecta a un AP, \u00e9ste emite el event WIFI_EVENT_AP_STACONNECTED . Es posible ignorarlo, o aprovecharlo para obtener informaci\u00f3n sobre la estaci\u00f3n conectada, por ejemplo. WIFI_EVENT_AP_STADISCONNECTED Este evento se genera en los siguientes escenarios: La aplicaci\u00f3n invoca a esp_wifi_disconnect() o esp_wifi_deauth_sta() para desconectarla manualmente del punto de acceso. El driver WiFi expulsa al dispositivo ( station ), por ejemplo en una situaci\u00f3n en la que el AP no ha recibido paquetes en los \u00faltimos minutos. Cuando ocurre este evento, la aplicaci\u00f3n necesitar\u00eda (idealmente) tomar las medidas necesarias asociadas al mismo, por ejemplo, cerrar los sockets abiertos.","title":"Eventos WiFi"},{"location":"RPI-I/P2/#modo-station","text":"La siguiente figura describe, a grandes rasgos, algunos de los escenarios principales que pueden darse en modo station : Se analizan a continuaci\u00f3n las fases principales en este tipo de firmware (no todas tienen que estar necesariamente presentes en cualquier escenario). Fase 1: inicializaci\u00f3n WiFi La tarea principal invoca a esp_netif_init() para crear la pila IP y realizar las tareas de inicializaci\u00f3n pertinentes. La tarea principal invoca a esp_event_loop_create() para crear e inicializar el sistema de eventos. La tarea principal invoca a esp_netif_create_default_wifi_sta() para crear la interfaz de red que asocia el dispositivo con la pila TCP/IP. La tarea principal invoca a esp_wifi_init() para crear la tarea que manejar\u00e1 la conexi\u00f3n WiFi e inicializa el driver WiFi. Por \u00faltimo, se invoca (si as\u00ed se desea, aunque es lo m\u00e1s com\u00fan) a la API para la creaci\u00f3n de la tarea o tareas de aplicaci\u00f3n. Esta secuencia es la recomendada para la inicializaci\u00f3n del sistema de comunicaci\u00f3n WiFi, pero no es estrictamente obligatorio seguirla en dicho orden o en su totalidad. Por ejemplo, se podr\u00eda crear directamente una tarea de aplicaci\u00f3n (paso 5) y realizar la configuraci\u00f3n en su cuerpo, o se puede diferir su creaci\u00f3n hasta la obtenci\u00f3n de una direcci\u00f3n IP. Fase 2: configuraci\u00f3n WiFi Una vez inicializado el driver WiFi, comienza su configuraci\u00f3n. En este escenario, el modo debe fijarse a station a trav\u00e9s de una invocaci\u00f3n a esp_wifi_set_mode(WIFI_MODE_STA) . Es posible invocar a continuaci\u00f3n a otras rutinas de tipo esp_wifi_set_xxx() para configurar par\u00e1metros adicionales (pa\u00eds, ancho de banda, modo de protocolo, ...). Para m\u00e1s informaci\u00f3n sobre los modos de operaci\u00f3n ( station , AP o modo combinado station/AP , consulta el siguiente enlace ). Generalmente, es necesario configurar el driver WiFi antes de establecer una conexi\u00f3n, pero no es obligatorio: es posible reconfigurarlo en cualquier momento, siempre que el driver est\u00e9 correctamente incializado. En cualquier caso, si la configuraci\u00f3n no tiene que modificarse tras la conexi\u00f3n, es mejor realizarla en este punto, porque algunos de los par\u00e1metros que pueden variar forzar\u00e1n una reconexi\u00f3n WiFi, aspecto que es mejor evitar. La rutina esp_wifi_set_config() permite configurar los aspectos b\u00e1sicos de la conexi\u00f3n WiFi. Por ejemplo, el c\u00f3digo: wifi_config_t wifi_config = { .sta = { .ssid = EXAMPLE_ESP_WIFI_SSID, .password = EXAMPLE_ESP_WIFI_PASS, .threshold.authmode = WIFI_AUTH_WPA2_PSK, .pmf_cfg = { .capable = true, .required = false }, }, }; ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA) ); ESP_ERROR_CHECK(esp_wifi_set_config(ESP_IF_WIFI_STA, &wifi_config) ); Realiza una configuraci\u00f3n b\u00e1sica WiFi proporcionando SSID, contrase\u00f1a y modo de autenticaci\u00f3n antes de configurar la conexi\u00f3n. Fase 3: inicio WiFi Invocaci\u00f3n a esp_wifi_start() para iniciar el driver WiFi. El driver WiFi envia un evento WIFI_EVENT_STA_START , que ser\u00e1 tratado por la tarea de gesti\u00f3n de eventos por defecto para realizar las tareas necesarias e invocar\u00e1 a la runtina de tratamiento del evento a nivel de aplicaci\u00f3n. La aplicaci\u00f3n deber\u00e1 tratar el evento WIFI_EVENT_STA_START , invocando (se recomienda) a esp_wifi_connect() . Fase 4: conexi\u00f3n WiFi Una vez invocada esp_wifi_connect() , el dirver WiFi comienza un proceso interno de escaneado/conexi\u00f3n. Si dicho proceso tiene \u00e9xito, se genera un evento WIFI_EVENT_STA_CONNECTED . Autom\u00e1ticamente se invoca al cliente DHCP y comienza el proceso de obtenci\u00f3n de direcci\u00f3n IP. Generalmente, la aplicaci\u00f3n no suele responder a este evento, pero podr\u00eda por ejemplo imprimirse un mensaje por pantalla a modo de depuraci\u00f3n. En el segundo paso, la conexi\u00f3n podr\u00eda fallar, por ejemplo, si la contrase\u00f1a proporcionada es incorrecta. En dicho caso, se env\u00eda un evento de tipo WIFI_EVENT_STA_DISCONNECTED y se proporcionar\u00e1 la causa del error. En el paso 6 se trata este aspecto. Fase 5: obtenci\u00f3n de IP Una vez inicializado el cliente DHCP (paso 4.2) comienza la fase de obtenci\u00f3n de IP. Si se recibe con \u00e9xito una IP desde el servidor DHCP, se emite un evento de tipo IP_EVENT_STA_GOT_IP . La aplicaci\u00f3n tratar\u00e1 este evento. Realmente, en este punto puede comenzar la l\u00f3gica de red de la aplicaci\u00f3n, incluyendo, por ejemplo, la creaci\u00f3n de sockets TCP/UDP. Es imprescindible la recepci\u00f3n de una direcci\u00f3n IP antes de la inicializaci\u00f3n de sockets. Fase 6: desconexi\u00f3n WiFi Cuando finaliza de forma abrupta una conexi\u00f3n WiFi, por ejemplo al apagar el punto de acceso (AP), si la calidad de recepci\u00f3n (RSSI) es baja, etc. se emite un evento WIFI_EVENT_STA_DISCONNECTED . La tarea de aplicaci\u00f3n deber\u00eda tratar este evento para, t\u00edpicamente, reintentar la conexi\u00f3n a trav\u00e9s de una invocaci\u00f3n a esp_wifi_reconnect() . Fase 7: cambio de IP Cuando la direcci\u00f3n IP asignada a un dispositivo cambia, se emite un evento de tipo IP_EVENT_STA_GOT_IP . Por defecto, y de forma autom\u00e1tica, se activa el campo ip_change de la estructura de tipo ip_event_got_ip_t que acompa\u00f1a al evento. La aplicaci\u00f3n deber\u00eda tomar las medidas necesarias (por ejemplo, recreaci\u00f3n de sockets) para mantenerse en un estado consistente. Fase 8: terminaci\u00f3n WiFi Invocaci\u00f3n a esp_wifi_disconnect() para desconectar la conexi\u00f3n en marcha. Invocaci\u00f3n a esp_wifi_stop() para parar el driver WiFi. Invocaci\u00f3n a esp_wifi_deinit() para descargar el driver WiFi.","title":"Modo Station"},{"location":"RPI-I/P2/#analisis-de-un-ejemplo-wifigetting_startedstation","text":"Tarea Analiza el ejemplo station , comp\u00edlalo y flashealo. Estudia el tratamiento de eventos que realiza, y c\u00f3mo estos son emitidos para casos reales. Para ello, conecta tu ESP32 con un punto de acceso existente, otro inexistente, apaga el punto de acceso mientras la IP est\u00e1 concedida, y analiza los eventos generados y su respuesta. Entregable 1 Revisa el tratamiento de eventos del c\u00f3digo anterior, a\u00f1ade el tratamiento de los eventos que falten por tratar. Entrega tu c\u00f3digo con comentarios explicando el c\u00f3digo a\u00f1adido.","title":"An\u00e1lisis de un ejemplo (wifi/getting_started/station)"},{"location":"RPI-I/P2/#modo-punto-de-acceso","text":"La siguiente figura describe, a grandes rasgos, algunos de los escenarios principales que pueden darse en modo AP (access point) : El flujo de trabajo es muy similar al del modo station , con la diferencia b\u00e1sica del tipo de configuraci\u00f3n WiFi a realizar ( WIFI_MODE_AP ) y obviamente los par\u00e1metros de configuraci\u00f3n. Observa el siguiente ejemplo de configuraci\u00f3n: wifi_config_t wifi_config = { .ap = { .ssid = EXAMPLE_ESP_WIFI_SSID, .ssid_len = strlen(EXAMPLE_ESP_WIFI_SSID), .channel = EXAMPLE_ESP_WIFI_CHANNEL, .password = EXAMPLE_ESP_WIFI_PASS, .max_connection = EXAMPLE_MAX_STA_CONN, .authmode = WIFI_AUTH_WPA_WPA2_PSK }, }; if (strlen(EXAMPLE_ESP_WIFI_PASS) == 0) { wifi_config.ap.authmode = WIFI_AUTH_OPEN; } ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_AP)); ESP_ERROR_CHECK(esp_wifi_set_config(ESP_IF_WIFI_AP, &wifi_config)); Para m\u00e1s informaci\u00f3n sobre los par\u00e1metros de configuraci\u00f3n de un punto de acceso, consulta este enlace .","title":"Modo Punto de Acceso"},{"location":"RPI-I/P2/#analisis-de-un-ejemplo-wifigetting_startedsoftap","text":"Tarea Analiza el ejemplo softAP , comp\u00edlalo y flashealo. Estudia el tratamiento de eventos que realiza, y c\u00f3mo estos son emitidos para casos reales. Para ello, conecta distintos clientes ( stations ), bien sean ESP32 o cualquier otro dispositivo, y analiza los eventos generados y su respuesta. Entregable 2 Revisa el tratamiento de eventos del c\u00f3digo anterior, a\u00f1ade el tratamiento de los eventos que falten por tratar. A\u00f1ade en tu c\u00f3digo un comentario explicando el c\u00f3digo a\u00f1adido.","title":"An\u00e1lisis de un ejemplo (wifi/getting_started/softAP)"},{"location":"RPI-I/P2/#modo-combinado-stationpunto-de-acceso","text":"ESP-IDF soporta un modo mixto de conexi\u00f3n, en el que el ESP32 es a la vez un punto de acceso (AP) y una estaci\u00f3n ( station ). Este modo se configura utilizando el par\u00e1metro ESP_MODE_APSTA en la invocaci\u00f3n a la rutina esp_wifi_set_mode() . Adem\u00e1s, obviamente el firmware combinado requerir\u00e1 la creaci\u00f3n de dos estructuras de tipo wifi_config_t , una con los datos asociados al punto de acceso (campo .ap ) y otra con los campos asociados a la station (campo .sta ). A continuaci\u00f3n, ser\u00e1 necesario invocar a la rutina de configuraci\u00f3n ( esp_wifi_set_config ) con cada una de dichas estructuras (por \u00faltimo, tambi\u00e9n es necesario invocar a la inicializaci\u00f3n de netif tanto en modo station -- esp_netif_create_default_wifi_sta() -- como en modo AP -- esp_netif_create_default_wifi_ap() ).","title":"Modo combinado Station/Punto de Acceso"},{"location":"RPI-I/P2/#ejercicio-desarrollo-de-un-nodo-mixto-stationap","text":"Entregable 3 Modifica el ejemplo station para que el ESP32 se comporte a la vez como estaci\u00f3n y como punto de acceso. A\u00f1ade las opciones de configuraci\u00f3n necesarias para que todos los par\u00e1metros se puedan modificar v\u00eda menuconfig . Comprueba que el ESP32 efectivamente se conecta al punto de acceso y que a la vez es posible conectar otro dispositivo al mismo (por ejemplo, tu tel\u00e9fono m\u00f3vil). Entrega el c\u00f3digo.","title":"Ejercicio: desarrollo de un nodo mixto station/AP"},{"location":"RPI-I/P2/#escaneado-de-redes-wifi","text":"","title":"Escaneado de redes WiFi"},{"location":"RPI-I/P2/#modos-de-escaneado-de-redes-wifi","text":"El modo de escaneo de redes WiFi (es decir, la invocaci\u00f3n de la rutina esp_wifi_scan_start() ) s\u00f3lo est\u00e1 soportada en la actualidad en modo station o station+AP . En este modo, se da soporte a distintos tipos de escaneado de redes, v\u00e9ase: Escaneado activo: El escaneado se desarrolla mediante el env\u00edo de paquetes probe y esperando respuesta, de forma activa. Escaneado pasivo: El escaneado se desarrolla simplemente escuchando en cada canal y esperando el env\u00edo por parte de los APs de paquetes baliza ( beacons ). El modo activo o pasivo puede configurarse desde la aplicaci\u00f3n, mediante el campo scan_type de la estrcutura wifi_scan_config_t (lo ver\u00e1s en el siguiente ejemplo). Escaneado en primer plano: : Se utiliza cuando no hay conexi\u00f3n WiFi activa en el momento del escaneado. No es, por tanto, directamente configurable. Escaneado en segundo plano: Se utiliza cuando hay conexi\u00f3n WiFi activa en el momento del escaneado. No es, por tanto, directamente configurable. Escaneado de todos los canales: Escanea SSIDs en todos los canales. La forma de activarlo es mediante el valor 0 en el campo correspondiente de wifi_scan_config_t . Escaneado de canal espec\u00edfico: Escanea \u00fanicamente en un canal. As\u00ed, existen 8 modos distintos de escaneado de red WiFi, resultantes de la combinaci\u00f3n de los anteriores modos, llamados: All-Channel Background Active Scan. All-Channel Background Passive Scan. All-Channel Foreground Active Scan. All-Channel Foreground Passive Scan. Specific-Channel Background Active Scan. Specific-Channel Background Passive Scan. Specific-Channel Foreground Active Scan. Specific-Channel Foreground Passive Scan.","title":"Modos de escaneado de redes WiFi"},{"location":"RPI-I/P2/#configuracion-de-escaneado-de-redes-wifi","text":"Para configurar una sesi\u00f3n de escaneado, se utilizan los campos correspondientes de la estructura de tipo wifi_scan_config_t , proporcionada a la rutina esp_wifi_scan_start() , que es la encargada de iniciar la sesi\u00f3n. Los campos de dicha estructura son: ssid : Si SSID no es NULL, s\u00f3lo se escanea en b\u00fasqueda de este ssid . channel : Si es 0, se realiza un escaneado de todos los canales. En caso contrario, s\u00f3lo se escanea el canal especificado. show_hidden : Si es 0, se ignoran los AP con SSID oculto. En caso contrario se consideran SSIDs normales, y por tanto se muestran. scan_type : Si toma el valor WIFI_SCAN_TYPE_ACTIVE realiza un escaneado activo. En cualquier otro caso, el escaneado es pasivo. scan_time : Especifica el tiempo de escaneado por canal.","title":"Configuraci\u00f3n de escaneado de redes WiFi"},{"location":"RPI-I/P2/#escaneado-de-todos-los-canales-en-primer-plano-ejemplo-de-flujo","text":"El siguiente escenario describe un escaneado b\u00e1sico sobre todos los canales en primer plano (recuerda que \u00fanicamente puede ocurrir en modo station si todav\u00eda no hay conexi\u00f3n a un AP). Fase 1: Configuraci\u00f3n del escaneado Se invoca a la rutina esp_wifi_set_country() para establecer el pa\u00eds donde se est\u00e1 desarrollando el escaneado (opcional). Se invoca a esp_wifi_scan_start() para configurar el escaneado. Para ello, se utilizan los par\u00e1metros por defecto o se configuran tal y como se ha especificado en la secci\u00f3n anterior. Fase 2: Fase de escaneado El driver WiFi cambia al canal 1 y emite (en caso de escaneado activo) en modo broadcast un paquete de tipo probe request . En caso de escaneado pasivo, seguir\u00e1 escuchando en el canal 1 durante un tiempo determinado a la espera de beacons . En cualquier caso, el valor por defecto de espera es de 120 milisengundos. El driver cambia al canal 2 y repite el proceso. El proceso se repite para N canales, donde N viene configurado seg\u00fan el pa\u00eds en el que se lleva a cabo el an\u00e1lisis. Fase 3: Fase de an\u00e1lisis de resultados Cuando todos los canales se han escaneado, se emite un evento de tipo WIFI_EVENT_SCAN_DONE . La aplicaci\u00f3n, a trav\u00e9s del callback correspondiente, recibe y procesa los resultados. Se invoca a esp_wifi_scan_get_ap_num() para obtener el n\u00famero de APs que se han encontrado. A continuaci\u00f3n, reserva memoria para este n\u00famero de entradas e invoca a esp_wifi_scan_get_ap_records() para obtener la informaci\u00f3n de cada AP.","title":"Escaneado de todos los canales en primer plano. Ejemplo de flujo"},{"location":"RPI-I/P2/#analisis-de-un-ejemplo-wifiscan","text":"Analiza el ejemplo de escaneado wifi/scan , e intenta observar el flujo de trabajo detallado anteriormente. Tarea Compila, flashea y ejecuta el ejemplo de escaneado. Observa si los resultados son los esperados en el laboratorio o en un entorno dom\u00e9stico. Modifica el c\u00f3digo para conseguir distintos tipos de escaneado, asegur\u00e1ndote, por ejemplo, de que si fijas un canal espec\u00edfico en el que tu punto de acceso est\u00e1 trabajando, \u00e9ste es detectado corretamente. Estudia y modifica los tiempos de espera en el escaneado y observa su efecto en el tiempo total de escaneado. Entregable 4 Dise\u00f1a un firmware de nodo que realice un escaneado de las redes disponibles. Si el nodo detecta la presencia de una o m\u00e1s de las redes conocidas , se conectar\u00e1 en modo STA a la red de mayor prioridad entre las conocidas. Probadlo usando como redes conocidas la del laboratorio, vuestro m\u00f3vil y vuestro domicilio. Entregable 5 Codificar el c\u00f3digo de la tarea anterior para que la lista de redes conocidas y la prioridad relativa se puedan configurar con menuconfig.","title":"An\u00e1lisis de un ejemplo (wifi/scan)"},{"location":"RPI-I/P2/#conexion-a-una-red-wpa2-enterprise-eduroam","text":"Las \u00faltimas versiones de ESP-IDF permiten la conexi\u00f3n a redes con autenticaci\u00f3n RADIUS, como por ejemplo eduroam . Aunque los detalles de configuraci\u00f3n y desarrollo de un ejemplo concreto van m\u00e1s all\u00e1 del objetivo de la pr\u00e1ctica, es deseable realizar una prueba de conexi\u00f3n a eduroam en el laboratorio, ya que nos resultar\u00e1 de utilidad de cara a futuras pr\u00e1cticas. Para conectar a eduroam nuestro ESP32, necesitaremos seguir los siguientes pasos: Descarga el certificado de la CA de la UCM desde este enlace . Copia el fichero descargado, con nombre eduroam.crt al directorio main , y as\u00edgnale el nombre wpa2_ca.pem . Configura el proyecto a trav\u00e9s de idf.py menuconfig con los siguientes par\u00e1metros: SSID: eduroam Validate server: activo EAP method: TTLS Phase2 method for TTLS: PAP EAP ID: anonymous@ucm.es EAP USERNAME: (tu correo UCM) EAP PASSWORD: (tu contrase\u00f1a UCM) Entregable 6 Configura el ejemplo de autenticaci\u00f3n para WPA2 Enterprise con tus credenciales de eduroam. Compila y ejecuta el ejemplo de autenticaci\u00f3n y adjunta una captura de pantalla que demuestre la correcta conexi\u00f3n del nodo a eduroam .","title":"Conexi\u00f3n a una red WPA2 Enterprise (eduroam)"},{"location":"RPI-I/P3/","text":"Pr\u00e1ctica 3. WiFi. Provisionamiento y ahorro de energ\u00eda. Objetivos La presente pr\u00e1ctica se divide en dos partes en las que se estudiar\u00e1n dos aspectos avanzados de wifi. Los objetivos de cada parte son: Provisionamiento de credenciales wifi Entender y experimentar con distintos modos de provisionamiento de credenciales WiFi, v\u00eda BLE y v\u00eda softAP . Comprobar el intercambio de claves en claro realizando provisionamientos desde l\u00ednea de comandos, as\u00ed como observar la utilidad (y necesidad) del env\u00edo cifrado de credenciales. Modos de ahorro de energ\u00eda Entender los tres modos de funcionamiento del ESP32 a nivel de ahorro energ\u00e9tico en conexiones WiFi. Observar la desviaci\u00f3n en latencia de recepci\u00f3n de paquetes en funci\u00f3n del modo aplicado. Entregable Para esta pr\u00e1ctica los alumnos har\u00e1n un breve informe documentando las tareas realizadas y los resultados obtenidos. Parte 1.Provisionamiento de credenciales WiFi Entendemos por provisionamiento WiFi el mecanismo o mecanismos mediante los cuales es posible proporcionar a un dispositivo, de forma externa y segura, el conjunto de credenciales necesario para conectarse a una red WiFi. Es decir, si nuestro c\u00f3digo en el ESP32 est\u00e1 preparado para conectarse a una wifi por WPA2 personal, en lugar de configurar una red fija o una serie de redes v\u00e1lidas, a\u00f1adimos a nuestro c\u00f3digo un componente de provisionamiento, que permitir\u00e1 al usuario conectarse de alg\u00fan modo al ESP32 para indicarle el nombre de la Wifi a la que conectarse (la SSID) y la contrase\u00f1a que debe utilizar. El provisionamiento por tanto suele hacerse la primera vez que se usa el dispositivo y no suele ser necesario repetirlo. ESP-IDF proporciona un componente que ofrece un servicio de provisionamiento WiFi por dos mecanismos: Bluetooth Low Energy (modo BLE ) o a trav\u00e9s de un punto de acceso WiFi temporal (modo SoftAP ). ESP-IDF proporciona una serie de APIs (con prototipos wifi_prov_mgr_* ) para implementar de forma sencilla ambos modos de provisionamiento. Para completar esta parte de la pr\u00e1ctica deber\u00e1s trabajar con el ejemplo examples/provisioning/wifi-prov-mgr . Inicializaci\u00f3n del servicio de provisionamiento La rutina wifi_prov_mgr_init() se utiliza para configurar e inicializar el componente de provisionamiento, y debe invocarse antes de cualquier otra invocaci\u00f3n a rutinas de tipo wifi_prov_mgr* . Adem\u00e1s, es necesario destacar que el componente de provisionamiento conf\u00eda en las funcionalidades de otros componentes (b\u00e1sicamente NVS, TCP/IP, Event loop y mDNS), por lo que \u00e9stos deben inicializarse antes del propio componente. Para finalizar el componente de provisionamiento, es suficiente con invocar a la rutina wifi_prov_mgr_deinit() . Un ejemplo de inicializaci\u00f3n resultar\u00eda en: wifi_prov_mgr_config_t config = { .scheme = wifi_prov_scheme_ble, .scheme_event_handler = WIFI_PROV_SCHEME_BLE_EVENT_HANDLER_FREE_BTDM }; ESP_ERR_CHECK( wifi_prov_mgr_init(config) ); La estructura de configuraci\u00f3n de tipo wifi_prov_mgr_config_t dispone de campos que permiten especificar el comportamiento del componente. El campo scheme especifica el esquema (o tipo) de provisionamiento que vamos a usar, mientras que el campo scheme_event_handler indica la funci\u00f3n callback que tratar\u00e1 los eventos correspondientes al componente de provisionameinto. Disponemos de tres esquemas: wifi_prov_scheme_softap : se crea un punto de acceso temporal desde el nodo a provisionar. El provisionador debe conectarse a dicho punto de acceso y transmitir las credenciales via WiFi, utilizando el servidor HTTP creado por el componente de provisionamiento. wifi_prov_scheme_ble : el nodo crea un servidor GATT al que se puede conectar el provisionador utilizando Bluetooth Low Energy (BLE), que usar\u00e1 la tabla GATT para comunicar las credenciales Wifi. wifi_prov_scheme_console : transporta la informaci\u00f3n v\u00eda puerto serie Una vez provisionado el nodo, las credenciales se almacenan en la flash (NVS), quedando disponibles para el siguiente reinicio del nodo. Comprobaci\u00f3n del estado de provisionamiento Es posible comprobar el estado de provisionamiento de un dispositivo mediante una invocaci\u00f3n a wifi_prov_mgr_is_provisioned() , que chequea si las credenciales de conexi\u00f3n WiFi est\u00e1n almacenadas en la memoria no vol\u00e1til (NVS). Aunque existen distintos m\u00e9todos para eliminar la informaci\u00f3n de provisionamento almacenada en la NVS, utilizaremos el mecanismo proporcionado por idf.py para eliminar su contenido. Para ello, ejecutaremos: idf.py erase_flash Par\u00e1metros de inicializaci\u00f3n del servicio de provisionamiento WiFi Al inicializar el componente de provisionamiento, es necesario especificar un nombre de servicio y una clave. Esto se traduce en: SSID y contrase\u00f1a para el modo SoftAP (es decir, cuando el esquema de provisionamiento se ha configurado como wifi_prov_scheme_softap ). Nombre del dispositivo BLE para el modo BLE (es decir, cuando el esquema de provisionamiento se ha configurado como wifi_prov_scheme_ble ). Adem\u00e1s, internamente el componente de provisionamiento utiliza el mecanismo de comunicaci\u00f3n protocomm , que permite tres niveles de seguridad en la comunicaci\u00f3n de credenciales de provisionamiento: Nivel 0, que consiste en un intercambio de credenciales utilizando texto plano y sin PoP Nivel 1, que consiste en un handshake previo entre ambos extremos, con intercambio de claves y utilizando encriptaci\u00f3n AES-CTR para el intercambio de mensajes. Admite el uso de una prueba de posesi\u00f3n (PoP, proof of possession ). Nivel 2, que consiste en un handshake previo entre ambos extremos, con intercambio de claves y utilizando encriptaci\u00f3n AES-GCM para el intercambio de mensajes. Permite el uso de Sal y Verificador (salt and verifier). As\u00ed, un ejemplo de inicializaci\u00f3n del servicio de provisionamiento podr\u00eda resultar en el siguiente c\u00f3digo: const char *service_key = NULL; wifi_prov_security2_params_t sec2_params = {}; ESP_ERROR_CHECK(example_get_sec2_salt(&sec2_params.salt, &sec2_params.salt_len)); ESP_ERROR_CHECK(example_get_sec2_verifier(&sec2_params.verifier, &sec2_params.verifier_len)); wifi_prov_security2_params_t *sec_params = &sec2_params; ESP_ERROR_CHECK(wifi_prov_mgr_start_provisioning(security, (const void *) sec_params, service_name, service_key)); El servicio de provisionamiento finalizar\u00e1 autom\u00e1ticamente al conectar a un AP con \u00e9xito (es decir, al obtener IP desde el mismo). En cualquier caso, puede tambi\u00e9n detenerse de forma manual en cualquier momento a trav\u00e9s de la invocaci\u00f3n a wifi_prov_mgr_stop_provisioning() . Espera a la finalizaci\u00f3n del proceso de provisionamiento T\u00edpicamente, las aplicaciones de usuario en el ESP32 deber\u00e1n esperar a que el proceso de provisionamiento finalice antes de proceder. En ese momento, y antes de proceder, liberar\u00e1n los recursos que se alojaron para el proceso de provisionamiento, y comenzar\u00e1n con su l\u00f3gica habitual. Existen dos mecanismos para conseguir este efecto: En primer lugar, la soluci\u00f3n m\u00e1s simple consiste en utilizar una invocaci\u00f3n bloqueante a la rutina wifi_prov_mgr_wait() : // Inicializaci\u00f3n del servicio de provisionamiento ESP_ERR_CHECK( wifi_prov_mgr_start_provisioning(security, pop, service_name, service_key) ); // Espera a la compleci\u00f3n del provisionamiento wifi_prov_mgr_wait(); // Liberaci\u00f3n de recursos wifi_prov_mgr_deinit(); // A partir de aqu\u00ed, comenzar\u00eda la l\u00f3gica habitual de la aplicaci\u00f3n // ... El segundo mecanismo estar\u00eda basado en eventos (es decir, ser\u00eda no bloqueante ), interceptando y trabajando sobre eventos de tipo WIFI_PROV_EVENT e invocando a wifi_prov_mgr_deinit() cuando el identificador de evento sea WIFI_PROV_END : static void event_handler(void* arg, esp_event_base_t event_base, int event_id, void* event_data) { if (event_base == WIFI_PROV_EVENT && event_id == WIFI_PROV_END) { /* Liberar recursos una vez el proceso de provisionamiento ha finalizado */ wifi_prov_mgr_deinit(); } } Herramientas de provisionamiento para dispositivos m\u00f3viles Existen aplicaciones para m\u00f3viles preparadas por Espressif para llevar a cabo el proceso de provisionamiento sobre ESP32. Estas aplicaciones est\u00e1n disponibles tanto para dispositivos Android como IOS, en las versiones con transporte BLE o SoftAP: Android: Provisionamiento BLE . Provisionamiento SoftAP . IOS: Provisionamiento BLE . Provisionamiento SoftAP . Estas aplicaciones funcionan mediante una comunicaci\u00f3n muy sencilla con el ESP32 no provisionado, cuyos mecanismos dependen del transporte utilizado; en el caso de BLE, se crea una tabla GATT con distintas caracter\u00edsticas que ser\u00e1n utilizadas para escribir (enviar) datos en el dispositivo. Veremos qu\u00e9 es una tabla GATT en pr\u00f3ximas pr\u00e1cticas. En el caso de softAP , se crean una serie de endpoints (URIs HTTP) que permiten, de forma sencilla, leer y escribir aquellos datos que deseamos comunicar al otro extremo de la comunicaci\u00f3n. La siguiente tabla resume los endpoints creados por las versiones est\u00e1ndar del protocolo de provisionamiento (pueden ser modificados o adaptados en funci\u00f3n de la informaci\u00f3n adicional que deseemos intercambiar): Endpoint (BLE + Servidor GATT) URI (SoftAP + HTTP) Establecimiento de sesi\u00f3n prov-session http://IP:80/prov-session Escaneo de redes disponibles prov-scan http://IP:80/prov-scan Configuraci\u00f3n de provisionamiento prov-config http://IP:80/prov-config Versi\u00f3n del protocolo proto-ver http://IP:80/proto-ver Tarea Utilizando las aplicaciones correspondientes a tu dispositivo m\u00f3vil, tanto para el uso de BLE como de SoftAP, provisiona tu ESP32 utilizando las credenciales que correspondan a tu red WiFi. Recuerda, antes de cada repetici\u00f3n del experimento, utilizar la orden idf.py erase_flash para eliminar informaci\u00f3n de provisionamiento de sesiones anteriores. Comprueba el funcionamiento de los distintos niveles de seguridad. A\u00f1ade a tu informe las capturas de pantalla correspondientes a la salida del ESP32 que evidencien que el proceso de provisionamiento se ha realizado correctamente. Los detalles de este tipo de protocolo de provisionamiento quedan como ejercicio adicional al alumno, y van m\u00e1s all\u00e1 del objetivo de la pr\u00e1ctica. No obstante, es conveniente disponer de alg\u00fan mecanismo que permita inspeccionar lo que hacen, para determinar por ejemplo si el intercambio de credenciales se realiza como texto plano (en claro) o cifrado. Para ello podemos utilizar una herramienta de l\u00ednea de comandos proporcionada con el SDK de Espressif (ESP-IDF), llamada esp_prov.py , que se encuentra en el directorio tools/esp_prov de la instalaci\u00f3n. Nota Antes de utilizar el programa, debes instalar las dependencias respectivas ejecutando los siguientes comandos desde el directorio de instalaci\u00f3n del esp-idf: En linux bash install.sh --enable-pytest En windows install.bat --enable-pytest Esta herramienta, permite hacer el provisionamiento de los dispositivos desde nuestro port\u00e1til y ofrece adem\u00e1s la posibilidad de usar un end-point adicional (custom-data) para pasar informaci\u00f3n adicional de provisonamiento, como el nombre del dispositivo, alguna credencial que se necesite para un servidor externo, etc. Su uso es sencillo, y puede consultarse ejecutando python esp_prov.py -h . B\u00e1sicamente, se trata de usar esta herramienta como provisionador para un dispositivo, usando tanto ble como softAP . En el caso de usar softAP el ordenador debe conectarse a la wifi temporal generada por el nodo a provisionar. El componente de provisionamiento estar\u00e1 escuchando en el puerto 80 del nodo (192.168.4.1), la aplicaci\u00f3n se conectar\u00e1 a dicho servidor y realizar\u00e1 el provisionamiento, pasando las credenciales indicadas en la l\u00ednea de comandos: python esp_prov.py --transport softap --service_name \"192.168.4.1:80\" --sec_ver 0 --ssid SSID_EJEMPLO --passphrase CLAVE_EJEMPLO Podemos monitorizar los paquetes enviados utilizando cualquier sniffer de red, como por ejemplo WireShark. Esto nos permitir\u00e1 ver el contenido de los paquetes enviados por la red y determinar si la contrase\u00f1a se env\u00eda en claro o si por el contrario est\u00e1 cifrada. Podemos usar tambi\u00e9n ble y versiones de seguridad m\u00e1s avanzadas: python esp_prov.py --transport ble --sec_ver 2 En un caso como este, en el que no pasamos los datos necesarios como par\u00e1metros de la l\u00ednea de comandos, el programa nos ir\u00e1 preguntando los datos de forma interactiva. Tarea Realiza el proceso de provisionamiento con softAP desde l\u00ednea de comandos siguiendo el procedimiento explicado arriba. Captura el tr\u00e1fico de red con Wireshark y comprueba que la contrase\u00f1a se env\u00eda en claro (sin cifrar). A continuaci\u00f3n, pasa a un modo seguro (opci\u00f3n --sec_ver 2 ) y observa c\u00f3mo las claves se intercambian cifradas. Tarea Realiza el proceso de provisionamiento (con ble o softAP) y usa el par\u00e1metro --custom_data para pasar el nombre de dispositivo a usar. Modifica el programa para que en el bucle principal se muestre \"Hello world from ...\" sustituyendo los puntos suspensivos por el nombre recibido durante el provisionamiento. Parte 2. Modos de ahorro de consumo WiFi En la versi\u00f3n actual de ESP-IDF, el framework soporta distintos modos de ahorro de energ\u00eda, con soporte tanto a nivel de dispositivo ( station ) como de punto de acceso ( AP ). Todos estos modos se basan en las caracter\u00edsticas de ahorro de consumo contempladas en el est\u00e1ndar 802.11 (concretamente en el modo Modem-sleep ). El modo Modem-sleep trabaja exclusivamente cuando un dispositivo est\u00e1 configurado como station , y se encuentra conectado a un AP. Si el modo Modem-sleep est\u00e1 activo, el dispositivo var\u00eda su estado entre activo y sleep peri\u00f3dicamente. En el modo sleep , tres de los principales componentes del subsistema de comunicacion inal\u00e1mbrica (PHY, BB y RF) se desconectan para reducir el consumo energ\u00e9tico. Pese a permanecer desconectados, la estaci\u00f3n sigue conectada al AP en todo momento. Este modo soporta adem\u00e1s dos submodos de ahorro de consumo: m\u00ednimo y m\u00e1ximo . En el modo m\u00ednimo , la estaci\u00f3n se despierta cada DTIM para recibir un beacon. Debido a que los mensajes de difusi\u00f3n ( broadcast ) se transmiten tras cada DTIM, en este caso no se perder\u00e1n y ser\u00e1n recibidos por las estaciones. Sin embargo, el ahorro energ\u00e9tico puede ser reducido si el DTIM es breve (adem\u00e1s, DTIM est\u00e1 determinado por el AP, por lo que la estaci\u00f3n no tiene control sobre este par\u00e1metro). En el modo m\u00e1ximo , la estaci\u00f3n se despierta tras cada intervalo de escucha para recibir un beacon. Este intervalo de escucha no tiene que coincidir con el valor de DTIM , y de hecho suele fijarse a un valor mayor para conseguir mayor ahorro energ\u00e9tico. Los datos de broadcast podr\u00edan perderse usando este modo si la estaci\u00f3n est\u00e1 en estado de reposo mientras expira el temporizador DTIM . El valor del intervalo de escucha puede configurarse mediante una invocaci\u00f3n a esp_wifi_set_config() antes de conectar al AP. Para activar el modo m\u00ednimo , es neceario invocar a la rutina esp_wifi_set_ps(WIFI_PS_MIN_MODEM) ; para activar el modo m\u00e1ximo , es neceario invocar a la rutina esp_wifi_set_ps(WIFI_PS_MAX_MODEM) , ambos tras la invocaci\u00f3n de esp_wifi_init() . Los modos de ahorro se activar\u00e1n al conectar al AP, y se desactivar\u00e1n al desconectar. Es posible desactivar los modos de ahorro mediante una invocaci\u00f3n a esp_wifi_set_ps(WIFI_PS_NONE) . Obviamente, esto aumentar\u00e1 el consumo, pero reducir\u00e1 la latencia en la recepci\u00f3n de mensajes. Con el modo de ahorro activado, la recepci\u00f3n de los mensajes se retrasar\u00e1 tanto como el per\u00edodo DTIM (en modo m\u00ednimo ahorro) o el per\u00edodo de escucha (modo m\u00e1ximo ahorro). El modo por defecto es WIFI_PS_MIN_MODEM . En modo punto de acceso, ESP-IDF no soporta todos los modos de ahorro dictados en la especificaci\u00f3n WiFi. Concretamente, un AP programado v\u00eda ESP-IDF s\u00f3lo cachear\u00e1 (almacenar\u00e1 temporalmente) los paquetes de tipo unicast para las estaciones conectadas a dicho AP, pero no paquetes multicast para dichas estacioens. As\u00ed, con el modo de ahorro activo, las estaciones podr\u00edan perder paquetes multicast . El ejemplo examples/wifi/power_save ilustra mediante un c\u00f3digo sencillo la configuraci\u00f3n de una estaci\u00f3n en los dos modos de ahorro energ\u00e9tico. Estos modos pueden configurarse a trav\u00e9s del men\u00fa de configuraci\u00f3n; adem\u00e1s, se ofrece una opci\u00f3n para modificar el tiempo de escucha en el caso del modo de ahorro m\u00e1ximo . Tarea Compila, flashea y ejecuta el c\u00f3digo de ejemplo utilizando los tres modos disponibles (sin ahorro, con ahorro m\u00ednimo y con ahorro m\u00e1ximo). En todos los casos, conecta tu ESP32 a un punto de acceso y, desde un port\u00e1til conectado al mismo AP, ejecuta una serie de pings hacia el nodo y observa como cambia el tiempo de respuesta de los pings. En el caso del ahorro m\u00e1ximo, var\u00eda el tiempo de escucha y mira si afecta al tiempo de recepci\u00f3n de los pings. Para cada modo, representa gr\u00e1ficamente el tiempo de respuesta de la estaci\u00f3n en una gr\u00e1fica para cada petici\u00f3n ping , relacionando su comportamiento con los tiempos DTIM y de escucha. A\u00f1ade a tu informe de la pr\u00e1ctica una descripci\u00f3n del ejercicio. Comenta y discute los resultados que observes.","title":"Pr\u00e1ctica 3"},{"location":"RPI-I/P3/#practica-3-wifi-provisionamiento-y-ahorro-de-energia","text":"","title":"Pr\u00e1ctica 3. WiFi. Provisionamiento y ahorro de energ\u00eda."},{"location":"RPI-I/P3/#objetivos","text":"La presente pr\u00e1ctica se divide en dos partes en las que se estudiar\u00e1n dos aspectos avanzados de wifi. Los objetivos de cada parte son: Provisionamiento de credenciales wifi Entender y experimentar con distintos modos de provisionamiento de credenciales WiFi, v\u00eda BLE y v\u00eda softAP . Comprobar el intercambio de claves en claro realizando provisionamientos desde l\u00ednea de comandos, as\u00ed como observar la utilidad (y necesidad) del env\u00edo cifrado de credenciales. Modos de ahorro de energ\u00eda Entender los tres modos de funcionamiento del ESP32 a nivel de ahorro energ\u00e9tico en conexiones WiFi. Observar la desviaci\u00f3n en latencia de recepci\u00f3n de paquetes en funci\u00f3n del modo aplicado. Entregable Para esta pr\u00e1ctica los alumnos har\u00e1n un breve informe documentando las tareas realizadas y los resultados obtenidos.","title":"Objetivos"},{"location":"RPI-I/P3/#parte-1provisionamiento-de-credenciales-wifi","text":"Entendemos por provisionamiento WiFi el mecanismo o mecanismos mediante los cuales es posible proporcionar a un dispositivo, de forma externa y segura, el conjunto de credenciales necesario para conectarse a una red WiFi. Es decir, si nuestro c\u00f3digo en el ESP32 est\u00e1 preparado para conectarse a una wifi por WPA2 personal, en lugar de configurar una red fija o una serie de redes v\u00e1lidas, a\u00f1adimos a nuestro c\u00f3digo un componente de provisionamiento, que permitir\u00e1 al usuario conectarse de alg\u00fan modo al ESP32 para indicarle el nombre de la Wifi a la que conectarse (la SSID) y la contrase\u00f1a que debe utilizar. El provisionamiento por tanto suele hacerse la primera vez que se usa el dispositivo y no suele ser necesario repetirlo. ESP-IDF proporciona un componente que ofrece un servicio de provisionamiento WiFi por dos mecanismos: Bluetooth Low Energy (modo BLE ) o a trav\u00e9s de un punto de acceso WiFi temporal (modo SoftAP ). ESP-IDF proporciona una serie de APIs (con prototipos wifi_prov_mgr_* ) para implementar de forma sencilla ambos modos de provisionamiento. Para completar esta parte de la pr\u00e1ctica deber\u00e1s trabajar con el ejemplo examples/provisioning/wifi-prov-mgr .","title":"Parte 1.Provisionamiento de credenciales WiFi"},{"location":"RPI-I/P3/#inicializacion-del-servicio-de-provisionamiento","text":"La rutina wifi_prov_mgr_init() se utiliza para configurar e inicializar el componente de provisionamiento, y debe invocarse antes de cualquier otra invocaci\u00f3n a rutinas de tipo wifi_prov_mgr* . Adem\u00e1s, es necesario destacar que el componente de provisionamiento conf\u00eda en las funcionalidades de otros componentes (b\u00e1sicamente NVS, TCP/IP, Event loop y mDNS), por lo que \u00e9stos deben inicializarse antes del propio componente. Para finalizar el componente de provisionamiento, es suficiente con invocar a la rutina wifi_prov_mgr_deinit() . Un ejemplo de inicializaci\u00f3n resultar\u00eda en: wifi_prov_mgr_config_t config = { .scheme = wifi_prov_scheme_ble, .scheme_event_handler = WIFI_PROV_SCHEME_BLE_EVENT_HANDLER_FREE_BTDM }; ESP_ERR_CHECK( wifi_prov_mgr_init(config) ); La estructura de configuraci\u00f3n de tipo wifi_prov_mgr_config_t dispone de campos que permiten especificar el comportamiento del componente. El campo scheme especifica el esquema (o tipo) de provisionamiento que vamos a usar, mientras que el campo scheme_event_handler indica la funci\u00f3n callback que tratar\u00e1 los eventos correspondientes al componente de provisionameinto. Disponemos de tres esquemas: wifi_prov_scheme_softap : se crea un punto de acceso temporal desde el nodo a provisionar. El provisionador debe conectarse a dicho punto de acceso y transmitir las credenciales via WiFi, utilizando el servidor HTTP creado por el componente de provisionamiento. wifi_prov_scheme_ble : el nodo crea un servidor GATT al que se puede conectar el provisionador utilizando Bluetooth Low Energy (BLE), que usar\u00e1 la tabla GATT para comunicar las credenciales Wifi. wifi_prov_scheme_console : transporta la informaci\u00f3n v\u00eda puerto serie Una vez provisionado el nodo, las credenciales se almacenan en la flash (NVS), quedando disponibles para el siguiente reinicio del nodo.","title":"Inicializaci\u00f3n del servicio de provisionamiento"},{"location":"RPI-I/P3/#comprobacion-del-estado-de-provisionamiento","text":"Es posible comprobar el estado de provisionamiento de un dispositivo mediante una invocaci\u00f3n a wifi_prov_mgr_is_provisioned() , que chequea si las credenciales de conexi\u00f3n WiFi est\u00e1n almacenadas en la memoria no vol\u00e1til (NVS). Aunque existen distintos m\u00e9todos para eliminar la informaci\u00f3n de provisionamento almacenada en la NVS, utilizaremos el mecanismo proporcionado por idf.py para eliminar su contenido. Para ello, ejecutaremos: idf.py erase_flash","title":"Comprobaci\u00f3n del estado de provisionamiento"},{"location":"RPI-I/P3/#parametros-de-inicializacion-del-servicio-de-provisionamiento-wifi","text":"Al inicializar el componente de provisionamiento, es necesario especificar un nombre de servicio y una clave. Esto se traduce en: SSID y contrase\u00f1a para el modo SoftAP (es decir, cuando el esquema de provisionamiento se ha configurado como wifi_prov_scheme_softap ). Nombre del dispositivo BLE para el modo BLE (es decir, cuando el esquema de provisionamiento se ha configurado como wifi_prov_scheme_ble ). Adem\u00e1s, internamente el componente de provisionamiento utiliza el mecanismo de comunicaci\u00f3n protocomm , que permite tres niveles de seguridad en la comunicaci\u00f3n de credenciales de provisionamiento: Nivel 0, que consiste en un intercambio de credenciales utilizando texto plano y sin PoP Nivel 1, que consiste en un handshake previo entre ambos extremos, con intercambio de claves y utilizando encriptaci\u00f3n AES-CTR para el intercambio de mensajes. Admite el uso de una prueba de posesi\u00f3n (PoP, proof of possession ). Nivel 2, que consiste en un handshake previo entre ambos extremos, con intercambio de claves y utilizando encriptaci\u00f3n AES-GCM para el intercambio de mensajes. Permite el uso de Sal y Verificador (salt and verifier). As\u00ed, un ejemplo de inicializaci\u00f3n del servicio de provisionamiento podr\u00eda resultar en el siguiente c\u00f3digo: const char *service_key = NULL; wifi_prov_security2_params_t sec2_params = {}; ESP_ERROR_CHECK(example_get_sec2_salt(&sec2_params.salt, &sec2_params.salt_len)); ESP_ERROR_CHECK(example_get_sec2_verifier(&sec2_params.verifier, &sec2_params.verifier_len)); wifi_prov_security2_params_t *sec_params = &sec2_params; ESP_ERROR_CHECK(wifi_prov_mgr_start_provisioning(security, (const void *) sec_params, service_name, service_key)); El servicio de provisionamiento finalizar\u00e1 autom\u00e1ticamente al conectar a un AP con \u00e9xito (es decir, al obtener IP desde el mismo). En cualquier caso, puede tambi\u00e9n detenerse de forma manual en cualquier momento a trav\u00e9s de la invocaci\u00f3n a wifi_prov_mgr_stop_provisioning() .","title":"Par\u00e1metros de inicializaci\u00f3n del servicio de provisionamiento WiFi"},{"location":"RPI-I/P3/#espera-a-la-finalizacion-del-proceso-de-provisionamiento","text":"T\u00edpicamente, las aplicaciones de usuario en el ESP32 deber\u00e1n esperar a que el proceso de provisionamiento finalice antes de proceder. En ese momento, y antes de proceder, liberar\u00e1n los recursos que se alojaron para el proceso de provisionamiento, y comenzar\u00e1n con su l\u00f3gica habitual. Existen dos mecanismos para conseguir este efecto: En primer lugar, la soluci\u00f3n m\u00e1s simple consiste en utilizar una invocaci\u00f3n bloqueante a la rutina wifi_prov_mgr_wait() : // Inicializaci\u00f3n del servicio de provisionamiento ESP_ERR_CHECK( wifi_prov_mgr_start_provisioning(security, pop, service_name, service_key) ); // Espera a la compleci\u00f3n del provisionamiento wifi_prov_mgr_wait(); // Liberaci\u00f3n de recursos wifi_prov_mgr_deinit(); // A partir de aqu\u00ed, comenzar\u00eda la l\u00f3gica habitual de la aplicaci\u00f3n // ... El segundo mecanismo estar\u00eda basado en eventos (es decir, ser\u00eda no bloqueante ), interceptando y trabajando sobre eventos de tipo WIFI_PROV_EVENT e invocando a wifi_prov_mgr_deinit() cuando el identificador de evento sea WIFI_PROV_END : static void event_handler(void* arg, esp_event_base_t event_base, int event_id, void* event_data) { if (event_base == WIFI_PROV_EVENT && event_id == WIFI_PROV_END) { /* Liberar recursos una vez el proceso de provisionamiento ha finalizado */ wifi_prov_mgr_deinit(); } }","title":"Espera a la finalizaci\u00f3n del proceso de provisionamiento"},{"location":"RPI-I/P3/#herramientas-de-provisionamiento-para-dispositivos-moviles","text":"Existen aplicaciones para m\u00f3viles preparadas por Espressif para llevar a cabo el proceso de provisionamiento sobre ESP32. Estas aplicaciones est\u00e1n disponibles tanto para dispositivos Android como IOS, en las versiones con transporte BLE o SoftAP: Android: Provisionamiento BLE . Provisionamiento SoftAP . IOS: Provisionamiento BLE . Provisionamiento SoftAP . Estas aplicaciones funcionan mediante una comunicaci\u00f3n muy sencilla con el ESP32 no provisionado, cuyos mecanismos dependen del transporte utilizado; en el caso de BLE, se crea una tabla GATT con distintas caracter\u00edsticas que ser\u00e1n utilizadas para escribir (enviar) datos en el dispositivo. Veremos qu\u00e9 es una tabla GATT en pr\u00f3ximas pr\u00e1cticas. En el caso de softAP , se crean una serie de endpoints (URIs HTTP) que permiten, de forma sencilla, leer y escribir aquellos datos que deseamos comunicar al otro extremo de la comunicaci\u00f3n. La siguiente tabla resume los endpoints creados por las versiones est\u00e1ndar del protocolo de provisionamiento (pueden ser modificados o adaptados en funci\u00f3n de la informaci\u00f3n adicional que deseemos intercambiar): Endpoint (BLE + Servidor GATT) URI (SoftAP + HTTP) Establecimiento de sesi\u00f3n prov-session http://IP:80/prov-session Escaneo de redes disponibles prov-scan http://IP:80/prov-scan Configuraci\u00f3n de provisionamiento prov-config http://IP:80/prov-config Versi\u00f3n del protocolo proto-ver http://IP:80/proto-ver Tarea Utilizando las aplicaciones correspondientes a tu dispositivo m\u00f3vil, tanto para el uso de BLE como de SoftAP, provisiona tu ESP32 utilizando las credenciales que correspondan a tu red WiFi. Recuerda, antes de cada repetici\u00f3n del experimento, utilizar la orden idf.py erase_flash para eliminar informaci\u00f3n de provisionamiento de sesiones anteriores. Comprueba el funcionamiento de los distintos niveles de seguridad. A\u00f1ade a tu informe las capturas de pantalla correspondientes a la salida del ESP32 que evidencien que el proceso de provisionamiento se ha realizado correctamente. Los detalles de este tipo de protocolo de provisionamiento quedan como ejercicio adicional al alumno, y van m\u00e1s all\u00e1 del objetivo de la pr\u00e1ctica. No obstante, es conveniente disponer de alg\u00fan mecanismo que permita inspeccionar lo que hacen, para determinar por ejemplo si el intercambio de credenciales se realiza como texto plano (en claro) o cifrado. Para ello podemos utilizar una herramienta de l\u00ednea de comandos proporcionada con el SDK de Espressif (ESP-IDF), llamada esp_prov.py , que se encuentra en el directorio tools/esp_prov de la instalaci\u00f3n. Nota Antes de utilizar el programa, debes instalar las dependencias respectivas ejecutando los siguientes comandos desde el directorio de instalaci\u00f3n del esp-idf: En linux bash install.sh --enable-pytest En windows install.bat --enable-pytest Esta herramienta, permite hacer el provisionamiento de los dispositivos desde nuestro port\u00e1til y ofrece adem\u00e1s la posibilidad de usar un end-point adicional (custom-data) para pasar informaci\u00f3n adicional de provisonamiento, como el nombre del dispositivo, alguna credencial que se necesite para un servidor externo, etc. Su uso es sencillo, y puede consultarse ejecutando python esp_prov.py -h . B\u00e1sicamente, se trata de usar esta herramienta como provisionador para un dispositivo, usando tanto ble como softAP . En el caso de usar softAP el ordenador debe conectarse a la wifi temporal generada por el nodo a provisionar. El componente de provisionamiento estar\u00e1 escuchando en el puerto 80 del nodo (192.168.4.1), la aplicaci\u00f3n se conectar\u00e1 a dicho servidor y realizar\u00e1 el provisionamiento, pasando las credenciales indicadas en la l\u00ednea de comandos: python esp_prov.py --transport softap --service_name \"192.168.4.1:80\" --sec_ver 0 --ssid SSID_EJEMPLO --passphrase CLAVE_EJEMPLO Podemos monitorizar los paquetes enviados utilizando cualquier sniffer de red, como por ejemplo WireShark. Esto nos permitir\u00e1 ver el contenido de los paquetes enviados por la red y determinar si la contrase\u00f1a se env\u00eda en claro o si por el contrario est\u00e1 cifrada. Podemos usar tambi\u00e9n ble y versiones de seguridad m\u00e1s avanzadas: python esp_prov.py --transport ble --sec_ver 2 En un caso como este, en el que no pasamos los datos necesarios como par\u00e1metros de la l\u00ednea de comandos, el programa nos ir\u00e1 preguntando los datos de forma interactiva. Tarea Realiza el proceso de provisionamiento con softAP desde l\u00ednea de comandos siguiendo el procedimiento explicado arriba. Captura el tr\u00e1fico de red con Wireshark y comprueba que la contrase\u00f1a se env\u00eda en claro (sin cifrar). A continuaci\u00f3n, pasa a un modo seguro (opci\u00f3n --sec_ver 2 ) y observa c\u00f3mo las claves se intercambian cifradas. Tarea Realiza el proceso de provisionamiento (con ble o softAP) y usa el par\u00e1metro --custom_data para pasar el nombre de dispositivo a usar. Modifica el programa para que en el bucle principal se muestre \"Hello world from ...\" sustituyendo los puntos suspensivos por el nombre recibido durante el provisionamiento.","title":"Herramientas de provisionamiento para dispositivos m\u00f3viles"},{"location":"RPI-I/P3/#parte-2-modos-de-ahorro-de-consumo-wifi","text":"En la versi\u00f3n actual de ESP-IDF, el framework soporta distintos modos de ahorro de energ\u00eda, con soporte tanto a nivel de dispositivo ( station ) como de punto de acceso ( AP ). Todos estos modos se basan en las caracter\u00edsticas de ahorro de consumo contempladas en el est\u00e1ndar 802.11 (concretamente en el modo Modem-sleep ). El modo Modem-sleep trabaja exclusivamente cuando un dispositivo est\u00e1 configurado como station , y se encuentra conectado a un AP. Si el modo Modem-sleep est\u00e1 activo, el dispositivo var\u00eda su estado entre activo y sleep peri\u00f3dicamente. En el modo sleep , tres de los principales componentes del subsistema de comunicacion inal\u00e1mbrica (PHY, BB y RF) se desconectan para reducir el consumo energ\u00e9tico. Pese a permanecer desconectados, la estaci\u00f3n sigue conectada al AP en todo momento. Este modo soporta adem\u00e1s dos submodos de ahorro de consumo: m\u00ednimo y m\u00e1ximo . En el modo m\u00ednimo , la estaci\u00f3n se despierta cada DTIM para recibir un beacon. Debido a que los mensajes de difusi\u00f3n ( broadcast ) se transmiten tras cada DTIM, en este caso no se perder\u00e1n y ser\u00e1n recibidos por las estaciones. Sin embargo, el ahorro energ\u00e9tico puede ser reducido si el DTIM es breve (adem\u00e1s, DTIM est\u00e1 determinado por el AP, por lo que la estaci\u00f3n no tiene control sobre este par\u00e1metro). En el modo m\u00e1ximo , la estaci\u00f3n se despierta tras cada intervalo de escucha para recibir un beacon. Este intervalo de escucha no tiene que coincidir con el valor de DTIM , y de hecho suele fijarse a un valor mayor para conseguir mayor ahorro energ\u00e9tico. Los datos de broadcast podr\u00edan perderse usando este modo si la estaci\u00f3n est\u00e1 en estado de reposo mientras expira el temporizador DTIM . El valor del intervalo de escucha puede configurarse mediante una invocaci\u00f3n a esp_wifi_set_config() antes de conectar al AP. Para activar el modo m\u00ednimo , es neceario invocar a la rutina esp_wifi_set_ps(WIFI_PS_MIN_MODEM) ; para activar el modo m\u00e1ximo , es neceario invocar a la rutina esp_wifi_set_ps(WIFI_PS_MAX_MODEM) , ambos tras la invocaci\u00f3n de esp_wifi_init() . Los modos de ahorro se activar\u00e1n al conectar al AP, y se desactivar\u00e1n al desconectar. Es posible desactivar los modos de ahorro mediante una invocaci\u00f3n a esp_wifi_set_ps(WIFI_PS_NONE) . Obviamente, esto aumentar\u00e1 el consumo, pero reducir\u00e1 la latencia en la recepci\u00f3n de mensajes. Con el modo de ahorro activado, la recepci\u00f3n de los mensajes se retrasar\u00e1 tanto como el per\u00edodo DTIM (en modo m\u00ednimo ahorro) o el per\u00edodo de escucha (modo m\u00e1ximo ahorro). El modo por defecto es WIFI_PS_MIN_MODEM . En modo punto de acceso, ESP-IDF no soporta todos los modos de ahorro dictados en la especificaci\u00f3n WiFi. Concretamente, un AP programado v\u00eda ESP-IDF s\u00f3lo cachear\u00e1 (almacenar\u00e1 temporalmente) los paquetes de tipo unicast para las estaciones conectadas a dicho AP, pero no paquetes multicast para dichas estacioens. As\u00ed, con el modo de ahorro activo, las estaciones podr\u00edan perder paquetes multicast . El ejemplo examples/wifi/power_save ilustra mediante un c\u00f3digo sencillo la configuraci\u00f3n de una estaci\u00f3n en los dos modos de ahorro energ\u00e9tico. Estos modos pueden configurarse a trav\u00e9s del men\u00fa de configuraci\u00f3n; adem\u00e1s, se ofrece una opci\u00f3n para modificar el tiempo de escucha en el caso del modo de ahorro m\u00e1ximo . Tarea Compila, flashea y ejecuta el c\u00f3digo de ejemplo utilizando los tres modos disponibles (sin ahorro, con ahorro m\u00ednimo y con ahorro m\u00e1ximo). En todos los casos, conecta tu ESP32 a un punto de acceso y, desde un port\u00e1til conectado al mismo AP, ejecuta una serie de pings hacia el nodo y observa como cambia el tiempo de respuesta de los pings. En el caso del ahorro m\u00e1ximo, var\u00eda el tiempo de escucha y mira si afecta al tiempo de recepci\u00f3n de los pings. Para cada modo, representa gr\u00e1ficamente el tiempo de respuesta de la estaci\u00f3n en una gr\u00e1fica para cada petici\u00f3n ping , relacionando su comportamiento con los tiempos DTIM y de escucha. A\u00f1ade a tu informe de la pr\u00e1ctica una descripci\u00f3n del ejercicio. Comenta y discute los resultados que observes.","title":"Parte 2. Modos de ahorro de consumo WiFi"},{"location":"RPI-I/P4/","text":"Pr\u00e1ctica 4. ESP WiFi Mesh Objetivos Revisar los conceptos b\u00e1sicos para la construcci\u00f3n de una red MESH WiFi autogestionada. Presentar la API b\u00e1sica para la creaci\u00f3n de aplicaciones basadas en la pila ESP-MESH. Observar en funcionamiento una red ESP-MESH, as\u00ed como sus capacidades de autoconfiguraci\u00f3n. Entregable Para esta pr\u00e1ctica los alumnos har\u00e1n un breve informe documentando las tareas realizadas y los resultados obtenidos. ESP WiFi Mesh El stack ESP-MESH est\u00e1 construido por encima del driver WiFi (es decir, obviamente hace uso de sus servicios), y en algunos casos tambi\u00e9n haciendo uso de servicios de la pila IP ( lwIP ), por ejemplo en el nodo ra\u00edz, que es el \u00fanico con comunicaci\u00f3n IP contra un router de borde. El siguiente diagrama muestra la situaci\u00f3n de la pila Mesh en ESP-IDF: Como cualquier otro componente ESP-IDF, ESP-MESH se comunica con las aplicaciones a trav\u00e9s de eventos propios: El tipo mesh_event_id_t define todos los posibles eventos que pueden surgir en las distintas fases del ciclo de vida de una red (por ejemplo, para un nodo determinado, conexi\u00f3n o desconexi\u00f3n de su nodo padre, o de uno de sus nodos hijo). Antes de utilizar los eventos ESP-MESH para gestionar u observar el funcionamiento de la red, es necesario registrarlos v\u00eda esp_event_handler_register() . Algunos usos t\u00edpicos de los eventos incluyen, por ejemplo, la situaci\u00f3n de conexi\u00f3n de un nodo padre ( MESH_EVENT_PARENT_CONNECTED ) o de un hijo ( MESH_EVENT_CHILD_CONNECTED ), indicando, respectivamente, que un nodo puede comenzar a emitir hacia arriba en el grafo, o hacia abajo. Del mismo modo, en un nodo ra\u00edz, la recepci\u00f3n de los eventos IP_EVENT_STA_GOT_IP y IP_EVENT_STA_LOST_IP se pueden aprovechar para indicar que dicho nodo ra\u00edz puede o no enviar datos a la red IP externa. Eventos MESH_EVENT_STARTED : mesh iniciada. MESH_EVENT_STOPPED : mesh finalizada. MESH_EVENT_CHANNEL_SWITCH : cambio de canal. MESH_EVENT_CHILD_CONNECTED : un hijo ha conectado a la interfaz softAP . MESH_EVENT_CHILD_DISCONNECTED : un hijo ha desconectado de la interfaz softAP . MESH_EVENT_ROUTING_TABLE_ADD : se han a\u00f1adido nuevas entradas a la tabla de enrutamiento a\u00f1adiendo nuevos hijos. MESH_EVENT_ROUTING_TABLE_REMOVE : se ha eliminado entradas de la tabla de enrutamiento eliminado hijos que han abandonado la red. MESH_EVENT_PARENT_CONNECTED : un padre se ha conectado a la interfaz station . MESH_EVENT_PARENT_DISCONNECTED : un padre se ha desconectado de la interfaz station . MESH_EVENT_NO_PARENT_FOUND : no se ha encontrado un padre. MESH_EVENT_LAYER_CHANGE : el nodo ha cambiado de nivel en la red. MESH_EVENT_TODS_STATE : indica que el nodo ra\u00edz es capaz de acceder a la red IP externa. MESH_EVENT_VOTE_STARTED : el proceso de voto de un nuevo nodo ra\u00edz ha comenzado. MESH_EVENT_VOTE_STOPPED : el proceo de voto de un nuevo nodo ra\u00edz ha finalizado. MESH_EVENT_ROOT_ADDRESS : se ha obtenido la direcci\u00f3n del nodo ra\u00edz. MESH_EVENT_ROOT_SWITCH_REQ : un nodo ra\u00edz candidato ya elegido solicita un cambio de nodo ra\u00edz. MESH_EVENT_ROOT_SWITCH_ACK : respuesta a la anterior petici\u00f3n por parte del nodo ra\u00edz actual. MESH_EVENT_NETWORK_STATE : la actual red tiene un nodo ra\u00edz. MESH_EVENT_STOP_RECONNECTION : el nodo ra\u00edz detiene el proceso de reconexi\u00f3n al router y los dem\u00e1s nodos detienen los procesos de conexi\u00f3n a sus nodos padre. MESH_EVENT_FIND_NETWORK : si el canal solicitado es 0, la pila escanear\u00e1 todos los canales para encontrar una red mesh a la que conectar, devolviendo el canal en el que lo ha conseguido. Uso de la pila IP (lwIP) El c\u00f3digo de una aplicaci\u00f3n que haga uso de ESP-MESH puede acceder directamente a la pila MESH sin pasar por la pila IP. De hecho, la pila IP s\u00f3lo es estrictamente necesaria por parte del nodo ra\u00edz, al ser el \u00fanico que puede recibir o transmitir datos desde o hacia la red IP externa. Sin embargo, como cualquier nodo de la topolog\u00eda puede potencialmente convertirse en nodo ra\u00edz (ya que su selecci\u00f3n es autom\u00e1tica), todos los nodos deber\u00e1n inicializar la pila IP. Cada nodo que pueda convertirse en root debe inicializar LwIP llamando a esp_netif_init() . Para prevenir el acceso de nodos no-root a LwIP, la aplicaci\u00f3n no debe crear o registrar ninguna interfaz de red usando el API de esp_netif . ESP-WIFI-MESH requiere que un nodo ra\u00edz est\u00e9 conectado con un router. Por lo tanto, en el caso de que un nodo se convierta en ra\u00edz, el manejador correspondiente debe iniciar el servicio cliente DHCP y obtener inmediatamente una direcci\u00f3n IP. Hacer esto permitir\u00e1 a otros nodos comenzar a transmitir/recibir paquetes hacia/desde la red IP externa. Sin embargo, este paso es innecesario si se utilizan configuraciones IP est\u00e1ticas. Estructura b\u00e1sica de una aplicaci\u00f3n ESP-MESH Los requisitos previos para iniciar ESP-WIFI-MESH es inicializar LwIP y Wi-Fi, El siguiente fragmento de c\u00f3digo demuestra los pasos necesarios requisito previo antes de ESP-WIFI-MESH en s\u00ed se puede inicializar. ESP_ERROR_CHECK(esp_netif_init()); /* event initialization */ ESP_ERROR_CHECK(esp_event_loop_create_default()); /* Wi-Fi initialization */ wifi_init_config_t config = WIFI_INIT_CONFIG_DEFAULT(); ESP_ERROR_CHECK(esp_wifi_init(&config)); /* register IP events handler */ ESP_ERROR_CHECK(esp_event_handler_register(IP_EVENT, IP_EVENT_STA_GOT_IP, &ip_event_handler, NULL)); ESP_ERROR_CHECK(esp_wifi_set_storage(WIFI_STORAGE_FLASH)); ESP_ERROR_CHECK(esp_wifi_start()); Tras inicializar LwIP y Wi-Fi, el proceso para poner en marcha una red ESP-WIFI-MESH puede resumirse en los tres pasos siguientes: Inicializar ESP-MESH Configurar una red ESP-WIFI-MESH Iniciar Mesh Paso 1. Inicializar ESP-MESH La inicializaci\u00f3n de ESP-MESH y el registro de eventos propios es sencilla: /* mesh initialization */ ESP_ERROR_CHECK(esp_mesh_init()); /* register mesh events handler */ ESP_ERROR_CHECK(esp_event_handler_register(MESH_EVENT, ESP_EVENT_ANY_ID, &mesh_event_handler, NULL)); Paso 2. Configurar una red ESP-WIFI-MESH ESP-WIFI-MESH se configura a trav\u00e9s de esp_mesh_set_config() que recibe sus argumentos usando la estructura mesh_cfg_t . La estructura contiene los siguientes par\u00e1metros utilizados para configurar ESP-WIFI-MESH: Par\u00e1metro Descripci\u00f3n Channel Canal (entre 1 y 14) Mesh ID Identificaci\u00f3n de la red MESH (6 bytes) Router SSID y contrase\u00f1a de conexi\u00f3n al router de salida Mesh AP Configuraci\u00f3n espec\u00edfica del AP generado por cada nodo Crypto Functions Funciones criptogr\u00e1ficas para Mesh IE Un ejemplo de configuraci\u00f3n podr\u00eda ser: /* Enable the Mesh IE encryption by default */ mesh_cfg_t cfg = MESH_INIT_CONFIG_DEFAULT(); /* mesh ID */ memcpy((uint8_t *) &cfg.mesh_id, MESH_ID, 6); /* channel (must match the router's channel) */ cfg.channel = CONFIG_MESH_CHANNEL; /* router */ cfg.router.ssid_len = strlen(CONFIG_MESH_ROUTER_SSID); memcpy((uint8_t *) &cfg.router.ssid, CONFIG_MESH_ROUTER_SSID, cfg.router.ssid_len); memcpy((uint8_t *) &cfg.router.password, CONFIG_MESH_ROUTER_PASSWD, strlen(CONFIG_MESH_ROUTER_PASSWD)); /* mesh softAP */ cfg.mesh_ap.max_connection = CONFIG_MESH_AP_CONNECTIONS; memcpy((uint8_t *) &cfg.mesh_ap.password, CONFIG_MESH_AP_PASSWD, strlen(CONFIG_MESH_AP_PASSWD)); ESP_ERROR_CHECK(esp_mesh_set_config(&cfg)); Paso 3. Arranque de la red El arranque de la red MESH es sencillo: /* mesh start */ ESP_ERROR_CHECK(esp_mesh_start()); Tras el arranque, la aplicaci\u00f3n deber\u00eda comprobar los eventos para determinar si la conexi\u00f3n a la red ha sido exitosa. Tras la conexi\u00f3n, la aplicaci\u00f3n puede comenzar a transmitir paquetes a trav\u00e9s de la red MESH utilizando las rutinas esp_mesh_send() y esp_mesh_recv() . Despliegue conjunto de una red WiFi Mesh La forma m\u00e1s conveniente de observar el comportamiento de una red WiFi Mesh es desplegar una infraestructura con suficiente n\u00famero de nodos pertenecientes a una misma red. Desafortunadamente, para ello es necesario disponer de dichos nodos en un espacio cercano. En la presente pr\u00e1ctica, desplegaremos una red WiFi Mesh en el laboratorio, utilizando vuestro o vuestros ESP32 como elementos de la red. Para ello, configuraremos, compilaremos y ejecutaremos el ejemplo examples/mesh/internal_communication . Antes de proceder, configuraremos el proyecto para: Conectar al punto de acceso com\u00fan del laboratorio ( Router SSID y Router password ). Configurar la red ESP-MESH para utilizar WPA2_PSK y seleccionar como contrase\u00f1a password . Aumentar el n\u00famero de conexiones al AP a 10. De momento, no realizaremos ning\u00fan cambio en el c\u00f3digo del ejemplo. Compila y ejecuta tu c\u00f3digo. Monitoriza la salida est\u00e1ndar del nodo para obtener la siguiente informaci\u00f3n: Direcciones MAC de las interfaces STA y SoftAP (lo observar\u00e1s en los primeros mensajes de salida). Capa de la topolog\u00eda Mesh en la que se encuentra tu nodo (lo observar\u00e1s en formato layer:XX en los env\u00edos y recepciones de datos). En caso de haber sido elegido nodo ra\u00edz, anota tambi\u00e9n esta circunstancia y la IP asignada por el router (observa la respuesta al evento correspondiente). Apunta toda esta informaci\u00f3n en el siguiente documento google accesible a todos los alumnos. Adem\u00e1s, anota la ID de la red Mesh que se ha utilizado para conectar. Antes de rellenar la informaci\u00f3n, espera que el profesor te indique que la topolog\u00eda ha convergido, y que por tanto no habr\u00e1 ning\u00fan cambio m\u00e1s en ella (siempre que ningun nodo deje de formar parte de la misma). Tarea Captura el estado de la red cuando todos tus compa\u00f1eros hayan llegado al punto de convergencia, e intenta determinar, en forma de grafo, la topolog\u00eda de la misma. A continuaci\u00f3n, apagaremos el nodo ra\u00edz y esperaremos a la vuelta a la convergencia de la red. Tarea Captura de nuevo el estado de la red cuando todos tus compa\u00f1eros hayan llegado al punto de convergencia, e intenta determinar, en forma de grafo, la topolog\u00eda de la misma. Documentan el proceso en tu informe de la pr\u00e1ctica, as\u00ed como los resultados observados. Despliegue conjunto de una red WiFi Mesh de menores dimensiones Como \u00faltimo ejercicio, vamos a crear nuevas redes Mesh en funci\u00f3n del puesto en el que est\u00e9s sentado. Observa los colores asignados a cada grupo de puestos en la siguiente hoja . Modifica tu c\u00f3digo para que el canal de escucha y el identificador de red coincidan con el indicado. Puedes configurar el canal a trav\u00e9s del men\u00fa de configuracion del ejemplo ( channel ) y el identificador modificando la variable correspondiente en el fichero mesh_main.c . Una vez hecho esto, reconstruid la informaci\u00f3n de las tablas para reflejar las nuevas topolog\u00edas. Pod\u00e9is hacer pruebas posteriores apagando el nodo ra\u00edz y observando la convergencia de la red. Tarea Captura de nuevo el estado de la red cuando todos tus compa\u00f1eros hayan llegado al punto de convergencia, e intenta determinar, en forma de grafo, la topolog\u00eda de la misma. Documenta esta actividad en tu informe. Tarea Analiza el c\u00f3digo del ejemplo. Observa el tratamiento de eventos y la fase de configuraci\u00f3n de la red. Intenta entender el funcionamiento del c\u00f3digo (env\u00edos y recepciones, destinatarios de los mismos, etc.). Explica en tu informe lo que hace esta aplicaci\u00f3n wifi mesh.","title":"Pr\u00e1ctica 4"},{"location":"RPI-I/P4/#practica-4-esp-wifi-mesh","text":"","title":"Pr\u00e1ctica 4. ESP WiFi Mesh"},{"location":"RPI-I/P4/#objetivos","text":"Revisar los conceptos b\u00e1sicos para la construcci\u00f3n de una red MESH WiFi autogestionada. Presentar la API b\u00e1sica para la creaci\u00f3n de aplicaciones basadas en la pila ESP-MESH. Observar en funcionamiento una red ESP-MESH, as\u00ed como sus capacidades de autoconfiguraci\u00f3n. Entregable Para esta pr\u00e1ctica los alumnos har\u00e1n un breve informe documentando las tareas realizadas y los resultados obtenidos.","title":"Objetivos"},{"location":"RPI-I/P4/#esp-wifi-mesh","text":"El stack ESP-MESH est\u00e1 construido por encima del driver WiFi (es decir, obviamente hace uso de sus servicios), y en algunos casos tambi\u00e9n haciendo uso de servicios de la pila IP ( lwIP ), por ejemplo en el nodo ra\u00edz, que es el \u00fanico con comunicaci\u00f3n IP contra un router de borde. El siguiente diagrama muestra la situaci\u00f3n de la pila Mesh en ESP-IDF: Como cualquier otro componente ESP-IDF, ESP-MESH se comunica con las aplicaciones a trav\u00e9s de eventos propios: El tipo mesh_event_id_t define todos los posibles eventos que pueden surgir en las distintas fases del ciclo de vida de una red (por ejemplo, para un nodo determinado, conexi\u00f3n o desconexi\u00f3n de su nodo padre, o de uno de sus nodos hijo). Antes de utilizar los eventos ESP-MESH para gestionar u observar el funcionamiento de la red, es necesario registrarlos v\u00eda esp_event_handler_register() . Algunos usos t\u00edpicos de los eventos incluyen, por ejemplo, la situaci\u00f3n de conexi\u00f3n de un nodo padre ( MESH_EVENT_PARENT_CONNECTED ) o de un hijo ( MESH_EVENT_CHILD_CONNECTED ), indicando, respectivamente, que un nodo puede comenzar a emitir hacia arriba en el grafo, o hacia abajo. Del mismo modo, en un nodo ra\u00edz, la recepci\u00f3n de los eventos IP_EVENT_STA_GOT_IP y IP_EVENT_STA_LOST_IP se pueden aprovechar para indicar que dicho nodo ra\u00edz puede o no enviar datos a la red IP externa.","title":"ESP WiFi Mesh"},{"location":"RPI-I/P4/#eventos","text":"MESH_EVENT_STARTED : mesh iniciada. MESH_EVENT_STOPPED : mesh finalizada. MESH_EVENT_CHANNEL_SWITCH : cambio de canal. MESH_EVENT_CHILD_CONNECTED : un hijo ha conectado a la interfaz softAP . MESH_EVENT_CHILD_DISCONNECTED : un hijo ha desconectado de la interfaz softAP . MESH_EVENT_ROUTING_TABLE_ADD : se han a\u00f1adido nuevas entradas a la tabla de enrutamiento a\u00f1adiendo nuevos hijos. MESH_EVENT_ROUTING_TABLE_REMOVE : se ha eliminado entradas de la tabla de enrutamiento eliminado hijos que han abandonado la red. MESH_EVENT_PARENT_CONNECTED : un padre se ha conectado a la interfaz station . MESH_EVENT_PARENT_DISCONNECTED : un padre se ha desconectado de la interfaz station . MESH_EVENT_NO_PARENT_FOUND : no se ha encontrado un padre. MESH_EVENT_LAYER_CHANGE : el nodo ha cambiado de nivel en la red. MESH_EVENT_TODS_STATE : indica que el nodo ra\u00edz es capaz de acceder a la red IP externa. MESH_EVENT_VOTE_STARTED : el proceso de voto de un nuevo nodo ra\u00edz ha comenzado. MESH_EVENT_VOTE_STOPPED : el proceo de voto de un nuevo nodo ra\u00edz ha finalizado. MESH_EVENT_ROOT_ADDRESS : se ha obtenido la direcci\u00f3n del nodo ra\u00edz. MESH_EVENT_ROOT_SWITCH_REQ : un nodo ra\u00edz candidato ya elegido solicita un cambio de nodo ra\u00edz. MESH_EVENT_ROOT_SWITCH_ACK : respuesta a la anterior petici\u00f3n por parte del nodo ra\u00edz actual. MESH_EVENT_NETWORK_STATE : la actual red tiene un nodo ra\u00edz. MESH_EVENT_STOP_RECONNECTION : el nodo ra\u00edz detiene el proceso de reconexi\u00f3n al router y los dem\u00e1s nodos detienen los procesos de conexi\u00f3n a sus nodos padre. MESH_EVENT_FIND_NETWORK : si el canal solicitado es 0, la pila escanear\u00e1 todos los canales para encontrar una red mesh a la que conectar, devolviendo el canal en el que lo ha conseguido.","title":"Eventos"},{"location":"RPI-I/P4/#uso-de-la-pila-ip-lwip","text":"El c\u00f3digo de una aplicaci\u00f3n que haga uso de ESP-MESH puede acceder directamente a la pila MESH sin pasar por la pila IP. De hecho, la pila IP s\u00f3lo es estrictamente necesaria por parte del nodo ra\u00edz, al ser el \u00fanico que puede recibir o transmitir datos desde o hacia la red IP externa. Sin embargo, como cualquier nodo de la topolog\u00eda puede potencialmente convertirse en nodo ra\u00edz (ya que su selecci\u00f3n es autom\u00e1tica), todos los nodos deber\u00e1n inicializar la pila IP. Cada nodo que pueda convertirse en root debe inicializar LwIP llamando a esp_netif_init() . Para prevenir el acceso de nodos no-root a LwIP, la aplicaci\u00f3n no debe crear o registrar ninguna interfaz de red usando el API de esp_netif . ESP-WIFI-MESH requiere que un nodo ra\u00edz est\u00e9 conectado con un router. Por lo tanto, en el caso de que un nodo se convierta en ra\u00edz, el manejador correspondiente debe iniciar el servicio cliente DHCP y obtener inmediatamente una direcci\u00f3n IP. Hacer esto permitir\u00e1 a otros nodos comenzar a transmitir/recibir paquetes hacia/desde la red IP externa. Sin embargo, este paso es innecesario si se utilizan configuraciones IP est\u00e1ticas.","title":"Uso de la pila IP (lwIP)"},{"location":"RPI-I/P4/#estructura-basica-de-una-aplicacion-esp-mesh","text":"Los requisitos previos para iniciar ESP-WIFI-MESH es inicializar LwIP y Wi-Fi, El siguiente fragmento de c\u00f3digo demuestra los pasos necesarios requisito previo antes de ESP-WIFI-MESH en s\u00ed se puede inicializar. ESP_ERROR_CHECK(esp_netif_init()); /* event initialization */ ESP_ERROR_CHECK(esp_event_loop_create_default()); /* Wi-Fi initialization */ wifi_init_config_t config = WIFI_INIT_CONFIG_DEFAULT(); ESP_ERROR_CHECK(esp_wifi_init(&config)); /* register IP events handler */ ESP_ERROR_CHECK(esp_event_handler_register(IP_EVENT, IP_EVENT_STA_GOT_IP, &ip_event_handler, NULL)); ESP_ERROR_CHECK(esp_wifi_set_storage(WIFI_STORAGE_FLASH)); ESP_ERROR_CHECK(esp_wifi_start()); Tras inicializar LwIP y Wi-Fi, el proceso para poner en marcha una red ESP-WIFI-MESH puede resumirse en los tres pasos siguientes: Inicializar ESP-MESH Configurar una red ESP-WIFI-MESH Iniciar Mesh","title":"Estructura b\u00e1sica de una aplicaci\u00f3n ESP-MESH"},{"location":"RPI-I/P4/#paso-1-inicializar-esp-mesh","text":"La inicializaci\u00f3n de ESP-MESH y el registro de eventos propios es sencilla: /* mesh initialization */ ESP_ERROR_CHECK(esp_mesh_init()); /* register mesh events handler */ ESP_ERROR_CHECK(esp_event_handler_register(MESH_EVENT, ESP_EVENT_ANY_ID, &mesh_event_handler, NULL));","title":"Paso 1. Inicializar ESP-MESH"},{"location":"RPI-I/P4/#paso-2-configurar-una-red-esp-wifi-mesh","text":"ESP-WIFI-MESH se configura a trav\u00e9s de esp_mesh_set_config() que recibe sus argumentos usando la estructura mesh_cfg_t . La estructura contiene los siguientes par\u00e1metros utilizados para configurar ESP-WIFI-MESH: Par\u00e1metro Descripci\u00f3n Channel Canal (entre 1 y 14) Mesh ID Identificaci\u00f3n de la red MESH (6 bytes) Router SSID y contrase\u00f1a de conexi\u00f3n al router de salida Mesh AP Configuraci\u00f3n espec\u00edfica del AP generado por cada nodo Crypto Functions Funciones criptogr\u00e1ficas para Mesh IE Un ejemplo de configuraci\u00f3n podr\u00eda ser: /* Enable the Mesh IE encryption by default */ mesh_cfg_t cfg = MESH_INIT_CONFIG_DEFAULT(); /* mesh ID */ memcpy((uint8_t *) &cfg.mesh_id, MESH_ID, 6); /* channel (must match the router's channel) */ cfg.channel = CONFIG_MESH_CHANNEL; /* router */ cfg.router.ssid_len = strlen(CONFIG_MESH_ROUTER_SSID); memcpy((uint8_t *) &cfg.router.ssid, CONFIG_MESH_ROUTER_SSID, cfg.router.ssid_len); memcpy((uint8_t *) &cfg.router.password, CONFIG_MESH_ROUTER_PASSWD, strlen(CONFIG_MESH_ROUTER_PASSWD)); /* mesh softAP */ cfg.mesh_ap.max_connection = CONFIG_MESH_AP_CONNECTIONS; memcpy((uint8_t *) &cfg.mesh_ap.password, CONFIG_MESH_AP_PASSWD, strlen(CONFIG_MESH_AP_PASSWD)); ESP_ERROR_CHECK(esp_mesh_set_config(&cfg));","title":"Paso 2. Configurar una red ESP-WIFI-MESH"},{"location":"RPI-I/P4/#paso-3-arranque-de-la-red","text":"El arranque de la red MESH es sencillo: /* mesh start */ ESP_ERROR_CHECK(esp_mesh_start()); Tras el arranque, la aplicaci\u00f3n deber\u00eda comprobar los eventos para determinar si la conexi\u00f3n a la red ha sido exitosa. Tras la conexi\u00f3n, la aplicaci\u00f3n puede comenzar a transmitir paquetes a trav\u00e9s de la red MESH utilizando las rutinas esp_mesh_send() y esp_mesh_recv() .","title":"Paso 3. Arranque de la red"},{"location":"RPI-I/P4/#despliegue-conjunto-de-una-red-wifi-mesh","text":"La forma m\u00e1s conveniente de observar el comportamiento de una red WiFi Mesh es desplegar una infraestructura con suficiente n\u00famero de nodos pertenecientes a una misma red. Desafortunadamente, para ello es necesario disponer de dichos nodos en un espacio cercano. En la presente pr\u00e1ctica, desplegaremos una red WiFi Mesh en el laboratorio, utilizando vuestro o vuestros ESP32 como elementos de la red. Para ello, configuraremos, compilaremos y ejecutaremos el ejemplo examples/mesh/internal_communication . Antes de proceder, configuraremos el proyecto para: Conectar al punto de acceso com\u00fan del laboratorio ( Router SSID y Router password ). Configurar la red ESP-MESH para utilizar WPA2_PSK y seleccionar como contrase\u00f1a password . Aumentar el n\u00famero de conexiones al AP a 10. De momento, no realizaremos ning\u00fan cambio en el c\u00f3digo del ejemplo. Compila y ejecuta tu c\u00f3digo. Monitoriza la salida est\u00e1ndar del nodo para obtener la siguiente informaci\u00f3n: Direcciones MAC de las interfaces STA y SoftAP (lo observar\u00e1s en los primeros mensajes de salida). Capa de la topolog\u00eda Mesh en la que se encuentra tu nodo (lo observar\u00e1s en formato layer:XX en los env\u00edos y recepciones de datos). En caso de haber sido elegido nodo ra\u00edz, anota tambi\u00e9n esta circunstancia y la IP asignada por el router (observa la respuesta al evento correspondiente). Apunta toda esta informaci\u00f3n en el siguiente documento google accesible a todos los alumnos. Adem\u00e1s, anota la ID de la red Mesh que se ha utilizado para conectar. Antes de rellenar la informaci\u00f3n, espera que el profesor te indique que la topolog\u00eda ha convergido, y que por tanto no habr\u00e1 ning\u00fan cambio m\u00e1s en ella (siempre que ningun nodo deje de formar parte de la misma). Tarea Captura el estado de la red cuando todos tus compa\u00f1eros hayan llegado al punto de convergencia, e intenta determinar, en forma de grafo, la topolog\u00eda de la misma. A continuaci\u00f3n, apagaremos el nodo ra\u00edz y esperaremos a la vuelta a la convergencia de la red. Tarea Captura de nuevo el estado de la red cuando todos tus compa\u00f1eros hayan llegado al punto de convergencia, e intenta determinar, en forma de grafo, la topolog\u00eda de la misma. Documentan el proceso en tu informe de la pr\u00e1ctica, as\u00ed como los resultados observados.","title":"Despliegue conjunto de una red WiFi Mesh"},{"location":"RPI-I/P4/#despliegue-conjunto-de-una-red-wifi-mesh-de-menores-dimensiones","text":"Como \u00faltimo ejercicio, vamos a crear nuevas redes Mesh en funci\u00f3n del puesto en el que est\u00e9s sentado. Observa los colores asignados a cada grupo de puestos en la siguiente hoja . Modifica tu c\u00f3digo para que el canal de escucha y el identificador de red coincidan con el indicado. Puedes configurar el canal a trav\u00e9s del men\u00fa de configuracion del ejemplo ( channel ) y el identificador modificando la variable correspondiente en el fichero mesh_main.c . Una vez hecho esto, reconstruid la informaci\u00f3n de las tablas para reflejar las nuevas topolog\u00edas. Pod\u00e9is hacer pruebas posteriores apagando el nodo ra\u00edz y observando la convergencia de la red. Tarea Captura de nuevo el estado de la red cuando todos tus compa\u00f1eros hayan llegado al punto de convergencia, e intenta determinar, en forma de grafo, la topolog\u00eda de la misma. Documenta esta actividad en tu informe. Tarea Analiza el c\u00f3digo del ejemplo. Observa el tratamiento de eventos y la fase de configuraci\u00f3n de la red. Intenta entender el funcionamiento del c\u00f3digo (env\u00edos y recepciones, destinatarios de los mismos, etc.). Explica en tu informe lo que hace esta aplicaci\u00f3n wifi mesh.","title":"Despliegue conjunto de una red WiFi Mesh de menores dimensiones"},{"location":"RPI-I/P5/","text":"Pr\u00e1ctica 5. Bluetooth Low Energy (BLE). Servidor Objetivos Diseccionar en detalle un firmware de construcci\u00f3n de tabla GATT (servidor GATT) utilizando la API de ESP-IDF. Aprender a utilizar la herramienta gatttool para interactuar con el servidor GATT. Modificar el servidor GATT para que acepte peticiones de notificaci\u00f3n por parte del cliente, y para que publique bajo demanda valores actualizados para una determinada caracter\u00edstica. Implementaci\u00f3n de un servidor GATT basado en tablas Introducci\u00f3n En esta pr\u00e1ctica, desplegaremos un servidor GATT utilizando la API de ESP-IDF para tal fin. Dicha API expone las funcionalidades de Bluedroid, la pila Bluetooth (incluyendo BLE) que proporciona ESP-IDF para el desarrollo de aplicaciones Bluetooth. El ejemplo con el que trabajaremos reside en el directorio examples/bluetooth/bluedroid/ble/gatt_server_service_table . Debido a la complejidad del ejemplo (al menos en su parte inicial), la presente pr\u00e1ctica procede, en primer lugar, con un recorrido por la preparaci\u00f3n y construcci\u00f3n del servidor siguiendo una estructura de tabla que define los servicios y caracter\u00edsticas que se implementar\u00e1n en el mismo. El ejemplo implementa el perfile Heart Rate Profile definido en la especificaci\u00f3n Bluetooth , y sigue la siguiente estructura: Desplegaremos, por tanto, tres caracter\u00edsticas. De ellas, la m\u00e1s importante para nosotros ser\u00e1 el valor de medici\u00f3n de ritmo cardiaco, con su valor ( Heart Rate Measurement Value ) y su configuraci\u00f3n de notificaciones ( Heart Rate Measurement Notification Configuration ). Inclusi\u00f3n de encabezados Los siguientes ficheros de cabecera son necesarios para dotar de funcionalidad BLE a nuestro firmware : #include \"freertos/FreeRTOS.h\" #include \"freertos/task.h\" #include \"freertos/event_groups.h\" #include \"esp_system.h\" #include \"esp_log.h\" #include \"nvs_flash.h\" #include \"esp_bt.h\" #include \"esp_gap_ble_api.h\" #include \"esp_gatts_api.h\" #include \"esp_bt_main.h\" #include \"gatts_table_creat_demo.h\" #include \"esp_gatt_common_api.h\" Estos encabezados son necesarios para un correcto funcionamiento de FreeRTOS y de sus componentes, incluyendo funcionalidad relativa a logging y almacenamiento no vol\u00e1til. Son especialmente interesantes los ficheros esp_bt.h , esp_bt_main.h , esp_gap_ble_api.h y esp_gatts_api.h , ya que exponen la API BLE necesaria para la implementaci\u00f3n del firmware : esp_bt.h : implementa el controlador BT y los procedimientos VHCI del lado del host. esp_bt_main.h : implementa las rutinas de inicializaci\u00f3n y activaci\u00f3n de la pila Bluedroid. esp_gap_ble_api.h : implementa la configuraci\u00f3n GAP (par\u00e1metros de anuncios y conexi\u00f3n). esp_gatts_api.h : implementa la configuraci\u00f3n del servidor GATT (por ejemplo, la creaci\u00f3n de servicios y caracter\u00edsticas). La tabla de servicios El fichero de cabecera gatts_table_creat_demo.h contiene una enumeraci\u00f3n de los servicios y caracter\u00edsticas deseadas: enum { IDX_SVC, IDX_CHAR_A, IDX_CHAR_VAL_A, IDX_CHAR_CFG_A, IDX_CHAR_B, IDX_CHAR_VAL_B, IDX_CHAR_C, IDX_CHAR_VAL_C, HRS_IDX_NB, }; Los elementos de la anterior estructura se han incluido en el mismo orden que los atributos del Heart Rate Profile , comenzando con el servicio, seguido por las caracter\u00edsticas del mismo. Adem\u00e1s, la caracter\u00edstica Heart Rate Measurement dispone de configuraci\u00f3n propia ( Client Characteristic Configuration , o CCC), un descriptor que describe si la caracter\u00edstica tiene las notificaciones activas . Todos estos \u00edndices pueden utilizarse para identificar a cada elemento a la hora de crear la tabla de atributos: IDX_SVC : \u00edndice del servicio Heart Rate IDX_CHAR_A : \u00edndice de la definici\u00f3n de la caracter\u00edstica Heart Rate Measurement IDX_CHAR_VAL_A : \u00edndice del valor de la caracter\u00edstica Heart Rate Measurement IDX_CHAR_CFG_A : \u00edndice del descriptor de caracter\u00edstica Client Configuration Characteristic (CCC) de la caracter\u00edstica Heart Rate Measurement (permite configurar notificaciones por cambio en el valor de la caracter\u00edstica) IDX_CHAR_B : \u00ednidce de la declaraci\u00f3n de caracter\u00edstica Heart Rate Body Sensor Location IDX_CHAR_VAL_B : \u00edndice del valor de la caracter\u00edstica Heart Rate Body Sensor Location IDX_CHAR_C : \u00edndice de la declaraci\u00f3n de caracter\u00edstica Heart Rate Control Point IDX_CHAR_VAL_C : \u00edndice del valor de la caracter\u00edstica Heart Rate Control Point IDX_NB : N\u00famero de elementos en la tabla Punto de entrada El punto de entrada de la aplicaci\u00f3n ( app_main() ) se implementa como sigue: void app_main(void) { esp_err_t ret; /* Initialize NVS. */ ret = nvs_flash_init(); if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) { ESP_ERROR_CHECK(nvs_flash_erase()); ret = nvs_flash_init(); } ESP_ERROR_CHECK( ret ); ESP_ERROR_CHECK(esp_bt_controller_mem_release(ESP_BT_MODE_CLASSIC_BT)); esp_bt_controller_config_t bt_cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT(); ret = esp_bt_controller_init(&bt_cfg); if (ret) { ESP_LOGE(GATTS_TABLE_TAG, \"%s enable controller failed: %s\", __func__, esp_err_to_name(ret)); return; } ret = esp_bt_controller_enable(ESP_BT_MODE_BLE); if (ret) { ESP_LOGE(GATTS_TABLE_TAG, \"%s enable controller failed: %s\", __func__, esp_err_to_name(ret)); return; } ret = esp_bluedroid_init(); if (ret) { ESP_LOGE(GATTS_TABLE_TAG, \"%s init bluetooth failed: %s\", __func__, esp_err_to_name(ret)); return; } ret = esp_bluedroid_enable(); if (ret) { ESP_LOGE(GATTS_TABLE_TAG, \"%s enable bluetooth failed: %s\", __func__, esp_err_to_name(ret)); return; } ret = esp_ble_gatts_register_callback(gatts_event_handler); if (ret){ ESP_LOGE(GATTS_TABLE_TAG, \"gatts register error, error code = %x\", ret); return; } ret = esp_ble_gap_register_callback(gap_event_handler); if (ret){ ESP_LOGE(GATTS_TABLE_TAG, \"gap register error, error code = %x\", ret); return; } ret = esp_ble_gatts_app_register(ESP_APP_ID); if (ret){ ESP_LOGE(GATTS_TABLE_TAG, \"gatts app register error, error code = %x\", ret); return; } esp_err_t local_mtu_ret = esp_ble_gatt_set_local_mtu(500); if (local_mtu_ret){ ESP_LOGE(GATTS_TABLE_TAG, \"set local MTU failed, error code = %x\", local_mtu_ret); } } Las acciones realizadas por esta funci\u00f3n de entrada se describen en los siguientes apartados. Inicializaci\u00f3n de la flash para almacenamiento no vol\u00e1til La funci\u00f3n principal procede incializando el almacenamiento no vol\u00e1til, para almacenar los par\u00e1metros necesarios en memoria flash : ret = nvs_flash_init(); Inicializaci\u00f3n y configuraci\u00f3n de BLE A continuaci\u00f3n la funci\u00f3n principal inicializa el controlador Bluetooth, creando en primer lugar una estructura de configuraci\u00f3n para tal fin de tipo esp_bt_controller_config_t con valores por defecto dictados por la macro BT_CONTROLLER_INIT_CONFIG_DEFAULT() . El controlador Bluetooth implementa el Host Controller Interface (HCI), la capa de enlace y la capa f\u00edsica BLE; es, por tanto, transparente para el programador. La configuraci\u00f3n incluye el tama\u00f1o de pila reservado al controlador, prioridad y baudios para la transmisi\u00f3n. Con estas configuraciones, el controlador puede ser inicializado y activado con la funci\u00f3n esp_bt_controller_init() : esp_bt_controller_config_t bt_cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT(); ret = esp_bt_controller_init(&bt_cfg); Una vez inicializado el controlador se activa el modo BLE: ret = esp_bt_controller_enable(ESP_BT_MODE_BLE); Existen cuatro modos de funcioinamiento del controlador Bluetooth: ESP_BT_MODE_IDLE : Bluetooth no funcional ESP_BT_MODE_BLE : Modo BLE ESP_BT_MODE_CLASSIC_BT : Modo BT Cl\u00e1sico ESP_BT_MODE_BTDM : Modo Dual (BLE + BT Cl\u00e1sico) Tras la incializaci\u00f3n del controlador Bluetooth, se inicializa y activa la pila Bluedroid (que incluye APIs tanto para BLE como para Bluetooth Cl\u00e1sico): ret = esp_bluedroid_init(); ret = esp_bluedroid_enable(); La pila Bluetooth est\u00e1, a partir de este punto, lista para funcionar, pero todav\u00eda no se ha implementado ninguna l\u00f3gica de aplicaci\u00f3n. Dicha funcionalidad se define con el cl\u00e1sico mecanismo basado en eventos, que pueden ser emitidos, por ejemplo, cuando otro dispositivo intenta leer o escribir par\u00e1metros, o establecer una conexi\u00f3n. Existen dos gestores de eventos para BLE: los manejadores ( handlers ) GAP y GATT. La aplicaci\u00f3n necesita registrar una funci\u00f3n de callback para cada uno de ellos, que ser\u00e1 la encargada de tratar los eventos correspondiente a estos servicios. esp_ble_gatts_register_callback(gatts_event_handler); esp_ble_gap_register_callback(gap_event_handler); En la aplicaci\u00f3n de ejemplo estos callbacks son las funciones gatts_event_handler() y gap_event_handler() , que manejar\u00e1n los eventos emitidos por la pila BLE hacia la plicaci\u00f3n. Perfiles de aplicaci\u00f3n ( Application profiles ) Como se ha dicho, el objetivo es implementar un Perfil de Aplicaci\u00f3n para el servicio Heart Rate . Un Perfil de Aplicaci\u00f3n es un mecanismo que permite agrupar funcionalidad dise\u00f1ada para ser utilizada por un cliente de la aplicaci\u00f3n, por ejemplo, una aplicaci\u00f3n m\u00f3vil. Un mismo servidor puede implementar uno o m\u00e1s perfiles de aplicaci\u00f3n (Aplicaciones en el mundo BLE). El Identifificador de Perfil de Aplicaci\u00f3n ( Application Profile ID ) es un valor seleccionable por el usuario para identificar cada perfil; su uso se recude al registro del perfil en la pila Bluetooth. En el ejemplo, el ID es 0x55 . #define PROFILE_NUM 1 #define PROFILE_APP_IDX 0 #define ESP_APP_ID 0x55 Los perfiles se almacenan en el array heart_rate_profile_tab . Al haber un \u00fanico perfil en el ejemplo, s\u00f3lo se almacena un elemento en el array, con \u00edndice 0 (tal y como se define en PROFILE_APP_IDX ). Adem\u00e1s, es necesario inicializar la funci\u00f3n de callback manejadora de los eventos del perfil. Cada aplicaci\u00f3n en el servidor GATT utiliza una interfaz diferenciada, representada por el par\u00e1metro gats_if . Para la incializaci\u00f3n, este par\u00e1metro se iguala a ESP_GATT_IF_NONE ; cuando la aplicaci\u00f3n se registre, m\u00e1s adelante, el par\u00e1metro gatts_if se actualizar\u00e1 con la interfaz generada autom\u00e1ticamente por la pila Bluetooth. /* One gatt-based profile one app_id and one gatts_if, this array will store the gatts_if returned by ESP_GATTS_REG_EVT */ static struct gatts_profile_inst heart_rate_profile_tab[PROFILE_NUM] = { [PROFILE_APP_IDX] = { .gatts_cb = gatts_profile_event_handler, .gatts_if = ESP_GATT_IF_NONE, /* Not get the gatt_if, so initial is ESP_GATT_IF_NONE */ }, }; La estructura gatts_profile_inst completa presenta los siguientes campos (no todos se usan en el ejemplo): struct gatts_profile_inst { esp_gatts_cb_t gatts_cb; uint16_t gatts_if; uint16_t app_id; uint16_t conn_id; uint16_t service_handle; esp_gatt_srvc_id_t service_id; uint16_t char_handle; esp_bt_uuid_t char_uuid; esp_gatt_perm_t perm; esp_gatt_char_prop_t property; uint16_t descr_handle; esp_bt_uuid_t descr_uuid; }; El registro de la aplicaci\u00f3n tiene lugar en la funci\u00f3n app_main() , utilizando la funci\u00f3n esp_ble_gatts_app_register() : esp_ble_gatts_app_register(ESP_APP_ID); Registro de aplicaci\u00f3n El evento de registro de aplicaci\u00f3n ESP_GATTS_REG_EVT es el primero que se generar\u00e1 en la vida del programa. Este evento es tratado por el callback registrado como manejador de eventos del servidor gatt, que en nuestro ejemplo lo termina delegando en el callback asociado al perfil de aplicaci\u00f3n ( gatts_profile_event_handler en nuestro ejemplo): static void gatts_event_handler(esp_gatts_cb_event_t event, esp_gatt_if_t gatts_if, esp_ble_gatts_cb_param_t *param) { ESP_LOGI(GATTS_TABLE_TAG, \"EVT %d, gatts if %d\\n\", event, gatts_if); /* If event is register event, store the gatts_if for each profile */ if (event == ESP_GATTS_REG_EVT) { if (param->reg.status == ESP_GATT_OK) { heart_rate_profile_tab[HEART_PROFILE_APP_IDX].gatts_if = gatts_if; } else { ESP_LOGI(GATTS_TABLE_TAG, \"Reg app failed, app_id %04x, status %d\\n\", param->reg.app_id, param->reg.status); return; } } do { int idx; for (idx = 0; idx < HEART_PROFILE_NUM; idx++) { if (gatts_if == ESP_GATT_IF_NONE || /* ESP_GATT_IF_NONE, not specify a certain gatt_if, need to call every profile cb function */ gatts_if == heart_rate_profile_tab[idx].gatts_if) { if (heart_rate_profile_tab[idx].gatts_cb) { heart_rate_profile_tab[idx].gatts_cb(event, gatts_if, param); } } } } while (0); } Los par\u00e1metros asociados al evento son: esp_gatt_status_t status; /* Operation status */ uint16_t app_id; /* Application id which input in register API */ esp_gatt_if_t gatts_if; /* Interfaz GATTS assignada por la pila BLE */ A partir de ese momento deber\u00e1 usarse la interfaz gatts_if para operar, por lo que la funci\u00f3n registra esta interfaz en la tabla de descripci\u00f3n del perfil de aplicaci\u00f3n. Finalmente, la funci\u00f3n delega el evento en el callback registrado para tratar los eventos asociados al perfil ( gatts_profile_event_handler ). Par\u00e1metros GAP Como hemos visto arriba, el evento ESP_GATTS_REG_EVT es delegado en la funci\u00f3n gatss_profile_event_handler por el manejador de eventos del servidor gatt, para completar su procesamiento: static void gatts_profile_event_handler(esp_gatts_cb_event_t event, esp_gatt_if_t gatts_if, esp_ble_gatts_cb_param_t *param) { switch (event) { case ESP_GATTS_REG_EVT:{ esp_err_t set_dev_name_ret = esp_ble_gap_set_device_name(SAMPLE_DEVICE_NAME); if (set_dev_name_ret){ ESP_LOGE(GATTS_TABLE_TAG, \"set device name failed, error code = %x\", set_dev_name_ret); } #ifdef CONFIG_SET_RAW_ADV_DATA esp_err_t raw_adv_ret = esp_ble_gap_config_adv_data_raw(raw_adv_data, sizeof(raw_adv_data)); if (raw_adv_ret){ ESP_LOGE(GATTS_TABLE_TAG, \"config raw adv data failed, error code = %x \", raw_adv_ret); } adv_config_done |= ADV_CONFIG_FLAG; esp_err_t raw_scan_ret = esp_ble_gap_config_scan_rsp_data_raw(raw_scan_rsp_data, sizeof(raw_scan_rsp_data)); if (raw_scan_ret){ ESP_LOGE(GATTS_TABLE_TAG, \"config raw scan rsp data failed, error code = %x\", raw_scan_ret); } adv_config_done |= SCAN_RSP_CONFIG_FLAG; ... #endif esp_err_t create_attr_ret = esp_ble_gatts_create_attr_tab(gatt_db, gatts_if, HRS_IDX_NB, SVC_INST_ID); if (create_attr_ret){ ESP_LOGE(GATTS_TABLE_TAG, \"create attr table failed, error code = %x\", create_attr_ret); } } break; ... } Esta funci\u00f3n utiliza el evento para configurar par\u00e1metros GAP (de anuncio). Las funciones asociadas son: esp_ble_gap_set_device_name() : utilizada para establecer el nombre del dispositivo anunciado. esp_ble_gap_config_adv_data_raw() : usada para configurar datos est\u00e1ndar de anuncio. Como podemos ver en el c\u00f3digo de arriba, se comienza estableciendo el nombre del dispositivo: case ESP_GATTS_REG_EVT:{ esp_err_t set_dev_name_ret = esp_ble_gap_set_device_name(SAMPLE_DEVICE_NAME); if (set_dev_name_ret){ ESP_LOGE(GATTS_TABLE_TAG, \"set device name failed, error code = %x\", set_dev_name_ret); } A continuaci\u00f3n se configuran los datos de anuncio. La funci\u00f3n esp_ble_gap_config_adv_data_raw() toma un puntero a un array de bytes con los datos de anuncio. Cada dato anunciado se compone de: Campo longitud: indica el n\u00famero de bytes que ocupa el dato, sin contar el campo longitud (es decir, cuantos bytes vienen despu\u00e9s del campo longitud) Campo tipo: indica el tipo de dato seg\u00fan el documento Bluetooth Assigned Numbers Document Campo datos: los bytes del dato anunciado Podemos ver que en nuestro ejemplo el anuncio env\u00eda: Flags: LE General Discoverable Mode y BR/EDR not supported Tx Power Level: 1 byte en complemento a 2, en dBm (-127 a 127 dBm). Se puede usar para determinar la potencia perdida en la transmisi\u00f3n, calculando la diferencia entre la potencia transmitida anunciada y el RSSI en la recepci\u00f3n. En nuestro ejemplo -21 dBm. Complete Local Name: el nombre local completo asignado al dispositivo. La carga total del paquete de anuncio ( payload ) puede ser como m\u00e1ximo de 31 bytes (en nuestro ejemplo el anuncio ocupa 26 bytes). Para poder enviar m\u00e1s datos se puede configurar un scan response , lo que har\u00e1 que los anuncios enviados sean de tipo scannable. El scan response se puede configurar usando la funci\u00f3n esp_ble_gap_config_scan_rsp_data_raw() . //config scan response data ret = esp_ble_gap_config_adv_data(&scan_rsp_data); if (ret){ ESP_LOGE(GATTS_TABLE_TAG, \"config scan response data failed, error code = %x\", ret); } adv_config_done |= SCAN_RSP_CONFIG_FLAG; Al final del tratamiento del evento de registro se inicializa la tabla del servidor GATT. En nuestro ejemplo los atributos de la tabla se pasan a trav\u00e9s del array gatt_db , indic\u00e1ndose el n\u00famero de entradas de este array ( HRS_IDX_NB ), el interfaz ble a utilizar ( gatts_if ) y la instancia de ese servicio ( SVC_INST_ID ). esp_err_t create_attr_ret = esp_ble_gatts_create_attr_tab(gatt_db, gatts_if, HRS_IDX_NB, SVC_INST_ID); if (create_attr_ret){ ESP_LOGE(GATTS_TABLE_TAG, \"create attr table failed, error code = %x\", create_attr_ret); } Estructura de la tabla GATT Como hemos visto arriba, la tabla GATT se inicializa en el evento de Registro de Aplicaci\u00f3n, usando la funci\u00f3n esp_ble_gatts_create_attr_tab() . Esta funci\u00f3n toma como argumento un array de estructuras de tipo esp_gatts_attr_db_t , indexable con los valores del enumerado definido en el fichero gatts_table_creat_demo.h . Las estructuras esp_gatts_attr_db_t tienen dos miembros: esp_attr_control_t attr_control; /* The attribute control type*/ esp_attr_desc_t att_desc; /* The attribute type*/ attr_control es el par\u00e1metro de autorespuesta, t\u00edpicamente fijado a ESP_GATT_AUTO_RSP para permitir que la pila BLE reponda autom\u00e1ticamente a los mensajes de lectura o escritura cuando dichos eventos son recibidos. Una opci\u00f3n alternativa es ESP_GATT_RSP_BY_APP que permite respuestas manuales utilizando la funci\u00f3n esp_ble_gatts_send_response() . att_desc es la descripci\u00f3n del atributo, una estructura con los siguientes campos: uint16_t uuid_length; /* UUID length */ uint8_t *uuid_p; /* UUID value */ uint16_t perm; /* Attribute permission */ uint16_t max_length; /* Maximum length of the element */ uint16_t length; /* Current length of the element */ uint8_t *value; /* Element value array */ Por ejemplo, el primer elemento de la tabla en el ejemplo es el atributo de servicio: // Service Declaration [IDX_SVC] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&primary_service_uuid, ESP_GATT_PERM_READ, sizeof(uint16_t), sizeof(GATTS_SERVICE_UUID_TEST), (uint8_t *)&GATTS_SERVICE_UUID_TEST}}, Los valores de inicializaci\u00f3n son: [IDX_SVC] : Inicializador en la tabla. ESP_GATT_AUTO_RSP : configuraci\u00f3n de respuesta autom\u00e1tica, fijada en este caso a respuesta autom\u00e1tica por parte de la pila BLE. ESP_UUID_LEN_16 : longitudo del UUID fijada a 16 bits. (uint8_t *)&primary_service_uuid : UUID para identificar al servicio como primario (0x2800). ESP_GATT_PERM_READ : Permisos de lectura para el servicio. sizeof(uint16_t) : Longitud m\u00e1xima del UUID del servicio (16 bits). sizeof(heart_rate_svc) : Longitud del servicio, en este caso 16 bits (fijada por el tama\u00f1o de la variable heart_rate_svc ). (uint8_t *)&heart_rate_svc : Valor del atributo servicio fijada a la variable the variable heart_rate_svc , que contiene el UUID del Heart Rate Service (0x180D). El resto de atributos se inicializan de forma similar. Algunos atributos tambi\u00e9n tienen activa la propiedad NOTIFY , que se establece v\u00eda &char_prop_notify . La tabla completa se inicializa como sigue: /* Full Database Description - Used to add attributes into the database */ static const esp_gatts_attr_db_t gatt_db[HRS_IDX_NB] = { // Service Declaration [IDX_SVC] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&primary_service_uuid, ESP_GATT_PERM_READ, sizeof(uint16_t), sizeof(GATTS_SERVICE_UUID_TEST), (uint8_t *)&GATTS_SERVICE_UUID_TEST}}, /* Characteristic Declaration */ [IDX_CHAR_A] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&character_declaration_uuid, ESP_GATT_PERM_READ, CHAR_DECLARATION_SIZE, CHAR_DECLARATION_SIZE, (uint8_t *)&char_prop_read_write_notify}}, /* Characteristic Value */ [IDX_CHAR_VAL_A] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&GATTS_CHAR_UUID_TEST_A, ESP_GATT_PERM_READ | ESP_GATT_PERM_WRITE, GATTS_DEMO_CHAR_VAL_LEN_MAX, sizeof(char_value), (uint8_t *)char_value}}, /* Client Characteristic Configuration Descriptor */ [IDX_CHAR_CFG_A] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&character_client_config_uuid, ESP_GATT_PERM_READ | ESP_GATT_PERM_WRITE, sizeof(uint16_t), sizeof(heart_measurement_ccc), (uint8_t *)heart_measurement_ccc}}, /* Characteristic Declaration */ [IDX_CHAR_B] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&character_declaration_uuid, ESP_GATT_PERM_READ, CHAR_DECLARATION_SIZE, CHAR_DECLARATION_SIZE, (uint8_t *)&char_prop_read}}, /* Characteristic Value */ [IDX_CHAR_VAL_B] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&GATTS_CHAR_UUID_TEST_B, ESP_GATT_PERM_READ | ESP_GATT_PERM_WRITE, GATTS_DEMO_CHAR_VAL_LEN_MAX, sizeof(char_value), (uint8_t *)char_value}}, /* Characteristic Declaration */ [IDX_CHAR_C] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&character_declaration_uuid, ESP_GATT_PERM_READ, CHAR_DECLARATION_SIZE, CHAR_DECLARATION_SIZE, (uint8_t *)&char_prop_write}}, /* Characteristic Value */ [IDX_CHAR_VAL_C] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&GATTS_CHAR_UUID_TEST_C, ESP_GATT_PERM_READ | ESP_GATT_PERM_WRITE, GATTS_DEMO_CHAR_VAL_LEN_MAX, sizeof(char_value), (uint8_t *)char_value}}, }; Inicializaci\u00f3n del servicio Cuando la tabla se crea, se emite un evento de tipo ESP_GATTS_CREAT_ATTR_TAB_EVT , tratado por el manejador de eventos del perfil. Este evento tiene los siguientes par\u00e1metros asociados: esp_gatt_status_t status; /* Operation status */ esp_bt_uuid_t svc_uuid; /* Service uuid type */ uint16_t num_handle; /* The number of the attribute handle to be added to the gatts database */ uint16_t *handles; /* The number to the handles */ Nuestro c\u00f3digo de ejemplo utiliza este evento para comprobar que el tama\u00f1o de la tabla creada es igual al n\u00famero de elementos en la enumeraci\u00f3n ( HRS_IDX_NB ). Si la tabla se cre\u00f3 correctamente, se copian en la tabla heart_rate_handle_table los manejadores (handels) asignados por el servidor GATT a los atributos, y finalmente se inicializa el servicio utilizando la funci\u00f3n esp_ble_gatts_start_service() : case ESP_GATTS_CREAT_ATTR_TAB_EVT:{ if (param->add_attr_tab.status != ESP_GATT_OK){ ESP_LOGE(GATTS_TABLE_TAG, \"create attribute table failed, error code=0x%x\", param->add_attr_tab.status); } else if (param->add_attr_tab.num_handle != HRS_IDX_NB){ ESP_LOGE(GATTS_TABLE_TAG, \"create attribute table abnormally, num_handle (%d) \\ doesn't equal to HRS_IDX_NB(%d)\", param->add_attr_tab.num_handle, HRS_IDX_NB); } else { ESP_LOGI(GATTS_TABLE_TAG, \"create attribute table successfully, the number handle = %d\\n\",param->add_attr_tab.num_handle); memcpy(heart_rate_handle_table, param->add_attr_tab.handles, sizeof(heart_rate_handle_table)); esp_ble_gatts_start_service(heart_rate_handle_table[IDX_SVC]); } break; Los manejadores (handles) almacenados son n\u00fameros que identifican cada atributo. Estos manejadores pueden usarse en cualquier punto de la aplicaci\u00f3n para operar sobre los atributos. El manejador de eventos GAP Como hemos visto arriba, en el procesamiento del evento de registro de aplicaci\u00f3n se establecen los datos de anuncio. Cuando se complete esta inicializaci\u00f3n, la pila BLE emitir\u00e1 un evento de tipo ESP_GAP_BLE_ADV_DATA_SET_COMPLETE_EVT , que ser\u00e1 manejado por el callback registrado como GAP handler. Si se ha configurado un anuncio scannable y una respuesta al escaneado (en nuestro ejemplo se ha configurado), la pila BLE emitir\u00e1 tambi\u00e9n un evento de tipo ESP_GAP_BLE_SCAN_RSP_DATA_SET_COMPLETE_EVT . El manejador del c\u00f3digo de ejemplo espera a que se produzcan estos dos eventos para comenzar con el proceso de anuncio, utilizando la funci\u00f3n esp_ble_gap_start_advertising() : static void gap_event_handler(esp_gap_ble_cb_event_t event, esp_ble_gap_cb_param_t *param) { ESP_LOGE(GATTS_TABLE_TAG, \"GAP_EVT, event %d\\n\", event); switch (event) { #ifdef CONFIG_SET_RAW_ADV_DATA case ESP_GAP_BLE_ADV_DATA_RAW_SET_COMPLETE_EVT: adv_config_done &= (~ADV_CONFIG_FLAG); if (adv_config_done == 0){ esp_ble_gap_start_advertising(&adv_params); } break; case ESP_GAP_BLE_SCAN_RSP_DATA_RAW_SET_COMPLETE_EVT: adv_config_done &= (~SCAN_RSP_CONFIG_FLAG); if (adv_config_done == 0){ esp_ble_gap_start_advertising(&adv_params); } break; #else ... #endif } } La funci\u00f3n de inicio de anuncios toma una estructura de tipo esp_ble_adv_params_t con los par\u00e1metros de anuncio requeridos: /// Advertising parameters typedef struct { uint16_t adv_int_min; /* Minimum advertising interval for undirected and low * duty cycle directed advertising. * Range: 0x0020 to 0x4000 * Default: N = 0x0800 (1.28 second) * Time = N * 0.625 msec * Time Range: 20 ms to 10.24 sec */ uint16_t adv_int_max; /* Maximum advertising interval for undirected and low * duty cycle directed advertising. * Range: 0x0020 to 0x4000 * Default: N = 0x0800 (1.28 second) * Time = N * 0.625 msec * Time Range: 20 ms to 10.24 sec */ esp_ble_adv_type_t adv_type; /* Advertising type */ esp_ble_addr_type_t own_addr_type; /* Owner bluetooth device address type */ esp_bd_addr_t peer_addr; /* Peer device bluetooth device address */ esp_ble_addr_type_t peer_addr_type; /* Peer device bluetooth device address type */ esp_ble_adv_channel_t channel_map; /* Advertising channel map */ esp_ble_adv_filter_t adv_filter_policy; /* Advertising filter policy */ } esp_ble_adv_params_t; N\u00f3tese como esp_ble_gap_config_adv_data_raw() (en gatts_profile_event_handler ) configura los datos enviados en el anuncio, mientras que esp_ble_gap_start_advertising() pone al dispositivo en modo advertising, haciendo que el servidor comience a enviar los anuncios. Los par\u00e1metros de anuncio configuran como y cu\u00e1ndo enviarlos. En nuestro ejemplo, los par\u00e1metros de anuncio se inicializan como sigue: static esp_ble_adv_params_t adv_params = { .adv_int_min = 0x20, .adv_int_max = 0x40, .adv_type = ADV_TYPE_IND, .own_addr_type = BLE_ADDR_TYPE_PUBLIC, .channel_map = ADV_CHNL_ALL, .adv_filter_policy = ADV_FILTER_ALLOW_SCAN_ANY_CON_ANY, }; Estos par\u00e1metros configuran el intervalo de anuncio entre 20 ms y 40 ms. El anuncio es de tipo ADV_TYPE_IND (tipo gen\u00e9rico), destinados a ning\u00fan dispositivo central en particular, y anuncia que el servidor GATT es conectable. El tipo de direcci\u00f3n es p\u00fablico, utiliza todos los canales y permite peticiones de escaneo y conexi\u00f3n por parte de cualquier dispositivo central. Si el proceso de anuncio se inici\u00f3 correctamente, se emitir\u00e1 un evento de tipo ESP_GAP_BLE_ADV_START_COMPLETE_EVT , que en este ejemplo se utiliza para comprobar si el estado es realmente anunciando u otro, en cuyo caso se emitir\u00e1 un mensaje de error: ... case ESP_GAP_BLE_ADV_START_COMPLETE_EVT: /* advertising start complete event to indicate advertising start successfully or failed */ if (param->adv_start_cmpl.status != ESP_BT_STATUS_SUCCESS) { ESP_LOGE(GATTS_TABLE_TAG, \"advertising start failed\"); }else{ ESP_LOGI(GATTS_TABLE_TAG, \"advertising start successfully\"); } break; ... Interacci\u00f3n a trav\u00e9s de un cliente GATT Existen multitud de herramientas que permiten gestionar la conexi\u00f3n al servidor GATT. En Linux, utilizaremos hcitool y gatttool ; en Windows, puedes utilizar una herramienta llamada Bluetooth LE Explorer , que implementa, aunque de forma gr\u00e1fica, la misma funcionalidad. Nota Para desarrollar esta parte de la pr\u00e1ctica, deber\u00e1s hacer visible en la m\u00e1quina virtual el controlador Bluetooth del equipo que la hospeda (tu port\u00e1til o el equipo de laboratorio). Uso de hcitool y gatttool en modo cliente Escaneando dispositivos disponibles: hcitool hcitool es una herramienta de l\u00ednea de comandos que permite gestionar la interfaz Bluetooth del equipo en el que se ejecuta. En nuestro caso, necesitaremos determinar la direcci\u00f3n MAC Bluetooth de nuestro servidor. Para ello, en primer lugar, realizaremos un escaneado de los dispsitivos BLE disponibles en el entorno utilizando la orden: sudo hcitool lescan Nota Este comando no funcionar\u00e1 si no has pasado el control del dispositivo bluetooth a la m\u00e1quina virtual. Si todo ha ido bien, se mostrar\u00e1 una l\u00ednea por dispositivo BLE disponible y en fase de anuncio. Entre ellos, deberemos encontrar nuestro dispositivo. Apuntaremos su direcci\u00f3n MAC, para poder usarla de aqu\u00ed en adelante. Tarea B\u00e1sica Edita el fichero main/gatts_table_creat_demo.c y modifica el nombre de tu dispositivo, que se enviar\u00e1 en cada anuncio emitido en la fase de advertising . Para ello, debes modificar el campo correspondiente de la estructura raw_adv_data . A continuaci\u00f3n, compila y flashea el ejemplo, y comienza una sesi\u00f3n de escaneado de dispositivos BLE mediante la orden: sudo hcitool lescan Deber\u00e1s observar tu dispositivo en una de las l\u00edneas. Anota o recuerda su direcci\u00f3n MAC. Tarea Adicional Documenta y explica el ejercicio en tu informe de la pr\u00e1ctica. Interactuando con el servidor GATT: gatttool Una vez obtenida la direcci\u00f3n MAC Bluetooth del dispositivo, deberemos proceder en dos fases. La primera de ellas es el emparejado al dispostivo desde tu consola. La segunda, la interacci\u00f3n con la tabla GATT. En ambos casos, se utilizar\u00e1 la herramienta gatttool desde l\u00ednea de comandos. Tarea Adicional Prepara un informe donde documentes y comentes cada uno de los pasos y tareas que realices en esta pr\u00e1ctica. Para comenzar una sesi\u00f3n gatttool , invocaremos a la herramienta en modo interactivo, utilizando la orden: gatttool -b MAC -I Esto abrir\u00e1 una consola interactiva, a la espera de las ordenes correspondientes. Para realizar el emparejamiento, y considerando que la MAC Bluetooth es ya conocida, utilizaremos la orden connect . Si todo ha ido bien, deberemos observar un cambio en el color del prompt, y un mensaje Connection successful . En este punto, observa como en la salida de depuraci\u00f3n del ESP32 se muestran los mensajes correspondientes al proceso de emparejamiento. Desde la terminal de gatttool , puedes ejecutar en cualquier momento la orden help para obtener ayuda (en forma de lista de comandos disponibles): gatttool -b 24:6F:28:36:60:B2 -I [24:6F:28:36:60:B2][LE]> connect Attempting to connect to 24:6F:28:36:60:B2 Connection successful [24:6F:28:36:60:B2][LE]> help help Show this help exit Exit interactive mode quit Exit interactive mode connect [address [address type]] Connect to a remote device disconnect Disconnect from a remote device primary [UUID] Primary Service Discovery included [start hnd [end hnd]] Find Included Services characteristics [start hnd [end hnd [UUID]]] Characteristics Discovery char-desc [start hnd] [end hnd] Characteristics Descriptor Discovery char-read-hnd <handle> Characteristics Value/Descriptor Read by handle char-read-uuid <UUID> [start hnd] [end hnd] Characteristics Value/Descriptor Read by UUID char-write-req <handle> <new value> Characteristic Value Write (Write Request) char-write-cmd <handle> <new value> Characteristic Value Write (No response) sec-level [low | medium | high] Set security level. Default: low mtu <value> Exchange MTU for GATT/ATT Comenzaremos consultando la lista de caracter\u00edsticas del servidor GATT. Tarea B\u00e1sica Mediante el comando correspondiente ( characteristics ), consulta y anota las caracter\u00edsticas disponibles en tu servidor GATT. Tarea Adicional Documenta y explica el ejercicio en tu informe de la pr\u00e1ctica. Una de estas caracter\u00edsticas ser\u00e1 de crucial inter\u00e9s, ya que nos permitir\u00e1 acceder, a trav\u00e9s de su UUID, la medici\u00f3n instant\u00e1nea de ritmo card\u00edaco, as\u00ed como la configuraci\u00f3n de notificaciones sobre dicho valor. Para determinar cu\u00e1l de las l\u00edneas es la que nos interesa, observa el valor de UUID devuelto para cada una de ellas, y determina, en funci\u00f3n de la macro GATTS_CHAR_UUID_TEST_A de cu\u00e1l se trata. Para interactuar con dicha caracter\u00edstica, necesitaremos conocer su manejador ( handler ). Dicho manejador se muestra, para cada l\u00ednea, tras la cadena char value handle . Tarea Adicional El manejador que permite leer desde la caracter\u00edstica *Heart Rate Value\" tiene un manejador de tipo char asociado. Anota su valor. Para leer el valor de la caracter\u00edstica, podemos utilizar su manejador asociado. As\u00ed, podemos obtener dicho valor con un comando de lectura, en este caso char-read-hnd manejador . Tarea B\u00e1sica Obt\u00e9n los datos de lectura de la caracter\u00edstica de medici\u00f3n del valor de monitorizaci\u00f3n de ritmo card\u00edaco. \u00bfCu\u00e1les son? Deber\u00edas observar un valor de retorno de cuatro bytes con valor 0x00. Estos valores corresponden a los de la variable char_value de tu c\u00f3digo. Modif\u00edcalos, recompila y vuelve a flashear el c\u00f3digo. \u00bfHan variado? Tarea B\u00e1sica Intenta ahora escribir en la anterior caracter\u00edstica. Para ello, utiliza el comando char-write-cmd handler valor , siendo valor, por ejemplo, 11223344 . Tarea Adicional Documenta el proceso en tu informe de la pr\u00e1ctica explicando c\u00f3mo saber el handle que se debe usar para poder modificar la caracter\u00edstica. Escribiremos a continuaci\u00f3n en la caracter\u00edstica de configuraci\u00f3n (CCC) del servicio de montorizaci\u00f3n. Para ello, utilizaremos el manejador siguiente al utilizado anteriormente. Esto es, si se nos devolvi\u00f3, por ejemplo, un manejador 0x0001 para el valor de monitorizaci\u00f3n, el valor de configuraci\u00f3n ser\u00e1 0x0002 . Tarea B\u00e1sica Intenta ahora escribir en la caracter\u00edstica de configuraci\u00f3n. Para ello, utiliza el comando char-write-cmd handler valor , siendo valor, por ejemplo, 0100 . Tarea Adicional Documenta el proceso en tu informe de la pr\u00e1ctica explicando c\u00f3mo saber el handle que se debe usar para poder modificar la caracter\u00edstica. Como habr\u00e1s observado, es posible leer desde el valor de monitorizaci\u00f3n, y escribir en el valor de configuraci\u00f3n. Utilizaremos esta \u00faltima caracter\u00edstica para configurar las notificaciones sobre el valor de monitorizaci\u00f3n. De este modo, cada vez que se desee enviar dicho valor a los clientes que tengan activada la notificaci\u00f3n, \u00e9stos la recibir\u00e1n sin necesidad de cambio alguno. Para ello, necesitamos modificar algunas partes de nuestro c\u00f3digo. Espec\u00edficamente, necesitaremos: Crear una nueva tarea que, peri\u00f3dicamente, modifique el valor de monitorizaci\u00f3n de ritmo card\u00edaco (ley\u00e9ndolo desde un sensor, si est\u00e1 disponible, o, en nuestro caso generando un valor aleatorio). Dicha tarea consistir\u00e1 en un bucle infinito que, en cualquier caso, s\u00f3lo enviar\u00e1 datos al cliente si la notificaci\u00f3n est\u00e1 activa, con un intervalo de env\u00edo de un segundo: static void publish_data_task(void *pvParameters) { while (1) { ESP_LOGI(\"APP\", \"Sending data...\"); // Paso 1: Actualizo valor... // Paso 2: Si las notificaciones est\u00e1n activas env\u00edo datos... // Paso 3: Duermo un segundo... vTaskDelay( 1000. / portTICK_PERIOD_MS); } } Esta rutina deber\u00e1 crearse en respuesta al evento de conexi\u00f3n por parte de un cliente, utilizando, por ejemplo, la invocaci\u00f3n a: xTaskCreate(&publish_data_task, \"publish_data_task\", 4096, NULL, 5, NULL); La actualizaci\u00f3n del valor, realizada peri\u00f3dicamente y de forma aleatoria, modificar\u00e1 el byte 1 de la variable char_value , tomando un valor aleatorio entre 0 y 255 (como nota adicional, los puls\u00f3metros actuales soportan valores mayores para ritmo cardiaco, aunque la configuraci\u00f3n de esta funcionalidad est\u00e1 fuera del alcance de la pr\u00e1ctica). La comprobaci\u00f3n de la activaci\u00f3n o no de la notificaci\u00f3n se realiza consultando los dos bytes de la variable heart_measurement_ccc . Si dichos valores son 0x01 y 0x00 (posiciones 0 y 1, respectivamente), las notificaciones est\u00e1n activas, y por tanto, se realizar\u00e1 el env\u00edo de notificaci\u00f3n. Para enviar la notificaci\u00f3n, utilizaremos la siguiente funci\u00f3n: esp_ble_gatts_send_indicate(heart_rate_profile_tab[0].gatts_if, heart_rate_profile_tab[0].conn_id, heart_rate_handle_table[IDX_CHAR_VAL_A], sizeof(char_value), char_value, false); La activaci\u00f3n de notificaciones desde gatttool se realizar\u00e1 mediante la escritura del valor 0x0100 en la caracter\u00edstica de configuraci\u00f3n, esto es: char-write-cmd HANDLER 0100 Nuestro firmware deber\u00e1 modificarse para que, al recibir dicho valor en la caracter\u00edstica, se sobreescriba el contenido de la variable heart_measurement_ccc . Esta escritura debe realizarse en respuesta al evento ESP_GATTS_WRITE_EVT . Tarea Adicional Modifica el firmware original para que, peri\u00f3dicamente (cada segundo) notifique el valor de ritmo card\u00edaco a los clientes conectados. Si adem\u00e1s modificas las UUID por las proporcionadas en la especificaci\u00f3n Bluetooth para el Servicio Heart Rate y todo ha sido configurado correctamente, tu ESP32 deber\u00eda poder interactuar con cualquier monitor de ritmo cardiaco, por ejemplo, Android. Para ello, utiliza las siguientes UUIDs: static const uint16_t GATTS_SERVICE_UUID_TEST = 0x180D; //0x00FF; static const uint16_t GATTS_CHAR_UUID_TEST_A = 0x2A37; //0xFF01; static const uint16_t GATTS_CHAR_UUID_TEST_B = 0x2A38; //0xFF02; static const uint16_t GATTS_CHAR_UUID_TEST_C = 0x2A39; //0xFF03; Entrega el c\u00f3digo modificado e incluye en tu informe evidencias (capturas de pantalla) que demuestren que un cliente gatttool suscrito a notificaciones recibe, cada segundo, la actualizaci\u00f3n de ritmo card\u00edaco por parte del sensor.","title":"Pr\u00e1ctica 5"},{"location":"RPI-I/P5/#practica-5-bluetooth-low-energy-ble-servidor","text":"","title":"Pr\u00e1ctica 5. Bluetooth Low Energy (BLE). Servidor"},{"location":"RPI-I/P5/#objetivos","text":"Diseccionar en detalle un firmware de construcci\u00f3n de tabla GATT (servidor GATT) utilizando la API de ESP-IDF. Aprender a utilizar la herramienta gatttool para interactuar con el servidor GATT. Modificar el servidor GATT para que acepte peticiones de notificaci\u00f3n por parte del cliente, y para que publique bajo demanda valores actualizados para una determinada caracter\u00edstica.","title":"Objetivos"},{"location":"RPI-I/P5/#implementacion-de-un-servidor-gatt-basado-en-tablas","text":"","title":"Implementaci\u00f3n de un servidor GATT basado en tablas"},{"location":"RPI-I/P5/#introduccion","text":"En esta pr\u00e1ctica, desplegaremos un servidor GATT utilizando la API de ESP-IDF para tal fin. Dicha API expone las funcionalidades de Bluedroid, la pila Bluetooth (incluyendo BLE) que proporciona ESP-IDF para el desarrollo de aplicaciones Bluetooth. El ejemplo con el que trabajaremos reside en el directorio examples/bluetooth/bluedroid/ble/gatt_server_service_table . Debido a la complejidad del ejemplo (al menos en su parte inicial), la presente pr\u00e1ctica procede, en primer lugar, con un recorrido por la preparaci\u00f3n y construcci\u00f3n del servidor siguiendo una estructura de tabla que define los servicios y caracter\u00edsticas que se implementar\u00e1n en el mismo. El ejemplo implementa el perfile Heart Rate Profile definido en la especificaci\u00f3n Bluetooth , y sigue la siguiente estructura: Desplegaremos, por tanto, tres caracter\u00edsticas. De ellas, la m\u00e1s importante para nosotros ser\u00e1 el valor de medici\u00f3n de ritmo cardiaco, con su valor ( Heart Rate Measurement Value ) y su configuraci\u00f3n de notificaciones ( Heart Rate Measurement Notification Configuration ).","title":"Introducci\u00f3n"},{"location":"RPI-I/P5/#inclusion-de-encabezados","text":"Los siguientes ficheros de cabecera son necesarios para dotar de funcionalidad BLE a nuestro firmware : #include \"freertos/FreeRTOS.h\" #include \"freertos/task.h\" #include \"freertos/event_groups.h\" #include \"esp_system.h\" #include \"esp_log.h\" #include \"nvs_flash.h\" #include \"esp_bt.h\" #include \"esp_gap_ble_api.h\" #include \"esp_gatts_api.h\" #include \"esp_bt_main.h\" #include \"gatts_table_creat_demo.h\" #include \"esp_gatt_common_api.h\" Estos encabezados son necesarios para un correcto funcionamiento de FreeRTOS y de sus componentes, incluyendo funcionalidad relativa a logging y almacenamiento no vol\u00e1til. Son especialmente interesantes los ficheros esp_bt.h , esp_bt_main.h , esp_gap_ble_api.h y esp_gatts_api.h , ya que exponen la API BLE necesaria para la implementaci\u00f3n del firmware : esp_bt.h : implementa el controlador BT y los procedimientos VHCI del lado del host. esp_bt_main.h : implementa las rutinas de inicializaci\u00f3n y activaci\u00f3n de la pila Bluedroid. esp_gap_ble_api.h : implementa la configuraci\u00f3n GAP (par\u00e1metros de anuncios y conexi\u00f3n). esp_gatts_api.h : implementa la configuraci\u00f3n del servidor GATT (por ejemplo, la creaci\u00f3n de servicios y caracter\u00edsticas).","title":"Inclusi\u00f3n de encabezados"},{"location":"RPI-I/P5/#la-tabla-de-servicios","text":"El fichero de cabecera gatts_table_creat_demo.h contiene una enumeraci\u00f3n de los servicios y caracter\u00edsticas deseadas: enum { IDX_SVC, IDX_CHAR_A, IDX_CHAR_VAL_A, IDX_CHAR_CFG_A, IDX_CHAR_B, IDX_CHAR_VAL_B, IDX_CHAR_C, IDX_CHAR_VAL_C, HRS_IDX_NB, }; Los elementos de la anterior estructura se han incluido en el mismo orden que los atributos del Heart Rate Profile , comenzando con el servicio, seguido por las caracter\u00edsticas del mismo. Adem\u00e1s, la caracter\u00edstica Heart Rate Measurement dispone de configuraci\u00f3n propia ( Client Characteristic Configuration , o CCC), un descriptor que describe si la caracter\u00edstica tiene las notificaciones activas . Todos estos \u00edndices pueden utilizarse para identificar a cada elemento a la hora de crear la tabla de atributos: IDX_SVC : \u00edndice del servicio Heart Rate IDX_CHAR_A : \u00edndice de la definici\u00f3n de la caracter\u00edstica Heart Rate Measurement IDX_CHAR_VAL_A : \u00edndice del valor de la caracter\u00edstica Heart Rate Measurement IDX_CHAR_CFG_A : \u00edndice del descriptor de caracter\u00edstica Client Configuration Characteristic (CCC) de la caracter\u00edstica Heart Rate Measurement (permite configurar notificaciones por cambio en el valor de la caracter\u00edstica) IDX_CHAR_B : \u00ednidce de la declaraci\u00f3n de caracter\u00edstica Heart Rate Body Sensor Location IDX_CHAR_VAL_B : \u00edndice del valor de la caracter\u00edstica Heart Rate Body Sensor Location IDX_CHAR_C : \u00edndice de la declaraci\u00f3n de caracter\u00edstica Heart Rate Control Point IDX_CHAR_VAL_C : \u00edndice del valor de la caracter\u00edstica Heart Rate Control Point IDX_NB : N\u00famero de elementos en la tabla","title":"La tabla de servicios"},{"location":"RPI-I/P5/#punto-de-entrada","text":"El punto de entrada de la aplicaci\u00f3n ( app_main() ) se implementa como sigue: void app_main(void) { esp_err_t ret; /* Initialize NVS. */ ret = nvs_flash_init(); if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) { ESP_ERROR_CHECK(nvs_flash_erase()); ret = nvs_flash_init(); } ESP_ERROR_CHECK( ret ); ESP_ERROR_CHECK(esp_bt_controller_mem_release(ESP_BT_MODE_CLASSIC_BT)); esp_bt_controller_config_t bt_cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT(); ret = esp_bt_controller_init(&bt_cfg); if (ret) { ESP_LOGE(GATTS_TABLE_TAG, \"%s enable controller failed: %s\", __func__, esp_err_to_name(ret)); return; } ret = esp_bt_controller_enable(ESP_BT_MODE_BLE); if (ret) { ESP_LOGE(GATTS_TABLE_TAG, \"%s enable controller failed: %s\", __func__, esp_err_to_name(ret)); return; } ret = esp_bluedroid_init(); if (ret) { ESP_LOGE(GATTS_TABLE_TAG, \"%s init bluetooth failed: %s\", __func__, esp_err_to_name(ret)); return; } ret = esp_bluedroid_enable(); if (ret) { ESP_LOGE(GATTS_TABLE_TAG, \"%s enable bluetooth failed: %s\", __func__, esp_err_to_name(ret)); return; } ret = esp_ble_gatts_register_callback(gatts_event_handler); if (ret){ ESP_LOGE(GATTS_TABLE_TAG, \"gatts register error, error code = %x\", ret); return; } ret = esp_ble_gap_register_callback(gap_event_handler); if (ret){ ESP_LOGE(GATTS_TABLE_TAG, \"gap register error, error code = %x\", ret); return; } ret = esp_ble_gatts_app_register(ESP_APP_ID); if (ret){ ESP_LOGE(GATTS_TABLE_TAG, \"gatts app register error, error code = %x\", ret); return; } esp_err_t local_mtu_ret = esp_ble_gatt_set_local_mtu(500); if (local_mtu_ret){ ESP_LOGE(GATTS_TABLE_TAG, \"set local MTU failed, error code = %x\", local_mtu_ret); } } Las acciones realizadas por esta funci\u00f3n de entrada se describen en los siguientes apartados.","title":"Punto de entrada"},{"location":"RPI-I/P5/#inicializacion-de-la-flash-para-almacenamiento-no-volatil","text":"La funci\u00f3n principal procede incializando el almacenamiento no vol\u00e1til, para almacenar los par\u00e1metros necesarios en memoria flash : ret = nvs_flash_init();","title":"Inicializaci\u00f3n de la flash para almacenamiento no vol\u00e1til"},{"location":"RPI-I/P5/#inicializacion-y-configuracion-de-ble","text":"A continuaci\u00f3n la funci\u00f3n principal inicializa el controlador Bluetooth, creando en primer lugar una estructura de configuraci\u00f3n para tal fin de tipo esp_bt_controller_config_t con valores por defecto dictados por la macro BT_CONTROLLER_INIT_CONFIG_DEFAULT() . El controlador Bluetooth implementa el Host Controller Interface (HCI), la capa de enlace y la capa f\u00edsica BLE; es, por tanto, transparente para el programador. La configuraci\u00f3n incluye el tama\u00f1o de pila reservado al controlador, prioridad y baudios para la transmisi\u00f3n. Con estas configuraciones, el controlador puede ser inicializado y activado con la funci\u00f3n esp_bt_controller_init() : esp_bt_controller_config_t bt_cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT(); ret = esp_bt_controller_init(&bt_cfg); Una vez inicializado el controlador se activa el modo BLE: ret = esp_bt_controller_enable(ESP_BT_MODE_BLE); Existen cuatro modos de funcioinamiento del controlador Bluetooth: ESP_BT_MODE_IDLE : Bluetooth no funcional ESP_BT_MODE_BLE : Modo BLE ESP_BT_MODE_CLASSIC_BT : Modo BT Cl\u00e1sico ESP_BT_MODE_BTDM : Modo Dual (BLE + BT Cl\u00e1sico) Tras la incializaci\u00f3n del controlador Bluetooth, se inicializa y activa la pila Bluedroid (que incluye APIs tanto para BLE como para Bluetooth Cl\u00e1sico): ret = esp_bluedroid_init(); ret = esp_bluedroid_enable(); La pila Bluetooth est\u00e1, a partir de este punto, lista para funcionar, pero todav\u00eda no se ha implementado ninguna l\u00f3gica de aplicaci\u00f3n. Dicha funcionalidad se define con el cl\u00e1sico mecanismo basado en eventos, que pueden ser emitidos, por ejemplo, cuando otro dispositivo intenta leer o escribir par\u00e1metros, o establecer una conexi\u00f3n. Existen dos gestores de eventos para BLE: los manejadores ( handlers ) GAP y GATT. La aplicaci\u00f3n necesita registrar una funci\u00f3n de callback para cada uno de ellos, que ser\u00e1 la encargada de tratar los eventos correspondiente a estos servicios. esp_ble_gatts_register_callback(gatts_event_handler); esp_ble_gap_register_callback(gap_event_handler); En la aplicaci\u00f3n de ejemplo estos callbacks son las funciones gatts_event_handler() y gap_event_handler() , que manejar\u00e1n los eventos emitidos por la pila BLE hacia la plicaci\u00f3n.","title":"Inicializaci\u00f3n y configuraci\u00f3n de BLE"},{"location":"RPI-I/P5/#perfiles-de-aplicacion-application-profiles","text":"Como se ha dicho, el objetivo es implementar un Perfil de Aplicaci\u00f3n para el servicio Heart Rate . Un Perfil de Aplicaci\u00f3n es un mecanismo que permite agrupar funcionalidad dise\u00f1ada para ser utilizada por un cliente de la aplicaci\u00f3n, por ejemplo, una aplicaci\u00f3n m\u00f3vil. Un mismo servidor puede implementar uno o m\u00e1s perfiles de aplicaci\u00f3n (Aplicaciones en el mundo BLE). El Identifificador de Perfil de Aplicaci\u00f3n ( Application Profile ID ) es un valor seleccionable por el usuario para identificar cada perfil; su uso se recude al registro del perfil en la pila Bluetooth. En el ejemplo, el ID es 0x55 . #define PROFILE_NUM 1 #define PROFILE_APP_IDX 0 #define ESP_APP_ID 0x55 Los perfiles se almacenan en el array heart_rate_profile_tab . Al haber un \u00fanico perfil en el ejemplo, s\u00f3lo se almacena un elemento en el array, con \u00edndice 0 (tal y como se define en PROFILE_APP_IDX ). Adem\u00e1s, es necesario inicializar la funci\u00f3n de callback manejadora de los eventos del perfil. Cada aplicaci\u00f3n en el servidor GATT utiliza una interfaz diferenciada, representada por el par\u00e1metro gats_if . Para la incializaci\u00f3n, este par\u00e1metro se iguala a ESP_GATT_IF_NONE ; cuando la aplicaci\u00f3n se registre, m\u00e1s adelante, el par\u00e1metro gatts_if se actualizar\u00e1 con la interfaz generada autom\u00e1ticamente por la pila Bluetooth. /* One gatt-based profile one app_id and one gatts_if, this array will store the gatts_if returned by ESP_GATTS_REG_EVT */ static struct gatts_profile_inst heart_rate_profile_tab[PROFILE_NUM] = { [PROFILE_APP_IDX] = { .gatts_cb = gatts_profile_event_handler, .gatts_if = ESP_GATT_IF_NONE, /* Not get the gatt_if, so initial is ESP_GATT_IF_NONE */ }, }; La estructura gatts_profile_inst completa presenta los siguientes campos (no todos se usan en el ejemplo): struct gatts_profile_inst { esp_gatts_cb_t gatts_cb; uint16_t gatts_if; uint16_t app_id; uint16_t conn_id; uint16_t service_handle; esp_gatt_srvc_id_t service_id; uint16_t char_handle; esp_bt_uuid_t char_uuid; esp_gatt_perm_t perm; esp_gatt_char_prop_t property; uint16_t descr_handle; esp_bt_uuid_t descr_uuid; }; El registro de la aplicaci\u00f3n tiene lugar en la funci\u00f3n app_main() , utilizando la funci\u00f3n esp_ble_gatts_app_register() : esp_ble_gatts_app_register(ESP_APP_ID);","title":"Perfiles de aplicaci\u00f3n (Application profiles)"},{"location":"RPI-I/P5/#registro-de-aplicacion","text":"El evento de registro de aplicaci\u00f3n ESP_GATTS_REG_EVT es el primero que se generar\u00e1 en la vida del programa. Este evento es tratado por el callback registrado como manejador de eventos del servidor gatt, que en nuestro ejemplo lo termina delegando en el callback asociado al perfil de aplicaci\u00f3n ( gatts_profile_event_handler en nuestro ejemplo): static void gatts_event_handler(esp_gatts_cb_event_t event, esp_gatt_if_t gatts_if, esp_ble_gatts_cb_param_t *param) { ESP_LOGI(GATTS_TABLE_TAG, \"EVT %d, gatts if %d\\n\", event, gatts_if); /* If event is register event, store the gatts_if for each profile */ if (event == ESP_GATTS_REG_EVT) { if (param->reg.status == ESP_GATT_OK) { heart_rate_profile_tab[HEART_PROFILE_APP_IDX].gatts_if = gatts_if; } else { ESP_LOGI(GATTS_TABLE_TAG, \"Reg app failed, app_id %04x, status %d\\n\", param->reg.app_id, param->reg.status); return; } } do { int idx; for (idx = 0; idx < HEART_PROFILE_NUM; idx++) { if (gatts_if == ESP_GATT_IF_NONE || /* ESP_GATT_IF_NONE, not specify a certain gatt_if, need to call every profile cb function */ gatts_if == heart_rate_profile_tab[idx].gatts_if) { if (heart_rate_profile_tab[idx].gatts_cb) { heart_rate_profile_tab[idx].gatts_cb(event, gatts_if, param); } } } } while (0); } Los par\u00e1metros asociados al evento son: esp_gatt_status_t status; /* Operation status */ uint16_t app_id; /* Application id which input in register API */ esp_gatt_if_t gatts_if; /* Interfaz GATTS assignada por la pila BLE */ A partir de ese momento deber\u00e1 usarse la interfaz gatts_if para operar, por lo que la funci\u00f3n registra esta interfaz en la tabla de descripci\u00f3n del perfil de aplicaci\u00f3n. Finalmente, la funci\u00f3n delega el evento en el callback registrado para tratar los eventos asociados al perfil ( gatts_profile_event_handler ).","title":"Registro de aplicaci\u00f3n"},{"location":"RPI-I/P5/#parametros-gap","text":"Como hemos visto arriba, el evento ESP_GATTS_REG_EVT es delegado en la funci\u00f3n gatss_profile_event_handler por el manejador de eventos del servidor gatt, para completar su procesamiento: static void gatts_profile_event_handler(esp_gatts_cb_event_t event, esp_gatt_if_t gatts_if, esp_ble_gatts_cb_param_t *param) { switch (event) { case ESP_GATTS_REG_EVT:{ esp_err_t set_dev_name_ret = esp_ble_gap_set_device_name(SAMPLE_DEVICE_NAME); if (set_dev_name_ret){ ESP_LOGE(GATTS_TABLE_TAG, \"set device name failed, error code = %x\", set_dev_name_ret); } #ifdef CONFIG_SET_RAW_ADV_DATA esp_err_t raw_adv_ret = esp_ble_gap_config_adv_data_raw(raw_adv_data, sizeof(raw_adv_data)); if (raw_adv_ret){ ESP_LOGE(GATTS_TABLE_TAG, \"config raw adv data failed, error code = %x \", raw_adv_ret); } adv_config_done |= ADV_CONFIG_FLAG; esp_err_t raw_scan_ret = esp_ble_gap_config_scan_rsp_data_raw(raw_scan_rsp_data, sizeof(raw_scan_rsp_data)); if (raw_scan_ret){ ESP_LOGE(GATTS_TABLE_TAG, \"config raw scan rsp data failed, error code = %x\", raw_scan_ret); } adv_config_done |= SCAN_RSP_CONFIG_FLAG; ... #endif esp_err_t create_attr_ret = esp_ble_gatts_create_attr_tab(gatt_db, gatts_if, HRS_IDX_NB, SVC_INST_ID); if (create_attr_ret){ ESP_LOGE(GATTS_TABLE_TAG, \"create attr table failed, error code = %x\", create_attr_ret); } } break; ... } Esta funci\u00f3n utiliza el evento para configurar par\u00e1metros GAP (de anuncio). Las funciones asociadas son: esp_ble_gap_set_device_name() : utilizada para establecer el nombre del dispositivo anunciado. esp_ble_gap_config_adv_data_raw() : usada para configurar datos est\u00e1ndar de anuncio. Como podemos ver en el c\u00f3digo de arriba, se comienza estableciendo el nombre del dispositivo: case ESP_GATTS_REG_EVT:{ esp_err_t set_dev_name_ret = esp_ble_gap_set_device_name(SAMPLE_DEVICE_NAME); if (set_dev_name_ret){ ESP_LOGE(GATTS_TABLE_TAG, \"set device name failed, error code = %x\", set_dev_name_ret); } A continuaci\u00f3n se configuran los datos de anuncio. La funci\u00f3n esp_ble_gap_config_adv_data_raw() toma un puntero a un array de bytes con los datos de anuncio. Cada dato anunciado se compone de: Campo longitud: indica el n\u00famero de bytes que ocupa el dato, sin contar el campo longitud (es decir, cuantos bytes vienen despu\u00e9s del campo longitud) Campo tipo: indica el tipo de dato seg\u00fan el documento Bluetooth Assigned Numbers Document Campo datos: los bytes del dato anunciado Podemos ver que en nuestro ejemplo el anuncio env\u00eda: Flags: LE General Discoverable Mode y BR/EDR not supported Tx Power Level: 1 byte en complemento a 2, en dBm (-127 a 127 dBm). Se puede usar para determinar la potencia perdida en la transmisi\u00f3n, calculando la diferencia entre la potencia transmitida anunciada y el RSSI en la recepci\u00f3n. En nuestro ejemplo -21 dBm. Complete Local Name: el nombre local completo asignado al dispositivo. La carga total del paquete de anuncio ( payload ) puede ser como m\u00e1ximo de 31 bytes (en nuestro ejemplo el anuncio ocupa 26 bytes). Para poder enviar m\u00e1s datos se puede configurar un scan response , lo que har\u00e1 que los anuncios enviados sean de tipo scannable. El scan response se puede configurar usando la funci\u00f3n esp_ble_gap_config_scan_rsp_data_raw() . //config scan response data ret = esp_ble_gap_config_adv_data(&scan_rsp_data); if (ret){ ESP_LOGE(GATTS_TABLE_TAG, \"config scan response data failed, error code = %x\", ret); } adv_config_done |= SCAN_RSP_CONFIG_FLAG; Al final del tratamiento del evento de registro se inicializa la tabla del servidor GATT. En nuestro ejemplo los atributos de la tabla se pasan a trav\u00e9s del array gatt_db , indic\u00e1ndose el n\u00famero de entradas de este array ( HRS_IDX_NB ), el interfaz ble a utilizar ( gatts_if ) y la instancia de ese servicio ( SVC_INST_ID ). esp_err_t create_attr_ret = esp_ble_gatts_create_attr_tab(gatt_db, gatts_if, HRS_IDX_NB, SVC_INST_ID); if (create_attr_ret){ ESP_LOGE(GATTS_TABLE_TAG, \"create attr table failed, error code = %x\", create_attr_ret); }","title":"Par\u00e1metros GAP"},{"location":"RPI-I/P5/#estructura-de-la-tabla-gatt","text":"Como hemos visto arriba, la tabla GATT se inicializa en el evento de Registro de Aplicaci\u00f3n, usando la funci\u00f3n esp_ble_gatts_create_attr_tab() . Esta funci\u00f3n toma como argumento un array de estructuras de tipo esp_gatts_attr_db_t , indexable con los valores del enumerado definido en el fichero gatts_table_creat_demo.h . Las estructuras esp_gatts_attr_db_t tienen dos miembros: esp_attr_control_t attr_control; /* The attribute control type*/ esp_attr_desc_t att_desc; /* The attribute type*/ attr_control es el par\u00e1metro de autorespuesta, t\u00edpicamente fijado a ESP_GATT_AUTO_RSP para permitir que la pila BLE reponda autom\u00e1ticamente a los mensajes de lectura o escritura cuando dichos eventos son recibidos. Una opci\u00f3n alternativa es ESP_GATT_RSP_BY_APP que permite respuestas manuales utilizando la funci\u00f3n esp_ble_gatts_send_response() . att_desc es la descripci\u00f3n del atributo, una estructura con los siguientes campos: uint16_t uuid_length; /* UUID length */ uint8_t *uuid_p; /* UUID value */ uint16_t perm; /* Attribute permission */ uint16_t max_length; /* Maximum length of the element */ uint16_t length; /* Current length of the element */ uint8_t *value; /* Element value array */ Por ejemplo, el primer elemento de la tabla en el ejemplo es el atributo de servicio: // Service Declaration [IDX_SVC] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&primary_service_uuid, ESP_GATT_PERM_READ, sizeof(uint16_t), sizeof(GATTS_SERVICE_UUID_TEST), (uint8_t *)&GATTS_SERVICE_UUID_TEST}}, Los valores de inicializaci\u00f3n son: [IDX_SVC] : Inicializador en la tabla. ESP_GATT_AUTO_RSP : configuraci\u00f3n de respuesta autom\u00e1tica, fijada en este caso a respuesta autom\u00e1tica por parte de la pila BLE. ESP_UUID_LEN_16 : longitudo del UUID fijada a 16 bits. (uint8_t *)&primary_service_uuid : UUID para identificar al servicio como primario (0x2800). ESP_GATT_PERM_READ : Permisos de lectura para el servicio. sizeof(uint16_t) : Longitud m\u00e1xima del UUID del servicio (16 bits). sizeof(heart_rate_svc) : Longitud del servicio, en este caso 16 bits (fijada por el tama\u00f1o de la variable heart_rate_svc ). (uint8_t *)&heart_rate_svc : Valor del atributo servicio fijada a la variable the variable heart_rate_svc , que contiene el UUID del Heart Rate Service (0x180D). El resto de atributos se inicializan de forma similar. Algunos atributos tambi\u00e9n tienen activa la propiedad NOTIFY , que se establece v\u00eda &char_prop_notify . La tabla completa se inicializa como sigue: /* Full Database Description - Used to add attributes into the database */ static const esp_gatts_attr_db_t gatt_db[HRS_IDX_NB] = { // Service Declaration [IDX_SVC] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&primary_service_uuid, ESP_GATT_PERM_READ, sizeof(uint16_t), sizeof(GATTS_SERVICE_UUID_TEST), (uint8_t *)&GATTS_SERVICE_UUID_TEST}}, /* Characteristic Declaration */ [IDX_CHAR_A] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&character_declaration_uuid, ESP_GATT_PERM_READ, CHAR_DECLARATION_SIZE, CHAR_DECLARATION_SIZE, (uint8_t *)&char_prop_read_write_notify}}, /* Characteristic Value */ [IDX_CHAR_VAL_A] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&GATTS_CHAR_UUID_TEST_A, ESP_GATT_PERM_READ | ESP_GATT_PERM_WRITE, GATTS_DEMO_CHAR_VAL_LEN_MAX, sizeof(char_value), (uint8_t *)char_value}}, /* Client Characteristic Configuration Descriptor */ [IDX_CHAR_CFG_A] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&character_client_config_uuid, ESP_GATT_PERM_READ | ESP_GATT_PERM_WRITE, sizeof(uint16_t), sizeof(heart_measurement_ccc), (uint8_t *)heart_measurement_ccc}}, /* Characteristic Declaration */ [IDX_CHAR_B] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&character_declaration_uuid, ESP_GATT_PERM_READ, CHAR_DECLARATION_SIZE, CHAR_DECLARATION_SIZE, (uint8_t *)&char_prop_read}}, /* Characteristic Value */ [IDX_CHAR_VAL_B] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&GATTS_CHAR_UUID_TEST_B, ESP_GATT_PERM_READ | ESP_GATT_PERM_WRITE, GATTS_DEMO_CHAR_VAL_LEN_MAX, sizeof(char_value), (uint8_t *)char_value}}, /* Characteristic Declaration */ [IDX_CHAR_C] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&character_declaration_uuid, ESP_GATT_PERM_READ, CHAR_DECLARATION_SIZE, CHAR_DECLARATION_SIZE, (uint8_t *)&char_prop_write}}, /* Characteristic Value */ [IDX_CHAR_VAL_C] = {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&GATTS_CHAR_UUID_TEST_C, ESP_GATT_PERM_READ | ESP_GATT_PERM_WRITE, GATTS_DEMO_CHAR_VAL_LEN_MAX, sizeof(char_value), (uint8_t *)char_value}}, };","title":"Estructura de la tabla GATT"},{"location":"RPI-I/P5/#inicializacion-del-servicio","text":"Cuando la tabla se crea, se emite un evento de tipo ESP_GATTS_CREAT_ATTR_TAB_EVT , tratado por el manejador de eventos del perfil. Este evento tiene los siguientes par\u00e1metros asociados: esp_gatt_status_t status; /* Operation status */ esp_bt_uuid_t svc_uuid; /* Service uuid type */ uint16_t num_handle; /* The number of the attribute handle to be added to the gatts database */ uint16_t *handles; /* The number to the handles */ Nuestro c\u00f3digo de ejemplo utiliza este evento para comprobar que el tama\u00f1o de la tabla creada es igual al n\u00famero de elementos en la enumeraci\u00f3n ( HRS_IDX_NB ). Si la tabla se cre\u00f3 correctamente, se copian en la tabla heart_rate_handle_table los manejadores (handels) asignados por el servidor GATT a los atributos, y finalmente se inicializa el servicio utilizando la funci\u00f3n esp_ble_gatts_start_service() : case ESP_GATTS_CREAT_ATTR_TAB_EVT:{ if (param->add_attr_tab.status != ESP_GATT_OK){ ESP_LOGE(GATTS_TABLE_TAG, \"create attribute table failed, error code=0x%x\", param->add_attr_tab.status); } else if (param->add_attr_tab.num_handle != HRS_IDX_NB){ ESP_LOGE(GATTS_TABLE_TAG, \"create attribute table abnormally, num_handle (%d) \\ doesn't equal to HRS_IDX_NB(%d)\", param->add_attr_tab.num_handle, HRS_IDX_NB); } else { ESP_LOGI(GATTS_TABLE_TAG, \"create attribute table successfully, the number handle = %d\\n\",param->add_attr_tab.num_handle); memcpy(heart_rate_handle_table, param->add_attr_tab.handles, sizeof(heart_rate_handle_table)); esp_ble_gatts_start_service(heart_rate_handle_table[IDX_SVC]); } break; Los manejadores (handles) almacenados son n\u00fameros que identifican cada atributo. Estos manejadores pueden usarse en cualquier punto de la aplicaci\u00f3n para operar sobre los atributos.","title":"Inicializaci\u00f3n del servicio"},{"location":"RPI-I/P5/#el-manejador-de-eventos-gap","text":"Como hemos visto arriba, en el procesamiento del evento de registro de aplicaci\u00f3n se establecen los datos de anuncio. Cuando se complete esta inicializaci\u00f3n, la pila BLE emitir\u00e1 un evento de tipo ESP_GAP_BLE_ADV_DATA_SET_COMPLETE_EVT , que ser\u00e1 manejado por el callback registrado como GAP handler. Si se ha configurado un anuncio scannable y una respuesta al escaneado (en nuestro ejemplo se ha configurado), la pila BLE emitir\u00e1 tambi\u00e9n un evento de tipo ESP_GAP_BLE_SCAN_RSP_DATA_SET_COMPLETE_EVT . El manejador del c\u00f3digo de ejemplo espera a que se produzcan estos dos eventos para comenzar con el proceso de anuncio, utilizando la funci\u00f3n esp_ble_gap_start_advertising() : static void gap_event_handler(esp_gap_ble_cb_event_t event, esp_ble_gap_cb_param_t *param) { ESP_LOGE(GATTS_TABLE_TAG, \"GAP_EVT, event %d\\n\", event); switch (event) { #ifdef CONFIG_SET_RAW_ADV_DATA case ESP_GAP_BLE_ADV_DATA_RAW_SET_COMPLETE_EVT: adv_config_done &= (~ADV_CONFIG_FLAG); if (adv_config_done == 0){ esp_ble_gap_start_advertising(&adv_params); } break; case ESP_GAP_BLE_SCAN_RSP_DATA_RAW_SET_COMPLETE_EVT: adv_config_done &= (~SCAN_RSP_CONFIG_FLAG); if (adv_config_done == 0){ esp_ble_gap_start_advertising(&adv_params); } break; #else ... #endif } } La funci\u00f3n de inicio de anuncios toma una estructura de tipo esp_ble_adv_params_t con los par\u00e1metros de anuncio requeridos: /// Advertising parameters typedef struct { uint16_t adv_int_min; /* Minimum advertising interval for undirected and low * duty cycle directed advertising. * Range: 0x0020 to 0x4000 * Default: N = 0x0800 (1.28 second) * Time = N * 0.625 msec * Time Range: 20 ms to 10.24 sec */ uint16_t adv_int_max; /* Maximum advertising interval for undirected and low * duty cycle directed advertising. * Range: 0x0020 to 0x4000 * Default: N = 0x0800 (1.28 second) * Time = N * 0.625 msec * Time Range: 20 ms to 10.24 sec */ esp_ble_adv_type_t adv_type; /* Advertising type */ esp_ble_addr_type_t own_addr_type; /* Owner bluetooth device address type */ esp_bd_addr_t peer_addr; /* Peer device bluetooth device address */ esp_ble_addr_type_t peer_addr_type; /* Peer device bluetooth device address type */ esp_ble_adv_channel_t channel_map; /* Advertising channel map */ esp_ble_adv_filter_t adv_filter_policy; /* Advertising filter policy */ } esp_ble_adv_params_t; N\u00f3tese como esp_ble_gap_config_adv_data_raw() (en gatts_profile_event_handler ) configura los datos enviados en el anuncio, mientras que esp_ble_gap_start_advertising() pone al dispositivo en modo advertising, haciendo que el servidor comience a enviar los anuncios. Los par\u00e1metros de anuncio configuran como y cu\u00e1ndo enviarlos. En nuestro ejemplo, los par\u00e1metros de anuncio se inicializan como sigue: static esp_ble_adv_params_t adv_params = { .adv_int_min = 0x20, .adv_int_max = 0x40, .adv_type = ADV_TYPE_IND, .own_addr_type = BLE_ADDR_TYPE_PUBLIC, .channel_map = ADV_CHNL_ALL, .adv_filter_policy = ADV_FILTER_ALLOW_SCAN_ANY_CON_ANY, }; Estos par\u00e1metros configuran el intervalo de anuncio entre 20 ms y 40 ms. El anuncio es de tipo ADV_TYPE_IND (tipo gen\u00e9rico), destinados a ning\u00fan dispositivo central en particular, y anuncia que el servidor GATT es conectable. El tipo de direcci\u00f3n es p\u00fablico, utiliza todos los canales y permite peticiones de escaneo y conexi\u00f3n por parte de cualquier dispositivo central. Si el proceso de anuncio se inici\u00f3 correctamente, se emitir\u00e1 un evento de tipo ESP_GAP_BLE_ADV_START_COMPLETE_EVT , que en este ejemplo se utiliza para comprobar si el estado es realmente anunciando u otro, en cuyo caso se emitir\u00e1 un mensaje de error: ... case ESP_GAP_BLE_ADV_START_COMPLETE_EVT: /* advertising start complete event to indicate advertising start successfully or failed */ if (param->adv_start_cmpl.status != ESP_BT_STATUS_SUCCESS) { ESP_LOGE(GATTS_TABLE_TAG, \"advertising start failed\"); }else{ ESP_LOGI(GATTS_TABLE_TAG, \"advertising start successfully\"); } break; ...","title":"El manejador de eventos GAP"},{"location":"RPI-I/P5/#interaccion-a-traves-de-un-cliente-gatt","text":"Existen multitud de herramientas que permiten gestionar la conexi\u00f3n al servidor GATT. En Linux, utilizaremos hcitool y gatttool ; en Windows, puedes utilizar una herramienta llamada Bluetooth LE Explorer , que implementa, aunque de forma gr\u00e1fica, la misma funcionalidad. Nota Para desarrollar esta parte de la pr\u00e1ctica, deber\u00e1s hacer visible en la m\u00e1quina virtual el controlador Bluetooth del equipo que la hospeda (tu port\u00e1til o el equipo de laboratorio).","title":"Interacci\u00f3n a trav\u00e9s de un cliente GATT"},{"location":"RPI-I/P5/#uso-de-hcitool-y-gatttool-en-modo-cliente","text":"","title":"Uso de hcitool y gatttool en modo cliente"},{"location":"RPI-I/P5/#escaneando-dispositivos-disponibles-hcitool","text":"hcitool es una herramienta de l\u00ednea de comandos que permite gestionar la interfaz Bluetooth del equipo en el que se ejecuta. En nuestro caso, necesitaremos determinar la direcci\u00f3n MAC Bluetooth de nuestro servidor. Para ello, en primer lugar, realizaremos un escaneado de los dispsitivos BLE disponibles en el entorno utilizando la orden: sudo hcitool lescan Nota Este comando no funcionar\u00e1 si no has pasado el control del dispositivo bluetooth a la m\u00e1quina virtual. Si todo ha ido bien, se mostrar\u00e1 una l\u00ednea por dispositivo BLE disponible y en fase de anuncio. Entre ellos, deberemos encontrar nuestro dispositivo. Apuntaremos su direcci\u00f3n MAC, para poder usarla de aqu\u00ed en adelante. Tarea B\u00e1sica Edita el fichero main/gatts_table_creat_demo.c y modifica el nombre de tu dispositivo, que se enviar\u00e1 en cada anuncio emitido en la fase de advertising . Para ello, debes modificar el campo correspondiente de la estructura raw_adv_data . A continuaci\u00f3n, compila y flashea el ejemplo, y comienza una sesi\u00f3n de escaneado de dispositivos BLE mediante la orden: sudo hcitool lescan Deber\u00e1s observar tu dispositivo en una de las l\u00edneas. Anota o recuerda su direcci\u00f3n MAC. Tarea Adicional Documenta y explica el ejercicio en tu informe de la pr\u00e1ctica.","title":"Escaneando dispositivos disponibles: hcitool"},{"location":"RPI-I/P5/#interactuando-con-el-servidor-gatt-gatttool","text":"Una vez obtenida la direcci\u00f3n MAC Bluetooth del dispositivo, deberemos proceder en dos fases. La primera de ellas es el emparejado al dispostivo desde tu consola. La segunda, la interacci\u00f3n con la tabla GATT. En ambos casos, se utilizar\u00e1 la herramienta gatttool desde l\u00ednea de comandos. Tarea Adicional Prepara un informe donde documentes y comentes cada uno de los pasos y tareas que realices en esta pr\u00e1ctica. Para comenzar una sesi\u00f3n gatttool , invocaremos a la herramienta en modo interactivo, utilizando la orden: gatttool -b MAC -I Esto abrir\u00e1 una consola interactiva, a la espera de las ordenes correspondientes. Para realizar el emparejamiento, y considerando que la MAC Bluetooth es ya conocida, utilizaremos la orden connect . Si todo ha ido bien, deberemos observar un cambio en el color del prompt, y un mensaje Connection successful . En este punto, observa como en la salida de depuraci\u00f3n del ESP32 se muestran los mensajes correspondientes al proceso de emparejamiento. Desde la terminal de gatttool , puedes ejecutar en cualquier momento la orden help para obtener ayuda (en forma de lista de comandos disponibles): gatttool -b 24:6F:28:36:60:B2 -I [24:6F:28:36:60:B2][LE]> connect Attempting to connect to 24:6F:28:36:60:B2 Connection successful [24:6F:28:36:60:B2][LE]> help help Show this help exit Exit interactive mode quit Exit interactive mode connect [address [address type]] Connect to a remote device disconnect Disconnect from a remote device primary [UUID] Primary Service Discovery included [start hnd [end hnd]] Find Included Services characteristics [start hnd [end hnd [UUID]]] Characteristics Discovery char-desc [start hnd] [end hnd] Characteristics Descriptor Discovery char-read-hnd <handle> Characteristics Value/Descriptor Read by handle char-read-uuid <UUID> [start hnd] [end hnd] Characteristics Value/Descriptor Read by UUID char-write-req <handle> <new value> Characteristic Value Write (Write Request) char-write-cmd <handle> <new value> Characteristic Value Write (No response) sec-level [low | medium | high] Set security level. Default: low mtu <value> Exchange MTU for GATT/ATT Comenzaremos consultando la lista de caracter\u00edsticas del servidor GATT. Tarea B\u00e1sica Mediante el comando correspondiente ( characteristics ), consulta y anota las caracter\u00edsticas disponibles en tu servidor GATT. Tarea Adicional Documenta y explica el ejercicio en tu informe de la pr\u00e1ctica. Una de estas caracter\u00edsticas ser\u00e1 de crucial inter\u00e9s, ya que nos permitir\u00e1 acceder, a trav\u00e9s de su UUID, la medici\u00f3n instant\u00e1nea de ritmo card\u00edaco, as\u00ed como la configuraci\u00f3n de notificaciones sobre dicho valor. Para determinar cu\u00e1l de las l\u00edneas es la que nos interesa, observa el valor de UUID devuelto para cada una de ellas, y determina, en funci\u00f3n de la macro GATTS_CHAR_UUID_TEST_A de cu\u00e1l se trata. Para interactuar con dicha caracter\u00edstica, necesitaremos conocer su manejador ( handler ). Dicho manejador se muestra, para cada l\u00ednea, tras la cadena char value handle . Tarea Adicional El manejador que permite leer desde la caracter\u00edstica *Heart Rate Value\" tiene un manejador de tipo char asociado. Anota su valor. Para leer el valor de la caracter\u00edstica, podemos utilizar su manejador asociado. As\u00ed, podemos obtener dicho valor con un comando de lectura, en este caso char-read-hnd manejador . Tarea B\u00e1sica Obt\u00e9n los datos de lectura de la caracter\u00edstica de medici\u00f3n del valor de monitorizaci\u00f3n de ritmo card\u00edaco. \u00bfCu\u00e1les son? Deber\u00edas observar un valor de retorno de cuatro bytes con valor 0x00. Estos valores corresponden a los de la variable char_value de tu c\u00f3digo. Modif\u00edcalos, recompila y vuelve a flashear el c\u00f3digo. \u00bfHan variado? Tarea B\u00e1sica Intenta ahora escribir en la anterior caracter\u00edstica. Para ello, utiliza el comando char-write-cmd handler valor , siendo valor, por ejemplo, 11223344 . Tarea Adicional Documenta el proceso en tu informe de la pr\u00e1ctica explicando c\u00f3mo saber el handle que se debe usar para poder modificar la caracter\u00edstica. Escribiremos a continuaci\u00f3n en la caracter\u00edstica de configuraci\u00f3n (CCC) del servicio de montorizaci\u00f3n. Para ello, utilizaremos el manejador siguiente al utilizado anteriormente. Esto es, si se nos devolvi\u00f3, por ejemplo, un manejador 0x0001 para el valor de monitorizaci\u00f3n, el valor de configuraci\u00f3n ser\u00e1 0x0002 . Tarea B\u00e1sica Intenta ahora escribir en la caracter\u00edstica de configuraci\u00f3n. Para ello, utiliza el comando char-write-cmd handler valor , siendo valor, por ejemplo, 0100 . Tarea Adicional Documenta el proceso en tu informe de la pr\u00e1ctica explicando c\u00f3mo saber el handle que se debe usar para poder modificar la caracter\u00edstica. Como habr\u00e1s observado, es posible leer desde el valor de monitorizaci\u00f3n, y escribir en el valor de configuraci\u00f3n. Utilizaremos esta \u00faltima caracter\u00edstica para configurar las notificaciones sobre el valor de monitorizaci\u00f3n. De este modo, cada vez que se desee enviar dicho valor a los clientes que tengan activada la notificaci\u00f3n, \u00e9stos la recibir\u00e1n sin necesidad de cambio alguno. Para ello, necesitamos modificar algunas partes de nuestro c\u00f3digo. Espec\u00edficamente, necesitaremos: Crear una nueva tarea que, peri\u00f3dicamente, modifique el valor de monitorizaci\u00f3n de ritmo card\u00edaco (ley\u00e9ndolo desde un sensor, si est\u00e1 disponible, o, en nuestro caso generando un valor aleatorio). Dicha tarea consistir\u00e1 en un bucle infinito que, en cualquier caso, s\u00f3lo enviar\u00e1 datos al cliente si la notificaci\u00f3n est\u00e1 activa, con un intervalo de env\u00edo de un segundo: static void publish_data_task(void *pvParameters) { while (1) { ESP_LOGI(\"APP\", \"Sending data...\"); // Paso 1: Actualizo valor... // Paso 2: Si las notificaciones est\u00e1n activas env\u00edo datos... // Paso 3: Duermo un segundo... vTaskDelay( 1000. / portTICK_PERIOD_MS); } } Esta rutina deber\u00e1 crearse en respuesta al evento de conexi\u00f3n por parte de un cliente, utilizando, por ejemplo, la invocaci\u00f3n a: xTaskCreate(&publish_data_task, \"publish_data_task\", 4096, NULL, 5, NULL); La actualizaci\u00f3n del valor, realizada peri\u00f3dicamente y de forma aleatoria, modificar\u00e1 el byte 1 de la variable char_value , tomando un valor aleatorio entre 0 y 255 (como nota adicional, los puls\u00f3metros actuales soportan valores mayores para ritmo cardiaco, aunque la configuraci\u00f3n de esta funcionalidad est\u00e1 fuera del alcance de la pr\u00e1ctica). La comprobaci\u00f3n de la activaci\u00f3n o no de la notificaci\u00f3n se realiza consultando los dos bytes de la variable heart_measurement_ccc . Si dichos valores son 0x01 y 0x00 (posiciones 0 y 1, respectivamente), las notificaciones est\u00e1n activas, y por tanto, se realizar\u00e1 el env\u00edo de notificaci\u00f3n. Para enviar la notificaci\u00f3n, utilizaremos la siguiente funci\u00f3n: esp_ble_gatts_send_indicate(heart_rate_profile_tab[0].gatts_if, heart_rate_profile_tab[0].conn_id, heart_rate_handle_table[IDX_CHAR_VAL_A], sizeof(char_value), char_value, false); La activaci\u00f3n de notificaciones desde gatttool se realizar\u00e1 mediante la escritura del valor 0x0100 en la caracter\u00edstica de configuraci\u00f3n, esto es: char-write-cmd HANDLER 0100 Nuestro firmware deber\u00e1 modificarse para que, al recibir dicho valor en la caracter\u00edstica, se sobreescriba el contenido de la variable heart_measurement_ccc . Esta escritura debe realizarse en respuesta al evento ESP_GATTS_WRITE_EVT . Tarea Adicional Modifica el firmware original para que, peri\u00f3dicamente (cada segundo) notifique el valor de ritmo card\u00edaco a los clientes conectados. Si adem\u00e1s modificas las UUID por las proporcionadas en la especificaci\u00f3n Bluetooth para el Servicio Heart Rate y todo ha sido configurado correctamente, tu ESP32 deber\u00eda poder interactuar con cualquier monitor de ritmo cardiaco, por ejemplo, Android. Para ello, utiliza las siguientes UUIDs: static const uint16_t GATTS_SERVICE_UUID_TEST = 0x180D; //0x00FF; static const uint16_t GATTS_CHAR_UUID_TEST_A = 0x2A37; //0xFF01; static const uint16_t GATTS_CHAR_UUID_TEST_B = 0x2A38; //0xFF02; static const uint16_t GATTS_CHAR_UUID_TEST_C = 0x2A39; //0xFF03; Entrega el c\u00f3digo modificado e incluye en tu informe evidencias (capturas de pantalla) que demuestren que un cliente gatttool suscrito a notificaciones recibe, cada segundo, la actualizaci\u00f3n de ritmo card\u00edaco por parte del sensor.","title":"Interactuando con el servidor GATT: gatttool"},{"location":"RPI-I/P6/","text":"Pr\u00e1ctica 6. Bluetooth Low Energy (BLE). Cliente Objetivos Diseccionar en detalle un firmware de un cliente GATT utilizando la API de ESP-IDF. Aprender a realizar un escaneo de dispositivos BLE Conocer la informaci\u00f3n disponible en los anuncios BLE Gestionar la conexi\u00f3n desde un cliente BLE a un servidor (GATT) BLE Implementaci\u00f3n de un cliente GATT para escaneo y conexi\u00f3n a servidor En esta pr\u00e1ctica, se revisa el c\u00f3digo de ejemplo para la construcci\u00f3n de un cliente GATT para el ESP32 utilizando ESP-IDF. El c\u00f3digo implementa un cliente de Atributo Gen\u00e9rico (GATT) de Bluetooth Low Energy (BLE), que escanea servidores perif\u00e9ricos cercanos y se conecta a un servicio predefinido. El cliente busca caracter\u00edsticas disponibles y se suscribe a una caracter\u00edstica conocida para recibir notificaciones o indicaciones. El ejemplo puede registrar un Perfil de Aplicaci\u00f3n e inicializa una secuencia de eventos que se pueden utilizar para configurar par\u00e1metros del Perfil de Acceso Gen\u00e9rico (GAP) y para manejar eventos como el escaneo, la conexi\u00f3n a perif\u00e9ricos y la lectura y escritura de caracter\u00edsticas. El desarrollo de esta pr\u00e1ctica requiere el uso de dos placas: una ejecutando el servidor GATT b\u00e1sico (o modificado) que usaste en la pr\u00e1ctica anterior, y otra ejecutando el c\u00f3digo cliente. Descripci\u00f3n del c\u00f3digo de ejemplo El ejemplo que seguiremos y adaptaremos se encuentra en la carpeta de ejemplos de ESP-IDF en bluetooth/bluedroid/ble/gatt_client/main . El archivo gattc_demo.c , ubicado en la carpeta principa, contiene todas las funcionalidades que vamos a revisar. Tarea previa Antes de comenzar, aseg\u00farate de que la variable remote_device_name (l\u00ednea 41) NO coincide con la de tu servidor GATT. Los archivos de encabezado contenidos en gattc_demo.c son: Ficheros de cabecera Observa los ficheros de cabecera incluidos (similares a los que utilizaste en la pr\u00e1ctica anterior): #include <stdint.h> #include <string.h> #include <stdbool.h> #include <stdio.h> #include \"nvs.h\" #include \"nvs_flash.h\" #include \"controller.h\" #include \"bt.h\" #include \"esp_gap_ble_api.h\" #include \"esp_gattc_api.h\" #include \"esp_gatt_defs.h\" #include \"esp_bt_main.h\" #include \"esp_gatt_common_api.h\" Estos includes son necesarios para que funcionen los componentes del sistema subyacente y FreeRTOS, incluida la funcionalidad de registro y una biblioteca para almacenar datos en memoria flash no vol\u00e1til. Estamos interesados en \"bt.h\" , \"esp_bt_main.h\" , \"esp_gap_ble_api.h\" y \"esp_gattc_api.h\" , que exponen las API de BLE necesarias para implementar este ejemplo. bt.h : configura el controlador BT y VHCI desde el lado del host. esp_bt_main.h : inicializa y habilita la pila Bluedroid. esp_gap_ble_api.h : implementa la configuraci\u00f3n GAP, por ejemplo los anuncios de dispositivos y los par\u00e1metros de conexi\u00f3n. esp_gattc_api.h : implementa la configuraci\u00f3n del Cliente GATT, como la conexi\u00f3n a perif\u00e9ricos y la b\u00fasqueda de servicios. Punto de Entrada Principal La funci\u00f3n de punto de entrada del programa es app_main() : void app_main() { // Inicializar NVS. esp_err_t ret = nvs_flash_init(); if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) { ESP_ERROR_CHECK(nvs_flash_erase()); ret = nvs_flash_init(); } ESP_ERROR_CHECK( ret ); esp_bt_controller_config_t bt_cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT(); ret = esp_bt_controller_init(&bt_cfg); if (ret) { ESP_LOGE(GATTC_TAG, \"%s inicializaci\u00f3n del controlador fallida, c\u00f3digo de error = %x\", __func__, ret); return; } ret = esp_bt_controller_enable(ESP_BT_MODE_BLE); if (ret) { ESP_LOGE(GATTC_TAG, \"%s habilitaci\u00f3n del controlador fallida, c\u00f3digo de error = %x\", __func__, ret); return; } esp_bluedroid_config_t bluedroid_cfg = BT_BLUEDROID_INIT_CONFIG_DEFAULT(); ret = esp_bluedroid_init_with_cfg(&bluedroid_cfg); if (ret) { ESP_LOGE(GATTC_TAG, \"%s inicializaci\u00f3n de Bluetooth fallida, c\u00f3digo de error = %x\", __func__, ret); return; } ret = esp_bluedroid_enable(); if (ret) { ESP_LOGE(GATTC_TAG, \"%s habilitaci\u00f3n de Bluetooth fallida, c\u00f3digo de error = %x\", __func__, ret); return; } // Registrar la funci\u00f3n de devoluci\u00f3n de llamada en el m\u00f3dulo GAP ret = esp_ble_gap_register_callback(esp_gap_cb); if (ret){ ESP_LOGE(GATTC_TAG, \"%s registro de GAP fallido, c\u00f3digo de error = %x\", __func__, ret); return; } // Registrar la funci\u00f3n de devoluci\u00f3n de llamada en el m\u00f3dulo GATTC ret = esp_ble_gattc_register_callback(esp_gattc_cb); if(ret){ ESP_LOGE(GATTC_TAG, \"%s registro de GATTC fallido, c\u00f3digo de error = %x\", __func__, ret); return; } ret = esp_ble_gattc_app_register(PROFILE_A_APP_ID); if (ret){ ESP_LOGE(GATTC_TAG, \"%s registro de la aplicaci\u00f3n GATTC fallido, c\u00f3digo de error = %x\", __func__, ret); } esp_err_t local_mtu_ret = esp_ble_gatt_set_local_mtu(500); if (local_mtu_ret){ ESP_LOGE(GATTC_TAG, \"configuraci\u00f3n del MTU local fallida, c\u00f3digo de error = %x\", local_mtu_ret); } } La funci\u00f3n principal comienza inicializando la biblioteca de almacenamiento no vol\u00e1til. Esta biblioteca permite guardar pares clave-valor en la memoria flash y se utiliza en algunos componentes, como la biblioteca Wi-Fi, para guardar el SSID y la contrase\u00f1a: esp_err_t ret = nvs_flash_init(); if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) { ESP_ERROR_CHECK(nvs_flash_erase()); ret = nvs_flash_init(); } ESP_ERROR_CHECK( ret ); Inicializaci\u00f3n del Controlador Bluetooth y la Pila BLE La funci\u00f3n principal tambi\u00e9n inicializa el controlador BT al crear primero una estructura de configuraci\u00f3n del controlador BT llamada esp_bt_controller_config_t con ajustes predeterminados generados por la macro BT_CONTROLLER_INIT_CONFIG_DEFAULT() . El controlador BT implementa la Interfaz del Controlador Host (HCI) en el lado del controlador, la Capa de Enlace (LL) y la Capa F\u00edsica (PHY). El controlador BT es invisible para las aplicaciones de usuario y se encarga de las capas inferiores de la pila BLE. La configuraci\u00f3n del controlador incluye el tama\u00f1o de la pila del controlador BT, la prioridad y la velocidad de baudios HCI. Con la configuraci\u00f3n creada, se inicializa y habilita el controlador BT con la funci\u00f3n esp_bt_controller_init() : esp_bt_controller_config_t bt_cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT(); ret = esp_bt_controller_init(&bt_cfg); A continuaci\u00f3n, el controlador se habilita en el modo BLE. ret = esp_bt_controller_enable(ESP_BT_MODE_BLE); El controlador debe habilitarse en ESP_BT_MODE_BTDM si desea utilizar el modo dual (BLE + BT). Hay cuatro modos de Bluetooth admitidos: ESP_BT_MODE_IDLE : Bluetooth no se est\u00e1 ejecutando. ESP_BT_MODE_BLE : Modo BLE. ESP_BT_MODE_CLASSIC_BT : Modo BT cl\u00e1sico. ESP_BT_MODE_BTDM : Modo dual (BLE + BT cl\u00e1sico). Despu\u00e9s de la inicializaci\u00f3n del controlador BT, se inicializa y habilita la pila Bluedroid, que incluye las definiciones y API comunes tanto para BT cl\u00e1sico como para BLE. Esto se realiza mediante: esp_bluedroid_config_t bluedroid_cfg = BT_BLUEDROID_INIT_CONFIG_DEFAULT(); ret = esp_bluedroid_init_with_cfg(&bluedroid_cfg); ret = esp_bluedroid_enable(); La funci\u00f3n principal finaliza registrando los controladores de eventos GAP y GATT, as\u00ed como el Perfil de Aplicaci\u00f3n y configurando el tama\u00f1o m\u00e1ximo admitido de MTU. // Registrar la funci\u00f3n de devoluci\u00f3n de llamada en el m\u00f3dulo GAP ret = esp_ble_gap_register_callback(esp_gap_cb); // Registrar la funci\u00f3n de devoluci\u00f3n de llamada en el m\u00f3dulo GATTC ret = esp_ble_gattc_register_callback(esp_gattc_cb); ret = esp_ble_gattc_app_register(PROFILE_A_APP_ID); esp_err_t local_mtu_ret = esp_ble_gatt_set_local_mtu(500); if (local_mtu_ret){ ESP_LOGE(GATTC_TAG, \"configuraci\u00f3n del MTU local fallida, c\u00f3digo de error = %x\", local_mtu_ret); } Los controladores de eventos GAP y GATT son las funciones utilizadas para capturar los eventos generados por la pila BLE y ejecutar funciones para configurar los par\u00e1metros de la aplicaci\u00f3n. Adem\u00e1s, los controladores de eventos tambi\u00e9n se utilizan para manejar eventos de lectura y escritura que provienen del dispositivo central. El controlador de eventos GAP se encarga del escaneo y la conexi\u00f3n a servidores, y el controlador GATT administra los eventos que ocurren despu\u00e9s de que el cliente se haya conectado a un servidor, como la b\u00fasqueda de servicios y la escritura y lectura de datos. Los controladores de eventos GAP y GATT se registran mediante: esp_ble_gap_register_callback(); esp_ble_gattc_register_callback(); Las funciones esp_gap_cb() y esp_gattc_cb() manejan todos los eventos generados por la pila BLE. Perfiles de Aplicaci\u00f3n Los Perfiles de Aplicaci\u00f3n son una forma de agrupar funcionalidades dise\u00f1adas para una o m\u00e1s aplicaciones de servidor. Por ejemplo, puede tener un Perfil de Aplicaci\u00f3n conectado a sensores de ritmo card\u00edaco y otro conectado a sensores de temperatura. Cada Perfil de Aplicaci\u00f3n crea una interfaz GATT para conectarse a otros dispositivos. Las estructuras de Perfiles de Aplicaci\u00f3n en el c\u00f3digo son instancias de la estructura gattc_profile_inst , que se define como: struct gattc_profile_inst { esp_gattc_cb_t gattc_cb; uint16_t gattc_if; uint16_t app_id; uint16_t conn_id; uint16_t service_start_handle; uint16_t service_end_handle; uint16_t char_handle; esp_bd_addr_t remote_bda; }; La estructura de Perfil de Aplicaci\u00f3n contiene: gattc_cb : funci\u00f3n de devoluci\u00f3n de llamada del cliente GATT gattc_if : n\u00famero de interfaz del cliente GATT para este perfil app_id : n\u00famero de ID del Perfil de Aplicaci\u00f3n conn_id : ID de conexi\u00f3n service_start_handle : mango de inicio del servicio service_end_handle : mango de fin del servicio char_handle : mango de caracter\u00edstica remote_bda : direcci\u00f3n del dispositivo remoto conectado a este cliente. En este ejemplo, hay un Perfil de Aplicaci\u00f3n y su ID se define como: #define PROFILE_NUM 1 #define PROFILE_A_APP_ID 0 Los Perfiles de Aplicaci\u00f3n se almacenan en el array gl_profile_tab , que se inicializa de la siguiente manera: /* Un perfil basado en GATT, un app_id y un gattc_if, este arreglo almacenar\u00e1 el gattc_if devuelto por ESP_GATTS_REG_EVT */ static struct gattc_profile_inst gl_profile_tab[PROFILE_NUM] = { [PROFILE_A_APP_ID] = {.gattc_cb = gattc_profile_event_handler, .gattc_if = ESP_GATT_IF_NONE, /* No se obtiene el gatt_if, por lo que se inicializa como ESP_GATT_IF_NONE */ }, }; La inicializaci\u00f3n del array de tablas de Perfiles de Aplicaci\u00f3n incluye la definici\u00f3n de la funci\u00f3n de devoluci\u00f3n de llamada para el Perfil. En este caso, es gattc_profile_event_handler() . Adem\u00e1s, la interfaz GATT se inicializa con el valor predeterminado de ESP_GATT_IF_NONE . M\u00e1s adelante, cuando se registre el Perfil de Aplicaci\u00f3n, la pila BLE devolver\u00e1 una instancia de interfaz GATT para usar con ese Perfil de Aplicaci\u00f3n. El registro del perfil desencadena un evento ESP_GATTC_REG_EVT , que es manejado por el manejador de eventos esp_gattc_cb() . El manejador toma la interfaz GATT devuelta por el evento y la almacena en la tabla de perfiles: static void esp_gattc_cb(esp_gattc_cb_event_t event, esp_gatt_if_t gattc_if, esp_ble_gattc_cb_param_t *param) { ESP_LOGI(GATTC_TAG, \"EVT %d, gattc if %d\", event, gattc_if); /* Si el evento es un evento de registro, almacena el gattc_if para cada perfil */ if (event == ESP_GATTC_REG_EVT) { if (param->reg.status == ESP_GATT_OK) { gl_profile_tab[param->reg.app_id].gattc_if = gattc_if; } else { ESP_LOGI(GATTC_TAG, \"registro de aplicaci\u00f3n fallido, app_id %04x, estado %d\", param->reg.app_id, param->reg.status); return; } } \u2026 Finalmente, la funci\u00f3n de devoluci\u00f3n de llamada invoca el manejador de eventos correspondiente para cada perfil en la tabla gl_profile_tab . \u2026 /* Si gattc_if es igual al perfil A, llamar al manejador de cb del perfil A, * por lo tanto, aqu\u00ed llamar a la funci\u00f3n cb de cada perfil */ do { int idx; for (idx = 0; idx < PROFILE_NUM; idx++) { if (gattc_if == ESP_GATT_IF_NONE || /* ESP_GATT_IF_NONE, no especifica un cierto gatt_if, es necesario llamar a cada funci\u00f3n cb del perfil */ gattc_if == gl_profile_tab[idx].gattc_if) { if (gl_profile_tab[idx].gattc_cb) { gl_profile_tab[idx].gattc_cb(event, gattc_if, param); } } } } while (0); } Configuraci\u00f3n de Par\u00e1metros de Escaneo El cliente GATT normalmente escanea servidores cercanos y trata de conectarse a ellos si est\u00e1 interesado. Sin embargo, para realizar el escaneo, primero es necesario configurar los par\u00e1metros de configuraci\u00f3n. Esto se hace despu\u00e9s del registro de los Perfiles de Aplicaci\u00f3n, porque una vez completado el registro, desencadena un evento ESP_GATTC_REG_EVT . La primera vez que se desencadena este evento, el manejador de eventos GATT lo captura y asigna una interfaz GATT al Perfil A. Luego, el evento se reenv\u00eda al manejador de eventos GATT del Perfil A. En este manejador de eventos, el evento se utiliza para llamar a la funci\u00f3n esp_ble_gap_set_scan_params() , que toma una instancia de estructura ble_scan_params como par\u00e1metro. Esta estructura se define como: /// Par\u00e1metros de escaneo BLE typedef struct { esp_ble_scan_type_t scan_type; /*!< Tipo de escaneo */ esp_ble_addr_type_t own_addr_type; /*!< Tipo de direcci\u00f3n propia */ esp_ble_scan_filter_t scan_filter_policy; /*!< Pol\u00edtica de filtro de escaneo */ uint16_t scan_interval; /*!< Intervalo de escaneo. Se define como el intervalo de tiempo desde que el controlador comenz\u00f3 su \u00faltimo escaneo LE hasta que comienza el siguiente escaneo LE.*/ //Rango: 0x0004 to 0x4000 //Predeterminado: 0x0010 (10 ms) //Tiempo = N * 0.625 ms //Rango de tiempo: 2.5 ms a 10.24 segundos uint16_t scan_window; /*!< Ventana de escaneo. La duraci\u00f3n del escaneo LE. LE_Scan_Window debe ser menor o igual que LE_Scan_Interval*/ //Rango: 0x0004 to 0x4000 //Predeterminado: 0x0010 (10 ms) //Tiempo = N * 0.625 ms //Rango de tiempo: 2.5 ms a 10240 ms } esp_ble_scan_params_t; Y se inicializa de la siguiente manera: static esp_ble_scan_params_t ble_scan_params = { .scan_type = BLE_SCAN_TYPE_ACTIVE, .own_addr_type = BLE_ADDR_TYPE_PUBLIC, .scan_filter_policy = BLE_SCAN_FILTER_ALLOW_ALL, .scan_interval = 0x50, .scan_window = 0x30 }; Los par\u00e1metros de escaneo BLE se configuran de manera que el tipo de escaneo sea activo (incluye la lectura de la respuesta de escaneo), es de tipo p\u00fablico, permite leer cualquier dispositivo anunciado y tiene un intervalo de escaneo de 100 ms (1.25 ms * 0x50) y una ventana de escaneo de 60 ms (1.25 ms * 0x30). Los valores de escaneo se establecen utilizando la funci\u00f3n esp_ble_gap_set_scan_params() : case ESP_GATTC_REG_EVT: ESP_LOGI(GATTC_TAG, \"REG_EVT\"); esp_err_t scan_ret = esp_ble_gap_set_scan_params(&ble_scan_params); if (scan_ret){ ESP_LOGE(GATTC_TAG, \"error al configurar par\u00e1metros de escaneo, c\u00f3digo de error = %x\", scan_ret); } break; Tarea B\u00e1sica Configura los par\u00e1metros de escaneo para que \u00e9ste se produzca con menos frecuencia (e.g. 1 segundo o un valor superior). Para ello, adapta el valor del campo scan_interval con el valor apropiado. Una vez que se establecen los par\u00e1metros de escaneo, se desencadena un evento ESP_GAP_BLE_SCAN_PARAM_SET_COMPLETE_EVT , que es manejado por el manejador de eventos GAP esp_gap_cb() . Este evento se utiliza para iniciar el escaneo de los servidores GATT cercanos: case ESP_GAP_BLE_SCAN_PARAM_SET_COMPLETE_EVT: { //la unidad de la duraci\u00f3n es en segundos uint32_t duration = 30; esp_ble_gap_start_scanning(duration); break; } Tarea B\u00e1sica El valor de duraci\u00f3n del proceso de escaneado es configurable. En esta primera parte de la pr\u00e1ctica, aum\u00e9ntalo para que el proceso sea m\u00e1s largo y as\u00ed tengas m\u00e1s tiempo para analizar la salidaproducida. Comprueba que efectivamente el tiempo en el que el dispositivo se encuentra en fase de escaneo es el seleccionado. Tarea Adicional Analiza el c\u00f3digo y modif\u00edcalo para que el proceso de escaneo se produzca c\u00edclicamente, con un par\u00e1metro de separaci\u00f3n entre fases de escaneado definido a trav\u00e9s de los men\u00fas de configuraci\u00f3. De la misma manera, a\u00f1ade a dichos men\u00fas un par\u00e1metro adicional que indique el inervalo entre eventos de escaneo. El escaneo se inicia mediante la funci\u00f3n esp_ble_gap_start_scanning() , que toma un par\u00e1metro que representa la duraci\u00f3n del escaneo continuo (en segundos). Una vez que finaliza el per\u00edodo de escaneo, se desencadena un evento ESP_GAP_SEARCH_INQ_CMPL_EVT . Los resultados del escaneo se muestran tan pronto como llegan con el evento ESP_GAP_BLE_SCAN_RESULT_EVT , que incluye los siguientes par\u00e1metros: /** * @brief ESP_GAP_BLE_SCAN_RESULT_EVT */ struct ble_scan_result_evt_param { esp_gap_search_evt_t search_evt; /*!< Tipo de evento de b\u00fasqueda */ esp_bd_addr_t bda; /*!< Direcci\u00f3n del dispositivo Bluetooth que ha sido buscado */ esp_bt_dev_type_t dev_type; /*!< Tipo de dispositivo */ esp_ble_addr_type_t ble_addr_type; /*!< Tipo de direcci\u00f3n del dispositivo BLE */ esp_ble_evt_type_t ble_evt_type; /*!< Tipo de evento de resultado de escaneo BLE */ int rssi; /*!< RSSI del dispositivo buscado */ uint8_t ble_adv[ESP_BLE_ADV_DATA_LEN_MAX + ESP_BLE_SCAN_RSP_DATA_LEN_MAX]; /*!< EIR recibido */ int flag; /*!< Bit de indicaci\u00f3n de datos de publicidad */ int num_resps; /*!< N\u00famero de resultados de escaneo */ uint8_t adv_data_len; /*!< Longitud de datos de publicidad */ uint8_t scan_rsp_len; /*!< Longitud de respuesta de escaneo */ } scan_rst; /*!< Par\u00e1metro de evento de ESP_GAP_BLE_SCAN_RESULT_EVT */ Este evento tambi\u00e9n incluye una lista de subeventos, como se muestra a continuaci\u00f3n: /// Sub Evento de ESP_GAP_BLE_SCAN_RESULT_EVT typedef enum { ESP_GAP_SEARCH_INQ_RES_EVT = 0, /*!< Resultado de la investigaci\u00f3n para un dispositivo par. */ ESP_GAP_SEARCH_INQ_CMPL_EVT = 1, /*!< B\u00fasqueda completa. */ ESP_GAP_SEARCH_DISC_RES_EVT = 2, /*!< Resultado del descubrimiento para un dispositivo par. */ ESP_GAP_SEARCH_DISC_BLE_RES_EVT = 3, /*!< Resultado del descubrimiento para servicio basado en BLE GATT en un dispositivo par. */ ESP_GAP_SEARCH_DISC_CMPL_EVT = 4, /*!< Descubrimiento completo. */ ESP_GAP_SEARCH_DI_DISC_CMPL_EVT = 5, /*!< Descubrimiento completo. */ ESP_GAP_SEARCH_SEARCH_CANCEL_CMPL_EVT = 6, /*!< B\u00fasqueda cancelada */ } esp_gap_search_evt_t; Nos interesa el evento ESP_GAP_SEARCH_INQ_RES_EVT , que se llama cada vez que se encuentra un nuevo dispositivo. Tambi\u00e9n nos interesa el evento ESP_GAP_SEARCH_INQ_CMPL_EVT , que se desencadena cuando se completa la duraci\u00f3n del escaneo y se puede utilizar para reiniciar el procedimiento de escaneo: case ESP_GAP_BLE_SCAN_RESULT_EVT: { esp_ble_gap_cb_param_t *scan_result = (esp_ble_gap_cb_param_t *)param; switch (scan_result->scan_rst.search_evt) { case ESP_GAP_SEARCH_INQ_RES_EVT: esp_log_buffer_hex(GATTC_TAG, scan_result->scan_rst.bda, 6); ESP_LOGI(GATTC_TAG, \"Longitud de datos de publicidad buscada %d, Longitud de respuesta de escaneo %d\", scan_result->scan_rst.adv_data_len, scan_result->scan_rst.scan_rsp_len); adv_name = esp_ble_resolve_adv_data(scan_result->scan_rst.ble_adv, ESP_BLE_AD_TYPE_NAME_CMPL, &adv_name_len); ESP_LOGI(GATTC_TAG, \"Longitud del nombre del dispositivo buscado %d\", adv_name_len); esp_log_buffer_char(GATTC_TAG, adv_name, adv_name_len); ESP_LOGI(GATTC_TAG, \" \"); if (adv_name != NULL) { if (strlen(remote_device_name) == adv_name_len && strncmp((char *)adv_name, remote_device_name, adv_name_len) == 0) { ESP_LOGI(GATTC_TAG, \"dispositivo buscado %s\", remote_device_name); if (connect == false) { connect = true; ESP_LOGI(GATTC_TAG, \"conectar al dispositivo remoto.\"); esp_ble_gap_stop_scanning(); esp_ble_gattc_open(gl_profile_tab[PROFILE_A_APP_ID].gattc_if, scan_result->scan_rst.bda, scan_result->scan_rst.ble_addr_type, true); } } } break; Primero, se resuelve el nombre del dispositivo y se compara con el nombre del dispositivo del servidor GATT en el que estamos interesados. Si coincide con el nombre del dispositivo del servidor GATT que estamos buscando, se detiene el escaneo. Cada vez que recibimos un resultado del evento ESP_GAP_SEARCH_INQ_RES_EVT , el c\u00f3digo primero imprime la direcci\u00f3n del dispositivo remoto: case ESP_GAP_SEARCH_INQ_RES_EVT: esp_log_buffer_hex(GATTC_TAG, scan_result->scan_rst.bda, 6); Luego, el cliente imprime la longitud de los datos anunciados y la longitud de la respuesta de escaneo: ESP_LOGI(GATTC_TAG, \"searched Adv Data Len %d, Scan Response Len %d\", scan_result->scan_rst.adv_data_len, scan_result->scan_rst.scan_rsp_len); Para obtener el nombre del dispositivo, utilizamos la funci\u00f3n esp_ble_resolve_adv_data() , que toma los datos anunciados almacenados en scan_result->scan_rst.ble_adv , el tipo de datos anunciados y la longitud, para extraer el valor del paquete publicitario. Luego, se imprime el nombre del dispositivo. adv_name = esp_ble_resolve_adv_data(scan_result->scan_rst.ble_adv, ESP_BLE_AD_TYPE_NAME_CMPL, &adv_name_len); ESP_LOGI(GATTC_TAG, \"searched Device Name Len %d\", adv_name_len); esp_log_buffer_char(GATTC_TAG, adv_name, adv_name_len); Tarea b\u00e1sica Muestra por pantalla el valor de RSSI de cada dispositivo BLE encontrado. Para ello, busca en la estructura de par\u00e1metros recibidos el campo correspondiente. Tarea b\u00e1sica A\u00f1ade a los men\u00fas de configuraci\u00f3n un campo que indique la direcci\u00f3n MAC BLE de un dispositivo (conocido) que est\u00e9 en fase de anuncio. Puedes utilizar los c\u00f3digos de servidor de la pr\u00e1ctica anterior. Tarea b\u00e1sica Modifica la fase de escaneado para que \u00fanicamente se muestre informaci\u00f3n (al menos nombre y RSSI) sobre el dispositivo cuya direcci\u00f3n MAC se haya configurado. Tarea b\u00e1sica Modifica el firmware b\u00e1sico para que, en funci\u00f3n del valor de RSSI obtenido para el dispositivo de inter\u00e9s, el cliente reporte con m\u00e1s o menos frecuencia por pantalla un valor proporcional a la distancia supuesta para dicho dispositivo. Si dispones de un LED conectado a la placa, puedes hacer que la frecuencia de parpadeo del mismo sea proporcional a dicha distancia. Tarea previa A partir de este punto puedes volver a fijar el nombre del dispositivo remoto de inter\u00e9s en funci\u00f3n del nombre otorgado en el servidor GATT. Finalmente, si el nombre del dispositivo remoto es el mismo que hemos definido anteriormente, el dispositivo local detiene el escaneo y trata de abrir una conexi\u00f3n con el dispositivo remoto utilizando la funci\u00f3n esp_ble_gattc_open() . Esta funci\u00f3n toma como par\u00e1metros la interfaz GATT del Perfil de Aplicaci\u00f3n, la direcci\u00f3n del servidor remoto y un valor booleano. El valor booleano se utiliza para indicar si la conexi\u00f3n se realiza directamente o en segundo plano (autoconexi\u00f3n). En este momento, este valor booleano debe establecerse en verdadero para establecer la conexi\u00f3n. Ten en cuenta que el cliente abre una conexi\u00f3n virtual con el servidor. La conexi\u00f3n virtual devuelve un ID de conexi\u00f3n. La conexi\u00f3n virtual es la conexi\u00f3n entre el Perfil de Aplicaci\u00f3n y el servidor remoto. Dado que muchos Perfiles de Aplicaci\u00f3n pueden ejecutarse en un ESP32, podr\u00eda haber muchas conexiones virtuales abiertas al mismo servidor remoto. Tambi\u00e9n est\u00e1 la conexi\u00f3n f\u00edsica, que es el enlace BLE real entre el cliente y el servidor. Por lo tanto, si la conexi\u00f3n f\u00edsica se desconecta con la funci\u00f3n esp_ble_gap_disconnect() , se cierran todas las dem\u00e1s conexiones virtuales. En este ejemplo, cada Perfil de Aplicaci\u00f3n crea una conexi\u00f3n virtual al mismo servidor con la funci\u00f3n esp_ble_gattc_open() , por lo que cuando se llama a la funci\u00f3n de cierre, solo se cierra esa conexi\u00f3n del Perfil de Aplicaci\u00f3n, mientras que si se llama a la funci\u00f3n de desconexi\u00f3n GAP, se cerrar\u00e1n ambas conexiones. Adem\u00e1s, los eventos de conexi\u00f3n se propagan a todos los perfiles porque se relacionan con la conexi\u00f3n f\u00edsica, mientras que los eventos de apertura se propagan solo al perfil que crea la conexi\u00f3n virtual. Configuraci\u00f3n del Tama\u00f1o de MTU El ATT_MTU se define como el tama\u00f1o m\u00e1ximo de cualquier paquete enviado entre un cliente y un servidor. Cuando el cliente se conecta al servidor, informa al servidor qu\u00e9 tama\u00f1o de MTU usar intercambiando unidades de datos de protocolo de solicitud y respuesta de MTU (PDUs). Esto se hace despu\u00e9s de abrir la conexi\u00f3n. Despu\u00e9s de abrir la conexi\u00f3n, se desencadena un evento ESP_GATTC_CONNECT_EVT : case ESP_GATTC_CONNECT_EVT: //p_data->connect.status siempre ser\u00e1 ESP_GATT_OK ESP_LOGI(GATTC_TAG, \"ESP_GATTC_CONNECT_EVT conn_id %d, if %d, status %d\", conn_id, gattc_if, p_data->connect.status); conn_id = p_data->connect.conn_id; gl_profile_tab[PROFILE_A_APP_ID].conn_id = p_data->connect.conn_id; memcpy(gl_profile_tab[PROFILE_A_APP_ID].remote_bda, p_data->connect.remote_bda, sizeof(esp_bd_addr_t)); ESP_LOGI(GATTC_TAG, \"BDA REMOTO:\"); esp_log_buffer_hex(GATTC_TAG, gl_profile_tab[PROFILE_A_APP_ID].remote_bda, sizeof(esp_bd_addr_t)); esp_err_t mtu_ret = esp_ble_gattc_send_mtu_req (gattc_if, conn_id); if (mtu_ret){ ESP_LOGE(GATTC_TAG, \"error de configuraci\u00f3n de MTU, c\u00f3digo de error = %x\", mtu_ret); } break; El ID de conexi\u00f3n y la direcci\u00f3n del dispositivo remoto (servidor) se almacenan en la tabla de Perfiles de la Aplicaci\u00f3n y se imprimen en la consola: conn_id = p_data->connect.conn_id; gl_profile_tab[PROFILE_A_APP_ID].conn_id = p_data->connect.conn_id; memcpy(gl_profile_tab[PROFILE_A_APP_ID].remote_bda, p_data->connect.remote_bda, sizeof(esp_bd_addr_t)); ESP_LOGI(GATTC_TAG, \"BDA REMOTO:\"); esp_log_buffer_hex(GATTC_TAG, gl_profile_tab[PROFILE_A_APP_ID].remote_bda, sizeof(esp_bd_addr_t)); El tama\u00f1o t\u00edpico del MTU para una conexi\u00f3n Bluetooth 4.0 es de 23 bytes. Un cliente puede cambiar el tama\u00f1o del MTU utilizando la funci\u00f3n esp_ble_gattc_send_mtu_req() , que toma la interfaz GATT y el ID de conexi\u00f3n. El tama\u00f1o del MTU solicitado se define mediante esp_ble_gatt_set_local_mtu() . Luego, el servidor puede aceptar o rechazar la solicitud. El ESP32 admite un tama\u00f1o de MTU de hasta 517 bytes, que se define en ESP_GATT_MAX_MTU_SIZE en esp_gattc_api.h . En este ejemplo, el tama\u00f1o del MTU se establece en 500 bytes. En caso de que la configuraci\u00f3n falle, se imprime el error devuelto: esp_err_t mtu_ret = esp_ble_gattc_send_mtu_req (gattc_if, conn_id); if (mtu_ret){ ESP_LOGE(GATTC_TAG, \"error de configuraci\u00f3n de MTU, c\u00f3digo de error = %x\", mtu_ret); } break; La apertura de la conexi\u00f3n tambi\u00e9n desencadena un evento ESP_GATTC_OPEN_EVT , que se utiliza para comprobar si la apertura de la conexi\u00f3n se realiz\u00f3 con \u00e9xito; de lo contrario, se imprime un error y se sale del programa: case ESP_GATTC_OPEN_EVT: if (param->open.status != ESP_GATT_OK){ ESP_LOGE(GATTC_TAG, \"apertura fallida, estado %d\", p_data->open.status); break; } ESP_LOGI(GATTC_TAG, \"apertura exitosa\"); Cuando se intercambia el MTU, se desencadena un evento ESP_GATTC_CFG_MTU_EVT , que en este ejemplo se utiliza para imprimir el nuevo tama\u00f1o del MTU: case ESP_GATTC_CFG_MTU_EVT: if (param->cfg_mtu.status != ESP_GATT_OK){ ESP_LOGE(GATTC_TAG,\"configuraci\u00f3n de MTU fallida, estado de error = %x\", param->cfg_mtu.status); } ESP_LOGI(GATTC_TAG, \"ESP_GATTC_CFG_MTU_EVT, Estado %d, MTU %d, ID de conexi\u00f3n %d\", param->cfg_mtu.status, param->cfg_mtu.mtu, param->cfg_mtu.conn_id); \u2026 La configuraci\u00f3n del MTU se utiliza tambi\u00e9n para comenzar a descubrir los servicios disponibles en el servidor al que se ha conectado el cliente. Para descubrir los servicios, se utiliza la funci\u00f3n esp_ble_gattc_search_service() . Los par\u00e1metros de la funci\u00f3n son la interfaz GATT, el ID de conexi\u00f3n del perfil de la aplicaci\u00f3n y el UUID de la aplicaci\u00f3n de servicio que interesa al cliente. El servicio que estamos buscando se define de la siguiente manera: static esp_bt_uuid_t remote_filter_service_uuid = { .len = ESP_UUID_LEN_16, .uuid = {.uuid16 = REMOTE_SERVICE_UUID,}, }; Donde, #define REMOTE_SERVICE_UUID 0x00FF Si el UUID de la aplicaci\u00f3n de servicio que interesa al usuario es de 128 bits, hay una nota relevante para el usuario que se relaciona con el modo de almacenamiento en \"little-endian\" de la arquitectura del procesador. La estructura del UUID se define de la siguiente manera: typedef struct { #define ESP_UUID_LEN_16 2 #define ESP_UUID_LEN_32 4 #define ESP_UUID_LEN_128 16 uint16_t len; /*!< Longitud del UUID, 16 bits, 32 bits o 128 bits */ union { uint16_t uuid16; /*!< UUID de 16 bits */ uint32_t uuid32; /*!< UUID de 32 bits */ uint8_t uuid128[ESP_UUID_LEN_128]; /*!< UUID de 128 bits */ } uuid; /*!< UUID */ } __attribute__((packed)) esp_bt_uuid_t; Nota: En el modo de almacenamiento en \"little-endian\", puedes definir directamente el UUID del servicio en el orden normal si es un UUID de 16 bits o 32 bits, pero si el UUID del servicio es de 128 bits, hay una peque\u00f1a diferencia. Por ejemplo, si el UUID de la aplicaci\u00f3n de servicio que le interesa al usuario es 12345678-a1b2-c3d4-e5f6-9fafd205e457, REMOTE_SERVICE_UUID deber\u00eda definirse como {0x57,0xE4,0x05,0xD2,0xAF,0x9F,0xF6,0xE5,0xD4,0xC3,0xB2,0xA1,0x78,0x56,0x34,0x12}. Los servicios se descubren de la siguiente manera: esp_ble_gattc_search_service(gattc_if, param->cfg_mtu.conn_id, &remote_filter_service_uuid); break; El servicio encontrado, si lo hay, se devolver\u00e1 desde un evento ESP_GATTC_SEARCH_RES_EVT . Para cada servicio encontrado, se desencadena un evento para imprimir informaci\u00f3n sobre el servicio descubierto, seg\u00fan el tama\u00f1o del UUID: case ESP_GATTC_SEARCH_RES_EVT: { esp_gatt_srvc_id_t *srvc_id = &p_data->search_res.srvc_id; conn_id = p_data->search_res.conn_id; Si el `len` del UUID en `srvc_id->id.uuid` es igual a `ESP_UUID_LEN_16` y `uuid16` coincide con `REMOTE_SERVICE_UUID`, se establece `get_server` en true. Luego, se almacena el valor de inicio (`start_handle`) y el valor de fin (`end_handle`) que se utilizar\u00e1n m\u00e1s adelante para obtener todas las caracter\u00edsticas de ese servicio. Finalmente, despu\u00e9s de que se devuelvan todos los resultados de los servicios, la b\u00fasqueda se completa y se desencadena un evento `ESP_GATTC_SEARCH_CMPL_EVT`. ESP_LOGI(GATTC_TAG, \"UUID16: %x\", srvc_id->id.uuid.uuid.uuid16); } break; En caso de que el cliente encuentre el servicio que busca, la bandera get_server se establece en true y se guardan los valores de inicio y fin que se utilizar\u00e1n posteriormente para obtener todas las caracter\u00edsticas de ese servicio. Una vez que se han devuelto todos los resultados de los servicios, se completa la b\u00fasqueda y se desencadena un evento ESP_GATTC_SEARCH_CMPL_EVT . Obteniendo Caracter\u00edsticas Este ejemplo implementa la obtenci\u00f3n de datos de caracter\u00edsticas de un servicio predefinido. El servicio del cual queremos obtener caracter\u00edsticas tiene un UUID de 0x00FF, y la caracter\u00edstica de inter\u00e9s tiene un UUID de 0xFF01: #define REMOTE_NOTIFY_CHAR_UUID 0xFF01 Un servicio se define utilizando la estructura esp_gatt_srvc_id_t de la siguiente manera: /** * @brief Gatt id, include uuid and instance id */ typedef struct { esp_bt_uuid_t uuid; /*!< UUID */ uint8_t inst_id; /*!< ID de instancia */ } __attribute__((packed)) esp_gatt_id_t; En este ejemplo, definimos el servicio del cual queremos obtener las caracter\u00edsticas de la siguiente manera: static esp_gatt_srvc_id_t remote_service_id = { .id = { .uuid = { .len = ESP_UUID_LEN_16, .uuid = {.uuid16 = REMOTE_SERVICE_UUID,}, }, .inst_id = 0, }, .is_primary = true, }; Una vez definido, podemos obtener las caracter\u00edsticas de ese servicio utilizando la funci\u00f3n esp_ble_gattc_get_characteristic() , la cual se llama en el evento ESP_GATTC_SEARCH_CMPL_EVT despu\u00e9s de que se haya completado la b\u00fasqueda de servicios y el cliente ha encontrado el servicio que estaba buscando. case ESP_GATTC_SEARCH_CMPL_EVT: if (p_data->search_cmpl.status != ESP_GATT_OK){ ESP_LOGE(GATTC_TAG, \"b\u00fasqueda de servicio fallida, estado de error = %x\", p_data->search_cmpl.status); break; } conn_id = p_data->search_cmpl.conn_id; if (get_server){ uint16_t count = 0; esp_gatt_status_t status = esp_ble_gattc_get_attr_count(gattc_if, p_data->search_cmpl.conn_id, ESP_GATT_DB_CHARACTERISTIC, gl_profile_tab[PROFILE_A_APP_ID].service_start_handle, gl_profile_tab[PROFILE_A_APP_ID].service_end_handle, INVALID_HANDLE, &count); if (status != ESP_GATT_OK){ ESP_LOGE(GATTC_TAG, \"esp_ble_gattc_get_attr_count error\"); } if (count > 0){ char_elem_result = (esp_gattc_char_elem_t*)malloc(sizeof(esp_gattc_char_elem_t) * count); if (!char_elem_result){ ESP_LOGE(GATTC_TAG, \"gattc sin memoria\"); }else{ status = esp_ble_gattc_get_char_by_uuid(gattc_if, p_data->search_cmpl.conn_id, gl_profile_tab[PROFILE_A_APP_ID].service_start_handle, gl_profile_tab[PROFILE_A_APP_ID].service_end_handle, remote_filter_char_uuid, char_elem_result, &count); if (status != ESP_GATT_OK){ ESP_LOGE(GATTC_TAG, \"esp_ble_gattc_get_char_by_uuid error\"); } /* Cada servicio tiene solo una caracter\u00edstica en nuestro demo 'ESP_GATTS_DEMO', por lo que usamos el primer 'char_elem_result' */ if (count > 0 && (char_elem_result[0].properties & ESP_GATT_CHAR_PROP_BIT_NOTIFY)){ gl_profile_tab[PROFILE_A_APP_ID].char_handle = char_elem_result[0].char_handle; esp_ble_gattc_register_for_notify(gattc_if, gl_profile_tab[PROFILE_A_APP_ID].remote_bda, char_elem_result[0].char_handle); } } /* Liberar char_elem_result */ free(char_elem_result); }else{ ESP_LOGE(GATTC_TAG, \"ninguna caracter\u00edstica encontrada\"); } } break; esp_ble_gattc_get_attr_count() obtiene el n\u00famero de atributos con el tipo de atributo dado en la cach\u00e9 GATT. Los par\u00e1metros de la funci\u00f3n esp_ble_gattc_get_attr_count() son la interfaz GATT, el ID de conexi\u00f3n, el tipo de atributo definido en esp_gatt_db_attr_type_t , el valor de inicio del atributo, el valor final del atributo, el identificador de la caracter\u00edstica (este par\u00e1metro solo es v\u00e1lido cuando el tipo se establece en ESP_GATT_DB_DESCRIPTOR ) y la salida del n\u00famero de atributos encontrados en la cach\u00e9 GATT con el tipo de atributo dado. Luego, se asigna un b\u00fafer para guardar la informaci\u00f3n de la caracter\u00edstica para la funci\u00f3n esp_ble_gattc_get_char_by_uuid() . Esta funci\u00f3n busca la caracter\u00edstica con el UUID de caracter\u00edstica dado en la cach\u00e9 GATT. Simplemente obtiene la caracter\u00edstica de la cach\u00e9 local, en lugar de los dispositivos remotos. En un servidor, puede haber m\u00e1s de una caracter\u00edstica con el mismo UUID. Sin embargo, en nuestro ejemplo de gatt_server, cada caracter\u00edstica tiene un UUID \u00fanico y es por eso que solo usamos la primera caracter\u00edstica en char_elem_result , que es el puntero a la caracter\u00edstica del servicio. El contador inicialmente almacena la cantidad de caracter\u00edsticas que el cliente desea encontrar y se actualizar\u00e1 con la cantidad de caracter\u00edsticas que se han encontrado en la cach\u00e9 GATT con esp_ble_gattc_get_char_by_uuid . Registro para Notificaciones El cliente puede registrarse para recibir notificaciones del servidor cada vez que cambia el valor de la caracter\u00edstica. En este ejemplo, queremos registrarnos para recibir notificaciones de la caracter\u00edstica identificada con un UUID de 0xff01. Despu\u00e9s de obtener todas las caracter\u00edsticas, verificamos las propiedades de la caracter\u00edstica recibida y luego utilizamos la funci\u00f3n esp_ble_gattc_register_for_notify() para registrarnos para notificaciones. Los argumentos de la funci\u00f3n son la interfaz GATT, la direcci\u00f3n del servidor remoto y el identificador del que queremos recibir notificaciones. ... /* Cada servicio tiene solo una caracter\u00edstica en nuestra demostraci\u00f3n 'ESP_GATTS_DEMO', por lo que usamos primero 'char_elem_result' */ if (count > 0 && (char_elem_result[0].properties & ESP_GATT_CHAR_PROP_BIT_NOTIFY)){ gl_profile_tab[PROFILE_A_APP_ID].char_handle = char_elem_result[0].char_handle; esp_ble_gattc_register_for_notify(gattc_if, gl_profile_tab[PROFILE_A_APP_ID].remote_bda, char_elem_result[0].char_handle); } ... Este procedimiento registra notificaciones en la pila BLE y desencadena un evento ESP_GATTC_REG_FOR_NOTIFY_EVT . Este evento se utiliza para escribir en el Descriptor de Configuraci\u00f3n del Cliente del servidor: case ESP_GATTC_REG_FOR_NOTIFY_EVT: { ESP_LOGI(GATTC_TAG, \"ESP_GATTC_REG_FOR_NOTIFY_EVT\"); if (p_data->reg_for_notify.status != ESP_GATT_OK){ ESP_LOGE(GATTC_TAG, \"REG FOR NOTIFY fall\u00f3: estado de error = %d\", p_data->reg_for_notify.status); }else{ uint16_t count = 0; uint16_t notify_en = 1; esp_gatt_status_t ret_status = esp_ble_gattc_get_attr_count( gattc_if, gl_profile_tab[PROFILE_A_APP_ID].conn_id, ESP_GATT_DB_DESCRIPTOR, gl_profile_tab[PROFILE_A_APP_ID].service_start_handle, gl_profile_tab[PROFILE_A_APP_ID].service_end_handle, gl_profile_tab[PROFILE_A_APP_ID].char_handle, &count); if (ret_status != ESP_GATT_OK){ ESP_LOGE(GATTC_TAG, \"esp_ble_gattc_get_attr_count error\"); } if (count > 0){ descr_elem_result = malloc(sizeof(esp_gattc_descr_elem_t) * count); if (!descr_elem_result){ ESP_LOGE(GATTC_TAG, \"error de asignaci\u00f3n de memoria, gattc sin memoria\"); }else{ ret_status = esp_ble_gattc_get_descr_by_char_handle( gattc_if, gl_profile_tab[PROFILE_A_APP_ID].conn_id, p_data->reg_for_notify.handle, notify_descr_uuid, descr_elem_result,&count); if (ret_status != ESP_GATT_OK){ ESP_LOGE(GATTC_TAG, \"esp_ble_gattc_get_descr_by_char_handle error\"); } /* Cada caracter\u00edstica tiene solo un descriptor en nuestra demostraci\u00f3n 'ESP_GATTS_DEMO', por lo que usamos primero 'descr_elem_result' */ if (count > 0 && descr_elem_result[0].uuid.len == ESP_UUID_LEN_16 && descr_elem_result[0].uuid.uuid.uuid16 == ESP_GATT_UUID_CHAR_CLIENT_CONFIG){ ret_status = esp_ble_gattc_write_char_descr( gattc_if, gl_profile_tab[PROFILE_A_APP_ID].conn_id, descr_elem_result[0].handle, sizeof(notify_en), (Uint8 *)&notify_en, ESP_GATT_WRITE_TYPE_RSP, ESP_GATT_AUTH_REQ_NONE); } if (ret_status != ESP_GATT_OK){ ESP_LOGE(GATTC_TAG, \"esp_ble_gattc_write_char_descr error\"); } /* Liberar descr_elem_result */ free(descr_elem_result); } } else{ ESP_LOGE(GATTC_TAG, \"descripci\u00f3n no encontrada\"); } } break; } El evento se utiliza primero para imprimir el estado del registro de notificaciones y los UUID del servicio y de la caracter\u00edstica que acaban de registrarse. Luego, el cliente escribe en el Descriptor de Configuraci\u00f3n del Cliente utilizando la funci\u00f3n esp_ble_gattc_write_char_descr() . Hay muchos descriptores de caracter\u00edsticas definidos en la especificaci\u00f3n de Bluetooth. Sin embargo, en este caso, nos interesa escribir en el descriptor que se encarga de habilitar las notificaciones, que es el descriptor de Configuraci\u00f3n del Cliente. Para pasar este descriptor como par\u00e1metro, primero lo definimos como: static esp_gatt_id_t notify_descr_id = { .uuid = { .len = ESP_UUID_LEN_16, .uuid = {.uuid16 = ESP_GATT_UUID_CHAR_CLIENT_CONFIG,}, }, .inst_id = 0, }; Donde ESP_GATT_UUID_CHAR_CLIENT_CONFIG se define con el UUID para identificar la Configuraci\u00f3n del Cliente de la Caracter\u00edstica: #define ESP_GATT_UUID_CHAR_CLIENT_CONFIG 0x2902 /* Configuraci\u00f3n del Cliente de Caracter\u00edsticas */ El valor a escribir es \"1\" para habilitar las notificaciones. Tambi\u00e9n pasamos ESP_GATT_WRITE_TYPE_RSP para solicitar que el servidor responda a la solicitud de habilitar las notificaciones y ESP_GATT_AUTH_REQ_NONE para indicar que la solicitud de escritura no requiere autorizaci\u00f3n. Tarea adicional Modifica el cliente para que las notificaciones enviadas por tu servidor GATT modificado en la pr\u00e1ctica anterior sean recibidas y monitorizadas por parte del cliente GATT.","title":"Pr\u00e1ctica 6"},{"location":"RPI-I/P6/#practica-6-bluetooth-low-energy-ble-cliente","text":"","title":"Pr\u00e1ctica 6. Bluetooth Low Energy (BLE). Cliente"},{"location":"RPI-I/P6/#objetivos","text":"Diseccionar en detalle un firmware de un cliente GATT utilizando la API de ESP-IDF. Aprender a realizar un escaneo de dispositivos BLE Conocer la informaci\u00f3n disponible en los anuncios BLE Gestionar la conexi\u00f3n desde un cliente BLE a un servidor (GATT) BLE","title":"Objetivos"},{"location":"RPI-I/P6/#implementacion-de-un-cliente-gatt-para-escaneo-y-conexion-a-servidor","text":"En esta pr\u00e1ctica, se revisa el c\u00f3digo de ejemplo para la construcci\u00f3n de un cliente GATT para el ESP32 utilizando ESP-IDF. El c\u00f3digo implementa un cliente de Atributo Gen\u00e9rico (GATT) de Bluetooth Low Energy (BLE), que escanea servidores perif\u00e9ricos cercanos y se conecta a un servicio predefinido. El cliente busca caracter\u00edsticas disponibles y se suscribe a una caracter\u00edstica conocida para recibir notificaciones o indicaciones. El ejemplo puede registrar un Perfil de Aplicaci\u00f3n e inicializa una secuencia de eventos que se pueden utilizar para configurar par\u00e1metros del Perfil de Acceso Gen\u00e9rico (GAP) y para manejar eventos como el escaneo, la conexi\u00f3n a perif\u00e9ricos y la lectura y escritura de caracter\u00edsticas. El desarrollo de esta pr\u00e1ctica requiere el uso de dos placas: una ejecutando el servidor GATT b\u00e1sico (o modificado) que usaste en la pr\u00e1ctica anterior, y otra ejecutando el c\u00f3digo cliente.","title":"Implementaci\u00f3n de un cliente GATT para escaneo y conexi\u00f3n a servidor"},{"location":"RPI-I/P6/#descripcion-del-codigo-de-ejemplo","text":"El ejemplo que seguiremos y adaptaremos se encuentra en la carpeta de ejemplos de ESP-IDF en bluetooth/bluedroid/ble/gatt_client/main . El archivo gattc_demo.c , ubicado en la carpeta principa, contiene todas las funcionalidades que vamos a revisar. Tarea previa Antes de comenzar, aseg\u00farate de que la variable remote_device_name (l\u00ednea 41) NO coincide con la de tu servidor GATT. Los archivos de encabezado contenidos en gattc_demo.c son:","title":"Descripci\u00f3n del c\u00f3digo de ejemplo"},{"location":"RPI-I/P6/#ficheros-de-cabecera","text":"Observa los ficheros de cabecera incluidos (similares a los que utilizaste en la pr\u00e1ctica anterior): #include <stdint.h> #include <string.h> #include <stdbool.h> #include <stdio.h> #include \"nvs.h\" #include \"nvs_flash.h\" #include \"controller.h\" #include \"bt.h\" #include \"esp_gap_ble_api.h\" #include \"esp_gattc_api.h\" #include \"esp_gatt_defs.h\" #include \"esp_bt_main.h\" #include \"esp_gatt_common_api.h\" Estos includes son necesarios para que funcionen los componentes del sistema subyacente y FreeRTOS, incluida la funcionalidad de registro y una biblioteca para almacenar datos en memoria flash no vol\u00e1til. Estamos interesados en \"bt.h\" , \"esp_bt_main.h\" , \"esp_gap_ble_api.h\" y \"esp_gattc_api.h\" , que exponen las API de BLE necesarias para implementar este ejemplo. bt.h : configura el controlador BT y VHCI desde el lado del host. esp_bt_main.h : inicializa y habilita la pila Bluedroid. esp_gap_ble_api.h : implementa la configuraci\u00f3n GAP, por ejemplo los anuncios de dispositivos y los par\u00e1metros de conexi\u00f3n. esp_gattc_api.h : implementa la configuraci\u00f3n del Cliente GATT, como la conexi\u00f3n a perif\u00e9ricos y la b\u00fasqueda de servicios.","title":"Ficheros de cabecera"},{"location":"RPI-I/P6/#punto-de-entrada-principal","text":"La funci\u00f3n de punto de entrada del programa es app_main() : void app_main() { // Inicializar NVS. esp_err_t ret = nvs_flash_init(); if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) { ESP_ERROR_CHECK(nvs_flash_erase()); ret = nvs_flash_init(); } ESP_ERROR_CHECK( ret ); esp_bt_controller_config_t bt_cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT(); ret = esp_bt_controller_init(&bt_cfg); if (ret) { ESP_LOGE(GATTC_TAG, \"%s inicializaci\u00f3n del controlador fallida, c\u00f3digo de error = %x\", __func__, ret); return; } ret = esp_bt_controller_enable(ESP_BT_MODE_BLE); if (ret) { ESP_LOGE(GATTC_TAG, \"%s habilitaci\u00f3n del controlador fallida, c\u00f3digo de error = %x\", __func__, ret); return; } esp_bluedroid_config_t bluedroid_cfg = BT_BLUEDROID_INIT_CONFIG_DEFAULT(); ret = esp_bluedroid_init_with_cfg(&bluedroid_cfg); if (ret) { ESP_LOGE(GATTC_TAG, \"%s inicializaci\u00f3n de Bluetooth fallida, c\u00f3digo de error = %x\", __func__, ret); return; } ret = esp_bluedroid_enable(); if (ret) { ESP_LOGE(GATTC_TAG, \"%s habilitaci\u00f3n de Bluetooth fallida, c\u00f3digo de error = %x\", __func__, ret); return; } // Registrar la funci\u00f3n de devoluci\u00f3n de llamada en el m\u00f3dulo GAP ret = esp_ble_gap_register_callback(esp_gap_cb); if (ret){ ESP_LOGE(GATTC_TAG, \"%s registro de GAP fallido, c\u00f3digo de error = %x\", __func__, ret); return; } // Registrar la funci\u00f3n de devoluci\u00f3n de llamada en el m\u00f3dulo GATTC ret = esp_ble_gattc_register_callback(esp_gattc_cb); if(ret){ ESP_LOGE(GATTC_TAG, \"%s registro de GATTC fallido, c\u00f3digo de error = %x\", __func__, ret); return; } ret = esp_ble_gattc_app_register(PROFILE_A_APP_ID); if (ret){ ESP_LOGE(GATTC_TAG, \"%s registro de la aplicaci\u00f3n GATTC fallido, c\u00f3digo de error = %x\", __func__, ret); } esp_err_t local_mtu_ret = esp_ble_gatt_set_local_mtu(500); if (local_mtu_ret){ ESP_LOGE(GATTC_TAG, \"configuraci\u00f3n del MTU local fallida, c\u00f3digo de error = %x\", local_mtu_ret); } } La funci\u00f3n principal comienza inicializando la biblioteca de almacenamiento no vol\u00e1til. Esta biblioteca permite guardar pares clave-valor en la memoria flash y se utiliza en algunos componentes, como la biblioteca Wi-Fi, para guardar el SSID y la contrase\u00f1a: esp_err_t ret = nvs_flash_init(); if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) { ESP_ERROR_CHECK(nvs_flash_erase()); ret = nvs_flash_init(); } ESP_ERROR_CHECK( ret );","title":"Punto de Entrada Principal"},{"location":"RPI-I/P6/#inicializacion-del-controlador-bluetooth-y-la-pila-ble","text":"La funci\u00f3n principal tambi\u00e9n inicializa el controlador BT al crear primero una estructura de configuraci\u00f3n del controlador BT llamada esp_bt_controller_config_t con ajustes predeterminados generados por la macro BT_CONTROLLER_INIT_CONFIG_DEFAULT() . El controlador BT implementa la Interfaz del Controlador Host (HCI) en el lado del controlador, la Capa de Enlace (LL) y la Capa F\u00edsica (PHY). El controlador BT es invisible para las aplicaciones de usuario y se encarga de las capas inferiores de la pila BLE. La configuraci\u00f3n del controlador incluye el tama\u00f1o de la pila del controlador BT, la prioridad y la velocidad de baudios HCI. Con la configuraci\u00f3n creada, se inicializa y habilita el controlador BT con la funci\u00f3n esp_bt_controller_init() : esp_bt_controller_config_t bt_cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT(); ret = esp_bt_controller_init(&bt_cfg); A continuaci\u00f3n, el controlador se habilita en el modo BLE. ret = esp_bt_controller_enable(ESP_BT_MODE_BLE); El controlador debe habilitarse en ESP_BT_MODE_BTDM si desea utilizar el modo dual (BLE + BT). Hay cuatro modos de Bluetooth admitidos: ESP_BT_MODE_IDLE : Bluetooth no se est\u00e1 ejecutando. ESP_BT_MODE_BLE : Modo BLE. ESP_BT_MODE_CLASSIC_BT : Modo BT cl\u00e1sico. ESP_BT_MODE_BTDM : Modo dual (BLE + BT cl\u00e1sico). Despu\u00e9s de la inicializaci\u00f3n del controlador BT, se inicializa y habilita la pila Bluedroid, que incluye las definiciones y API comunes tanto para BT cl\u00e1sico como para BLE. Esto se realiza mediante: esp_bluedroid_config_t bluedroid_cfg = BT_BLUEDROID_INIT_CONFIG_DEFAULT(); ret = esp_bluedroid_init_with_cfg(&bluedroid_cfg); ret = esp_bluedroid_enable(); La funci\u00f3n principal finaliza registrando los controladores de eventos GAP y GATT, as\u00ed como el Perfil de Aplicaci\u00f3n y configurando el tama\u00f1o m\u00e1ximo admitido de MTU. // Registrar la funci\u00f3n de devoluci\u00f3n de llamada en el m\u00f3dulo GAP ret = esp_ble_gap_register_callback(esp_gap_cb); // Registrar la funci\u00f3n de devoluci\u00f3n de llamada en el m\u00f3dulo GATTC ret = esp_ble_gattc_register_callback(esp_gattc_cb); ret = esp_ble_gattc_app_register(PROFILE_A_APP_ID); esp_err_t local_mtu_ret = esp_ble_gatt_set_local_mtu(500); if (local_mtu_ret){ ESP_LOGE(GATTC_TAG, \"configuraci\u00f3n del MTU local fallida, c\u00f3digo de error = %x\", local_mtu_ret); } Los controladores de eventos GAP y GATT son las funciones utilizadas para capturar los eventos generados por la pila BLE y ejecutar funciones para configurar los par\u00e1metros de la aplicaci\u00f3n. Adem\u00e1s, los controladores de eventos tambi\u00e9n se utilizan para manejar eventos de lectura y escritura que provienen del dispositivo central. El controlador de eventos GAP se encarga del escaneo y la conexi\u00f3n a servidores, y el controlador GATT administra los eventos que ocurren despu\u00e9s de que el cliente se haya conectado a un servidor, como la b\u00fasqueda de servicios y la escritura y lectura de datos. Los controladores de eventos GAP y GATT se registran mediante: esp_ble_gap_register_callback(); esp_ble_gattc_register_callback(); Las funciones esp_gap_cb() y esp_gattc_cb() manejan todos los eventos generados por la pila BLE.","title":"Inicializaci\u00f3n del Controlador Bluetooth y la Pila BLE"},{"location":"RPI-I/P6/#perfiles-de-aplicacion","text":"Los Perfiles de Aplicaci\u00f3n son una forma de agrupar funcionalidades dise\u00f1adas para una o m\u00e1s aplicaciones de servidor. Por ejemplo, puede tener un Perfil de Aplicaci\u00f3n conectado a sensores de ritmo card\u00edaco y otro conectado a sensores de temperatura. Cada Perfil de Aplicaci\u00f3n crea una interfaz GATT para conectarse a otros dispositivos. Las estructuras de Perfiles de Aplicaci\u00f3n en el c\u00f3digo son instancias de la estructura gattc_profile_inst , que se define como: struct gattc_profile_inst { esp_gattc_cb_t gattc_cb; uint16_t gattc_if; uint16_t app_id; uint16_t conn_id; uint16_t service_start_handle; uint16_t service_end_handle; uint16_t char_handle; esp_bd_addr_t remote_bda; }; La estructura de Perfil de Aplicaci\u00f3n contiene: gattc_cb : funci\u00f3n de devoluci\u00f3n de llamada del cliente GATT gattc_if : n\u00famero de interfaz del cliente GATT para este perfil app_id : n\u00famero de ID del Perfil de Aplicaci\u00f3n conn_id : ID de conexi\u00f3n service_start_handle : mango de inicio del servicio service_end_handle : mango de fin del servicio char_handle : mango de caracter\u00edstica remote_bda : direcci\u00f3n del dispositivo remoto conectado a este cliente. En este ejemplo, hay un Perfil de Aplicaci\u00f3n y su ID se define como: #define PROFILE_NUM 1 #define PROFILE_A_APP_ID 0 Los Perfiles de Aplicaci\u00f3n se almacenan en el array gl_profile_tab , que se inicializa de la siguiente manera: /* Un perfil basado en GATT, un app_id y un gattc_if, este arreglo almacenar\u00e1 el gattc_if devuelto por ESP_GATTS_REG_EVT */ static struct gattc_profile_inst gl_profile_tab[PROFILE_NUM] = { [PROFILE_A_APP_ID] = {.gattc_cb = gattc_profile_event_handler, .gattc_if = ESP_GATT_IF_NONE, /* No se obtiene el gatt_if, por lo que se inicializa como ESP_GATT_IF_NONE */ }, }; La inicializaci\u00f3n del array de tablas de Perfiles de Aplicaci\u00f3n incluye la definici\u00f3n de la funci\u00f3n de devoluci\u00f3n de llamada para el Perfil. En este caso, es gattc_profile_event_handler() . Adem\u00e1s, la interfaz GATT se inicializa con el valor predeterminado de ESP_GATT_IF_NONE . M\u00e1s adelante, cuando se registre el Perfil de Aplicaci\u00f3n, la pila BLE devolver\u00e1 una instancia de interfaz GATT para usar con ese Perfil de Aplicaci\u00f3n. El registro del perfil desencadena un evento ESP_GATTC_REG_EVT , que es manejado por el manejador de eventos esp_gattc_cb() . El manejador toma la interfaz GATT devuelta por el evento y la almacena en la tabla de perfiles: static void esp_gattc_cb(esp_gattc_cb_event_t event, esp_gatt_if_t gattc_if, esp_ble_gattc_cb_param_t *param) { ESP_LOGI(GATTC_TAG, \"EVT %d, gattc if %d\", event, gattc_if); /* Si el evento es un evento de registro, almacena el gattc_if para cada perfil */ if (event == ESP_GATTC_REG_EVT) { if (param->reg.status == ESP_GATT_OK) { gl_profile_tab[param->reg.app_id].gattc_if = gattc_if; } else { ESP_LOGI(GATTC_TAG, \"registro de aplicaci\u00f3n fallido, app_id %04x, estado %d\", param->reg.app_id, param->reg.status); return; } } \u2026 Finalmente, la funci\u00f3n de devoluci\u00f3n de llamada invoca el manejador de eventos correspondiente para cada perfil en la tabla gl_profile_tab . \u2026 /* Si gattc_if es igual al perfil A, llamar al manejador de cb del perfil A, * por lo tanto, aqu\u00ed llamar a la funci\u00f3n cb de cada perfil */ do { int idx; for (idx = 0; idx < PROFILE_NUM; idx++) { if (gattc_if == ESP_GATT_IF_NONE || /* ESP_GATT_IF_NONE, no especifica un cierto gatt_if, es necesario llamar a cada funci\u00f3n cb del perfil */ gattc_if == gl_profile_tab[idx].gattc_if) { if (gl_profile_tab[idx].gattc_cb) { gl_profile_tab[idx].gattc_cb(event, gattc_if, param); } } } } while (0); }","title":"Perfiles de Aplicaci\u00f3n"},{"location":"RPI-I/P6/#configuracion-de-parametros-de-escaneo","text":"El cliente GATT normalmente escanea servidores cercanos y trata de conectarse a ellos si est\u00e1 interesado. Sin embargo, para realizar el escaneo, primero es necesario configurar los par\u00e1metros de configuraci\u00f3n. Esto se hace despu\u00e9s del registro de los Perfiles de Aplicaci\u00f3n, porque una vez completado el registro, desencadena un evento ESP_GATTC_REG_EVT . La primera vez que se desencadena este evento, el manejador de eventos GATT lo captura y asigna una interfaz GATT al Perfil A. Luego, el evento se reenv\u00eda al manejador de eventos GATT del Perfil A. En este manejador de eventos, el evento se utiliza para llamar a la funci\u00f3n esp_ble_gap_set_scan_params() , que toma una instancia de estructura ble_scan_params como par\u00e1metro. Esta estructura se define como: /// Par\u00e1metros de escaneo BLE typedef struct { esp_ble_scan_type_t scan_type; /*!< Tipo de escaneo */ esp_ble_addr_type_t own_addr_type; /*!< Tipo de direcci\u00f3n propia */ esp_ble_scan_filter_t scan_filter_policy; /*!< Pol\u00edtica de filtro de escaneo */ uint16_t scan_interval; /*!< Intervalo de escaneo. Se define como el intervalo de tiempo desde que el controlador comenz\u00f3 su \u00faltimo escaneo LE hasta que comienza el siguiente escaneo LE.*/ //Rango: 0x0004 to 0x4000 //Predeterminado: 0x0010 (10 ms) //Tiempo = N * 0.625 ms //Rango de tiempo: 2.5 ms a 10.24 segundos uint16_t scan_window; /*!< Ventana de escaneo. La duraci\u00f3n del escaneo LE. LE_Scan_Window debe ser menor o igual que LE_Scan_Interval*/ //Rango: 0x0004 to 0x4000 //Predeterminado: 0x0010 (10 ms) //Tiempo = N * 0.625 ms //Rango de tiempo: 2.5 ms a 10240 ms } esp_ble_scan_params_t; Y se inicializa de la siguiente manera: static esp_ble_scan_params_t ble_scan_params = { .scan_type = BLE_SCAN_TYPE_ACTIVE, .own_addr_type = BLE_ADDR_TYPE_PUBLIC, .scan_filter_policy = BLE_SCAN_FILTER_ALLOW_ALL, .scan_interval = 0x50, .scan_window = 0x30 }; Los par\u00e1metros de escaneo BLE se configuran de manera que el tipo de escaneo sea activo (incluye la lectura de la respuesta de escaneo), es de tipo p\u00fablico, permite leer cualquier dispositivo anunciado y tiene un intervalo de escaneo de 100 ms (1.25 ms * 0x50) y una ventana de escaneo de 60 ms (1.25 ms * 0x30). Los valores de escaneo se establecen utilizando la funci\u00f3n esp_ble_gap_set_scan_params() : case ESP_GATTC_REG_EVT: ESP_LOGI(GATTC_TAG, \"REG_EVT\"); esp_err_t scan_ret = esp_ble_gap_set_scan_params(&ble_scan_params); if (scan_ret){ ESP_LOGE(GATTC_TAG, \"error al configurar par\u00e1metros de escaneo, c\u00f3digo de error = %x\", scan_ret); } break; Tarea B\u00e1sica Configura los par\u00e1metros de escaneo para que \u00e9ste se produzca con menos frecuencia (e.g. 1 segundo o un valor superior). Para ello, adapta el valor del campo scan_interval con el valor apropiado. Una vez que se establecen los par\u00e1metros de escaneo, se desencadena un evento ESP_GAP_BLE_SCAN_PARAM_SET_COMPLETE_EVT , que es manejado por el manejador de eventos GAP esp_gap_cb() . Este evento se utiliza para iniciar el escaneo de los servidores GATT cercanos: case ESP_GAP_BLE_SCAN_PARAM_SET_COMPLETE_EVT: { //la unidad de la duraci\u00f3n es en segundos uint32_t duration = 30; esp_ble_gap_start_scanning(duration); break; } Tarea B\u00e1sica El valor de duraci\u00f3n del proceso de escaneado es configurable. En esta primera parte de la pr\u00e1ctica, aum\u00e9ntalo para que el proceso sea m\u00e1s largo y as\u00ed tengas m\u00e1s tiempo para analizar la salidaproducida. Comprueba que efectivamente el tiempo en el que el dispositivo se encuentra en fase de escaneo es el seleccionado. Tarea Adicional Analiza el c\u00f3digo y modif\u00edcalo para que el proceso de escaneo se produzca c\u00edclicamente, con un par\u00e1metro de separaci\u00f3n entre fases de escaneado definido a trav\u00e9s de los men\u00fas de configuraci\u00f3. De la misma manera, a\u00f1ade a dichos men\u00fas un par\u00e1metro adicional que indique el inervalo entre eventos de escaneo. El escaneo se inicia mediante la funci\u00f3n esp_ble_gap_start_scanning() , que toma un par\u00e1metro que representa la duraci\u00f3n del escaneo continuo (en segundos). Una vez que finaliza el per\u00edodo de escaneo, se desencadena un evento ESP_GAP_SEARCH_INQ_CMPL_EVT . Los resultados del escaneo se muestran tan pronto como llegan con el evento ESP_GAP_BLE_SCAN_RESULT_EVT , que incluye los siguientes par\u00e1metros: /** * @brief ESP_GAP_BLE_SCAN_RESULT_EVT */ struct ble_scan_result_evt_param { esp_gap_search_evt_t search_evt; /*!< Tipo de evento de b\u00fasqueda */ esp_bd_addr_t bda; /*!< Direcci\u00f3n del dispositivo Bluetooth que ha sido buscado */ esp_bt_dev_type_t dev_type; /*!< Tipo de dispositivo */ esp_ble_addr_type_t ble_addr_type; /*!< Tipo de direcci\u00f3n del dispositivo BLE */ esp_ble_evt_type_t ble_evt_type; /*!< Tipo de evento de resultado de escaneo BLE */ int rssi; /*!< RSSI del dispositivo buscado */ uint8_t ble_adv[ESP_BLE_ADV_DATA_LEN_MAX + ESP_BLE_SCAN_RSP_DATA_LEN_MAX]; /*!< EIR recibido */ int flag; /*!< Bit de indicaci\u00f3n de datos de publicidad */ int num_resps; /*!< N\u00famero de resultados de escaneo */ uint8_t adv_data_len; /*!< Longitud de datos de publicidad */ uint8_t scan_rsp_len; /*!< Longitud de respuesta de escaneo */ } scan_rst; /*!< Par\u00e1metro de evento de ESP_GAP_BLE_SCAN_RESULT_EVT */ Este evento tambi\u00e9n incluye una lista de subeventos, como se muestra a continuaci\u00f3n: /// Sub Evento de ESP_GAP_BLE_SCAN_RESULT_EVT typedef enum { ESP_GAP_SEARCH_INQ_RES_EVT = 0, /*!< Resultado de la investigaci\u00f3n para un dispositivo par. */ ESP_GAP_SEARCH_INQ_CMPL_EVT = 1, /*!< B\u00fasqueda completa. */ ESP_GAP_SEARCH_DISC_RES_EVT = 2, /*!< Resultado del descubrimiento para un dispositivo par. */ ESP_GAP_SEARCH_DISC_BLE_RES_EVT = 3, /*!< Resultado del descubrimiento para servicio basado en BLE GATT en un dispositivo par. */ ESP_GAP_SEARCH_DISC_CMPL_EVT = 4, /*!< Descubrimiento completo. */ ESP_GAP_SEARCH_DI_DISC_CMPL_EVT = 5, /*!< Descubrimiento completo. */ ESP_GAP_SEARCH_SEARCH_CANCEL_CMPL_EVT = 6, /*!< B\u00fasqueda cancelada */ } esp_gap_search_evt_t; Nos interesa el evento ESP_GAP_SEARCH_INQ_RES_EVT , que se llama cada vez que se encuentra un nuevo dispositivo. Tambi\u00e9n nos interesa el evento ESP_GAP_SEARCH_INQ_CMPL_EVT , que se desencadena cuando se completa la duraci\u00f3n del escaneo y se puede utilizar para reiniciar el procedimiento de escaneo: case ESP_GAP_BLE_SCAN_RESULT_EVT: { esp_ble_gap_cb_param_t *scan_result = (esp_ble_gap_cb_param_t *)param; switch (scan_result->scan_rst.search_evt) { case ESP_GAP_SEARCH_INQ_RES_EVT: esp_log_buffer_hex(GATTC_TAG, scan_result->scan_rst.bda, 6); ESP_LOGI(GATTC_TAG, \"Longitud de datos de publicidad buscada %d, Longitud de respuesta de escaneo %d\", scan_result->scan_rst.adv_data_len, scan_result->scan_rst.scan_rsp_len); adv_name = esp_ble_resolve_adv_data(scan_result->scan_rst.ble_adv, ESP_BLE_AD_TYPE_NAME_CMPL, &adv_name_len); ESP_LOGI(GATTC_TAG, \"Longitud del nombre del dispositivo buscado %d\", adv_name_len); esp_log_buffer_char(GATTC_TAG, adv_name, adv_name_len); ESP_LOGI(GATTC_TAG, \" \"); if (adv_name != NULL) { if (strlen(remote_device_name) == adv_name_len && strncmp((char *)adv_name, remote_device_name, adv_name_len) == 0) { ESP_LOGI(GATTC_TAG, \"dispositivo buscado %s\", remote_device_name); if (connect == false) { connect = true; ESP_LOGI(GATTC_TAG, \"conectar al dispositivo remoto.\"); esp_ble_gap_stop_scanning(); esp_ble_gattc_open(gl_profile_tab[PROFILE_A_APP_ID].gattc_if, scan_result->scan_rst.bda, scan_result->scan_rst.ble_addr_type, true); } } } break; Primero, se resuelve el nombre del dispositivo y se compara con el nombre del dispositivo del servidor GATT en el que estamos interesados. Si coincide con el nombre del dispositivo del servidor GATT que estamos buscando, se detiene el escaneo. Cada vez que recibimos un resultado del evento ESP_GAP_SEARCH_INQ_RES_EVT , el c\u00f3digo primero imprime la direcci\u00f3n del dispositivo remoto: case ESP_GAP_SEARCH_INQ_RES_EVT: esp_log_buffer_hex(GATTC_TAG, scan_result->scan_rst.bda, 6); Luego, el cliente imprime la longitud de los datos anunciados y la longitud de la respuesta de escaneo: ESP_LOGI(GATTC_TAG, \"searched Adv Data Len %d, Scan Response Len %d\", scan_result->scan_rst.adv_data_len, scan_result->scan_rst.scan_rsp_len); Para obtener el nombre del dispositivo, utilizamos la funci\u00f3n esp_ble_resolve_adv_data() , que toma los datos anunciados almacenados en scan_result->scan_rst.ble_adv , el tipo de datos anunciados y la longitud, para extraer el valor del paquete publicitario. Luego, se imprime el nombre del dispositivo. adv_name = esp_ble_resolve_adv_data(scan_result->scan_rst.ble_adv, ESP_BLE_AD_TYPE_NAME_CMPL, &adv_name_len); ESP_LOGI(GATTC_TAG, \"searched Device Name Len %d\", adv_name_len); esp_log_buffer_char(GATTC_TAG, adv_name, adv_name_len); Tarea b\u00e1sica Muestra por pantalla el valor de RSSI de cada dispositivo BLE encontrado. Para ello, busca en la estructura de par\u00e1metros recibidos el campo correspondiente. Tarea b\u00e1sica A\u00f1ade a los men\u00fas de configuraci\u00f3n un campo que indique la direcci\u00f3n MAC BLE de un dispositivo (conocido) que est\u00e9 en fase de anuncio. Puedes utilizar los c\u00f3digos de servidor de la pr\u00e1ctica anterior. Tarea b\u00e1sica Modifica la fase de escaneado para que \u00fanicamente se muestre informaci\u00f3n (al menos nombre y RSSI) sobre el dispositivo cuya direcci\u00f3n MAC se haya configurado. Tarea b\u00e1sica Modifica el firmware b\u00e1sico para que, en funci\u00f3n del valor de RSSI obtenido para el dispositivo de inter\u00e9s, el cliente reporte con m\u00e1s o menos frecuencia por pantalla un valor proporcional a la distancia supuesta para dicho dispositivo. Si dispones de un LED conectado a la placa, puedes hacer que la frecuencia de parpadeo del mismo sea proporcional a dicha distancia. Tarea previa A partir de este punto puedes volver a fijar el nombre del dispositivo remoto de inter\u00e9s en funci\u00f3n del nombre otorgado en el servidor GATT. Finalmente, si el nombre del dispositivo remoto es el mismo que hemos definido anteriormente, el dispositivo local detiene el escaneo y trata de abrir una conexi\u00f3n con el dispositivo remoto utilizando la funci\u00f3n esp_ble_gattc_open() . Esta funci\u00f3n toma como par\u00e1metros la interfaz GATT del Perfil de Aplicaci\u00f3n, la direcci\u00f3n del servidor remoto y un valor booleano. El valor booleano se utiliza para indicar si la conexi\u00f3n se realiza directamente o en segundo plano (autoconexi\u00f3n). En este momento, este valor booleano debe establecerse en verdadero para establecer la conexi\u00f3n. Ten en cuenta que el cliente abre una conexi\u00f3n virtual con el servidor. La conexi\u00f3n virtual devuelve un ID de conexi\u00f3n. La conexi\u00f3n virtual es la conexi\u00f3n entre el Perfil de Aplicaci\u00f3n y el servidor remoto. Dado que muchos Perfiles de Aplicaci\u00f3n pueden ejecutarse en un ESP32, podr\u00eda haber muchas conexiones virtuales abiertas al mismo servidor remoto. Tambi\u00e9n est\u00e1 la conexi\u00f3n f\u00edsica, que es el enlace BLE real entre el cliente y el servidor. Por lo tanto, si la conexi\u00f3n f\u00edsica se desconecta con la funci\u00f3n esp_ble_gap_disconnect() , se cierran todas las dem\u00e1s conexiones virtuales. En este ejemplo, cada Perfil de Aplicaci\u00f3n crea una conexi\u00f3n virtual al mismo servidor con la funci\u00f3n esp_ble_gattc_open() , por lo que cuando se llama a la funci\u00f3n de cierre, solo se cierra esa conexi\u00f3n del Perfil de Aplicaci\u00f3n, mientras que si se llama a la funci\u00f3n de desconexi\u00f3n GAP, se cerrar\u00e1n ambas conexiones. Adem\u00e1s, los eventos de conexi\u00f3n se propagan a todos los perfiles porque se relacionan con la conexi\u00f3n f\u00edsica, mientras que los eventos de apertura se propagan solo al perfil que crea la conexi\u00f3n virtual.","title":"Configuraci\u00f3n de Par\u00e1metros de Escaneo"},{"location":"RPI-I/P6/#configuracion-del-tamano-de-mtu","text":"El ATT_MTU se define como el tama\u00f1o m\u00e1ximo de cualquier paquete enviado entre un cliente y un servidor. Cuando el cliente se conecta al servidor, informa al servidor qu\u00e9 tama\u00f1o de MTU usar intercambiando unidades de datos de protocolo de solicitud y respuesta de MTU (PDUs). Esto se hace despu\u00e9s de abrir la conexi\u00f3n. Despu\u00e9s de abrir la conexi\u00f3n, se desencadena un evento ESP_GATTC_CONNECT_EVT : case ESP_GATTC_CONNECT_EVT: //p_data->connect.status siempre ser\u00e1 ESP_GATT_OK ESP_LOGI(GATTC_TAG, \"ESP_GATTC_CONNECT_EVT conn_id %d, if %d, status %d\", conn_id, gattc_if, p_data->connect.status); conn_id = p_data->connect.conn_id; gl_profile_tab[PROFILE_A_APP_ID].conn_id = p_data->connect.conn_id; memcpy(gl_profile_tab[PROFILE_A_APP_ID].remote_bda, p_data->connect.remote_bda, sizeof(esp_bd_addr_t)); ESP_LOGI(GATTC_TAG, \"BDA REMOTO:\"); esp_log_buffer_hex(GATTC_TAG, gl_profile_tab[PROFILE_A_APP_ID].remote_bda, sizeof(esp_bd_addr_t)); esp_err_t mtu_ret = esp_ble_gattc_send_mtu_req (gattc_if, conn_id); if (mtu_ret){ ESP_LOGE(GATTC_TAG, \"error de configuraci\u00f3n de MTU, c\u00f3digo de error = %x\", mtu_ret); } break; El ID de conexi\u00f3n y la direcci\u00f3n del dispositivo remoto (servidor) se almacenan en la tabla de Perfiles de la Aplicaci\u00f3n y se imprimen en la consola: conn_id = p_data->connect.conn_id; gl_profile_tab[PROFILE_A_APP_ID].conn_id = p_data->connect.conn_id; memcpy(gl_profile_tab[PROFILE_A_APP_ID].remote_bda, p_data->connect.remote_bda, sizeof(esp_bd_addr_t)); ESP_LOGI(GATTC_TAG, \"BDA REMOTO:\"); esp_log_buffer_hex(GATTC_TAG, gl_profile_tab[PROFILE_A_APP_ID].remote_bda, sizeof(esp_bd_addr_t)); El tama\u00f1o t\u00edpico del MTU para una conexi\u00f3n Bluetooth 4.0 es de 23 bytes. Un cliente puede cambiar el tama\u00f1o del MTU utilizando la funci\u00f3n esp_ble_gattc_send_mtu_req() , que toma la interfaz GATT y el ID de conexi\u00f3n. El tama\u00f1o del MTU solicitado se define mediante esp_ble_gatt_set_local_mtu() . Luego, el servidor puede aceptar o rechazar la solicitud. El ESP32 admite un tama\u00f1o de MTU de hasta 517 bytes, que se define en ESP_GATT_MAX_MTU_SIZE en esp_gattc_api.h . En este ejemplo, el tama\u00f1o del MTU se establece en 500 bytes. En caso de que la configuraci\u00f3n falle, se imprime el error devuelto: esp_err_t mtu_ret = esp_ble_gattc_send_mtu_req (gattc_if, conn_id); if (mtu_ret){ ESP_LOGE(GATTC_TAG, \"error de configuraci\u00f3n de MTU, c\u00f3digo de error = %x\", mtu_ret); } break; La apertura de la conexi\u00f3n tambi\u00e9n desencadena un evento ESP_GATTC_OPEN_EVT , que se utiliza para comprobar si la apertura de la conexi\u00f3n se realiz\u00f3 con \u00e9xito; de lo contrario, se imprime un error y se sale del programa: case ESP_GATTC_OPEN_EVT: if (param->open.status != ESP_GATT_OK){ ESP_LOGE(GATTC_TAG, \"apertura fallida, estado %d\", p_data->open.status); break; } ESP_LOGI(GATTC_TAG, \"apertura exitosa\"); Cuando se intercambia el MTU, se desencadena un evento ESP_GATTC_CFG_MTU_EVT , que en este ejemplo se utiliza para imprimir el nuevo tama\u00f1o del MTU: case ESP_GATTC_CFG_MTU_EVT: if (param->cfg_mtu.status != ESP_GATT_OK){ ESP_LOGE(GATTC_TAG,\"configuraci\u00f3n de MTU fallida, estado de error = %x\", param->cfg_mtu.status); } ESP_LOGI(GATTC_TAG, \"ESP_GATTC_CFG_MTU_EVT, Estado %d, MTU %d, ID de conexi\u00f3n %d\", param->cfg_mtu.status, param->cfg_mtu.mtu, param->cfg_mtu.conn_id); \u2026 La configuraci\u00f3n del MTU se utiliza tambi\u00e9n para comenzar a descubrir los servicios disponibles en el servidor al que se ha conectado el cliente. Para descubrir los servicios, se utiliza la funci\u00f3n esp_ble_gattc_search_service() . Los par\u00e1metros de la funci\u00f3n son la interfaz GATT, el ID de conexi\u00f3n del perfil de la aplicaci\u00f3n y el UUID de la aplicaci\u00f3n de servicio que interesa al cliente. El servicio que estamos buscando se define de la siguiente manera: static esp_bt_uuid_t remote_filter_service_uuid = { .len = ESP_UUID_LEN_16, .uuid = {.uuid16 = REMOTE_SERVICE_UUID,}, }; Donde, #define REMOTE_SERVICE_UUID 0x00FF Si el UUID de la aplicaci\u00f3n de servicio que interesa al usuario es de 128 bits, hay una nota relevante para el usuario que se relaciona con el modo de almacenamiento en \"little-endian\" de la arquitectura del procesador. La estructura del UUID se define de la siguiente manera: typedef struct { #define ESP_UUID_LEN_16 2 #define ESP_UUID_LEN_32 4 #define ESP_UUID_LEN_128 16 uint16_t len; /*!< Longitud del UUID, 16 bits, 32 bits o 128 bits */ union { uint16_t uuid16; /*!< UUID de 16 bits */ uint32_t uuid32; /*!< UUID de 32 bits */ uint8_t uuid128[ESP_UUID_LEN_128]; /*!< UUID de 128 bits */ } uuid; /*!< UUID */ } __attribute__((packed)) esp_bt_uuid_t; Nota: En el modo de almacenamiento en \"little-endian\", puedes definir directamente el UUID del servicio en el orden normal si es un UUID de 16 bits o 32 bits, pero si el UUID del servicio es de 128 bits, hay una peque\u00f1a diferencia. Por ejemplo, si el UUID de la aplicaci\u00f3n de servicio que le interesa al usuario es 12345678-a1b2-c3d4-e5f6-9fafd205e457, REMOTE_SERVICE_UUID deber\u00eda definirse como {0x57,0xE4,0x05,0xD2,0xAF,0x9F,0xF6,0xE5,0xD4,0xC3,0xB2,0xA1,0x78,0x56,0x34,0x12}. Los servicios se descubren de la siguiente manera: esp_ble_gattc_search_service(gattc_if, param->cfg_mtu.conn_id, &remote_filter_service_uuid); break; El servicio encontrado, si lo hay, se devolver\u00e1 desde un evento ESP_GATTC_SEARCH_RES_EVT . Para cada servicio encontrado, se desencadena un evento para imprimir informaci\u00f3n sobre el servicio descubierto, seg\u00fan el tama\u00f1o del UUID: case ESP_GATTC_SEARCH_RES_EVT: { esp_gatt_srvc_id_t *srvc_id = &p_data->search_res.srvc_id; conn_id = p_data->search_res.conn_id; Si el `len` del UUID en `srvc_id->id.uuid` es igual a `ESP_UUID_LEN_16` y `uuid16` coincide con `REMOTE_SERVICE_UUID`, se establece `get_server` en true. Luego, se almacena el valor de inicio (`start_handle`) y el valor de fin (`end_handle`) que se utilizar\u00e1n m\u00e1s adelante para obtener todas las caracter\u00edsticas de ese servicio. Finalmente, despu\u00e9s de que se devuelvan todos los resultados de los servicios, la b\u00fasqueda se completa y se desencadena un evento `ESP_GATTC_SEARCH_CMPL_EVT`. ESP_LOGI(GATTC_TAG, \"UUID16: %x\", srvc_id->id.uuid.uuid.uuid16); } break; En caso de que el cliente encuentre el servicio que busca, la bandera get_server se establece en true y se guardan los valores de inicio y fin que se utilizar\u00e1n posteriormente para obtener todas las caracter\u00edsticas de ese servicio. Una vez que se han devuelto todos los resultados de los servicios, se completa la b\u00fasqueda y se desencadena un evento ESP_GATTC_SEARCH_CMPL_EVT .","title":"Configuraci\u00f3n del Tama\u00f1o de MTU"},{"location":"RPI-I/P6/#obteniendo-caracteristicas","text":"Este ejemplo implementa la obtenci\u00f3n de datos de caracter\u00edsticas de un servicio predefinido. El servicio del cual queremos obtener caracter\u00edsticas tiene un UUID de 0x00FF, y la caracter\u00edstica de inter\u00e9s tiene un UUID de 0xFF01: #define REMOTE_NOTIFY_CHAR_UUID 0xFF01 Un servicio se define utilizando la estructura esp_gatt_srvc_id_t de la siguiente manera: /** * @brief Gatt id, include uuid and instance id */ typedef struct { esp_bt_uuid_t uuid; /*!< UUID */ uint8_t inst_id; /*!< ID de instancia */ } __attribute__((packed)) esp_gatt_id_t; En este ejemplo, definimos el servicio del cual queremos obtener las caracter\u00edsticas de la siguiente manera: static esp_gatt_srvc_id_t remote_service_id = { .id = { .uuid = { .len = ESP_UUID_LEN_16, .uuid = {.uuid16 = REMOTE_SERVICE_UUID,}, }, .inst_id = 0, }, .is_primary = true, }; Una vez definido, podemos obtener las caracter\u00edsticas de ese servicio utilizando la funci\u00f3n esp_ble_gattc_get_characteristic() , la cual se llama en el evento ESP_GATTC_SEARCH_CMPL_EVT despu\u00e9s de que se haya completado la b\u00fasqueda de servicios y el cliente ha encontrado el servicio que estaba buscando. case ESP_GATTC_SEARCH_CMPL_EVT: if (p_data->search_cmpl.status != ESP_GATT_OK){ ESP_LOGE(GATTC_TAG, \"b\u00fasqueda de servicio fallida, estado de error = %x\", p_data->search_cmpl.status); break; } conn_id = p_data->search_cmpl.conn_id; if (get_server){ uint16_t count = 0; esp_gatt_status_t status = esp_ble_gattc_get_attr_count(gattc_if, p_data->search_cmpl.conn_id, ESP_GATT_DB_CHARACTERISTIC, gl_profile_tab[PROFILE_A_APP_ID].service_start_handle, gl_profile_tab[PROFILE_A_APP_ID].service_end_handle, INVALID_HANDLE, &count); if (status != ESP_GATT_OK){ ESP_LOGE(GATTC_TAG, \"esp_ble_gattc_get_attr_count error\"); } if (count > 0){ char_elem_result = (esp_gattc_char_elem_t*)malloc(sizeof(esp_gattc_char_elem_t) * count); if (!char_elem_result){ ESP_LOGE(GATTC_TAG, \"gattc sin memoria\"); }else{ status = esp_ble_gattc_get_char_by_uuid(gattc_if, p_data->search_cmpl.conn_id, gl_profile_tab[PROFILE_A_APP_ID].service_start_handle, gl_profile_tab[PROFILE_A_APP_ID].service_end_handle, remote_filter_char_uuid, char_elem_result, &count); if (status != ESP_GATT_OK){ ESP_LOGE(GATTC_TAG, \"esp_ble_gattc_get_char_by_uuid error\"); } /* Cada servicio tiene solo una caracter\u00edstica en nuestro demo 'ESP_GATTS_DEMO', por lo que usamos el primer 'char_elem_result' */ if (count > 0 && (char_elem_result[0].properties & ESP_GATT_CHAR_PROP_BIT_NOTIFY)){ gl_profile_tab[PROFILE_A_APP_ID].char_handle = char_elem_result[0].char_handle; esp_ble_gattc_register_for_notify(gattc_if, gl_profile_tab[PROFILE_A_APP_ID].remote_bda, char_elem_result[0].char_handle); } } /* Liberar char_elem_result */ free(char_elem_result); }else{ ESP_LOGE(GATTC_TAG, \"ninguna caracter\u00edstica encontrada\"); } } break; esp_ble_gattc_get_attr_count() obtiene el n\u00famero de atributos con el tipo de atributo dado en la cach\u00e9 GATT. Los par\u00e1metros de la funci\u00f3n esp_ble_gattc_get_attr_count() son la interfaz GATT, el ID de conexi\u00f3n, el tipo de atributo definido en esp_gatt_db_attr_type_t , el valor de inicio del atributo, el valor final del atributo, el identificador de la caracter\u00edstica (este par\u00e1metro solo es v\u00e1lido cuando el tipo se establece en ESP_GATT_DB_DESCRIPTOR ) y la salida del n\u00famero de atributos encontrados en la cach\u00e9 GATT con el tipo de atributo dado. Luego, se asigna un b\u00fafer para guardar la informaci\u00f3n de la caracter\u00edstica para la funci\u00f3n esp_ble_gattc_get_char_by_uuid() . Esta funci\u00f3n busca la caracter\u00edstica con el UUID de caracter\u00edstica dado en la cach\u00e9 GATT. Simplemente obtiene la caracter\u00edstica de la cach\u00e9 local, en lugar de los dispositivos remotos. En un servidor, puede haber m\u00e1s de una caracter\u00edstica con el mismo UUID. Sin embargo, en nuestro ejemplo de gatt_server, cada caracter\u00edstica tiene un UUID \u00fanico y es por eso que solo usamos la primera caracter\u00edstica en char_elem_result , que es el puntero a la caracter\u00edstica del servicio. El contador inicialmente almacena la cantidad de caracter\u00edsticas que el cliente desea encontrar y se actualizar\u00e1 con la cantidad de caracter\u00edsticas que se han encontrado en la cach\u00e9 GATT con esp_ble_gattc_get_char_by_uuid .","title":"Obteniendo Caracter\u00edsticas"},{"location":"RPI-I/P6/#registro-para-notificaciones","text":"El cliente puede registrarse para recibir notificaciones del servidor cada vez que cambia el valor de la caracter\u00edstica. En este ejemplo, queremos registrarnos para recibir notificaciones de la caracter\u00edstica identificada con un UUID de 0xff01. Despu\u00e9s de obtener todas las caracter\u00edsticas, verificamos las propiedades de la caracter\u00edstica recibida y luego utilizamos la funci\u00f3n esp_ble_gattc_register_for_notify() para registrarnos para notificaciones. Los argumentos de la funci\u00f3n son la interfaz GATT, la direcci\u00f3n del servidor remoto y el identificador del que queremos recibir notificaciones. ... /* Cada servicio tiene solo una caracter\u00edstica en nuestra demostraci\u00f3n 'ESP_GATTS_DEMO', por lo que usamos primero 'char_elem_result' */ if (count > 0 && (char_elem_result[0].properties & ESP_GATT_CHAR_PROP_BIT_NOTIFY)){ gl_profile_tab[PROFILE_A_APP_ID].char_handle = char_elem_result[0].char_handle; esp_ble_gattc_register_for_notify(gattc_if, gl_profile_tab[PROFILE_A_APP_ID].remote_bda, char_elem_result[0].char_handle); } ... Este procedimiento registra notificaciones en la pila BLE y desencadena un evento ESP_GATTC_REG_FOR_NOTIFY_EVT . Este evento se utiliza para escribir en el Descriptor de Configuraci\u00f3n del Cliente del servidor: case ESP_GATTC_REG_FOR_NOTIFY_EVT: { ESP_LOGI(GATTC_TAG, \"ESP_GATTC_REG_FOR_NOTIFY_EVT\"); if (p_data->reg_for_notify.status != ESP_GATT_OK){ ESP_LOGE(GATTC_TAG, \"REG FOR NOTIFY fall\u00f3: estado de error = %d\", p_data->reg_for_notify.status); }else{ uint16_t count = 0; uint16_t notify_en = 1; esp_gatt_status_t ret_status = esp_ble_gattc_get_attr_count( gattc_if, gl_profile_tab[PROFILE_A_APP_ID].conn_id, ESP_GATT_DB_DESCRIPTOR, gl_profile_tab[PROFILE_A_APP_ID].service_start_handle, gl_profile_tab[PROFILE_A_APP_ID].service_end_handle, gl_profile_tab[PROFILE_A_APP_ID].char_handle, &count); if (ret_status != ESP_GATT_OK){ ESP_LOGE(GATTC_TAG, \"esp_ble_gattc_get_attr_count error\"); } if (count > 0){ descr_elem_result = malloc(sizeof(esp_gattc_descr_elem_t) * count); if (!descr_elem_result){ ESP_LOGE(GATTC_TAG, \"error de asignaci\u00f3n de memoria, gattc sin memoria\"); }else{ ret_status = esp_ble_gattc_get_descr_by_char_handle( gattc_if, gl_profile_tab[PROFILE_A_APP_ID].conn_id, p_data->reg_for_notify.handle, notify_descr_uuid, descr_elem_result,&count); if (ret_status != ESP_GATT_OK){ ESP_LOGE(GATTC_TAG, \"esp_ble_gattc_get_descr_by_char_handle error\"); } /* Cada caracter\u00edstica tiene solo un descriptor en nuestra demostraci\u00f3n 'ESP_GATTS_DEMO', por lo que usamos primero 'descr_elem_result' */ if (count > 0 && descr_elem_result[0].uuid.len == ESP_UUID_LEN_16 && descr_elem_result[0].uuid.uuid.uuid16 == ESP_GATT_UUID_CHAR_CLIENT_CONFIG){ ret_status = esp_ble_gattc_write_char_descr( gattc_if, gl_profile_tab[PROFILE_A_APP_ID].conn_id, descr_elem_result[0].handle, sizeof(notify_en), (Uint8 *)&notify_en, ESP_GATT_WRITE_TYPE_RSP, ESP_GATT_AUTH_REQ_NONE); } if (ret_status != ESP_GATT_OK){ ESP_LOGE(GATTC_TAG, \"esp_ble_gattc_write_char_descr error\"); } /* Liberar descr_elem_result */ free(descr_elem_result); } } else{ ESP_LOGE(GATTC_TAG, \"descripci\u00f3n no encontrada\"); } } break; } El evento se utiliza primero para imprimir el estado del registro de notificaciones y los UUID del servicio y de la caracter\u00edstica que acaban de registrarse. Luego, el cliente escribe en el Descriptor de Configuraci\u00f3n del Cliente utilizando la funci\u00f3n esp_ble_gattc_write_char_descr() . Hay muchos descriptores de caracter\u00edsticas definidos en la especificaci\u00f3n de Bluetooth. Sin embargo, en este caso, nos interesa escribir en el descriptor que se encarga de habilitar las notificaciones, que es el descriptor de Configuraci\u00f3n del Cliente. Para pasar este descriptor como par\u00e1metro, primero lo definimos como: static esp_gatt_id_t notify_descr_id = { .uuid = { .len = ESP_UUID_LEN_16, .uuid = {.uuid16 = ESP_GATT_UUID_CHAR_CLIENT_CONFIG,}, }, .inst_id = 0, }; Donde ESP_GATT_UUID_CHAR_CLIENT_CONFIG se define con el UUID para identificar la Configuraci\u00f3n del Cliente de la Caracter\u00edstica: #define ESP_GATT_UUID_CHAR_CLIENT_CONFIG 0x2902 /* Configuraci\u00f3n del Cliente de Caracter\u00edsticas */ El valor a escribir es \"1\" para habilitar las notificaciones. Tambi\u00e9n pasamos ESP_GATT_WRITE_TYPE_RSP para solicitar que el servidor responda a la solicitud de habilitar las notificaciones y ESP_GATT_AUTH_REQ_NONE para indicar que la solicitud de escritura no requiere autorizaci\u00f3n. Tarea adicional Modifica el cliente para que las notificaciones enviadas por tu servidor GATT modificado en la pr\u00e1ctica anterior sean recibidas y monitorizadas por parte del cliente GATT.","title":"Registro para Notificaciones"},{"location":"RPI-I/P7/","text":"Pr\u00e1ctica 7. BLE Mesh Objetivos Poner en pr\u00e1ctica los conceptos estudiados en teor\u00eda en relaci\u00f3n a BLE MESH, espec\u00edficamente provisionamiento y modelos cliente/servidor. Desplegar una infraestructura de provisionamiento de un modelo ONOFF GENERIC SERVER con provisionamiento desde aplicaci\u00f3n m\u00f3vil para el control remoto de encendido/apagado LED. Desplegar una infraestructura de provisionamiento de un modelo GENERIC SENSOR con provisionamiento desde ESP32. Estructura de la pr\u00e1ctica Esta pr\u00e1ctica est\u00e1 dividida en dos partes. En la primera parte trabajaremos un ejemplo de modelo gen\u00e9rico ON-OFF (bluetooth/esp_ble_mesh/ble_mesh_node), en el que se simular\u00e1 una red dom\u00f3tica con un interruptor y varias luces conectadas a una red BLE-Mesh (o un s\u00f3lo led rgb). Si disponemos de ellos, podemos conectar leds a los pines GPIO indicados en el fichero board.h para ver f\u00edsicamente el efecto del encendido y apagado de las luces. En la segunda parte trabajaremos un ejemplo de modelo sensor (ble_mesh_sensor_model), en el que un sensor enviar\u00e1 informaci\u00f3n de un sensor virtual (simulado con n\u00fameros aleatorios) que enviar\u00e1 a los clientes conectados en la red BLE-Mesh. Tarea Escribe un informe en el que describas cada una de las tareas propuestas, su desarrollo y los resultados obeservados, as\u00ed como tus observaciones o comentarios personales. Requisitos previos En segundo lugar, deber\u00e1s rellenar la hoja Excel correspondiente a tu puesto con la direcci\u00f3n MAC Bluetooth de tu dispositivo, que podr\u00e1s obtener con cualquier mecanismo que hayas utilizado en pr\u00e1cticas anteriores. Los c\u00f3digos que estudiaremos en la pr\u00e1ctica se encuentran en el directorio examples/bluetooth/esp_ble_mesh/ble_mesh_node en el caso del sistema OnOff (primera parte de la pr\u00e1ctica) y ble_mesh_sensor_model en el caso del modelo sensor (segunda parte de la pr\u00e1ctica). Por \u00faltimo, descarga e instala la aplicaci\u00f3n (disponible para Android e IOS) nRF Mesh . Modelo gen\u00e9rico ON-OFF El servidor ON-OFF El servidor implementa un \u00fanico elemento, en el cual se integran dos modelos distintos: Modelo Configuration Server , que implementa la configuraci\u00f3n de claves de aplicaci\u00f3n ( AppKey ), as\u00ed como configuraciones gen\u00e9ricas del servidor como suscripciones, tama\u00f1o de TTL o funcionalidad de relay de mensajes. Modelo Generic OnOff Server , que implementa la funcionalidad b\u00e1sica de encendido/apagado de una luz. El c\u00f3digo en el fichero main.c contiene la funcionalidad b\u00e1sica del servidor, que podemos resumir en: Inicializaci\u00f3n de la pila BLE ( bluedroid ). Inicializaci\u00f3n de la pila BLE Mesh. Registro de las funciones de callback para el proceso de provisionamiento y del modelo o modelos implementados. Implementaci\u00f3n e inicializaci\u00f3n del elemento BLE Mesh. Implementaci\u00f3n e inicializaci\u00f3n del modelo Configuration Server y Generic OnOff Server . Soporte para operaciones Get Opcode y Set Opcode en el modelo de configuraci\u00f3n. An\u00e1lisis b\u00e1sico de c\u00f3digo Inicializaci\u00f3n y activaci\u00f3n de la pila BLE Mesh Tras la inicializaci\u00f3n del sistema, la tarea principal ( app_main ) se encarga de la incializaci\u00f3n de las pilas BLE y BLE Mesh: void app_main(void) { int err; ESP_LOGI(TAG, \"Initializing...\"); board_init(); err = bluetooth_init(); if (err) { ESP_LOGE(TAG, \"esp32_bluetooth_init failed (err %d)\", err); return; } /* Initializes the Bluetooth Mesh Subsystem */ err = ble_mesh_init(); if (err) { ESP_LOGE(TAG, \"Bluetooth mesh init failed (err %d)\", err); } } En particular, el c\u00f3digo incluye invocaciones a bluetooth_init() y ble_mesh_init() , que se encargan de ambas inicializaciones. La inicializaci\u00f3n de la pila BLE Mesh requiere alguna explicaci\u00f3n adicional: static esp_err_t ble_mesh_init(void) { int err = 0; memcpy(dev_uuid + 2, esp_bt_dev_get_address(), BLE_MESH_ADDR_LEN); // See comment 1 esp_ble_mesh_register_prov_callback(esp_ble_mesh_prov_cb); esp_ble_mesh_register_custom_model_callback(esp_ble_mesh_model_cb); err = esp_ble_mesh_init(&provision, &composition); if (err) { ESP_LOGE(TAG, \"Initializing mesh failed (err %d)\", err); return err; } esp_ble_mesh_node_prov_enable(ESP_BLE_MESH_PROV_ADV | ESP_BLE_MESH_PROV_GATT); ESP_LOGI(TAG, \"BLE Mesh Node initialized\"); board_led_operation(LED_G, LED_ON); return err; } Observa que el c\u00f3digo incluye la siguiente funcionalidad: esp_ble_mesh_register_prov_callback(esp_ble_mesh_prov_cb) : registra la funci\u00f3n de callback para la pila BLE Mesh. Esta funci\u00f3n se ejecuta durante el proceso de configuraci\u00f3n, y permite a la pila BLE Mesh generar eventos y notificar a la aplicaci\u00f3n sobre hitos importantes en el proceso de configuraci\u00f3n. Los eventos principales que pueden emitirse son: ESP_BLE_MESH_PROVISION_REGISTER_COMP_EVT : generado cuando se completa el proceso de incializaci\u00f3n de BLE Mesh. ESP_BLE_MESH_NODE_PROV_LINK_OPEN_EVT : generado cuando un provisionador y un dispositivo no provisionado establecen un enlace. ESP_BLE_MESH_NODE_PROV_LINK_CLOSE_EVT : generado para notificar a la aplicaci\u00f3n que se ha roto un enlace con un dispositivo asociado. ESP_BLE_MESH_NODE_PROV_COMPLETE_EVT : recibido por la aplicaci\u00f3n cuando el proceso de provisionamiento se completa. esp_ble_mesh_register_custom_model_callback(esp_ble_mesh_model_cb) : registra la funci\u00f3n de callback asociada al modelo. Esta funci\u00f3n se utiliza cuando el otro extremo de la comunicaci\u00f3n solicita operaciones sobre el modelo, y es capaz de emitir los siguientes eventos principales: ESP_BLE_MESH_MODEL_OPERATION_EVT : se puede generar en dos situaciones: El modelo servidor recibe un Get Status o Set Status desde un modelo cliente. El modelo cliente recibe un Status State desde un modelo servidor. ESP_BLE_MESH_MODEL_SEND_COMP_EVT : generado despu\u00e9s de que el modelo servidor env\u00ede un Status State a trav\u00e9s de la funci\u00f3n esp_ble_mesh_server_model_send_msg . ESP_BLE_MESH_MODEL_PUBLISH_COMP_EVT : generado despu\u00e9s de que la aplicaci\u00f3n complete la invocaci\u00f3n a esp_ble_mesh_model_publish_msg para publicar mensajes. ESP_BLE_MESH_CLIENT_MODEL_SEND_TIMEOUT_EVT : generado cuando el modelo cliente invoca a la funci\u00f3n esp_ble_mesh_client_model_send_msg , pero no recibe mensaje de ACK de vuelta. ESP_BLE_MESH_MODEL_PUBLISH_UPDATE_EVT : generado despu\u00e9s de que la aplicaci\u00f3n configure la funci\u00f3n de publicaci\u00f3n para enviar de forma peri\u00f3dica mensajes al otro extremo. esp_ble_mesh_node_prov_enable(ESP_BLE_MESH_PROV_ADV | ESP_BLE_MESH_PROV_GATT) : activa el proceso de Anuncio y Escaneo, haciendo visible al dispositivo para potenciales provisionadores que est\u00e9n a la escucha. board_led_operation(LED_G, LED_ON) : inicializa un hipot\u00e9tico LED RGB, que se controlar\u00e1 remotamente. En este punto, la inicializaci\u00f3n de la pila BLE Mesh deber\u00eda estar completa, por lo que un provisionador podr\u00eda identificar dispositivos para privisonamiento de par\u00e1metros de red y transmisi\u00f3n de datos. Implementaci\u00f3n de la estructura BLE Mesh Element A continuaci\u00f3n, se detallan los pasos necesarios para, en el servidor: Completar la inicializaci\u00f3n del sistema. A\u00f1adir un elemento y un modelo al servidor. Elegir distintas implementaciones de encriptaci\u00f3n. Declarar las caracter\u00edsticas de Proxy , Relay , Low Power y Friend del nodo. En primer lugar, para declarar y definir un elemento y un modelo asociado, utilizaremos las siguientes estructuras: /*!< Abstraction that describes a BLE Mesh Element. This structure is associated with bt_mesh_elem in mesh_access.h */ typedef struct { /* Element Address, it is assigned during provisioning. */ uint16_t element_addr; /* Location Descriptor (GATT Bluetooth Namespace Descriptors) */ const uint16_t location; /* Model count */ const uint8_t sig_model_count; const uint8_t vnd_model_count; /* Models */ esp_ble_mesh_model_t *sig_models; esp_ble_mesh_model_t *vnd_models; } esp_ble_mesh_elem_t; As\u00ed, podemos mantener informaci\u00f3n sobre los elementos disponibles en el vector elements : static esp_ble_mesh_elem_t elements[] = { ESP_BLE_MESH_ELEMENT(0, root_models, ESP_BLE_MESH_MODEL_NONE), ESP_BLE_MESH_ELEMENT(0, extend_model_0, ESP_BLE_MESH_MODEL_NONE), ESP_BLE_MESH_ELEMENT(0, extend_model_1, ESP_BLE_MESH_MODEL_NONE), }; D\u00f3nde la macro ESP_BLE_MESH_ELEMEN se utiliza para inicializar los campos de la estructura esp_ble_mesh_elem_t : #define ESP_BLE_MESH_ELEMENT(_loc, _mods, _vnd_mods) \\ { \\ .location = (_loc), \\ .sig_model_count = ARRAY_SIZE(_mods), \\ .sig_models = (_mods), \\ .vnd_model_count = ARRAY_SIZE(_vnd_mods), \\ .vnd_models = (_vnd_mods), \\ } Las variables de la estructura son las siguientes: addr : almacena la direcci\u00f3n del elemento primario, usado por la pila ble mesh durante la inicializaci\u00f3n. Puede ser ignorado por las aplicaciones. loc : descriptor location definido por el SIG. En este ejemplo se pone a 0 . model_count : n\u00famero de modelos soportados por este elemento. vnd_model_count : n\u00famero de modelos de vendedor soportados por este elemento. models : puntero al array de modelos ya definidos. vnd_models : puntero al array de modelos de vendedor ya definidos (ninguno en nuestro ejemplo). Como vemos, cada elemento usa un array del tipo ble_mesh_model_t para identificar los modelos implementados por el elemento, como es el array root_models en nuestro c\u00f3digo de ejemplo. static esp_ble_mesh_model_t root_models[] = { ESP_BLE_MESH_MODEL_CFG_SRV(&config_server), ESP_BLE_MESH_MODEL_GEN_ONOFF_SRV(&onoff_pub_0, &onoff_server_0), }; Distintos modelos requieren diferentes macros (en este caso, ya que vamos a implementar un modelo Generic OnOff Server , hemos utilizado ESP_BLE_MESH_MODEL_GEN_ONOFF_SRV ). El cliente ON-OFF El cliente resulta mucho m\u00e1s sencillo en su funcionamiento. El c\u00f3digo de ejemplo es (ble_mesh_node/onoff_client). De forma gen\u00e9rica, simplemente define un modelo Client ON/OFF y espera a ser provisionado. Una vez completado el proceso de provisionamento, espera a la pulsaci\u00f3n de uno de los botones en la placa (RESET) para el env\u00edo a todos los nodos en la misma red de una solicitud de modificaci\u00f3n en el estado de activaci\u00f3n de las luces. Concretamente, nos interesan las siguientes definiciones. En el fichero board.c , observa la respusta a la pulsaci\u00f3n del bot\u00f3n: static void button_tap_cb(void* arg) { ESP_LOGI(TAG, \"tap cb (%s)\", (char *)arg); example_ble_mesh_send_gen_onoff_set(); } static void board_button_init(void) { button_handle_t btn_handle = iot_button_create(BUTTON_IO_NUM, BUTTON_ACTIVE_LEVEL); if (btn_handle) { iot_button_set_evt_cb(btn_handle, BUTTON_CB_RELEASE, button_tap_cb, \"RELEASE\"); } } void board_init(void) { board_led_init(); board_button_init(); } La funci\u00f3n invocada, example_ble_mesh_send_gen_onoff_set() (definida en el fichero main.c ), realiza el env\u00edo de una operaci\u00f3n de tipo SET a todos los miembros de la red : void example_ble_mesh_send_gen_onoff_set(void) { esp_ble_mesh_generic_client_set_state_t set = {0}; esp_ble_mesh_client_common_param_t common = {0}; esp_err_t err = ESP_OK; common.opcode = ESP_BLE_MESH_MODEL_OP_GEN_ONOFF_SET_UNACK; common.model = onoff_client.model; common.ctx.net_idx = store.net_idx; common.ctx.app_idx = store.app_idx; common.ctx.addr = 0xFFFF; /* to all nodes */ common.ctx.send_ttl = 3; common.ctx.send_rel = false; common.msg_timeout = 0; /* 0 indicates that timeout value from menuconfig will be used */ common.msg_role = ROLE_NODE; set.onoff_set.op_en = false; set.onoff_set.onoff = store.onoff; set.onoff_set.tid = store.tid++; err = esp_ble_mesh_generic_client_set_state(&common, &set); if (err) { ESP_LOGE(TAG, \"Send Generic OnOff Set Unack failed\"); return; } store.onoff = !store.onoff; mesh_example_info_store(); /* Store proper mesh example info */ } Observa c\u00f3mo el mensaje se enviar\u00e1 a todos los nodos de la red ( common.ctx.addr = 0xFFFF; ). Provisionamiento y control desde una aplicaci\u00f3n m\u00f3vil En primer lugar, nos dividiremos en grupos de 3-4 personas. Uno de vosotros, utilizando la aplicaci\u00f3n m\u00f3vil nRF Mesh , actuar\u00e1 como provisionador de la red, proporcionando claves de red y aplicaci\u00f3n, as\u00ed como informaci\u00f3n b\u00e1sica de red (por ejemplo, direcciones unicast). Adem\u00e1s, podr\u00e1 crear grupos y suscribir/desuscribir modelos a dichos grupos. Adem\u00e1s, se requiere que uno de vuestros ESP32 act\u00fae como cliente, y el resto como servidores. As\u00ed, emularemos una sala con m\u00faltiples luces, y un s\u00f3lo interruptor que controlar\u00e1 su estado de encendido/apagado. PASO 1 : en la pantalla inicial se nos mostrar\u00e1n los nodos ya provisionados. En nuestro caso, inicialmente ninguno. PASO 2 : pincharemos sobre ADD NODE , y provisionaremos, uno a uno, todos los nodos que deseemos que formen parte de nuestra red (s\u00f3lo aquellos que forman parte de tu grupo de compa\u00f1eros): PASO 3 : antes de provisionar, generamos informaci\u00f3n de red para el nuevo nodo (lo identificamos ), presionando en IDENTIFY : PASO 4 : una vez generada la informaci\u00f3n de red, provisionamos el nodo ( PROVISION ): PASO 5 : si todo ha ido bien, se nos mostrar\u00e1 un mensaje de \u00e9xito como el siguiente: PASO 6 : tras repetir este paso con todos los nodos de nuestro grupo, veremos una pantalla como la siguiente. Observa y anota las direcciones unicast de cada nodo. Los nodos con un elemento son el cliente OnOff; los nodos con tres elementos son los servidores OnOff: A continuaci\u00f3n, generar\u00e1s un grupo de nodos. Esto nos permitir\u00e1 suscribir a modelos al mismo, y publicar mensajes que se transmitir\u00e1n a todos los modelos del grupo. PASO 7 : crea un nuevo grupo pulsando el bot\u00f3n + . Dale el nombre y la direcci\u00f3n que desees, por ejemplo, Sala de Estar , 0xC000 . Si todo ha ido bien, se especificar\u00e1 que en el \u00fanico grupo disponible no hay ning\u00fan dispositivo suscrito/asociado. A continuaci\u00f3n, suscribiremos a cada modelo de los servidores y clientes (de tipo Generic On Off Server y Generic On Off Client ) al grupo creado. Esto lo har\u00e1s nodo a nodo, en primer lugar pincando en el modelo concreto: Y a continuaci\u00f3n asociando una clave de aplicaci\u00f3n ( BIND KEY ) y suscribiendo ( SUBSCRIBE ) al grupo deseado: Ahora, si vuelves a la descripci\u00f3n del grupo, ver\u00e1s que, tras pinchar, observas dos luces (o una por servidor) y un interruptor (correspondiente al cliente): En este punto, si est\u00e1s monitorizando la salida de todos los ESP32, ver\u00e1s que el estado del LED cambia a petici\u00f3n de la aplicaci\u00f3n. Adem\u00e1s, ver\u00e1s que tambi\u00e9n cambia si presionas el bot\u00f3n correspondiente del interruptor ( RESET ) en la placa. Tarea El cliente env\u00eda, tras presionar un bot\u00f3n, el mensaje de tipo SET a todos los nodos de la red. Modif\u00edcalo para que \u00fanicamente se env\u00ede a los pertenecientes a tu grupo. Prueba a suscribir/desuscribir un modelo del grupo, y ver\u00e1s como ya no recibe los mensajes de solicitud de modificaci\u00f3n de estado. Modelo sensor En este ejemplo (ble_mesh_sensor_model), se implementa la creaci\u00f3n de un cliente de modelo sensor que, adem\u00e1s, es provisionador, y un servidor de modelo sensor configurable. El modelo Sensor Server es un modelo que permite exponer series de datos de sensorizaci\u00f3n. El modelo Sensor Client se usa para consumir valores de sensorizaci\u00f3n ( Sensor states ) expuestos por el servidor. Estos estados se componen de las siguientes partes: Estado Sensor Descriptor . Describe los datos del sensor, y es inmutable durante su vida. Estado Sensor Setting . Controla los par\u00e1metros del sensor. Por ejemplo, podr\u00eda indicar su sensibilidad, y podr\u00eda ser ajustado remotamente para prevenir que un sensor de movimiento se disparase ante peque\u00f1os movimientos. Estado Sensor Cadence . Controla la cadencia de sensorizaci\u00f3n. Estado Sensor Data . Contiene los valores de sensorizaci\u00f3n. Realmente, representa uno o m\u00e1s pares Property ID - Valor . Estado Sensor Series Column . S\u00f3lo utilizado si se considera cada uno de los valores como perteneciente a una serie de datos. En el ejemplo client , el dispositivo es a la vez un provisionador y un cliente. Una vez el dispositivo servidor es provisionado y configurado, los usuarios pueden presionar el bot\u00f3n de la placa para enviar al servidor peticiones que, sucesivamente, devolver\u00e1n el siguiente estado del sensor en orden ( Descriptor , Setting , Cadence , ...). En el ejemplo server , el dispositivo no provisonado implementa un modelo Sensor Server . El servidor soporta dos instancias de estados: la pimrea ( Property ID 0x0056 ) representar\u00eda la temperatura Indoor ; la segunda ( Property ID 0x005B ) representar\u00eda la temperatura Outdoor . Todos los datos, en estos ejemplos, est\u00e1n preinicializados. Puesta en marcha En primer lugar, arranca en tu grupo un nodo cliente/provisionador, y monitoriza su salida. Cuando un compa\u00f1ero/a arranque un nodo servidor, ver\u00e1s que es provisionado por tu cliente, otorg\u00e1ndole una direcci\u00f3n unicast. An\u00f3tala. El funcionamiento general del sistema es: El dispositivo A ejecuta el ejemplo client , y el dispositivo B ejecuta el ejemplo server . A act\u00faa como provisionador. Tras recibir una petici\u00f3n por parte de B, lo provisiona y almacena su direcci\u00f3n. Observar\u00e1s la MAC BLE (UUID) de B en el proceso de provisionamiento desde A. En A, cada pulsaci\u00f3n del bot\u00f3n supondr\u00e1 una petici\u00f3n al nodo B. Sucesivamente, estas peticiones ser\u00e1n, en orden y por cada pulsaci\u00f3n: Sensor Descriptor . Sensor Cadence . Sensor Settings . Sensor Data . Sensor Series . Tarea Estudia el c\u00f3digo del cliente y del servidor, y observa a qu\u00e9 nodo se env\u00edan las peticiones desde el cliente, qu\u00e9 operaciones se solicitan en cada pulsaci\u00f3n de bot\u00f3n, y qu\u00e9 datos devuelve el servidor en cada caso. Tarea Modifica el c\u00f3digo de cliente y/o servidor para que los valores de sensorizaci\u00f3n que se consulten en cada pulsaci\u00f3n del bot\u00f3n no sean todos los del modelo del \u00faltimo nodo provisonado, como ahora se hace, sino \u00fanicamente los datos de sensorizaci\u00f3n ( Sensor Data State ) de todos los nodos provisionados. As\u00ed, si hay tres nodos provisionados, cada pulsaci\u00f3n nos devolver\u00e1 el valor de sensorizaci\u00f3n de uno de ellos, por orden de provisionamiento. Tarea Como funcionalidad adicional, s\u00f3lo se provisionar\u00e1 autom\u00e1ticamente a aquellos nodos autorizados (los que pertenecen a tu sala, por ejemplo). Tarea Por \u00faltimo, se pide que el valor sensorizado var\u00ede aleatoriamente de forma peri\u00f3dica en el servidor, con una cadencia predeterminada. Tarea Opcional Modifica el c\u00f3digo de cliente y/o servidor para que se pueda cambiar remotamente la cadencia de cambio del valor sensorizado.","title":"Pr\u00e1ctica 7"},{"location":"RPI-I/P7/#practica-7-ble-mesh","text":"","title":"Pr\u00e1ctica 7. BLE Mesh"},{"location":"RPI-I/P7/#objetivos","text":"Poner en pr\u00e1ctica los conceptos estudiados en teor\u00eda en relaci\u00f3n a BLE MESH, espec\u00edficamente provisionamiento y modelos cliente/servidor. Desplegar una infraestructura de provisionamiento de un modelo ONOFF GENERIC SERVER con provisionamiento desde aplicaci\u00f3n m\u00f3vil para el control remoto de encendido/apagado LED. Desplegar una infraestructura de provisionamiento de un modelo GENERIC SENSOR con provisionamiento desde ESP32.","title":"Objetivos"},{"location":"RPI-I/P7/#estructura-de-la-practica","text":"Esta pr\u00e1ctica est\u00e1 dividida en dos partes. En la primera parte trabajaremos un ejemplo de modelo gen\u00e9rico ON-OFF (bluetooth/esp_ble_mesh/ble_mesh_node), en el que se simular\u00e1 una red dom\u00f3tica con un interruptor y varias luces conectadas a una red BLE-Mesh (o un s\u00f3lo led rgb). Si disponemos de ellos, podemos conectar leds a los pines GPIO indicados en el fichero board.h para ver f\u00edsicamente el efecto del encendido y apagado de las luces. En la segunda parte trabajaremos un ejemplo de modelo sensor (ble_mesh_sensor_model), en el que un sensor enviar\u00e1 informaci\u00f3n de un sensor virtual (simulado con n\u00fameros aleatorios) que enviar\u00e1 a los clientes conectados en la red BLE-Mesh. Tarea Escribe un informe en el que describas cada una de las tareas propuestas, su desarrollo y los resultados obeservados, as\u00ed como tus observaciones o comentarios personales.","title":"Estructura de la pr\u00e1ctica"},{"location":"RPI-I/P7/#requisitos-previos","text":"En segundo lugar, deber\u00e1s rellenar la hoja Excel correspondiente a tu puesto con la direcci\u00f3n MAC Bluetooth de tu dispositivo, que podr\u00e1s obtener con cualquier mecanismo que hayas utilizado en pr\u00e1cticas anteriores. Los c\u00f3digos que estudiaremos en la pr\u00e1ctica se encuentran en el directorio examples/bluetooth/esp_ble_mesh/ble_mesh_node en el caso del sistema OnOff (primera parte de la pr\u00e1ctica) y ble_mesh_sensor_model en el caso del modelo sensor (segunda parte de la pr\u00e1ctica). Por \u00faltimo, descarga e instala la aplicaci\u00f3n (disponible para Android e IOS) nRF Mesh .","title":"Requisitos previos"},{"location":"RPI-I/P7/#modelo-generico-on-off","text":"","title":"Modelo gen\u00e9rico ON-OFF"},{"location":"RPI-I/P7/#el-servidor-on-off","text":"El servidor implementa un \u00fanico elemento, en el cual se integran dos modelos distintos: Modelo Configuration Server , que implementa la configuraci\u00f3n de claves de aplicaci\u00f3n ( AppKey ), as\u00ed como configuraciones gen\u00e9ricas del servidor como suscripciones, tama\u00f1o de TTL o funcionalidad de relay de mensajes. Modelo Generic OnOff Server , que implementa la funcionalidad b\u00e1sica de encendido/apagado de una luz. El c\u00f3digo en el fichero main.c contiene la funcionalidad b\u00e1sica del servidor, que podemos resumir en: Inicializaci\u00f3n de la pila BLE ( bluedroid ). Inicializaci\u00f3n de la pila BLE Mesh. Registro de las funciones de callback para el proceso de provisionamiento y del modelo o modelos implementados. Implementaci\u00f3n e inicializaci\u00f3n del elemento BLE Mesh. Implementaci\u00f3n e inicializaci\u00f3n del modelo Configuration Server y Generic OnOff Server . Soporte para operaciones Get Opcode y Set Opcode en el modelo de configuraci\u00f3n.","title":"El servidor ON-OFF"},{"location":"RPI-I/P7/#analisis-basico-de-codigo","text":"Inicializaci\u00f3n y activaci\u00f3n de la pila BLE Mesh Tras la inicializaci\u00f3n del sistema, la tarea principal ( app_main ) se encarga de la incializaci\u00f3n de las pilas BLE y BLE Mesh: void app_main(void) { int err; ESP_LOGI(TAG, \"Initializing...\"); board_init(); err = bluetooth_init(); if (err) { ESP_LOGE(TAG, \"esp32_bluetooth_init failed (err %d)\", err); return; } /* Initializes the Bluetooth Mesh Subsystem */ err = ble_mesh_init(); if (err) { ESP_LOGE(TAG, \"Bluetooth mesh init failed (err %d)\", err); } } En particular, el c\u00f3digo incluye invocaciones a bluetooth_init() y ble_mesh_init() , que se encargan de ambas inicializaciones. La inicializaci\u00f3n de la pila BLE Mesh requiere alguna explicaci\u00f3n adicional: static esp_err_t ble_mesh_init(void) { int err = 0; memcpy(dev_uuid + 2, esp_bt_dev_get_address(), BLE_MESH_ADDR_LEN); // See comment 1 esp_ble_mesh_register_prov_callback(esp_ble_mesh_prov_cb); esp_ble_mesh_register_custom_model_callback(esp_ble_mesh_model_cb); err = esp_ble_mesh_init(&provision, &composition); if (err) { ESP_LOGE(TAG, \"Initializing mesh failed (err %d)\", err); return err; } esp_ble_mesh_node_prov_enable(ESP_BLE_MESH_PROV_ADV | ESP_BLE_MESH_PROV_GATT); ESP_LOGI(TAG, \"BLE Mesh Node initialized\"); board_led_operation(LED_G, LED_ON); return err; } Observa que el c\u00f3digo incluye la siguiente funcionalidad: esp_ble_mesh_register_prov_callback(esp_ble_mesh_prov_cb) : registra la funci\u00f3n de callback para la pila BLE Mesh. Esta funci\u00f3n se ejecuta durante el proceso de configuraci\u00f3n, y permite a la pila BLE Mesh generar eventos y notificar a la aplicaci\u00f3n sobre hitos importantes en el proceso de configuraci\u00f3n. Los eventos principales que pueden emitirse son: ESP_BLE_MESH_PROVISION_REGISTER_COMP_EVT : generado cuando se completa el proceso de incializaci\u00f3n de BLE Mesh. ESP_BLE_MESH_NODE_PROV_LINK_OPEN_EVT : generado cuando un provisionador y un dispositivo no provisionado establecen un enlace. ESP_BLE_MESH_NODE_PROV_LINK_CLOSE_EVT : generado para notificar a la aplicaci\u00f3n que se ha roto un enlace con un dispositivo asociado. ESP_BLE_MESH_NODE_PROV_COMPLETE_EVT : recibido por la aplicaci\u00f3n cuando el proceso de provisionamiento se completa. esp_ble_mesh_register_custom_model_callback(esp_ble_mesh_model_cb) : registra la funci\u00f3n de callback asociada al modelo. Esta funci\u00f3n se utiliza cuando el otro extremo de la comunicaci\u00f3n solicita operaciones sobre el modelo, y es capaz de emitir los siguientes eventos principales: ESP_BLE_MESH_MODEL_OPERATION_EVT : se puede generar en dos situaciones: El modelo servidor recibe un Get Status o Set Status desde un modelo cliente. El modelo cliente recibe un Status State desde un modelo servidor. ESP_BLE_MESH_MODEL_SEND_COMP_EVT : generado despu\u00e9s de que el modelo servidor env\u00ede un Status State a trav\u00e9s de la funci\u00f3n esp_ble_mesh_server_model_send_msg . ESP_BLE_MESH_MODEL_PUBLISH_COMP_EVT : generado despu\u00e9s de que la aplicaci\u00f3n complete la invocaci\u00f3n a esp_ble_mesh_model_publish_msg para publicar mensajes. ESP_BLE_MESH_CLIENT_MODEL_SEND_TIMEOUT_EVT : generado cuando el modelo cliente invoca a la funci\u00f3n esp_ble_mesh_client_model_send_msg , pero no recibe mensaje de ACK de vuelta. ESP_BLE_MESH_MODEL_PUBLISH_UPDATE_EVT : generado despu\u00e9s de que la aplicaci\u00f3n configure la funci\u00f3n de publicaci\u00f3n para enviar de forma peri\u00f3dica mensajes al otro extremo. esp_ble_mesh_node_prov_enable(ESP_BLE_MESH_PROV_ADV | ESP_BLE_MESH_PROV_GATT) : activa el proceso de Anuncio y Escaneo, haciendo visible al dispositivo para potenciales provisionadores que est\u00e9n a la escucha. board_led_operation(LED_G, LED_ON) : inicializa un hipot\u00e9tico LED RGB, que se controlar\u00e1 remotamente. En este punto, la inicializaci\u00f3n de la pila BLE Mesh deber\u00eda estar completa, por lo que un provisionador podr\u00eda identificar dispositivos para privisonamiento de par\u00e1metros de red y transmisi\u00f3n de datos.","title":"An\u00e1lisis b\u00e1sico de c\u00f3digo"},{"location":"RPI-I/P7/#implementacion-de-la-estructura-ble-mesh-element","text":"A continuaci\u00f3n, se detallan los pasos necesarios para, en el servidor: Completar la inicializaci\u00f3n del sistema. A\u00f1adir un elemento y un modelo al servidor. Elegir distintas implementaciones de encriptaci\u00f3n. Declarar las caracter\u00edsticas de Proxy , Relay , Low Power y Friend del nodo. En primer lugar, para declarar y definir un elemento y un modelo asociado, utilizaremos las siguientes estructuras: /*!< Abstraction that describes a BLE Mesh Element. This structure is associated with bt_mesh_elem in mesh_access.h */ typedef struct { /* Element Address, it is assigned during provisioning. */ uint16_t element_addr; /* Location Descriptor (GATT Bluetooth Namespace Descriptors) */ const uint16_t location; /* Model count */ const uint8_t sig_model_count; const uint8_t vnd_model_count; /* Models */ esp_ble_mesh_model_t *sig_models; esp_ble_mesh_model_t *vnd_models; } esp_ble_mesh_elem_t; As\u00ed, podemos mantener informaci\u00f3n sobre los elementos disponibles en el vector elements : static esp_ble_mesh_elem_t elements[] = { ESP_BLE_MESH_ELEMENT(0, root_models, ESP_BLE_MESH_MODEL_NONE), ESP_BLE_MESH_ELEMENT(0, extend_model_0, ESP_BLE_MESH_MODEL_NONE), ESP_BLE_MESH_ELEMENT(0, extend_model_1, ESP_BLE_MESH_MODEL_NONE), }; D\u00f3nde la macro ESP_BLE_MESH_ELEMEN se utiliza para inicializar los campos de la estructura esp_ble_mesh_elem_t : #define ESP_BLE_MESH_ELEMENT(_loc, _mods, _vnd_mods) \\ { \\ .location = (_loc), \\ .sig_model_count = ARRAY_SIZE(_mods), \\ .sig_models = (_mods), \\ .vnd_model_count = ARRAY_SIZE(_vnd_mods), \\ .vnd_models = (_vnd_mods), \\ } Las variables de la estructura son las siguientes: addr : almacena la direcci\u00f3n del elemento primario, usado por la pila ble mesh durante la inicializaci\u00f3n. Puede ser ignorado por las aplicaciones. loc : descriptor location definido por el SIG. En este ejemplo se pone a 0 . model_count : n\u00famero de modelos soportados por este elemento. vnd_model_count : n\u00famero de modelos de vendedor soportados por este elemento. models : puntero al array de modelos ya definidos. vnd_models : puntero al array de modelos de vendedor ya definidos (ninguno en nuestro ejemplo). Como vemos, cada elemento usa un array del tipo ble_mesh_model_t para identificar los modelos implementados por el elemento, como es el array root_models en nuestro c\u00f3digo de ejemplo. static esp_ble_mesh_model_t root_models[] = { ESP_BLE_MESH_MODEL_CFG_SRV(&config_server), ESP_BLE_MESH_MODEL_GEN_ONOFF_SRV(&onoff_pub_0, &onoff_server_0), }; Distintos modelos requieren diferentes macros (en este caso, ya que vamos a implementar un modelo Generic OnOff Server , hemos utilizado ESP_BLE_MESH_MODEL_GEN_ONOFF_SRV ).","title":"Implementaci\u00f3n de la estructura BLE Mesh Element"},{"location":"RPI-I/P7/#el-cliente-on-off","text":"El cliente resulta mucho m\u00e1s sencillo en su funcionamiento. El c\u00f3digo de ejemplo es (ble_mesh_node/onoff_client). De forma gen\u00e9rica, simplemente define un modelo Client ON/OFF y espera a ser provisionado. Una vez completado el proceso de provisionamento, espera a la pulsaci\u00f3n de uno de los botones en la placa (RESET) para el env\u00edo a todos los nodos en la misma red de una solicitud de modificaci\u00f3n en el estado de activaci\u00f3n de las luces. Concretamente, nos interesan las siguientes definiciones. En el fichero board.c , observa la respusta a la pulsaci\u00f3n del bot\u00f3n: static void button_tap_cb(void* arg) { ESP_LOGI(TAG, \"tap cb (%s)\", (char *)arg); example_ble_mesh_send_gen_onoff_set(); } static void board_button_init(void) { button_handle_t btn_handle = iot_button_create(BUTTON_IO_NUM, BUTTON_ACTIVE_LEVEL); if (btn_handle) { iot_button_set_evt_cb(btn_handle, BUTTON_CB_RELEASE, button_tap_cb, \"RELEASE\"); } } void board_init(void) { board_led_init(); board_button_init(); } La funci\u00f3n invocada, example_ble_mesh_send_gen_onoff_set() (definida en el fichero main.c ), realiza el env\u00edo de una operaci\u00f3n de tipo SET a todos los miembros de la red : void example_ble_mesh_send_gen_onoff_set(void) { esp_ble_mesh_generic_client_set_state_t set = {0}; esp_ble_mesh_client_common_param_t common = {0}; esp_err_t err = ESP_OK; common.opcode = ESP_BLE_MESH_MODEL_OP_GEN_ONOFF_SET_UNACK; common.model = onoff_client.model; common.ctx.net_idx = store.net_idx; common.ctx.app_idx = store.app_idx; common.ctx.addr = 0xFFFF; /* to all nodes */ common.ctx.send_ttl = 3; common.ctx.send_rel = false; common.msg_timeout = 0; /* 0 indicates that timeout value from menuconfig will be used */ common.msg_role = ROLE_NODE; set.onoff_set.op_en = false; set.onoff_set.onoff = store.onoff; set.onoff_set.tid = store.tid++; err = esp_ble_mesh_generic_client_set_state(&common, &set); if (err) { ESP_LOGE(TAG, \"Send Generic OnOff Set Unack failed\"); return; } store.onoff = !store.onoff; mesh_example_info_store(); /* Store proper mesh example info */ } Observa c\u00f3mo el mensaje se enviar\u00e1 a todos los nodos de la red ( common.ctx.addr = 0xFFFF; ).","title":"El cliente ON-OFF"},{"location":"RPI-I/P7/#provisionamiento-y-control-desde-una-aplicacion-movil","text":"En primer lugar, nos dividiremos en grupos de 3-4 personas. Uno de vosotros, utilizando la aplicaci\u00f3n m\u00f3vil nRF Mesh , actuar\u00e1 como provisionador de la red, proporcionando claves de red y aplicaci\u00f3n, as\u00ed como informaci\u00f3n b\u00e1sica de red (por ejemplo, direcciones unicast). Adem\u00e1s, podr\u00e1 crear grupos y suscribir/desuscribir modelos a dichos grupos. Adem\u00e1s, se requiere que uno de vuestros ESP32 act\u00fae como cliente, y el resto como servidores. As\u00ed, emularemos una sala con m\u00faltiples luces, y un s\u00f3lo interruptor que controlar\u00e1 su estado de encendido/apagado. PASO 1 : en la pantalla inicial se nos mostrar\u00e1n los nodos ya provisionados. En nuestro caso, inicialmente ninguno. PASO 2 : pincharemos sobre ADD NODE , y provisionaremos, uno a uno, todos los nodos que deseemos que formen parte de nuestra red (s\u00f3lo aquellos que forman parte de tu grupo de compa\u00f1eros): PASO 3 : antes de provisionar, generamos informaci\u00f3n de red para el nuevo nodo (lo identificamos ), presionando en IDENTIFY : PASO 4 : una vez generada la informaci\u00f3n de red, provisionamos el nodo ( PROVISION ): PASO 5 : si todo ha ido bien, se nos mostrar\u00e1 un mensaje de \u00e9xito como el siguiente: PASO 6 : tras repetir este paso con todos los nodos de nuestro grupo, veremos una pantalla como la siguiente. Observa y anota las direcciones unicast de cada nodo. Los nodos con un elemento son el cliente OnOff; los nodos con tres elementos son los servidores OnOff: A continuaci\u00f3n, generar\u00e1s un grupo de nodos. Esto nos permitir\u00e1 suscribir a modelos al mismo, y publicar mensajes que se transmitir\u00e1n a todos los modelos del grupo. PASO 7 : crea un nuevo grupo pulsando el bot\u00f3n + . Dale el nombre y la direcci\u00f3n que desees, por ejemplo, Sala de Estar , 0xC000 . Si todo ha ido bien, se especificar\u00e1 que en el \u00fanico grupo disponible no hay ning\u00fan dispositivo suscrito/asociado. A continuaci\u00f3n, suscribiremos a cada modelo de los servidores y clientes (de tipo Generic On Off Server y Generic On Off Client ) al grupo creado. Esto lo har\u00e1s nodo a nodo, en primer lugar pincando en el modelo concreto: Y a continuaci\u00f3n asociando una clave de aplicaci\u00f3n ( BIND KEY ) y suscribiendo ( SUBSCRIBE ) al grupo deseado: Ahora, si vuelves a la descripci\u00f3n del grupo, ver\u00e1s que, tras pinchar, observas dos luces (o una por servidor) y un interruptor (correspondiente al cliente): En este punto, si est\u00e1s monitorizando la salida de todos los ESP32, ver\u00e1s que el estado del LED cambia a petici\u00f3n de la aplicaci\u00f3n. Adem\u00e1s, ver\u00e1s que tambi\u00e9n cambia si presionas el bot\u00f3n correspondiente del interruptor ( RESET ) en la placa. Tarea El cliente env\u00eda, tras presionar un bot\u00f3n, el mensaje de tipo SET a todos los nodos de la red. Modif\u00edcalo para que \u00fanicamente se env\u00ede a los pertenecientes a tu grupo. Prueba a suscribir/desuscribir un modelo del grupo, y ver\u00e1s como ya no recibe los mensajes de solicitud de modificaci\u00f3n de estado.","title":"Provisionamiento y control desde una aplicaci\u00f3n m\u00f3vil"},{"location":"RPI-I/P7/#modelo-sensor","text":"En este ejemplo (ble_mesh_sensor_model), se implementa la creaci\u00f3n de un cliente de modelo sensor que, adem\u00e1s, es provisionador, y un servidor de modelo sensor configurable. El modelo Sensor Server es un modelo que permite exponer series de datos de sensorizaci\u00f3n. El modelo Sensor Client se usa para consumir valores de sensorizaci\u00f3n ( Sensor states ) expuestos por el servidor. Estos estados se componen de las siguientes partes: Estado Sensor Descriptor . Describe los datos del sensor, y es inmutable durante su vida. Estado Sensor Setting . Controla los par\u00e1metros del sensor. Por ejemplo, podr\u00eda indicar su sensibilidad, y podr\u00eda ser ajustado remotamente para prevenir que un sensor de movimiento se disparase ante peque\u00f1os movimientos. Estado Sensor Cadence . Controla la cadencia de sensorizaci\u00f3n. Estado Sensor Data . Contiene los valores de sensorizaci\u00f3n. Realmente, representa uno o m\u00e1s pares Property ID - Valor . Estado Sensor Series Column . S\u00f3lo utilizado si se considera cada uno de los valores como perteneciente a una serie de datos. En el ejemplo client , el dispositivo es a la vez un provisionador y un cliente. Una vez el dispositivo servidor es provisionado y configurado, los usuarios pueden presionar el bot\u00f3n de la placa para enviar al servidor peticiones que, sucesivamente, devolver\u00e1n el siguiente estado del sensor en orden ( Descriptor , Setting , Cadence , ...). En el ejemplo server , el dispositivo no provisonado implementa un modelo Sensor Server . El servidor soporta dos instancias de estados: la pimrea ( Property ID 0x0056 ) representar\u00eda la temperatura Indoor ; la segunda ( Property ID 0x005B ) representar\u00eda la temperatura Outdoor . Todos los datos, en estos ejemplos, est\u00e1n preinicializados.","title":"Modelo sensor"},{"location":"RPI-I/P7/#puesta-en-marcha","text":"En primer lugar, arranca en tu grupo un nodo cliente/provisionador, y monitoriza su salida. Cuando un compa\u00f1ero/a arranque un nodo servidor, ver\u00e1s que es provisionado por tu cliente, otorg\u00e1ndole una direcci\u00f3n unicast. An\u00f3tala. El funcionamiento general del sistema es: El dispositivo A ejecuta el ejemplo client , y el dispositivo B ejecuta el ejemplo server . A act\u00faa como provisionador. Tras recibir una petici\u00f3n por parte de B, lo provisiona y almacena su direcci\u00f3n. Observar\u00e1s la MAC BLE (UUID) de B en el proceso de provisionamiento desde A. En A, cada pulsaci\u00f3n del bot\u00f3n supondr\u00e1 una petici\u00f3n al nodo B. Sucesivamente, estas peticiones ser\u00e1n, en orden y por cada pulsaci\u00f3n: Sensor Descriptor . Sensor Cadence . Sensor Settings . Sensor Data . Sensor Series . Tarea Estudia el c\u00f3digo del cliente y del servidor, y observa a qu\u00e9 nodo se env\u00edan las peticiones desde el cliente, qu\u00e9 operaciones se solicitan en cada pulsaci\u00f3n de bot\u00f3n, y qu\u00e9 datos devuelve el servidor en cada caso. Tarea Modifica el c\u00f3digo de cliente y/o servidor para que los valores de sensorizaci\u00f3n que se consulten en cada pulsaci\u00f3n del bot\u00f3n no sean todos los del modelo del \u00faltimo nodo provisonado, como ahora se hace, sino \u00fanicamente los datos de sensorizaci\u00f3n ( Sensor Data State ) de todos los nodos provisionados. As\u00ed, si hay tres nodos provisionados, cada pulsaci\u00f3n nos devolver\u00e1 el valor de sensorizaci\u00f3n de uno de ellos, por orden de provisionamiento. Tarea Como funcionalidad adicional, s\u00f3lo se provisionar\u00e1 autom\u00e1ticamente a aquellos nodos autorizados (los que pertenecen a tu sala, por ejemplo). Tarea Por \u00faltimo, se pide que el valor sensorizado var\u00ede aleatoriamente de forma peri\u00f3dica en el servidor, con una cadencia predeterminada. Tarea Opcional Modifica el c\u00f3digo de cliente y/o servidor para que se pueda cambiar remotamente la cadencia de cambio del valor sensorizado.","title":"Puesta en marcha"},{"location":"RPI-I/P8/","text":"Pr\u00e1ctica 8. 8012.15.4 y Thread Demo en clase.","title":"Pr\u00e1ctica 8"},{"location":"RPI-I/P8/#practica-8-8012154-y-thread","text":"Demo en clase.","title":"Pr\u00e1ctica 8. 8012.15.4 y Thread"},{"location":"RPI-I/P9/","text":"Pr\u00e1ctica 9. 6LowPAN con simulador Cooja Introducci\u00f3n y objetivos Los routers de borde son enrutadores que pueden encontrarse en el borde de una red, encaminando el tr\u00e1fico de dicha red hacia una segunda red externa. Su funci\u00f3n, en definitiva, es conectar una red con otra. En esta pr\u00e1ctica, usaremos el simulador Cooja, del proyecto Contiki-ng, para construir una red de nodos que se comuniquen por 6LowPAN, usando RPL como algoritmo de encaminamiento. Los nodos simulados usan el RTOS de Contiki-ng. Veremos c\u00f3mo un router de borde puede utilizarse para enrutar tr\u00e1fico entre una red RPL (una red de sensores simulada) y una red IPv4 externa, siguiendo el siguiente diagrama: El objetivo de la pr\u00e1ctica es ofrecer una visi\u00f3n general sobre c\u00f3mo desplegar tanto una red RPL con Contiki-ng en el simulador Cooja, as\u00ed como conseguir hacerla interactuar con una segunda red externa real utilizando la herramienta tunslip . Tarea Escribe un informe en el que describas cada una de las tareas propuestas, su desarrollo y los resultados obeservados, as\u00ed como tus observaciones o comentarios personales. Instalaci\u00f3n de Cooja Damos a los alumnos dos alternativas para instalar el simulador cooja en su equipo: La instalaci\u00f3n con contenedores docker, o La copia de una m\u00e1quina virtual de virtualbox creada por el profesor. Alternativa 1: Instalaci\u00f3n con Docker A continuaci\u00f3n indicamos los pasos a seguir para realizar la instalaci\u00f3n del software necesario en un sistema GNU/Linux. Los detalles de instalaci\u00f3n para Windows y Mac OS X est\u00e1n detallados en la getting started guide de Contiki-ng . Comenzaremos por instalar docker si no lo tenemos instalado ya, haciendo: sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin Si nuestro usuario no pertenece al grupo docker, lo a\u00f1adimos: sudo usermod -aG docker <your-user> Despu\u00e9s de a\u00f1adirlo deberemos salir de la sesi\u00f3n de escritorio y volver a entrar para que se actualice la lista de grupos del usuario. A continuaci\u00f3n descargaremos la imagen del contenedor de Contiki-ng: docker pull contiker/contiki-ng Esto descarga la imagen contiker/contiki-ng:latest. Podr\u00edamos cambiar el tag de la imagen por otra anterior si no interesase por alg\u00fan motivo. Una vez descargada la image clonaremos el repositorio git de contiki (por ejemplo en nuestro directorio home), de forma que podamos editar los ficheros desde la m\u00e1quina host: git clone https://github.com/contiki-ng/contiki-ng.git cd contiki-ng git submodule update --init --recursive A continuaci\u00f3n crearemos el script $HOME/.local/bin/contiker que usaremos en el futuro para lanzar el contenedor. El contenido de este script ser\u00e1: #!/bin/bash export CNG_PATH=$HOME/contiki-ng xhost +SI:localuser:$(id -un) docker run --privileged --sysctl net.ipv6.conf.all.disable_ipv6=0 \\ --mount type=bind,source=$CNG_PATH,destination=/home/user/contiki-ng \\ -e DISPLAY=$DISPLAY -e LOCAL_UID=$(id -u $USER) -e LOCAL_GID=$(id -g $USER) \\ -v /tmp/.X11-unix:/tmp/.X11-unix -v /dev/bus/usb:/dev/bus/usb \\ -ti contiker/contiki-ng xhost -SI:localuser:$(id -un) En este momento, si tenemos a\u00f1adida la ruta $HOME/.local/bin en la variable PATH , podemos ejecutar el contenedor de contiki-ng ejecutando el script contiker; y una vez dentro del contenedor ejecutar el simulador cooja: $ contiker localuser:christian being added to access control list To run a command as administrator (user \"root\"), use \"sudo <command>\". See \"man sudo_root\" for details. user@6dd1f25a702d:~/contiki-ng$ cooja La primera vez que lo ejecutemos tardar\u00e1 un poco porque se descargar\u00e1 una serie de ficheros java necesarios para el simulador. Es posible que se produzca un error en la resoluci\u00f3n de nombres (DNS). En ese caso debemos configurar el dns de docker: dockerd --dns 8.8.8.8 Si queremos ahorrar el tiempo de descarga de los ficheros jar podemos modificar la imagen del docker: $ docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 77675abad9f3 contiker/contiki-ng \"/usr/local/bin/rema\u2026\" 10 seconds ago Up 9 seconds hardcore_kilby $ docker commit hardcore_kilby contiker/contiki-ng-cooja No te olvides en este caso de actualizar el script contiker para que use la nueva imagen, y si quieres puedes borrar la imagen anterior. Alternativa 2: Uso de M\u00e1quina Virtual Si no tenemos instalado Virtualbox en nuestro equipo lo primero que haremos ser\u00e1 instalarlo, descargando el instalable de su p\u00e1gina web de Oracle Virtualbox . A continuaci\u00f3n descargaremos la m\u00e1quina virtual debian con contiki-ng instalado de este enlace de Google Drive . Se trata de un fichero ova, que tendremos que importar en Virtualbox. Para ello abrimos la aplicaci\u00f3n y seleccionamos File->Import Appliance, y seleccionamos el fichero descargado. Una vez importado podemos arrancar la m\u00e1quina virtual, el usuario es user y la contrase\u00f1a contiki . Para arrancar el simulador bastar\u00e1 con abrir un terminal y ejecutar el comando cooja . El repositorio de contiki-ng est\u00e1 en una directorio del mismo nombre dentro del home del usuario user . C\u00f3digo Contiki En el desarrollo de la pr\u00e1ctica utilizaremos algunos de los ejemplos de la instalaci\u00f3n de contiki-ng (en el directorio contiki-ng/examples): rpl-border-router/border_router.c : que contendr\u00e1 la l\u00f3gica de enrutamiento del router de borde, que ser\u00e1 la raiz del DODAG. hello-world/hello-world.c : que ejecutar\u00e1n el resto de nodos de la red RPL. Los nodos que implementen el c\u00f3digo hello-world.c formar\u00e1n un DAG con el router de borde configurado como ra\u00edz. El router de borde recibir\u00e1 el prefijo de red v\u00eda una conexi\u00f3n SLIP ( Serial Line Interface Protocol ) y lo comunicar\u00e1 al resto de nodos de la red RPL para que conformen sus respectivas direcciones IPv6 globales. Una vez recibido el prefijo, el router de borde se configura como la ra\u00edz del DODAG y env\u00eda el prefijo al resto de nodos de la red. Simulaci\u00f3n en Cooja Para crear una simulaci\u00f3n completa en Cooja arrancamos el simulador usando la siguiente orden: To run a command as administrator (user \"root\"), use \"sudo <command>\". See \"man sudo_root\" for details. user@e2d84745c836:~/contiki-ng$ cooja Si usamos la m\u00e1quina virtual s\u00f3lo tenemos que ejecutar cooja desde un terminal. De aqu\u00ed en adelante se pueden ignorar todos los detalles relativos a Docker si hemos optado por utilizar la m\u00e1quina virtual de Virtualbox. Dependiendo de si usamos la imagen original del contenedor de contiki-ng o si la hemos modificado para almacenar los jar descargados por la ejecuci\u00f3n de cooja, la primera vez que lo ejecutemos puede tardar un poco, pero finalmente se abrir\u00e1 la ventana del simulador: Tras la ejecuci\u00f3n, sigue los siguientes pasos para crear una nueva simulaci\u00f3n. Primero selecciona la opci\u00f3n File->New Simulation . Selecciona UDGM e introduce el nombre de la simulaci\u00f3n. Presiona Create y se abrir\u00e1 una ventana de simulaci\u00f3n: En el men\u00fa Motes , selecciona Add New Motes->Create new motes y seleccona el tipo de mota Cooja mote . Luego selecciona como c\u00f3digo fuente el fichero del ejemplo para el router de borde: examples/rpl-border-router/rpl-border-router.c . Pulsa en Compile y luego en Create y a\u00f1ade una \u00fanica mota de este tipo. Repite los pasos anteriores para crear de 4 a 8 motas de tipo Cooja que ejecuten el ejemplo hello-world.c . Distribuyelas por la simulaci\u00f3n, vigilando que no todas est\u00e9n al alcance del router de borde pero que puedan llegar a \u00e9l pasando a trav\u00e9s de otros nodos que s\u00ed est\u00e1n a su alcance. A continuaci\u00f3n, crearemos un puente entre la red RPL simulada en Cooja y el contenedor. Para ello pulsamos en el men\u00fa Tools , Serial Socket (SERVER) y seleccionamos la mota correspondiente al router de borde (ident\u00edficala con su valor num\u00e9rico). Obtendr\u00e1s un mensaje como el de la siguiente figura (observa que el mensaje indica Listening on port 60001 ): A continuaci\u00f3n, arranca la simulaci\u00f3n (bot\u00f3n Start ). Asignando el prefijo de red Como hemos dicho, un router de borde act\u00faa como enlace para conectar una red a otra. En este ejemplo, el router de borde se usa para establecer ruta de datos entre la red RPL y el docker. Para ello, utilizaremos la utilidad tunslip6 proporcionada por Contiki-ng en el directorio tools/serial-io , y se puede compilar con la orden: make tunslip6 A continuaci\u00f3n, podemos establecer una conexi\u00f3n entre la red RPL y la m\u00e1quina local: sudo ./tunslip6 -a 127.0.0.1 aaaa::1/64 Si la ejecuci\u00f3n ha sido correcta, veremos una salida similar a la siguiente en la terminal: user@50a25697ee43:~/contiki-ng/examples/rpl-border-router$ sudo ../../tools/serial-io/tunslip6 -a 127.0.0.1 aaaa::1/64 slip connected to ``127.0.0.1:60001'' opened tun device ``/dev/tun0'' ifconfig tun0 inet `hostname` mtu 1500 up ifconfig tun0 add aaaa::1/64 ifconfig tun0 add fe80::0:0:0:1/64 ifconfig tun0 tun0: flags=4305<UP,POINTOPOINT,RUNNING,NOARP,MULTICAST> mtu 1500 inet 172.17.0.2 netmask 255.255.255.255 destination 172.17.0.2 inet6 fe80::1 prefixlen 64 scopeid 0x20<link> inet6 aaaa::1 prefixlen 64 scopeid 0x0<global> inet6 fe80::93d:daef:6b56:52a7 prefixlen 64 scopeid 0x20<link> unspec 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00 txqueuelen 500 (UNSPEC) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 [INFO: Main ] Starting Contiki-NG-develop/v4.9-749-g7a8ba26ca-dirty [INFO: Main ] - Routing: RPL Lite [INFO: Main ] - Net: sicslowpan [INFO: Main ] - MAC: CSMA [INFO: Main ] - 802.15.4 PANID: 0xabcd [INFO: Main ] - 802.15.4 Default channel: 26 [INFO: Main ] Node ID: 1 [INFO: Main ] Link-layer address: 0001.0001.0001.0001 [INFO: Main ] Tentative link-local IPv6 address: fe80::201:1:1:1 [INFO: RPL BR ] Contiki-NG Border Router Web Server Started [INFO: RPL BR ] Contiki-NG Border Router started [INFO: BR ] RPL-Border router started *** Address:aaaa::1 => aaaa:0000:0000:0000 [INFO: BR ] Waiting for prefix [INFO: BR ] Server IPv6 addresses: [INFO: BR ] aaaa::201:1:1:1 [INFO: BR ] fe80::201:1:1:1 El programa ha creado una interfaz puente tun0 con IPv4 127.0.1.1, y ha enviado, v\u00eda serie, un mensaje de configuraci\u00f3n al router de borde indicando el prefijo deseado para los nodos de la red RPL ( aaaa ). La salida de las \u00faltimas dos l\u00edneas pertenece al router de borde, e indica cu\u00e1les son sus direcciones IPv6 tras la recepci\u00f3n del prefijo. Vuelve al simulador Cooja y observa que ha aparecido un mensaje en el que se observa la cadena Client connected: /127.0.0.1 . Verificaci\u00f3n de resultados Es posible verificar la direcci\u00f3n del router de borde a trav\u00e9s de una orden ping desde tu m\u00e1quina virtual: user@50a25697ee43:~/contiki-ng/examples/rpl-border-router$ ping6 aaaa::201:1:1:1 PING aaaa::201:1:1:1(aaaa::201:1:1:1) 56 data bytes 64 bytes from aaaa::201:1:1:1: icmp_seq=1 ttl=64 time=17.7 ms 64 bytes from aaaa::201:1:1:1: icmp_seq=2 ttl=64 time=44.8 ms 64 bytes from aaaa::201:1:1:1: icmp_seq=3 ttl=64 time=10.4 ms 64 bytes from aaaa::201:1:1:1: icmp_seq=4 ttl=64 time=1.62 ms 64 bytes from aaaa::201:1:1:1: icmp_seq=5 ttl=64 time=29.2 ms 64 bytes from aaaa::201:1:1:1: icmp_seq=6 ttl=64 time=78.0 ms ^C As\u00ed como la de cualquier nodo de la red, por ejemplo el nodo 5: user@50a25697ee43:~/contiki-ng/examples/rpl-border-router$ ping6 aaaa::205:5:5:5 PING aaaa::205:5:5:5(aaaa::205:5:5:5) 56 data bytes 64 bytes from aaaa::205:5:5:5: icmp_seq=1 ttl=61 time=6.56 ms 64 bytes from aaaa::205:5:5:5: icmp_seq=2 ttl=61 time=17.2 ms 64 bytes from aaaa::205:5:5:5: icmp_seq=3 ttl=61 time=6.38 ms ^C --- aaaa::205:5:5:5 ping statistics --- 3 packets transmitted, 3 received, 0% packet loss, time 2003ms rtt min/avg/max/mdev = 6.380/10.057/17.232/5.073 ms La direcci\u00f3n de cada nodo puede obtenerse filtrando el la pantalla de log en funci\u00f3n del ID del nodo (mota) destino. Captura de paquetes para an\u00e1lisis En el simulador cooja, dentro del men\u00fa tools, podemos abrir la ventana de Radio Messages . Esta ventana nos permite capturar todos los paquetes de la simulaci\u00f3n y generar un fichero pcap para su posterior an\u00e1lisis con wireshark. Para ello seleccionamos en el men\u00fa Analyzer de la ventana de Radio Messages la opci\u00f3n 6LowPAN Analyzer with PCAP . Reiniciamos la simulaci\u00f3n anterior pulsando en el bot\u00f3n Reload en la ventana de Cooja. Esto habr\u00e1 cortado la comunicaci\u00f3n con el host, por lo que debemos volver a ejecutar la herramienta tunslip6: sudo ./tunslip6 -a 127.0.0.1 aaaa::1/64 Ahora estamos listos para volver a simular la red capturando todos los paquetes enviados entre los nodos, pulsando para ello el bot\u00f3n Start de la ventana de Cooja. Dejamos simular un rato y luego paramos la simulaci\u00f3n. Cooja habr\u00e1 generado un fichero radiolog-<n>.pcap , d\u00f3nde <n> ser\u00e1 un n\u00famero aleatorio, en el directorio desde el que lanzamos cooja: /home/user/contiki-ng . Este direcorio es el que se ha mapeado con el direcorio del host donde clonamos el repositorio de contiki-ng, por lo que podemos abrir el fichero con el analizador de red Wireshark instalado en nuestro sistema operativo host (inst\u00e1lalo si no lo tienes instalado ya). Con wireshark podemos filtrar los paquetes relacionados con el protocolo RPL, y buscar los paquetes con Destination Advertisement Objects , que los nodos env\u00edan hacia la raiz indicando el nodo que han elegido como padre. Por ejemplo, en la siguiente figura podemos ver que el nodo 3 env\u00eda su DAO indicando que escoge al nodo 4 como padre: Esto es razonable para la topolog\u00eda escogida en la simulaci\u00f3n en la que el nodo 3 no tiene al nodo 1 al alcance de radio, pero s\u00ed al nodo 4, que est\u00e1 a un salto del nodo raiz: Tarea Sigue los pasos descritos arriba para crear una red RPL con un n\u00famero reducido de nodos (entre 5 y 10), conect\u00e1ndola a tu red local. Haz que no todos los nodos est\u00e9n al alcance del router de borde, y comienza tu simulaci\u00f3n. Comprueba la conectividad con todos ellos v\u00eda ping6 y documenta el proceso en la memoria de la pr\u00e1ctica. Tarea Con una ejecuci\u00f3n de ping6 activa sobre una mota al alcance directo del router de borde, cambia la posici\u00f3n de la mota para que necesite al menos un salto intermedio para llegar a la raiz. Reporta el tiempo que tarda RPL en hacer converger de nuevo el DODAG. Documenta el proceso y tus observaciones. Tarea Captura los mensajes enviados por los nodos en un fichero pcap . Estudia y reporta en tu informe de la pr\u00e1ctica el tr\u00e1fico RPL generado en el proceso de construcci\u00f3n del DAG. Deduce a partir de esta informaci\u00f3n la topolog\u00eda de red que se est\u00e1 usando, identificando el padre preferente de cada nodo. Para ello debes usar la informaci\u00f3n transmitida en los paquetes DAO.","title":"Pr\u00e1ctica 9. 6LowPAN con simulador Cooja"},{"location":"RPI-I/P9/#practica-9-6lowpan-con-simulador-cooja","text":"","title":"Pr\u00e1ctica 9. 6LowPAN con simulador Cooja"},{"location":"RPI-I/P9/#introduccion-y-objetivos","text":"Los routers de borde son enrutadores que pueden encontrarse en el borde de una red, encaminando el tr\u00e1fico de dicha red hacia una segunda red externa. Su funci\u00f3n, en definitiva, es conectar una red con otra. En esta pr\u00e1ctica, usaremos el simulador Cooja, del proyecto Contiki-ng, para construir una red de nodos que se comuniquen por 6LowPAN, usando RPL como algoritmo de encaminamiento. Los nodos simulados usan el RTOS de Contiki-ng. Veremos c\u00f3mo un router de borde puede utilizarse para enrutar tr\u00e1fico entre una red RPL (una red de sensores simulada) y una red IPv4 externa, siguiendo el siguiente diagrama: El objetivo de la pr\u00e1ctica es ofrecer una visi\u00f3n general sobre c\u00f3mo desplegar tanto una red RPL con Contiki-ng en el simulador Cooja, as\u00ed como conseguir hacerla interactuar con una segunda red externa real utilizando la herramienta tunslip . Tarea Escribe un informe en el que describas cada una de las tareas propuestas, su desarrollo y los resultados obeservados, as\u00ed como tus observaciones o comentarios personales.","title":"Introducci\u00f3n y objetivos"},{"location":"RPI-I/P9/#instalacion-de-cooja","text":"Damos a los alumnos dos alternativas para instalar el simulador cooja en su equipo: La instalaci\u00f3n con contenedores docker, o La copia de una m\u00e1quina virtual de virtualbox creada por el profesor.","title":"Instalaci\u00f3n de Cooja"},{"location":"RPI-I/P9/#alternativa-1-instalacion-con-docker","text":"A continuaci\u00f3n indicamos los pasos a seguir para realizar la instalaci\u00f3n del software necesario en un sistema GNU/Linux. Los detalles de instalaci\u00f3n para Windows y Mac OS X est\u00e1n detallados en la getting started guide de Contiki-ng . Comenzaremos por instalar docker si no lo tenemos instalado ya, haciendo: sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin Si nuestro usuario no pertenece al grupo docker, lo a\u00f1adimos: sudo usermod -aG docker <your-user> Despu\u00e9s de a\u00f1adirlo deberemos salir de la sesi\u00f3n de escritorio y volver a entrar para que se actualice la lista de grupos del usuario. A continuaci\u00f3n descargaremos la imagen del contenedor de Contiki-ng: docker pull contiker/contiki-ng Esto descarga la imagen contiker/contiki-ng:latest. Podr\u00edamos cambiar el tag de la imagen por otra anterior si no interesase por alg\u00fan motivo. Una vez descargada la image clonaremos el repositorio git de contiki (por ejemplo en nuestro directorio home), de forma que podamos editar los ficheros desde la m\u00e1quina host: git clone https://github.com/contiki-ng/contiki-ng.git cd contiki-ng git submodule update --init --recursive A continuaci\u00f3n crearemos el script $HOME/.local/bin/contiker que usaremos en el futuro para lanzar el contenedor. El contenido de este script ser\u00e1: #!/bin/bash export CNG_PATH=$HOME/contiki-ng xhost +SI:localuser:$(id -un) docker run --privileged --sysctl net.ipv6.conf.all.disable_ipv6=0 \\ --mount type=bind,source=$CNG_PATH,destination=/home/user/contiki-ng \\ -e DISPLAY=$DISPLAY -e LOCAL_UID=$(id -u $USER) -e LOCAL_GID=$(id -g $USER) \\ -v /tmp/.X11-unix:/tmp/.X11-unix -v /dev/bus/usb:/dev/bus/usb \\ -ti contiker/contiki-ng xhost -SI:localuser:$(id -un) En este momento, si tenemos a\u00f1adida la ruta $HOME/.local/bin en la variable PATH , podemos ejecutar el contenedor de contiki-ng ejecutando el script contiker; y una vez dentro del contenedor ejecutar el simulador cooja: $ contiker localuser:christian being added to access control list To run a command as administrator (user \"root\"), use \"sudo <command>\". See \"man sudo_root\" for details. user@6dd1f25a702d:~/contiki-ng$ cooja La primera vez que lo ejecutemos tardar\u00e1 un poco porque se descargar\u00e1 una serie de ficheros java necesarios para el simulador. Es posible que se produzca un error en la resoluci\u00f3n de nombres (DNS). En ese caso debemos configurar el dns de docker: dockerd --dns 8.8.8.8 Si queremos ahorrar el tiempo de descarga de los ficheros jar podemos modificar la imagen del docker: $ docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 77675abad9f3 contiker/contiki-ng \"/usr/local/bin/rema\u2026\" 10 seconds ago Up 9 seconds hardcore_kilby $ docker commit hardcore_kilby contiker/contiki-ng-cooja No te olvides en este caso de actualizar el script contiker para que use la nueva imagen, y si quieres puedes borrar la imagen anterior.","title":"Alternativa 1: Instalaci\u00f3n con Docker"},{"location":"RPI-I/P9/#alternativa-2-uso-de-maquina-virtual","text":"Si no tenemos instalado Virtualbox en nuestro equipo lo primero que haremos ser\u00e1 instalarlo, descargando el instalable de su p\u00e1gina web de Oracle Virtualbox . A continuaci\u00f3n descargaremos la m\u00e1quina virtual debian con contiki-ng instalado de este enlace de Google Drive . Se trata de un fichero ova, que tendremos que importar en Virtualbox. Para ello abrimos la aplicaci\u00f3n y seleccionamos File->Import Appliance, y seleccionamos el fichero descargado. Una vez importado podemos arrancar la m\u00e1quina virtual, el usuario es user y la contrase\u00f1a contiki . Para arrancar el simulador bastar\u00e1 con abrir un terminal y ejecutar el comando cooja . El repositorio de contiki-ng est\u00e1 en una directorio del mismo nombre dentro del home del usuario user .","title":"Alternativa 2: Uso de M\u00e1quina Virtual"},{"location":"RPI-I/P9/#codigo-contiki","text":"En el desarrollo de la pr\u00e1ctica utilizaremos algunos de los ejemplos de la instalaci\u00f3n de contiki-ng (en el directorio contiki-ng/examples): rpl-border-router/border_router.c : que contendr\u00e1 la l\u00f3gica de enrutamiento del router de borde, que ser\u00e1 la raiz del DODAG. hello-world/hello-world.c : que ejecutar\u00e1n el resto de nodos de la red RPL. Los nodos que implementen el c\u00f3digo hello-world.c formar\u00e1n un DAG con el router de borde configurado como ra\u00edz. El router de borde recibir\u00e1 el prefijo de red v\u00eda una conexi\u00f3n SLIP ( Serial Line Interface Protocol ) y lo comunicar\u00e1 al resto de nodos de la red RPL para que conformen sus respectivas direcciones IPv6 globales. Una vez recibido el prefijo, el router de borde se configura como la ra\u00edz del DODAG y env\u00eda el prefijo al resto de nodos de la red.","title":"C\u00f3digo Contiki"},{"location":"RPI-I/P9/#simulacion-en-cooja","text":"Para crear una simulaci\u00f3n completa en Cooja arrancamos el simulador usando la siguiente orden: To run a command as administrator (user \"root\"), use \"sudo <command>\". See \"man sudo_root\" for details. user@e2d84745c836:~/contiki-ng$ cooja Si usamos la m\u00e1quina virtual s\u00f3lo tenemos que ejecutar cooja desde un terminal. De aqu\u00ed en adelante se pueden ignorar todos los detalles relativos a Docker si hemos optado por utilizar la m\u00e1quina virtual de Virtualbox. Dependiendo de si usamos la imagen original del contenedor de contiki-ng o si la hemos modificado para almacenar los jar descargados por la ejecuci\u00f3n de cooja, la primera vez que lo ejecutemos puede tardar un poco, pero finalmente se abrir\u00e1 la ventana del simulador: Tras la ejecuci\u00f3n, sigue los siguientes pasos para crear una nueva simulaci\u00f3n. Primero selecciona la opci\u00f3n File->New Simulation . Selecciona UDGM e introduce el nombre de la simulaci\u00f3n. Presiona Create y se abrir\u00e1 una ventana de simulaci\u00f3n: En el men\u00fa Motes , selecciona Add New Motes->Create new motes y seleccona el tipo de mota Cooja mote . Luego selecciona como c\u00f3digo fuente el fichero del ejemplo para el router de borde: examples/rpl-border-router/rpl-border-router.c . Pulsa en Compile y luego en Create y a\u00f1ade una \u00fanica mota de este tipo. Repite los pasos anteriores para crear de 4 a 8 motas de tipo Cooja que ejecuten el ejemplo hello-world.c . Distribuyelas por la simulaci\u00f3n, vigilando que no todas est\u00e9n al alcance del router de borde pero que puedan llegar a \u00e9l pasando a trav\u00e9s de otros nodos que s\u00ed est\u00e1n a su alcance. A continuaci\u00f3n, crearemos un puente entre la red RPL simulada en Cooja y el contenedor. Para ello pulsamos en el men\u00fa Tools , Serial Socket (SERVER) y seleccionamos la mota correspondiente al router de borde (ident\u00edficala con su valor num\u00e9rico). Obtendr\u00e1s un mensaje como el de la siguiente figura (observa que el mensaje indica Listening on port 60001 ): A continuaci\u00f3n, arranca la simulaci\u00f3n (bot\u00f3n Start ).","title":"Simulaci\u00f3n en Cooja"},{"location":"RPI-I/P9/#asignando-el-prefijo-de-red","text":"Como hemos dicho, un router de borde act\u00faa como enlace para conectar una red a otra. En este ejemplo, el router de borde se usa para establecer ruta de datos entre la red RPL y el docker. Para ello, utilizaremos la utilidad tunslip6 proporcionada por Contiki-ng en el directorio tools/serial-io , y se puede compilar con la orden: make tunslip6 A continuaci\u00f3n, podemos establecer una conexi\u00f3n entre la red RPL y la m\u00e1quina local: sudo ./tunslip6 -a 127.0.0.1 aaaa::1/64 Si la ejecuci\u00f3n ha sido correcta, veremos una salida similar a la siguiente en la terminal: user@50a25697ee43:~/contiki-ng/examples/rpl-border-router$ sudo ../../tools/serial-io/tunslip6 -a 127.0.0.1 aaaa::1/64 slip connected to ``127.0.0.1:60001'' opened tun device ``/dev/tun0'' ifconfig tun0 inet `hostname` mtu 1500 up ifconfig tun0 add aaaa::1/64 ifconfig tun0 add fe80::0:0:0:1/64 ifconfig tun0 tun0: flags=4305<UP,POINTOPOINT,RUNNING,NOARP,MULTICAST> mtu 1500 inet 172.17.0.2 netmask 255.255.255.255 destination 172.17.0.2 inet6 fe80::1 prefixlen 64 scopeid 0x20<link> inet6 aaaa::1 prefixlen 64 scopeid 0x0<global> inet6 fe80::93d:daef:6b56:52a7 prefixlen 64 scopeid 0x20<link> unspec 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00 txqueuelen 500 (UNSPEC) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 [INFO: Main ] Starting Contiki-NG-develop/v4.9-749-g7a8ba26ca-dirty [INFO: Main ] - Routing: RPL Lite [INFO: Main ] - Net: sicslowpan [INFO: Main ] - MAC: CSMA [INFO: Main ] - 802.15.4 PANID: 0xabcd [INFO: Main ] - 802.15.4 Default channel: 26 [INFO: Main ] Node ID: 1 [INFO: Main ] Link-layer address: 0001.0001.0001.0001 [INFO: Main ] Tentative link-local IPv6 address: fe80::201:1:1:1 [INFO: RPL BR ] Contiki-NG Border Router Web Server Started [INFO: RPL BR ] Contiki-NG Border Router started [INFO: BR ] RPL-Border router started *** Address:aaaa::1 => aaaa:0000:0000:0000 [INFO: BR ] Waiting for prefix [INFO: BR ] Server IPv6 addresses: [INFO: BR ] aaaa::201:1:1:1 [INFO: BR ] fe80::201:1:1:1 El programa ha creado una interfaz puente tun0 con IPv4 127.0.1.1, y ha enviado, v\u00eda serie, un mensaje de configuraci\u00f3n al router de borde indicando el prefijo deseado para los nodos de la red RPL ( aaaa ). La salida de las \u00faltimas dos l\u00edneas pertenece al router de borde, e indica cu\u00e1les son sus direcciones IPv6 tras la recepci\u00f3n del prefijo. Vuelve al simulador Cooja y observa que ha aparecido un mensaje en el que se observa la cadena Client connected: /127.0.0.1 .","title":"Asignando el prefijo de red"},{"location":"RPI-I/P9/#verificacion-de-resultados","text":"Es posible verificar la direcci\u00f3n del router de borde a trav\u00e9s de una orden ping desde tu m\u00e1quina virtual: user@50a25697ee43:~/contiki-ng/examples/rpl-border-router$ ping6 aaaa::201:1:1:1 PING aaaa::201:1:1:1(aaaa::201:1:1:1) 56 data bytes 64 bytes from aaaa::201:1:1:1: icmp_seq=1 ttl=64 time=17.7 ms 64 bytes from aaaa::201:1:1:1: icmp_seq=2 ttl=64 time=44.8 ms 64 bytes from aaaa::201:1:1:1: icmp_seq=3 ttl=64 time=10.4 ms 64 bytes from aaaa::201:1:1:1: icmp_seq=4 ttl=64 time=1.62 ms 64 bytes from aaaa::201:1:1:1: icmp_seq=5 ttl=64 time=29.2 ms 64 bytes from aaaa::201:1:1:1: icmp_seq=6 ttl=64 time=78.0 ms ^C As\u00ed como la de cualquier nodo de la red, por ejemplo el nodo 5: user@50a25697ee43:~/contiki-ng/examples/rpl-border-router$ ping6 aaaa::205:5:5:5 PING aaaa::205:5:5:5(aaaa::205:5:5:5) 56 data bytes 64 bytes from aaaa::205:5:5:5: icmp_seq=1 ttl=61 time=6.56 ms 64 bytes from aaaa::205:5:5:5: icmp_seq=2 ttl=61 time=17.2 ms 64 bytes from aaaa::205:5:5:5: icmp_seq=3 ttl=61 time=6.38 ms ^C --- aaaa::205:5:5:5 ping statistics --- 3 packets transmitted, 3 received, 0% packet loss, time 2003ms rtt min/avg/max/mdev = 6.380/10.057/17.232/5.073 ms La direcci\u00f3n de cada nodo puede obtenerse filtrando el la pantalla de log en funci\u00f3n del ID del nodo (mota) destino.","title":"Verificaci\u00f3n de resultados"},{"location":"RPI-I/P9/#captura-de-paquetes-para-analisis","text":"En el simulador cooja, dentro del men\u00fa tools, podemos abrir la ventana de Radio Messages . Esta ventana nos permite capturar todos los paquetes de la simulaci\u00f3n y generar un fichero pcap para su posterior an\u00e1lisis con wireshark. Para ello seleccionamos en el men\u00fa Analyzer de la ventana de Radio Messages la opci\u00f3n 6LowPAN Analyzer with PCAP . Reiniciamos la simulaci\u00f3n anterior pulsando en el bot\u00f3n Reload en la ventana de Cooja. Esto habr\u00e1 cortado la comunicaci\u00f3n con el host, por lo que debemos volver a ejecutar la herramienta tunslip6: sudo ./tunslip6 -a 127.0.0.1 aaaa::1/64 Ahora estamos listos para volver a simular la red capturando todos los paquetes enviados entre los nodos, pulsando para ello el bot\u00f3n Start de la ventana de Cooja. Dejamos simular un rato y luego paramos la simulaci\u00f3n. Cooja habr\u00e1 generado un fichero radiolog-<n>.pcap , d\u00f3nde <n> ser\u00e1 un n\u00famero aleatorio, en el directorio desde el que lanzamos cooja: /home/user/contiki-ng . Este direcorio es el que se ha mapeado con el direcorio del host donde clonamos el repositorio de contiki-ng, por lo que podemos abrir el fichero con el analizador de red Wireshark instalado en nuestro sistema operativo host (inst\u00e1lalo si no lo tienes instalado ya). Con wireshark podemos filtrar los paquetes relacionados con el protocolo RPL, y buscar los paquetes con Destination Advertisement Objects , que los nodos env\u00edan hacia la raiz indicando el nodo que han elegido como padre. Por ejemplo, en la siguiente figura podemos ver que el nodo 3 env\u00eda su DAO indicando que escoge al nodo 4 como padre: Esto es razonable para la topolog\u00eda escogida en la simulaci\u00f3n en la que el nodo 3 no tiene al nodo 1 al alcance de radio, pero s\u00ed al nodo 4, que est\u00e1 a un salto del nodo raiz: Tarea Sigue los pasos descritos arriba para crear una red RPL con un n\u00famero reducido de nodos (entre 5 y 10), conect\u00e1ndola a tu red local. Haz que no todos los nodos est\u00e9n al alcance del router de borde, y comienza tu simulaci\u00f3n. Comprueba la conectividad con todos ellos v\u00eda ping6 y documenta el proceso en la memoria de la pr\u00e1ctica. Tarea Con una ejecuci\u00f3n de ping6 activa sobre una mota al alcance directo del router de borde, cambia la posici\u00f3n de la mota para que necesite al menos un salto intermedio para llegar a la raiz. Reporta el tiempo que tarda RPL en hacer converger de nuevo el DODAG. Documenta el proceso y tus observaciones. Tarea Captura los mensajes enviados por los nodos en un fichero pcap . Estudia y reporta en tu informe de la pr\u00e1ctica el tr\u00e1fico RPL generado en el proceso de construcci\u00f3n del DAG. Deduce a partir de esta informaci\u00f3n la topolog\u00eda de red que se est\u00e1 usando, identificando el padre preferente de cada nodo. Para ello debes usar la informaci\u00f3n transmitida en los paquetes DAO.","title":"Captura de paquetes para an\u00e1lisis"},{"location":"RPI-I/old/P8/","text":"Pr\u00e1ctica 8. Redes LoRaWAN Nota Esta pr\u00e1ctica es opcional para aquellos que opten a evaluaci\u00f3n por proyecto y obligatoria para los que se evaluen por pr\u00e1cticas. Las tareas aqu\u00ed descritas son por tanto obligatorias para los que se presentan por pr\u00e1cticas, los que vayan por proyecto no tienen qu\u00e9 hacerlas. Objetivos Los objetivos did\u00e1cticos de esta pr\u00e1ctica son: Introducir conceptos b\u00e1sicos de programaci\u00f3n usando el entorno MicroPython Experimentar con el protocolo LoRa sobre placas reales (Pycom LoPy4). Desarrollar ejemplos reales de topolog\u00edas punto-a-punto, en estrella y en malla usando tecnolog\u00eda LoRa. Introducci\u00f3n al entorno de desarrollo LoRa Pycom LoPy4 La placa Pycom LoPy4 es una placa de desarrollo con soporte para m\u00faltiples tecnolog\u00edas de red (WiFi, BLE, LoRa y Sigfox), que equipa un SoC Espressif ESP32, 4 MBytes de memoria RAM, 8 MBytes de memoria flash externa, aceleraci\u00f3n hardware para c\u00f3mputo en punto flotante y soporte para desarrollo usando el framework MicroPython. Adem\u00e1s, integra interfaces UART (2), SPI, I2C (2), I2S y soporte para tarjetas microSD, junto con 24 pines GPIO. Seg\u00fan sus especificaciones, puede soportar rangos de transmisi\u00f3n de hasta 40 kil\u00f3metros (para comunicaci\u00f3n nodo a nodo) o 22 kil\u00f3metros (funcionando en modo gateway ), en este caso con soporte de hasta 100 nodos conectados. Tarea Como parte de la pr\u00e1ctica, se te proporciona un entorno hardware compuesto por una placa LoPy4 con antena sub-GHz LoRa y una placa de expansi\u00f3n ( Expansion Board 3.0 ) con conexi\u00f3n microUSB, que permitir\u00e1 la programaci\u00f3n de la primera. Investiga en la p\u00e1gina del fabricante las caracter\u00edsticas de ambos elementos y comprueba que las conexiones de antena son correctas. Sigue las instrucciones del fabricante para actualizar el firmware de la placa, en funci\u00f3n del sistema operativo con el que vayas a trabajar ( https://docs.pycom.io/updatefirmware/device/ ). Instala el firmware de tipo legacy , versi\u00f3n 1.29.0.b4 . Micropython Micropython es una implementaci\u00f3n de la versi\u00f3n 3.5 del lenguaje de programaci\u00f3n Python, reducida y adaptada espec\u00edficamente para su correcta ejecuci\u00f3n en microcontroladores con recursos limitados. A cambio de una huella en memoria mayor, permite un desarrollo y prototipado mucho m\u00e1s r\u00e1pido que lenguajes de menor nivel (por ejemplo, C). Como dato, a d\u00eda de hoy, sus requisitos b\u00e1sicos incluyen 256kB de memoria ROM y 16kB de RAM. MicroPython implementa un sistema de ficheros m\u00ednimo directamente en la memoria flash de la placa en la que se ejecuta, siempre que \u00e9sta disponga de m\u00e1s de 1Mb de almacenamiento. En este sistema de ficheros, existen dos archivos con un papel especial: boot.py y main.py . Estos dos ficheros se ejecutan, en este orden, en el arranque del sistema, por lo que deber\u00e1n contener las partes principales de los programas que deseemos ejecutar tras el inicio de la placa. boot.py contiene t\u00edpicamente par\u00e1metros generales de configuraci\u00f3n (por ejemplo, redes WiFi a las que conectar en el arranque), mientras que main.py suele contener la l\u00f3gica principal del programa. Tarea Instala, en tu sistema operativo el plugin Pymakr para VS Code tal y como se muestra en la p\u00e1gina del fabricante pymark . Deber\u00e1s instalar tambi\u00e9n el paquete nodejs (sudo apt install nodejs). Creaci\u00f3n de un proyecto en Pymark En primer lugar, crea un directorio nuevo y vac\u00edo en tu sistema. Por ejemplo, podemos crear un directorio llamado MiProyecto . Abre el directorio en VS Code ( Open Folder ). Necesitaremos crear una jerarqu\u00eda para nuestro proyecto. T\u00edpicamente, la jerarqu\u00eda de un proyecto sigue el siguiente esquema: MiProyecto |-lib |-biblioteca.py |boot.py |main.py En este primer ejemplo, simplemente utilizaremos un fichero main.py . Adicionalmente, crearemos un fichero de configuraci\u00f3n para nuestro proyecto a pulsando el bot\u00f3n Allcommands de la barra inferior y seleccionando Pymakr > Project Settings , que a\u00f1adir\u00e1 un fichero pymakr.conf al proyecto. Para m\u00e1s informaci\u00f3n sobre el contenido de este fichero, consulta pymakr/settings . Controlando el LED de nuestra placa A\u00f1adiremos a nuestro fichero principal ( main.py ) la l\u00f3gica para controlar un LED de nuestra placa. Para ello, a\u00f1adiremos, en primer lugar, las bibliotecas a importar: import pycom import time La primera de las bibliotecas a\u00f1ade la funcionalidad necesaria para controlar espec\u00edficamente ciertas funcionalidades de las placas Pycom. La segunda nos ayudar\u00e1 a fijar temporizadores. Tarea Habr\u00e1s observado que, al arrancar la placa Pycom, el LED de la placa parpadea de forma regular. Para desactivar este parpadeo, puedes utilizar la sentencia pycom.heartbeat(False) . A\u00f1ade esta sentencia a tu c\u00f3digo y ejec\u00fatalo ( Run ) para coprobar que tu placa puede ejecutar tus c\u00f3digos. Tarea Una vez comprobada la funcionalidad del bot\u00f3n Run , modifica el c\u00f3digo para que el LED cambie de color (R-G-B) cada segundo. Encontrar\u00e1s la documentaci\u00f3n necesaria en la p\u00e1gina de documentaci\u00f3n de Pycom . El uso del bot\u00f3n Run es intuitivo y muy \u00fatil en el desarrollo, pero no es adecuado en despliegues, ya que, como puedes observar, el c\u00f3digo desarrollado no se almacena en la placa, y por tanto se pierde en el reinicio. Para salvar esta limitaci\u00f3n, experimenta con el bot\u00f3n Upload y observa c\u00f3mo tu c\u00f3digo sigue ejecut\u00e1ndose tras un reinicio. REPL REPL ( Read Evaluate Print Loop ) es el nombre que recibe la l\u00ednea de \u00f3rdenes interactivas ofrecida por las placas Pycom (y otras muchas compatibles con MicroPython). REPL proporciona historial de comandos, completado de comandos (usando la tecla Tab ), ejecuci\u00f3n y parada de c\u00f3digo (usando Ctrl-C ) y otras funcionalidades que facilitan el desarrollo sobremanera. Existe un conjunto de atajos que pueden resultar de inter\u00e9s a la hora de interactuar con la placa. Entre ellos: Ctrl-A Entra en modo raw : permite pegar y copiar c\u00f3digo, sin realizar un echo de cada l\u00ednea introducida. Ctrl-B Pasa REPL a modo normal. Ctrl-C Cancela cualquier entrada o interrumpe el c\u00f3digo que se est\u00e1 ejecutando. Ctrl-D Realiza un soft-reset de la placa. Ctrl-E Entra en modo paste , lo que permite copiar y pegar fragmentos de texto. Para salir de este modo es necesario utilizar el atajo Ctrl-D . Ctrl-F Realiza un arranque seguro del dispositivo; en otras palabras, no ejecuta los scripts boot.py ni main.py en el momento del arranque. Infraestructura LoRa a desarrollar Conexi\u00f3n a red WiFi Todas las placas Pycom soportan WiFi, por lo que es trivial realizar una conexi\u00f3n a este tipo de red. En primer lugar, inicializamos el m\u00f3dulo WLAN y construimos un objeto para interactuar con este tipo de conexi\u00f3n: import machine from network import WLAN wlan = WLAN() wlan.mode() # Chequeamos el modo - Por defecto WLAN.AP (punto de acceso). Para conectar a un punto de acceso, en primer lugar deberemos configurar nuestra placa como station en lugar de access point (modo por defecto): import machine from network import WLAN wlan = WLAN(mode=WLAN.STA) # Modo station. Y a continuaci\u00f3n podemos, sin m\u00e1s, conectar a un SSID existente: nets = wlan.scan() for net in nets: if net.ssid == 'SSID': print('Red encontrada!') wlan.connect(net.ssid, auth=(net.sec, 'clave'), timeout=5000) while not wlan.isconnected(): machine.idle() # Ahorro de energia mientras esperamos. print('WLAN: conexion establecida!') break Si necesitamos asignar una IP est\u00e1tica a nuestra placa en el proceso de arranque, podemos hacerlo en el fichero boot.py : import machine from network import WLAN wlan = WLAN() # get current object, without changing the mode if machine.reset_cause() != machine.SOFT_RESET: wlan.init(mode=WLAN.STA) # Esta configuracion debe coincidir con la del router. wlan.ifconfig(config=('192.168.178.107', '255.255.255.0', '192.168.178.1', '8.8.8.8')) if not wlan.isconnected(): wlan.connect('SSID', auth=(WLAN.WPA2, 'clave'), timeout=5000) while not wlan.isconnected(): machine.idle() Tarea Conecta tu placa a un punto de acceso wifi (por ejemplo el router de clase o tu tel\u00e9fono m\u00f3vil). Experimenta asignando una IP est\u00e1tica a la placa. Tarea Investiga c\u00f3mo conseguir que tu placa sea capaz de almacenar una lista de redes inal\u00e1mbricas a las que potencialmente conectar, y realice un proceso de intento de conexi\u00f3n a cada una de ellas en el momento del arranque, hasta llegar a conectar con una de ellas. Pod\u00e9is consultar la documentaci\u00f3n del API en https://docs.pycom.io/firmwareapi/ . LoRaMAC Comunicaci\u00f3n punto-a-punto En esta primera parte de la pr\u00e1ctica, utilizaremos la interfaz LoRa directamente ( raw mode ), por lo que se ignora la capa LoRaWAN para enviar y recibir datos. De este modo, los datos son enviados en crudo, sin formato ni encriptaci\u00f3n posible, y no se a\u00f1ade ning\u00fan tipo de direccionamiento a nivel de enlace en los frames enviados. En este ejemplo, utilizaremos dos placas LoPy. El script a desarrollar se basa en un bucle infinito ( while ) con un tiempo de espera variable (y aleatorio) entre env\u00edos para minimizar las posibilidades de transmisi\u00f3n simult\u00e1nea entre dos o m\u00e1s dispositivos. El siguiente c\u00f3digo realiza env\u00edos y recepciones del modo descrito: from network import LoRa import socket import machine import time # initialise LoRa in LORA mode # Please pick the region that matches where you are using the device: # Asia = LoRa.AS923 # Australia = LoRa.AU915 # Europe = LoRa.EU868 # United States = LoRa.US915 # more params can also be given, like frequency, tx power and spreading factor lora = LoRa(mode=LoRa.LORA, region=LoRa.EU868) # create a raw LoRa socket s = socket.socket(socket.AF_LORA, socket.SOCK_RAW) while True: # send some data s.setblocking(True) s.send('Hello') # get any data received... s.setblocking(False) data = s.recv(64) print(data) # wait a random amount of time time.sleep(machine.rng() & 0x0F) Tarea Modifica el programa anterior para que cada LoPy cambie el estado de iluminaci\u00f3n de su LED en el momento en el que reciba cada frame . El resultado deber\u00eda iluminar/apagar alternativamente dicho LED con la recepci\u00f3n de cada dato. Tarea Estudia la documentaci\u00f3n del m\u00f3dulo LoRa en https://docs.pycom.io/firmwareapi/pycom/network/lora , especialmente los par\u00e1metros de inicializaci\u00f3n/construcci\u00f3n del m\u00f3dulo. Experimenta, en tu placa, variando cada uno de los valores configurables (por ejemplo, frequency , tx_power , bandwidth , spreading factor , preamble y coding rate . Describe (y entrega) una descripci\u00f3n sobre su impacto en la transmisi\u00f3n, as\u00ed como (si te es posible) su impacto en la velocidad de transmisi\u00f3n o distancia m\u00e1xima de transferencia. Comunicaci\u00f3n gateway - nodo El ejemplo que se muestra a continuaci\u00f3n propone una topolog\u00eda en la que un gateway o elemento central recibe datos crudos LoRa desde uno o m\u00e1s nodos LoRa. El c\u00f3digo, en este caso, es distinto en funci\u00f3n del elemento de la topolog\u00eda que estemos tratando. El gateway , en nuestro caso, realizar\u00e1 una escucha pasiva a la espera de la recepci\u00f3n de un paquete por parte de los nodos. Observa que el formato del paquete recibido (y acuse de recibo --ACK-- enviado en respuesta) est\u00e1 definido al inicio del propio script, y debe coincidir con el formato esperado en los nodos: import socket import struct from network import LoRa # A basic package header, B: 1 byte for the deviceId, B: 1 byte for the pkg size, %ds: Formatted string for string _LORA_PKG_FORMAT = \"!BB%ds\" # A basic ack package, B: 1 byte for the deviceId, B: 1 byte for the pkg size, B: 1 byte for the Ok (200) or error messages _LORA_PKG_ACK_FORMAT = \"BBB\" # Open a LoRa Socket, use rx_iq to avoid listening to our own messages # Please pick the region that matches where you are using the device: # Asia = LoRa.AS923 # Australia = LoRa.AU915 # Europe = LoRa.EU868 # United States = LoRa.US915 lora = LoRa(mode=LoRa.LORA, rx_iq=True, region=LoRa.EU868) lora_sock = socket.socket(socket.AF_LORA, socket.SOCK_RAW) lora_sock.setblocking(False) while (True): recv_pkg = lora_sock.recv(512) if (len(recv_pkg) > 2): recv_pkg_len = recv_pkg[1] device_id, pkg_len, msg = struct.unpack(_LORA_PKG_FORMAT % recv_pkg_len, recv_pkg) # If the uart = machine.UART(0, 115200) and os.dupterm(uart) are set in the boot.py this print should appear in the serial port print('Device: %d - Pkg: %s' % (device_id, msg)) ack_pkg = struct.pack(_LORA_PKG_ACK_FORMAT, device_id, 1, 200) lora_sock.send(ack_pkg) Observa como _LORA_PKG_FORMAT se utiliza como un mecanismo para identificar los distintos dispositivos existentes en la red. Por su parte, _LORA_PKG_ACK_FORMAT es un mecanismo de acuse de recibo sencillo para responder al nodo que envi\u00f3 el paquete. Por otra parte, el c\u00f3digo del nodo se reduce al env\u00edo de paquetes y a la espera activa a sus respectivos acuses de recibo: import os import socket import time import struct from network import LoRa # A basic package header, B: 1 byte for the deviceId, B: 1 byte for the pkg size _LORA_PKG_FORMAT = \"BB%ds\" _LORA_PKG_ACK_FORMAT = \"BBB\" DEVICE_ID = 0x01 # Open a Lora Socket, use tx_iq to avoid listening to our own messages # Please pick the region that matches where you are using the device: # Asia = LoRa.AS923 # Australia = LoRa.AU915 # Europe = LoRa.EU868 # United States = LoRa.US915 lora = LoRa(mode=LoRa.LORA, tx_iq=True, region=LoRa.EU868) lora_sock = socket.socket(socket.AF_LORA, socket.SOCK_RAW) lora_sock.setblocking(False) while(True): # Package send containing a simple string msg = \"Device 1 Here\" pkg = struct.pack(_LORA_PKG_FORMAT % len(msg), DEVICE_ID, len(msg), msg) lora_sock.send(pkg) # Wait for the response from the gateway. NOTE: For this demo the device does an infinite loop for while waiting the response. Introduce a max_time_waiting for you application waiting_ack = True while(waiting_ack): recv_ack = lora_sock.recv(256) if (len(recv_ack) > 0): device_id, pkg_len, ack = struct.unpack(_LORA_PKG_ACK_FORMAT, recv_ack) if (device_id == DEVICE_ID): if (ack == 200): waiting_ack = False # If the uart = machine.UART(0, 115200) and os.dupterm(uart) are set in the boot.py this print should appear in the serial port print(\"ACK\") else: waiting_ack = False # If the uart = machine.UART(0, 115200) and os.dupterm(uart) are set in the boot.py this print should appear in the serial port print(\"Message Failed\") time.sleep(5) Tarea Adapta el c\u00f3digo anterior a alg\u00fan escenario real, por ejemplo: Fija un tiempo m\u00e1ximo de espera para la recepci\u00f3n de acuse de recibo y el reenv\u00edo del paquete (o para descartarlo). Incrementa el tama\u00f1o de paquete modificando _LORA_PKG_FORMAT a BH\\%ds ; el car\u00e1cter H permite usar 2 bytes para el tama\u00f1o (v\u00e9ase https://docs.python.org/2/library/struct.html#format-characters para m\u00e1s informaci\u00f3n). Reduce el tama\u00f1o de mensaje y ad\u00e1ptalo a un escenario real de tu elecci\u00f3n. LoRaWAN. Topolog\u00eda en estrella. Implementaci\u00f3n de un Gateway LoRaWAN En esta secci\u00f3n trabajaremos en el desarrollo de un gateway implementado en una LoPy utilizando MicroPython. Este tipo de ejemplo permite conectar a una red LoRaWAN existente (por ejemplo, The Things Network --elegida en nuestro caso-- o Loriot ), haciendo que nuestro gateway simplemente act\u00fae como forwarder de paquetes recibidos desde nodos hacia un servidor remoto. El c\u00f3digo del gateway est\u00e1 dividido en tres scripts diferenciados: main.py , config.py y nanogateway.py . Conjuntamente, su funcionalidad es configurar el gateway para realizar una conexi\u00f3n a una red preferida (WLAN) y para actuar como packet forwarder hacia un servidor. Obtenci\u00f3n del Gateway ID La mayor\u00eda de servidores LoRaWAN esperan un identificador de gateway ( gateway ID ) en forma de n\u00famero hexadecimal de 64 bits, t\u00edpicamente nombrado como EUI-64 ). La pr\u00e1ctica recomendada consiste, durante el desarrollo del gateway , en obtener este ID a partir de una expansi\u00f3n de la MAC WiFi de la placa (que es un valor de 48 bits). Podemos obtener este identificador usando el siguiente c\u00f3digo: from network import WLAN import ubinascii wl = WLAN() ubinascii.hexlify(wl.mac())[:6] + 'FFFE' + ubinascii.hexlify(wl.mac())[6:] El resultado ser\u00e1 algo similar a b'240ac4FFFE008d88' , donde 40ac4FFFE008d88 ser\u00eda nuestro identificador de gateway , que usaremos en la configuraci\u00f3n del servidor LoRa para identificar de forma un\u00edvoca a nuestro dispositivo. El fichero main.py Este fichero, como se ha dicho anteriormente, se ejecuta al inicio e importa, en primer lugar, el script de configuraci\u00f3n config.py para inicializar el gateway . Una vez configurado, se arranca la l\u00f3gica del gateway . \"\"\" LoPy LoRaWAN Nano Gateway example usage \"\"\" import config from nanogateway import NanoGateway if __name__ == '__main__': nanogw = NanoGateway( id=config.GATEWAY_ID, frequency=config.LORA_FREQUENCY, datarate=config.LORA_GW_DR, ssid=config.WIFI_SSID, password=config.WIFI_PASS, server=config.SERVER, port=config.PORT, ntp_server=config.NTP, ntp_period=config.NTP_PERIOD_S ) nanogw.start() nanogw._log('You may now press ENTER to enter the REPL') input() El fichero config.py El fichero de configuraci\u00f3n config.py contiene par\u00e1metros generales de configuraci\u00f3n para el servidor y la red LoRa a la que deseamos conectar nuestro dispositivo. En funci\u00f3n de la regi\u00f3n y el proveedor ( TTN, Loriot, etc. ), estos par\u00e1metros variar\u00e1n, por lo que ser\u00e1 necesario adaptar estos valores en funci\u00f3n de nuestra configuraci\u00f3n. El siguiente ejemplo muestra la configuraci\u00f3n necesaria para la conexi\u00f3n a The Things Network (TTN) en regi\u00f3n europea (868 Mhz). Obs\u00e9rvese c\u00f3mo se obtiene un Gateway ID como se ha indicado anteriormente, y c\u00f3mo es necesario adaptar tanto el SSID como la contrase\u00f1a para autenticaci\u00f3n en nuestra red WiFi de forma acorde: \"\"\" LoPy LoRaWAN Nano Gateway configuration options \"\"\" import machine import ubinascii WIFI_MAC = ubinascii.hexlify(machine.unique_id()).upper() # Set the Gateway ID to be the first 3 bytes of MAC address + 'FFFE' + last 3 bytes of MAC address GATEWAY_ID = WIFI_MAC[:6] + \"FFFE\" + WIFI_MAC[6:12] SERVER = 'router.eu.thethings.network' PORT = 1700 NTP = \"pool.ntp.org\" NTP_PERIOD_S = 3600 WIFI_SSID = 'my-wifi' WIFI_PASS = 'my-wifi-password' # for EU868 LORA_FREQUENCY = 868100000 LORA_GW_DR = \"SF7BW125\" # DR_5 LORA_NODE_DR = 5 # for US915 # LORA_FREQUENCY = 903900000 # LORA_GW_DR = \"SF7BW125\" # DR_3 # LORA_NODE_DR = 3 El fichero/bilioteca nanogateway.py La biblioteca nanogateway.py implementa la l\u00f3gica de recepci\u00f3n, generaci\u00f3n y reenv\u00edo de paquetes de datos LoRa. No requiere ninguna configuraci\u00f3n, se sugiere que el estudiante observe e intente enteder su fucionamiento y funcionalidad ofrecida. \"\"\" LoPy LoRaWAN Nano Gateway. Can be used for both EU868 and US915. \"\"\" import errno import machine import ubinascii import ujson import uos import usocket import utime import _thread from micropython import const from network import LoRa from network import WLAN from machine import Timer PROTOCOL_VERSION = const(2) PUSH_DATA = const(0) PUSH_ACK = const(1) PULL_DATA = const(2) PULL_ACK = const(4) PULL_RESP = const(3) TX_ERR_NONE = 'NONE' TX_ERR_TOO_LATE = 'TOO_LATE' TX_ERR_TOO_EARLY = 'TOO_EARLY' TX_ERR_COLLISION_PACKET = 'COLLISION_PACKET' TX_ERR_COLLISION_BEACON = 'COLLISION_BEACON' TX_ERR_TX_FREQ = 'TX_FREQ' TX_ERR_TX_POWER = 'TX_POWER' TX_ERR_GPS_UNLOCKED = 'GPS_UNLOCKED' UDP_THREAD_CYCLE_MS = const(20) STAT_PK = { 'stat': { 'time': '', 'lati': 0, 'long': 0, 'alti': 0, 'rxnb': 0, 'rxok': 0, 'rxfw': 0, 'ackr': 100.0, 'dwnb': 0, 'txnb': 0 } } RX_PK = { 'rxpk': [{ 'time': '', 'tmst': 0, 'chan': 0, 'rfch': 0, 'freq': 0, 'stat': 1, 'modu': 'LORA', 'datr': '', 'codr': '4/5', 'rssi': 0, 'lsnr': 0, 'size': 0, 'data': '' }] } TX_ACK_PK = { 'txpk_ack': { 'error': '' } } class NanoGateway: \"\"\" Nano gateway class, set up by default for use with TTN, but can be configured for any other network supporting the Semtech Packet Forwarder. Only required configuration is wifi_ssid and wifi_password which are used for connecting to the Internet. \"\"\" def __init__(self, id, frequency, datarate, ssid, password, server, port, ntp_server='pool.ntp.org', ntp_period=3600): self.id = id self.server = server self.port = port self.frequency = frequency self.datarate = datarate self.ssid = ssid self.password = password self.ntp_server = ntp_server self.ntp_period = ntp_period self.server_ip = None self.rxnb = 0 self.rxok = 0 self.rxfw = 0 self.dwnb = 0 self.txnb = 0 self.sf = self._dr_to_sf(self.datarate) self.bw = self._dr_to_bw(self.datarate) self.stat_alarm = None self.pull_alarm = None self.uplink_alarm = None self.wlan = None self.sock = None self.udp_stop = False self.udp_lock = _thread.allocate_lock() self.lora = None self.lora_sock = None self.rtc = machine.RTC() def start(self): \"\"\" Starts the LoRaWAN nano gateway. \"\"\" self._log('Starting LoRaWAN nano gateway with id: {}', self.id) # setup WiFi as a station and connect self.wlan = WLAN(mode=WLAN.STA) self._connect_to_wifi() # get a time sync self._log('Syncing time with {} ...', self.ntp_server) self.rtc.ntp_sync(self.ntp_server, update_period=self.ntp_period) while not self.rtc.synced(): utime.sleep_ms(50) self._log(\"RTC NTP sync complete\") # get the server IP and create an UDP socket self.server_ip = usocket.getaddrinfo(self.server, self.port)[0][-1] self._log('Opening UDP socket to {} ({}) port {}...', self.server, self.server_ip[0], self.server_ip[1]) self.sock = usocket.socket(usocket.AF_INET, usocket.SOCK_DGRAM, usocket.IPPROTO_UDP) self.sock.setsockopt(usocket.SOL_SOCKET, usocket.SO_REUSEADDR, 1) self.sock.setblocking(False) # push the first time immediatelly self._push_data(self._make_stat_packet()) # create the alarms self.stat_alarm = Timer.Alarm(handler=lambda t: self._push_data(self._make_stat_packet()), s=60, periodic=True) self.pull_alarm = Timer.Alarm(handler=lambda u: self._pull_data(), s=25, periodic=True) # start the UDP receive thread self.udp_stop = False _thread.start_new_thread(self._udp_thread, ()) # initialize the LoRa radio in LORA mode self._log('Setting up the LoRa radio at {} Mhz using {}', self._freq_to_float(self.frequency), self.datarate) self.lora = LoRa( mode=LoRa.LORA, frequency=self.frequency, bandwidth=self.bw, sf=self.sf, preamble=8, coding_rate=LoRa.CODING_4_5, tx_iq=True ) # create a raw LoRa socket self.lora_sock = usocket.socket(usocket.AF_LORA, usocket.SOCK_RAW) self.lora_sock.setblocking(False) self.lora_tx_done = False self.lora.callback(trigger=(LoRa.RX_PACKET_EVENT | LoRa.TX_PACKET_EVENT), handler=self._lora_cb) self._log('LoRaWAN nano gateway online') def stop(self): \"\"\" Stops the LoRaWAN nano gateway. \"\"\" self._log('Stopping...') # send the LoRa radio to sleep self.lora.callback(trigger=None, handler=None) self.lora.power_mode(LoRa.SLEEP) # stop the NTP sync self.rtc.ntp_sync(None) # cancel all the alarms self.stat_alarm.cancel() self.pull_alarm.cancel() # signal the UDP thread to stop self.udp_stop = True while self.udp_stop: utime.sleep_ms(50) # disable WLAN self.wlan.disconnect() self.wlan.deinit() def _connect_to_wifi(self): self.wlan.connect(self.ssid, auth=(None, self.password)) while not self.wlan.isconnected(): utime.sleep_ms(50) self._log('WiFi connected to: {}', self.ssid) def _dr_to_sf(self, dr): sf = dr[2:4] if sf[1] not in '0123456789': sf = sf[:1] return int(sf) def _dr_to_bw(self, dr): bw = dr[-5:] if bw == 'BW125': return LoRa.BW_125KHZ elif bw == 'BW250': return LoRa.BW_250KHZ else: return LoRa.BW_500KHZ def _sf_bw_to_dr(self, sf, bw): dr = 'SF' + str(sf) if bw == LoRa.BW_125KHZ: return dr + 'BW125' elif bw == LoRa.BW_250KHZ: return dr + 'BW250' else: return dr + 'BW500' def _lora_cb(self, lora): \"\"\" LoRa radio events callback handler. \"\"\" events = lora.events() if events & LoRa.RX_PACKET_EVENT: self.rxnb += 1 self.rxok += 1 rx_data = self.lora_sock.recv(256) stats = lora.stats() packet = self._make_node_packet(rx_data, self.rtc.now(), stats.rx_timestamp, stats.sfrx, self.bw, stats.rssi, stats.snr) packet = self.frequency_rounding_fix(packet, self.frequency) self._push_data(packet) self._log('Received packet: {}', packet) self.rxfw += 1 if events & LoRa.TX_PACKET_EVENT: self.txnb += 1 lora.init( mode=LoRa.LORA, frequency=self.frequency, bandwidth=self.bw, sf=self.sf, preamble=8, coding_rate=LoRa.CODING_4_5, tx_iq=True ) def _freq_to_float(self, frequency): \"\"\" MicroPython has some inprecision when doing large float division. To counter this, this method first does integer division until we reach the decimal breaking point. This doesn't completely elimate the issue in all cases, but it does help for a number of commonly used frequencies. \"\"\" divider = 6 while divider > 0 and frequency % 10 == 0: frequency = frequency // 10 divider -= 1 if divider > 0: frequency = frequency / (10 ** divider) return frequency def frequency_rounding_fix(self, packet, frequency): freq = str(frequency)[0:3] + '.' + str(frequency)[3] start = packet.find(\"freq\\\":\") end = packet.find(\",\", start) packet = packet[:start + 7] + freq + packet[end:] return packet def _make_stat_packet(self): now = self.rtc.now() STAT_PK[\"stat\"][\"time\"] = \"%d-%02d-%02d %02d:%02d:%02d GMT\" % (now[0], now[1], now[2], now[3], now[4], now[5]) STAT_PK[\"stat\"][\"rxnb\"] = self.rxnb STAT_PK[\"stat\"][\"rxok\"] = self.rxok STAT_PK[\"stat\"][\"rxfw\"] = self.rxfw STAT_PK[\"stat\"][\"dwnb\"] = self.dwnb STAT_PK[\"stat\"][\"txnb\"] = self.txnb return ujson.dumps(STAT_PK) def _make_node_packet(self, rx_data, rx_time, tmst, sf, bw, rssi, snr): RX_PK[\"rxpk\"][0][\"time\"] = \"%d-%02d-%02dT%02d:%02d:%02d.%dZ\" % (rx_time[0], rx_time[1], rx_time[2], rx_time[3], rx_time[4], rx_time[5], rx_time[6]) RX_PK[\"rxpk\"][0][\"tmst\"] = tmst RX_PK[\"rxpk\"][0][\"freq\"] = self._freq_to_float(self.frequency) RX_PK[\"rxpk\"][0][\"datr\"] = self._sf_bw_to_dr(sf, bw) RX_PK[\"rxpk\"][0][\"rssi\"] = rssi RX_PK[\"rxpk\"][0][\"lsnr\"] = snr RX_PK[\"rxpk\"][0][\"data\"] = ubinascii.b2a_base64(rx_data)[:-1] RX_PK[\"rxpk\"][0][\"size\"] = len(rx_data) return ujson.dumps(RX_PK) def _push_data(self, data): token = uos.urandom(2) packet = bytes([PROTOCOL_VERSION]) + token + bytes([PUSH_DATA]) + ubinascii.unhexlify(self.id) + data with self.udp_lock: try: self.sock.sendto(packet, self.server_ip) except Exception as ex: self._log('Failed to push uplink packet to server: {}', ex) def _pull_data(self): token = uos.urandom(2) packet = bytes([PROTOCOL_VERSION]) + token + bytes([PULL_DATA]) + ubinascii.unhexlify(self.id) with self.udp_lock: try: self.sock.sendto(packet, self.server_ip) except Exception as ex: self._log('Failed to pull downlink packets from server: {}', ex) def _ack_pull_rsp(self, token, error): TX_ACK_PK[\"txpk_ack\"][\"error\"] = error resp = ujson.dumps(TX_ACK_PK) packet = bytes([PROTOCOL_VERSION]) + token + bytes([PULL_ACK]) + ubinascii.unhexlify(self.id) + resp with self.udp_lock: try: self.sock.sendto(packet, self.server_ip) except Exception as ex: self._log('PULL RSP ACK exception: {}', ex) def _send_down_link(self, data, tmst, datarate, frequency): \"\"\" Transmits a downlink message over LoRa. \"\"\" self.lora.init( mode=LoRa.LORA, frequency=frequency, bandwidth=self._dr_to_bw(datarate), sf=self._dr_to_sf(datarate), preamble=8, coding_rate=LoRa.CODING_4_5, tx_iq=True ) #while utime.ticks_cpu() < tmst: # pass self.lora_sock.send(data) self._log( 'Sent downlink packet scheduled on {:.3f}, at {:.3f} Mhz using {}: {}', tmst / 1000000, self._freq_to_float(frequency), datarate, data ) def _send_down_link_class_c(self, data, datarate, frequency): self.lora.init( mode=LoRa.LORA, frequency=frequency, bandwidth=self._dr_to_bw(datarate), sf=self._dr_to_sf(datarate), preamble=8, coding_rate=LoRa.CODING_4_5, tx_iq=True, device_class=LoRa.CLASS_C ) self.lora_sock.send(data) self._log( 'Sent downlink packet scheduled on {:.3f}, at {:.3f} Mhz using {}: {}', utime.time(), self._freq_to_float(frequency), datarate, data ) def _udp_thread(self): \"\"\" UDP thread, reads data from the server and handles it. \"\"\" while not self.udp_stop: try: data, src = self.sock.recvfrom(1024) _token = data[1:3] _type = data[3] if _type == PUSH_ACK: self._log(\"Push ack\") elif _type == PULL_ACK: self._log(\"Pull ack\") elif _type == PULL_RESP: self.dwnb += 1 ack_error = TX_ERR_NONE tx_pk = ujson.loads(data[4:]) if \"tmst\" in data: tmst = tx_pk[\"txpk\"][\"tmst\"] t_us = tmst - utime.ticks_cpu() - 15000 if t_us < 0: t_us += 0xFFFFFFFF if t_us < 20000000: self.uplink_alarm = Timer.Alarm( handler=lambda x: self._send_down_link( ubinascii.a2b_base64(tx_pk[\"txpk\"][\"data\"]), tx_pk[\"txpk\"][\"tmst\"] - 50, tx_pk[\"txpk\"][\"datr\"], int(tx_pk[\"txpk\"][\"freq\"] * 1000) * 1000 ), us=t_us ) else: ack_error = TX_ERR_TOO_LATE self._log('Downlink timestamp error!, t_us: {}', t_us) else: self.uplink_alarm = Timer.Alarm( handler=lambda x: self._send_down_link_class_c( ubinascii.a2b_base64(tx_pk[\"txpk\"][\"data\"]), tx_pk[\"txpk\"][\"datr\"], int(tx_pk[\"txpk\"][\"freq\"] * 1000) * 1000 ), us=50 ) self._ack_pull_rsp(_token, ack_error) self._log(\"Pull rsp\") except usocket.timeout: pass except OSError as ex: if ex.errno != errno.EAGAIN: self._log('UDP recv OSError Exception: {}', ex) except Exception as ex: self._log('UDP recv Exception: {}', ex) # wait before trying to receive again utime.sleep_ms(UDP_THREAD_CYCLE_MS) # we are to close the socket self.sock.close() self.udp_stop = False self._log('UDP thread stopped') def _log(self, message, *args): \"\"\" Outputs a log message to stdout. \"\"\" print('[{:>10.3f}] {}'.format( utime.ticks_ms() / 1000, str(message).format(*args) )) Registro en el servidor LoRaWAN ( The Things Network -- TTN ) Para configurar nuestro gateway en TTN, navegaremos a su p\u00e1gina web y crearemos una nueva cuenta, introduciendo un nombre de usuario, contrase\u00f1a y direcci\u00f3n de correo que nos permitir\u00e1 validar dicha informaci\u00f3n, como se muestra en la Figura: Con la cuenta ya creada, podemos proceder con el registro del gateway desde la consola TTN. Registro del gateway en ( The Things Network -- TTN ) En la consola TTN existen dos opciones: applications y gateways , como muestra la Figura: Selecciona la opci\u00f3n gateways y, dentro de ella, Register Gateway . Esto permitir\u00e1 registrar un nuevo gateway . En esta opci\u00f3n, configuraremos los par\u00e1metros que se muestran en la siguiente tabla: Opci\u00f3n Valor Protocolo Packet Forwarder Gateway EUI Definido por el usuario (debe coincidir con el obtenido en config.py ) Description Definido por el usuario Frequency Plan Spain/EU 868 Mhz Location Definido por el usuario Antena Indoor o outdoor Una vez configurado, registramos el gateway con el bot\u00f3n Register Gateway ; una vez registrado, navega a la opci\u00f3n Gateway Settiings y selecciona una direcci\u00f3n de router que coincida con la usada en la configuraci\u00f3n del mismo (en este caso, router.eu.thethings.network , v\u00e9ase la siguiente Figura). En este punto, si todo ha ido bien, el gateway deber\u00eda estar configurado y registrado en TTN. Pasamos a continuaci\u00f3n a la configuraci\u00f3n de los nodos LoRa . Configuraci\u00f3n del nodo LoRaWAN Existen dos m\u00e9todos para conectar dispositivos LoPy a nuestro gateway : OTAA ( Over The Air Activation ) y ABP ( Activation By Personalization ), cuyas instrucciones de confguraci\u00f3n se muestran en las siguientes secciones. Configuraci\u00f3n del nodo v\u00eda OTAA ( Over The Air Activation ) Si nuestro nodo LoPy conecta una aplicaci\u00f3n (a trav\u00e9s de TTN) usando OTAA, la configuraci\u00f3n de red se extrae usando un protocolo de handshake entre la LoPy y el servidor de red. Obs\u00e9rvese como las claves de red derivadas usando OTAA son espec\u00edficas para el dispositivo y se utilizan para encriptar y verificar las transmisiones a nivel de red: \"\"\" OTAA Node example compatible with the LoPy Nano Gateway \"\"\" from network import LoRa import socket import ubinascii import struct import time # Initialize LoRa in LORAWAN mode. lora = LoRa(mode=LoRa.LORAWAN) # create an OTA authentication params dev_eui = ubinascii.unhexlify('AABBCCDDEEFF7778') # these settings can be found from TTN app_eui = ubinascii.unhexlify('70B3D57EF0003BFD') # these settings can be found from TTN app_key = ubinascii.unhexlify('36AB7625FE77776881683B495300FFD6') # these settings can be found from TTN # set the 3 default channels to the same frequency (must be before sending the OTAA join request) lora.add_channel(0, frequency=868100000, dr_min=0, dr_max=5) lora.add_channel(1, frequency=868100000, dr_min=0, dr_max=5) lora.add_channel(2, frequency=868100000, dr_min=0, dr_max=5) # join a network using OTAA lora.join(activation=LoRa.OTAA, auth=(dev_eui, app_eui, app_key), timeout=0) # wait until the module has joined the network while not lora.has_joined(): time.sleep(2.5) print('Not joined yet...') # remove all the non-default channels for i in range(3, 16): lora.remove_channel(i) # create a LoRa socket s = socket.socket(socket.AF_LORA, socket.SOCK_RAW) # set the LoRaWAN data rate s.setsockopt(socket.SOL_LORA, socket.SO_DR, 5) # make the socket non-blocking s.setblocking(False) time.sleep(5.0) \"\"\" Your own code can be written below! \"\"\" for i in range (200): s.send(b'PKT #' + bytes([i])) time.sleep(4) rx = s.recv(256) if rx: print(rx) time.sleep(6) Configuraci\u00f3n del nodo v\u00eda ABP ( Activation By Personalization ) Si se escoge el modo de uni\u00f3n a la red ABP, se requiere que el usuario defina los siguietnes valores, que deben definirse en el firmware y especificarse en TTN: Direcci\u00f3n del dispositivo. Clave de sesi\u00f3n de aplicaci\u00f3n ( Application Session Key ). Clave de sesi\u00f3n de red ( Network Session Key ). El siguiente c\u00f3digo muestra un ejemplo de configuraci\u00f3n de nodo usando ABP: \"\"\" ABP Node example compatible with the LoPy Nano Gateway \"\"\" from network import LoRa import socket import ubinascii import struct import time # Initialise LoRa in LORAWAN mode. lora = LoRa(mode=LoRa.LORAWAN) # create an ABP authentication params dev_addr = struct.unpack(\">l\", ubinascii.unhexlify('2601147D'))[0] # these settings can be found from TTN nwk_swkey = ubinascii.unhexlify('3C74F4F40CAE2221303BC24284FCF3AF') # these settings can be found from TTN app_swkey = ubinascii.unhexlify('0FFA7072CC6FF69A102A0F39BEB0880F') # these settings can be found from TTN # join a network using ABP (Activation By Personalisation) lora.join(activation=LoRa.ABP, auth=(dev_addr, nwk_swkey, app_swkey)) # remove all the non-default channels for i in range(3, 16): lora.remove_channel(i) # set the 3 default channels to the same frequency lora.add_channel(0, frequency=868100000, dr_min=0, dr_max=5) lora.add_channel(1, frequency=868100000, dr_min=0, dr_max=5) lora.add_channel(2, frequency=868100000, dr_min=0, dr_max=5) # create a LoRa socket s = socket.socket(socket.AF_LORA, socket.SOCK_RAW) # set the LoRaWAN data rate s.setsockopt(socket.SOL_LORA, socket.SO_DR, 5) # make the socket non-blocking s.setblocking(False) \"\"\" Your own code can be written below! \"\"\" for i in range (200): s.send(b'PKT #' + bytes([i])) time.sleep(4) rx = s.recv(256) if rx: print(rx) time.sleep(6) Aplicaciones TTN Cno los nodos y gateways ya configurados, podemos proceder al desarrollo de una aplicaci\u00f3n en TTN (esto es, el procesamiento que sufren los datos LoRa una vez recibidos por parte de TTN). Aunque existen multitud de configuraciones disponibles, nosotros trabajaremos con una integraci\u00f3n de nuestra aplicaci\u00f3n con peticiones HTTP de salida. Registro de una nueva aplicaci\u00f3n Seleccionando la pesta\u00f1a Applications en la consola TTN, aparecer\u00e1 una pantalla para el registro de aplicaciones. Al clicar en Register aparecer\u00e1 una nueva ventana como la mostrada en la siguiente Figura. Introduce en el formulario un ID de aplicaci\u00f3n \u00fanico y un descriptor y manejador. Registro de dispositivos Para conectar nodos al gateway , los dispositivos deben a\u00f1adirse a la propia aplicaci\u00f3n. Para ello, navega a la pesta\u00f1a Devices en la p\u00e1gina Application y pulsa el bot\u00f3n Register Device . En el panel que aparecer\u00e1, completa los campos Device ID y Device EUI ; el primero es seleccionado por el usuario y es \u00fanica para cada dispositivo en esta aplicaci\u00f3n; el segundo tambi\u00e9n es seleccionable por el usuario y debe consistir en un valor de 8 bytes, dados en hexadecimal. Una vez a\u00f1adido, modifica el m\u00e9todo de activaci\u00f3n ( Activation Method ) y selecciona OTAA o ABP , en funci\u00f3n de tu c\u00f3digo del nodo (pesta\u00f1a Settings ). Integraci\u00f3n con aplicaciones/servicios externos En este punto, los datos deber\u00edan estar siendo recibidos por el backend TTN. Podemos indicar a TTN c\u00f3mo reenviar estos datos a un servicio externo. Para ello, utilizaremos la pesta\u00f1a Integrations dentro de las preferencias de la nueva aplicaci\u00f3n. A\u00f1adiremos una nueva integraci\u00f3n de tipo HTTP, en la que, entre otros valores, deberemos indicar la URL destino de nuestros env\u00edos, el m\u00e9todo de env\u00edo (por ejemplo, POST) y en caso de ser necesaria, informaci\u00f3n sobre autenticaci\u00f3n. TTN reenviar\u00e1 los datos recibidos al servidor indicado tan pronto como nuestros nodos LoPy comiencen a enviar datos. Tarea Sigue los pasos anteriormente descritos para configurar un gateway LoRaWAN, registr\u00e1ndolo en TTN, y para la configuraci\u00f3n de al menos uno nodo LoRa que, a trav\u00e9s del gateway configurado, env\u00ede datos a TTN.","title":"Pr\u00e1ctica 8. Redes LoRaWAN"},{"location":"RPI-I/old/P8/#practica-8-redes-lorawan","text":"Nota Esta pr\u00e1ctica es opcional para aquellos que opten a evaluaci\u00f3n por proyecto y obligatoria para los que se evaluen por pr\u00e1cticas. Las tareas aqu\u00ed descritas son por tanto obligatorias para los que se presentan por pr\u00e1cticas, los que vayan por proyecto no tienen qu\u00e9 hacerlas.","title":"Pr\u00e1ctica 8. Redes LoRaWAN"},{"location":"RPI-I/old/P8/#objetivos","text":"Los objetivos did\u00e1cticos de esta pr\u00e1ctica son: Introducir conceptos b\u00e1sicos de programaci\u00f3n usando el entorno MicroPython Experimentar con el protocolo LoRa sobre placas reales (Pycom LoPy4). Desarrollar ejemplos reales de topolog\u00edas punto-a-punto, en estrella y en malla usando tecnolog\u00eda LoRa.","title":"Objetivos"},{"location":"RPI-I/old/P8/#introduccion-al-entorno-de-desarrollo-lora","text":"","title":"Introducci\u00f3n al entorno de desarrollo LoRa"},{"location":"RPI-I/old/P8/#pycom-lopy4","text":"La placa Pycom LoPy4 es una placa de desarrollo con soporte para m\u00faltiples tecnolog\u00edas de red (WiFi, BLE, LoRa y Sigfox), que equipa un SoC Espressif ESP32, 4 MBytes de memoria RAM, 8 MBytes de memoria flash externa, aceleraci\u00f3n hardware para c\u00f3mputo en punto flotante y soporte para desarrollo usando el framework MicroPython. Adem\u00e1s, integra interfaces UART (2), SPI, I2C (2), I2S y soporte para tarjetas microSD, junto con 24 pines GPIO. Seg\u00fan sus especificaciones, puede soportar rangos de transmisi\u00f3n de hasta 40 kil\u00f3metros (para comunicaci\u00f3n nodo a nodo) o 22 kil\u00f3metros (funcionando en modo gateway ), en este caso con soporte de hasta 100 nodos conectados. Tarea Como parte de la pr\u00e1ctica, se te proporciona un entorno hardware compuesto por una placa LoPy4 con antena sub-GHz LoRa y una placa de expansi\u00f3n ( Expansion Board 3.0 ) con conexi\u00f3n microUSB, que permitir\u00e1 la programaci\u00f3n de la primera. Investiga en la p\u00e1gina del fabricante las caracter\u00edsticas de ambos elementos y comprueba que las conexiones de antena son correctas. Sigue las instrucciones del fabricante para actualizar el firmware de la placa, en funci\u00f3n del sistema operativo con el que vayas a trabajar ( https://docs.pycom.io/updatefirmware/device/ ). Instala el firmware de tipo legacy , versi\u00f3n 1.29.0.b4 .","title":"Pycom LoPy4"},{"location":"RPI-I/old/P8/#micropython","text":"Micropython es una implementaci\u00f3n de la versi\u00f3n 3.5 del lenguaje de programaci\u00f3n Python, reducida y adaptada espec\u00edficamente para su correcta ejecuci\u00f3n en microcontroladores con recursos limitados. A cambio de una huella en memoria mayor, permite un desarrollo y prototipado mucho m\u00e1s r\u00e1pido que lenguajes de menor nivel (por ejemplo, C). Como dato, a d\u00eda de hoy, sus requisitos b\u00e1sicos incluyen 256kB de memoria ROM y 16kB de RAM. MicroPython implementa un sistema de ficheros m\u00ednimo directamente en la memoria flash de la placa en la que se ejecuta, siempre que \u00e9sta disponga de m\u00e1s de 1Mb de almacenamiento. En este sistema de ficheros, existen dos archivos con un papel especial: boot.py y main.py . Estos dos ficheros se ejecutan, en este orden, en el arranque del sistema, por lo que deber\u00e1n contener las partes principales de los programas que deseemos ejecutar tras el inicio de la placa. boot.py contiene t\u00edpicamente par\u00e1metros generales de configuraci\u00f3n (por ejemplo, redes WiFi a las que conectar en el arranque), mientras que main.py suele contener la l\u00f3gica principal del programa. Tarea Instala, en tu sistema operativo el plugin Pymakr para VS Code tal y como se muestra en la p\u00e1gina del fabricante pymark . Deber\u00e1s instalar tambi\u00e9n el paquete nodejs (sudo apt install nodejs).","title":"Micropython"},{"location":"RPI-I/old/P8/#creacion-de-un-proyecto-en-pymark","text":"En primer lugar, crea un directorio nuevo y vac\u00edo en tu sistema. Por ejemplo, podemos crear un directorio llamado MiProyecto . Abre el directorio en VS Code ( Open Folder ). Necesitaremos crear una jerarqu\u00eda para nuestro proyecto. T\u00edpicamente, la jerarqu\u00eda de un proyecto sigue el siguiente esquema: MiProyecto |-lib |-biblioteca.py |boot.py |main.py En este primer ejemplo, simplemente utilizaremos un fichero main.py . Adicionalmente, crearemos un fichero de configuraci\u00f3n para nuestro proyecto a pulsando el bot\u00f3n Allcommands de la barra inferior y seleccionando Pymakr > Project Settings , que a\u00f1adir\u00e1 un fichero pymakr.conf al proyecto. Para m\u00e1s informaci\u00f3n sobre el contenido de este fichero, consulta pymakr/settings .","title":"Creaci\u00f3n de un proyecto en Pymark"},{"location":"RPI-I/old/P8/#controlando-el-led-de-nuestra-placa","text":"A\u00f1adiremos a nuestro fichero principal ( main.py ) la l\u00f3gica para controlar un LED de nuestra placa. Para ello, a\u00f1adiremos, en primer lugar, las bibliotecas a importar: import pycom import time La primera de las bibliotecas a\u00f1ade la funcionalidad necesaria para controlar espec\u00edficamente ciertas funcionalidades de las placas Pycom. La segunda nos ayudar\u00e1 a fijar temporizadores. Tarea Habr\u00e1s observado que, al arrancar la placa Pycom, el LED de la placa parpadea de forma regular. Para desactivar este parpadeo, puedes utilizar la sentencia pycom.heartbeat(False) . A\u00f1ade esta sentencia a tu c\u00f3digo y ejec\u00fatalo ( Run ) para coprobar que tu placa puede ejecutar tus c\u00f3digos. Tarea Una vez comprobada la funcionalidad del bot\u00f3n Run , modifica el c\u00f3digo para que el LED cambie de color (R-G-B) cada segundo. Encontrar\u00e1s la documentaci\u00f3n necesaria en la p\u00e1gina de documentaci\u00f3n de Pycom . El uso del bot\u00f3n Run es intuitivo y muy \u00fatil en el desarrollo, pero no es adecuado en despliegues, ya que, como puedes observar, el c\u00f3digo desarrollado no se almacena en la placa, y por tanto se pierde en el reinicio. Para salvar esta limitaci\u00f3n, experimenta con el bot\u00f3n Upload y observa c\u00f3mo tu c\u00f3digo sigue ejecut\u00e1ndose tras un reinicio.","title":"Controlando el LED de nuestra placa"},{"location":"RPI-I/old/P8/#repl","text":"REPL ( Read Evaluate Print Loop ) es el nombre que recibe la l\u00ednea de \u00f3rdenes interactivas ofrecida por las placas Pycom (y otras muchas compatibles con MicroPython). REPL proporciona historial de comandos, completado de comandos (usando la tecla Tab ), ejecuci\u00f3n y parada de c\u00f3digo (usando Ctrl-C ) y otras funcionalidades que facilitan el desarrollo sobremanera. Existe un conjunto de atajos que pueden resultar de inter\u00e9s a la hora de interactuar con la placa. Entre ellos: Ctrl-A Entra en modo raw : permite pegar y copiar c\u00f3digo, sin realizar un echo de cada l\u00ednea introducida. Ctrl-B Pasa REPL a modo normal. Ctrl-C Cancela cualquier entrada o interrumpe el c\u00f3digo que se est\u00e1 ejecutando. Ctrl-D Realiza un soft-reset de la placa. Ctrl-E Entra en modo paste , lo que permite copiar y pegar fragmentos de texto. Para salir de este modo es necesario utilizar el atajo Ctrl-D . Ctrl-F Realiza un arranque seguro del dispositivo; en otras palabras, no ejecuta los scripts boot.py ni main.py en el momento del arranque.","title":"REPL"},{"location":"RPI-I/old/P8/#infraestructura-lora-a-desarrollar","text":"","title":"Infraestructura LoRa a desarrollar"},{"location":"RPI-I/old/P8/#conexion-a-red-wifi","text":"Todas las placas Pycom soportan WiFi, por lo que es trivial realizar una conexi\u00f3n a este tipo de red. En primer lugar, inicializamos el m\u00f3dulo WLAN y construimos un objeto para interactuar con este tipo de conexi\u00f3n: import machine from network import WLAN wlan = WLAN() wlan.mode() # Chequeamos el modo - Por defecto WLAN.AP (punto de acceso). Para conectar a un punto de acceso, en primer lugar deberemos configurar nuestra placa como station en lugar de access point (modo por defecto): import machine from network import WLAN wlan = WLAN(mode=WLAN.STA) # Modo station. Y a continuaci\u00f3n podemos, sin m\u00e1s, conectar a un SSID existente: nets = wlan.scan() for net in nets: if net.ssid == 'SSID': print('Red encontrada!') wlan.connect(net.ssid, auth=(net.sec, 'clave'), timeout=5000) while not wlan.isconnected(): machine.idle() # Ahorro de energia mientras esperamos. print('WLAN: conexion establecida!') break Si necesitamos asignar una IP est\u00e1tica a nuestra placa en el proceso de arranque, podemos hacerlo en el fichero boot.py : import machine from network import WLAN wlan = WLAN() # get current object, without changing the mode if machine.reset_cause() != machine.SOFT_RESET: wlan.init(mode=WLAN.STA) # Esta configuracion debe coincidir con la del router. wlan.ifconfig(config=('192.168.178.107', '255.255.255.0', '192.168.178.1', '8.8.8.8')) if not wlan.isconnected(): wlan.connect('SSID', auth=(WLAN.WPA2, 'clave'), timeout=5000) while not wlan.isconnected(): machine.idle() Tarea Conecta tu placa a un punto de acceso wifi (por ejemplo el router de clase o tu tel\u00e9fono m\u00f3vil). Experimenta asignando una IP est\u00e1tica a la placa. Tarea Investiga c\u00f3mo conseguir que tu placa sea capaz de almacenar una lista de redes inal\u00e1mbricas a las que potencialmente conectar, y realice un proceso de intento de conexi\u00f3n a cada una de ellas en el momento del arranque, hasta llegar a conectar con una de ellas. Pod\u00e9is consultar la documentaci\u00f3n del API en https://docs.pycom.io/firmwareapi/ .","title":"Conexi\u00f3n a red WiFi"},{"location":"RPI-I/old/P8/#loramac","text":"","title":"LoRaMAC"},{"location":"RPI-I/old/P8/#comunicacion-punto-a-punto","text":"En esta primera parte de la pr\u00e1ctica, utilizaremos la interfaz LoRa directamente ( raw mode ), por lo que se ignora la capa LoRaWAN para enviar y recibir datos. De este modo, los datos son enviados en crudo, sin formato ni encriptaci\u00f3n posible, y no se a\u00f1ade ning\u00fan tipo de direccionamiento a nivel de enlace en los frames enviados. En este ejemplo, utilizaremos dos placas LoPy. El script a desarrollar se basa en un bucle infinito ( while ) con un tiempo de espera variable (y aleatorio) entre env\u00edos para minimizar las posibilidades de transmisi\u00f3n simult\u00e1nea entre dos o m\u00e1s dispositivos. El siguiente c\u00f3digo realiza env\u00edos y recepciones del modo descrito: from network import LoRa import socket import machine import time # initialise LoRa in LORA mode # Please pick the region that matches where you are using the device: # Asia = LoRa.AS923 # Australia = LoRa.AU915 # Europe = LoRa.EU868 # United States = LoRa.US915 # more params can also be given, like frequency, tx power and spreading factor lora = LoRa(mode=LoRa.LORA, region=LoRa.EU868) # create a raw LoRa socket s = socket.socket(socket.AF_LORA, socket.SOCK_RAW) while True: # send some data s.setblocking(True) s.send('Hello') # get any data received... s.setblocking(False) data = s.recv(64) print(data) # wait a random amount of time time.sleep(machine.rng() & 0x0F) Tarea Modifica el programa anterior para que cada LoPy cambie el estado de iluminaci\u00f3n de su LED en el momento en el que reciba cada frame . El resultado deber\u00eda iluminar/apagar alternativamente dicho LED con la recepci\u00f3n de cada dato. Tarea Estudia la documentaci\u00f3n del m\u00f3dulo LoRa en https://docs.pycom.io/firmwareapi/pycom/network/lora , especialmente los par\u00e1metros de inicializaci\u00f3n/construcci\u00f3n del m\u00f3dulo. Experimenta, en tu placa, variando cada uno de los valores configurables (por ejemplo, frequency , tx_power , bandwidth , spreading factor , preamble y coding rate . Describe (y entrega) una descripci\u00f3n sobre su impacto en la transmisi\u00f3n, as\u00ed como (si te es posible) su impacto en la velocidad de transmisi\u00f3n o distancia m\u00e1xima de transferencia.","title":"Comunicaci\u00f3n punto-a-punto"},{"location":"RPI-I/old/P8/#comunicacion-gateway-nodo","text":"El ejemplo que se muestra a continuaci\u00f3n propone una topolog\u00eda en la que un gateway o elemento central recibe datos crudos LoRa desde uno o m\u00e1s nodos LoRa. El c\u00f3digo, en este caso, es distinto en funci\u00f3n del elemento de la topolog\u00eda que estemos tratando. El gateway , en nuestro caso, realizar\u00e1 una escucha pasiva a la espera de la recepci\u00f3n de un paquete por parte de los nodos. Observa que el formato del paquete recibido (y acuse de recibo --ACK-- enviado en respuesta) est\u00e1 definido al inicio del propio script, y debe coincidir con el formato esperado en los nodos: import socket import struct from network import LoRa # A basic package header, B: 1 byte for the deviceId, B: 1 byte for the pkg size, %ds: Formatted string for string _LORA_PKG_FORMAT = \"!BB%ds\" # A basic ack package, B: 1 byte for the deviceId, B: 1 byte for the pkg size, B: 1 byte for the Ok (200) or error messages _LORA_PKG_ACK_FORMAT = \"BBB\" # Open a LoRa Socket, use rx_iq to avoid listening to our own messages # Please pick the region that matches where you are using the device: # Asia = LoRa.AS923 # Australia = LoRa.AU915 # Europe = LoRa.EU868 # United States = LoRa.US915 lora = LoRa(mode=LoRa.LORA, rx_iq=True, region=LoRa.EU868) lora_sock = socket.socket(socket.AF_LORA, socket.SOCK_RAW) lora_sock.setblocking(False) while (True): recv_pkg = lora_sock.recv(512) if (len(recv_pkg) > 2): recv_pkg_len = recv_pkg[1] device_id, pkg_len, msg = struct.unpack(_LORA_PKG_FORMAT % recv_pkg_len, recv_pkg) # If the uart = machine.UART(0, 115200) and os.dupterm(uart) are set in the boot.py this print should appear in the serial port print('Device: %d - Pkg: %s' % (device_id, msg)) ack_pkg = struct.pack(_LORA_PKG_ACK_FORMAT, device_id, 1, 200) lora_sock.send(ack_pkg) Observa como _LORA_PKG_FORMAT se utiliza como un mecanismo para identificar los distintos dispositivos existentes en la red. Por su parte, _LORA_PKG_ACK_FORMAT es un mecanismo de acuse de recibo sencillo para responder al nodo que envi\u00f3 el paquete. Por otra parte, el c\u00f3digo del nodo se reduce al env\u00edo de paquetes y a la espera activa a sus respectivos acuses de recibo: import os import socket import time import struct from network import LoRa # A basic package header, B: 1 byte for the deviceId, B: 1 byte for the pkg size _LORA_PKG_FORMAT = \"BB%ds\" _LORA_PKG_ACK_FORMAT = \"BBB\" DEVICE_ID = 0x01 # Open a Lora Socket, use tx_iq to avoid listening to our own messages # Please pick the region that matches where you are using the device: # Asia = LoRa.AS923 # Australia = LoRa.AU915 # Europe = LoRa.EU868 # United States = LoRa.US915 lora = LoRa(mode=LoRa.LORA, tx_iq=True, region=LoRa.EU868) lora_sock = socket.socket(socket.AF_LORA, socket.SOCK_RAW) lora_sock.setblocking(False) while(True): # Package send containing a simple string msg = \"Device 1 Here\" pkg = struct.pack(_LORA_PKG_FORMAT % len(msg), DEVICE_ID, len(msg), msg) lora_sock.send(pkg) # Wait for the response from the gateway. NOTE: For this demo the device does an infinite loop for while waiting the response. Introduce a max_time_waiting for you application waiting_ack = True while(waiting_ack): recv_ack = lora_sock.recv(256) if (len(recv_ack) > 0): device_id, pkg_len, ack = struct.unpack(_LORA_PKG_ACK_FORMAT, recv_ack) if (device_id == DEVICE_ID): if (ack == 200): waiting_ack = False # If the uart = machine.UART(0, 115200) and os.dupterm(uart) are set in the boot.py this print should appear in the serial port print(\"ACK\") else: waiting_ack = False # If the uart = machine.UART(0, 115200) and os.dupterm(uart) are set in the boot.py this print should appear in the serial port print(\"Message Failed\") time.sleep(5) Tarea Adapta el c\u00f3digo anterior a alg\u00fan escenario real, por ejemplo: Fija un tiempo m\u00e1ximo de espera para la recepci\u00f3n de acuse de recibo y el reenv\u00edo del paquete (o para descartarlo). Incrementa el tama\u00f1o de paquete modificando _LORA_PKG_FORMAT a BH\\%ds ; el car\u00e1cter H permite usar 2 bytes para el tama\u00f1o (v\u00e9ase https://docs.python.org/2/library/struct.html#format-characters para m\u00e1s informaci\u00f3n). Reduce el tama\u00f1o de mensaje y ad\u00e1ptalo a un escenario real de tu elecci\u00f3n.","title":"Comunicaci\u00f3n gateway - nodo"},{"location":"RPI-I/old/P8/#lorawan-topologia-en-estrella-implementacion-de-un-gateway-lorawan","text":"En esta secci\u00f3n trabajaremos en el desarrollo de un gateway implementado en una LoPy utilizando MicroPython. Este tipo de ejemplo permite conectar a una red LoRaWAN existente (por ejemplo, The Things Network --elegida en nuestro caso-- o Loriot ), haciendo que nuestro gateway simplemente act\u00fae como forwarder de paquetes recibidos desde nodos hacia un servidor remoto. El c\u00f3digo del gateway est\u00e1 dividido en tres scripts diferenciados: main.py , config.py y nanogateway.py . Conjuntamente, su funcionalidad es configurar el gateway para realizar una conexi\u00f3n a una red preferida (WLAN) y para actuar como packet forwarder hacia un servidor.","title":"LoRaWAN. Topolog\u00eda en estrella. Implementaci\u00f3n de un Gateway LoRaWAN"},{"location":"RPI-I/old/P8/#obtencion-del-gateway-id","text":"La mayor\u00eda de servidores LoRaWAN esperan un identificador de gateway ( gateway ID ) en forma de n\u00famero hexadecimal de 64 bits, t\u00edpicamente nombrado como EUI-64 ). La pr\u00e1ctica recomendada consiste, durante el desarrollo del gateway , en obtener este ID a partir de una expansi\u00f3n de la MAC WiFi de la placa (que es un valor de 48 bits). Podemos obtener este identificador usando el siguiente c\u00f3digo: from network import WLAN import ubinascii wl = WLAN() ubinascii.hexlify(wl.mac())[:6] + 'FFFE' + ubinascii.hexlify(wl.mac())[6:] El resultado ser\u00e1 algo similar a b'240ac4FFFE008d88' , donde 40ac4FFFE008d88 ser\u00eda nuestro identificador de gateway , que usaremos en la configuraci\u00f3n del servidor LoRa para identificar de forma un\u00edvoca a nuestro dispositivo.","title":"Obtenci\u00f3n del Gateway ID"},{"location":"RPI-I/old/P8/#el-fichero-mainpy","text":"Este fichero, como se ha dicho anteriormente, se ejecuta al inicio e importa, en primer lugar, el script de configuraci\u00f3n config.py para inicializar el gateway . Una vez configurado, se arranca la l\u00f3gica del gateway . \"\"\" LoPy LoRaWAN Nano Gateway example usage \"\"\" import config from nanogateway import NanoGateway if __name__ == '__main__': nanogw = NanoGateway( id=config.GATEWAY_ID, frequency=config.LORA_FREQUENCY, datarate=config.LORA_GW_DR, ssid=config.WIFI_SSID, password=config.WIFI_PASS, server=config.SERVER, port=config.PORT, ntp_server=config.NTP, ntp_period=config.NTP_PERIOD_S ) nanogw.start() nanogw._log('You may now press ENTER to enter the REPL') input()","title":"El fichero main.py"},{"location":"RPI-I/old/P8/#el-fichero-configpy","text":"El fichero de configuraci\u00f3n config.py contiene par\u00e1metros generales de configuraci\u00f3n para el servidor y la red LoRa a la que deseamos conectar nuestro dispositivo. En funci\u00f3n de la regi\u00f3n y el proveedor ( TTN, Loriot, etc. ), estos par\u00e1metros variar\u00e1n, por lo que ser\u00e1 necesario adaptar estos valores en funci\u00f3n de nuestra configuraci\u00f3n. El siguiente ejemplo muestra la configuraci\u00f3n necesaria para la conexi\u00f3n a The Things Network (TTN) en regi\u00f3n europea (868 Mhz). Obs\u00e9rvese c\u00f3mo se obtiene un Gateway ID como se ha indicado anteriormente, y c\u00f3mo es necesario adaptar tanto el SSID como la contrase\u00f1a para autenticaci\u00f3n en nuestra red WiFi de forma acorde: \"\"\" LoPy LoRaWAN Nano Gateway configuration options \"\"\" import machine import ubinascii WIFI_MAC = ubinascii.hexlify(machine.unique_id()).upper() # Set the Gateway ID to be the first 3 bytes of MAC address + 'FFFE' + last 3 bytes of MAC address GATEWAY_ID = WIFI_MAC[:6] + \"FFFE\" + WIFI_MAC[6:12] SERVER = 'router.eu.thethings.network' PORT = 1700 NTP = \"pool.ntp.org\" NTP_PERIOD_S = 3600 WIFI_SSID = 'my-wifi' WIFI_PASS = 'my-wifi-password' # for EU868 LORA_FREQUENCY = 868100000 LORA_GW_DR = \"SF7BW125\" # DR_5 LORA_NODE_DR = 5 # for US915 # LORA_FREQUENCY = 903900000 # LORA_GW_DR = \"SF7BW125\" # DR_3 # LORA_NODE_DR = 3","title":"El fichero config.py"},{"location":"RPI-I/old/P8/#el-ficherobilioteca-nanogatewaypy","text":"La biblioteca nanogateway.py implementa la l\u00f3gica de recepci\u00f3n, generaci\u00f3n y reenv\u00edo de paquetes de datos LoRa. No requiere ninguna configuraci\u00f3n, se sugiere que el estudiante observe e intente enteder su fucionamiento y funcionalidad ofrecida. \"\"\" LoPy LoRaWAN Nano Gateway. Can be used for both EU868 and US915. \"\"\" import errno import machine import ubinascii import ujson import uos import usocket import utime import _thread from micropython import const from network import LoRa from network import WLAN from machine import Timer PROTOCOL_VERSION = const(2) PUSH_DATA = const(0) PUSH_ACK = const(1) PULL_DATA = const(2) PULL_ACK = const(4) PULL_RESP = const(3) TX_ERR_NONE = 'NONE' TX_ERR_TOO_LATE = 'TOO_LATE' TX_ERR_TOO_EARLY = 'TOO_EARLY' TX_ERR_COLLISION_PACKET = 'COLLISION_PACKET' TX_ERR_COLLISION_BEACON = 'COLLISION_BEACON' TX_ERR_TX_FREQ = 'TX_FREQ' TX_ERR_TX_POWER = 'TX_POWER' TX_ERR_GPS_UNLOCKED = 'GPS_UNLOCKED' UDP_THREAD_CYCLE_MS = const(20) STAT_PK = { 'stat': { 'time': '', 'lati': 0, 'long': 0, 'alti': 0, 'rxnb': 0, 'rxok': 0, 'rxfw': 0, 'ackr': 100.0, 'dwnb': 0, 'txnb': 0 } } RX_PK = { 'rxpk': [{ 'time': '', 'tmst': 0, 'chan': 0, 'rfch': 0, 'freq': 0, 'stat': 1, 'modu': 'LORA', 'datr': '', 'codr': '4/5', 'rssi': 0, 'lsnr': 0, 'size': 0, 'data': '' }] } TX_ACK_PK = { 'txpk_ack': { 'error': '' } } class NanoGateway: \"\"\" Nano gateway class, set up by default for use with TTN, but can be configured for any other network supporting the Semtech Packet Forwarder. Only required configuration is wifi_ssid and wifi_password which are used for connecting to the Internet. \"\"\" def __init__(self, id, frequency, datarate, ssid, password, server, port, ntp_server='pool.ntp.org', ntp_period=3600): self.id = id self.server = server self.port = port self.frequency = frequency self.datarate = datarate self.ssid = ssid self.password = password self.ntp_server = ntp_server self.ntp_period = ntp_period self.server_ip = None self.rxnb = 0 self.rxok = 0 self.rxfw = 0 self.dwnb = 0 self.txnb = 0 self.sf = self._dr_to_sf(self.datarate) self.bw = self._dr_to_bw(self.datarate) self.stat_alarm = None self.pull_alarm = None self.uplink_alarm = None self.wlan = None self.sock = None self.udp_stop = False self.udp_lock = _thread.allocate_lock() self.lora = None self.lora_sock = None self.rtc = machine.RTC() def start(self): \"\"\" Starts the LoRaWAN nano gateway. \"\"\" self._log('Starting LoRaWAN nano gateway with id: {}', self.id) # setup WiFi as a station and connect self.wlan = WLAN(mode=WLAN.STA) self._connect_to_wifi() # get a time sync self._log('Syncing time with {} ...', self.ntp_server) self.rtc.ntp_sync(self.ntp_server, update_period=self.ntp_period) while not self.rtc.synced(): utime.sleep_ms(50) self._log(\"RTC NTP sync complete\") # get the server IP and create an UDP socket self.server_ip = usocket.getaddrinfo(self.server, self.port)[0][-1] self._log('Opening UDP socket to {} ({}) port {}...', self.server, self.server_ip[0], self.server_ip[1]) self.sock = usocket.socket(usocket.AF_INET, usocket.SOCK_DGRAM, usocket.IPPROTO_UDP) self.sock.setsockopt(usocket.SOL_SOCKET, usocket.SO_REUSEADDR, 1) self.sock.setblocking(False) # push the first time immediatelly self._push_data(self._make_stat_packet()) # create the alarms self.stat_alarm = Timer.Alarm(handler=lambda t: self._push_data(self._make_stat_packet()), s=60, periodic=True) self.pull_alarm = Timer.Alarm(handler=lambda u: self._pull_data(), s=25, periodic=True) # start the UDP receive thread self.udp_stop = False _thread.start_new_thread(self._udp_thread, ()) # initialize the LoRa radio in LORA mode self._log('Setting up the LoRa radio at {} Mhz using {}', self._freq_to_float(self.frequency), self.datarate) self.lora = LoRa( mode=LoRa.LORA, frequency=self.frequency, bandwidth=self.bw, sf=self.sf, preamble=8, coding_rate=LoRa.CODING_4_5, tx_iq=True ) # create a raw LoRa socket self.lora_sock = usocket.socket(usocket.AF_LORA, usocket.SOCK_RAW) self.lora_sock.setblocking(False) self.lora_tx_done = False self.lora.callback(trigger=(LoRa.RX_PACKET_EVENT | LoRa.TX_PACKET_EVENT), handler=self._lora_cb) self._log('LoRaWAN nano gateway online') def stop(self): \"\"\" Stops the LoRaWAN nano gateway. \"\"\" self._log('Stopping...') # send the LoRa radio to sleep self.lora.callback(trigger=None, handler=None) self.lora.power_mode(LoRa.SLEEP) # stop the NTP sync self.rtc.ntp_sync(None) # cancel all the alarms self.stat_alarm.cancel() self.pull_alarm.cancel() # signal the UDP thread to stop self.udp_stop = True while self.udp_stop: utime.sleep_ms(50) # disable WLAN self.wlan.disconnect() self.wlan.deinit() def _connect_to_wifi(self): self.wlan.connect(self.ssid, auth=(None, self.password)) while not self.wlan.isconnected(): utime.sleep_ms(50) self._log('WiFi connected to: {}', self.ssid) def _dr_to_sf(self, dr): sf = dr[2:4] if sf[1] not in '0123456789': sf = sf[:1] return int(sf) def _dr_to_bw(self, dr): bw = dr[-5:] if bw == 'BW125': return LoRa.BW_125KHZ elif bw == 'BW250': return LoRa.BW_250KHZ else: return LoRa.BW_500KHZ def _sf_bw_to_dr(self, sf, bw): dr = 'SF' + str(sf) if bw == LoRa.BW_125KHZ: return dr + 'BW125' elif bw == LoRa.BW_250KHZ: return dr + 'BW250' else: return dr + 'BW500' def _lora_cb(self, lora): \"\"\" LoRa radio events callback handler. \"\"\" events = lora.events() if events & LoRa.RX_PACKET_EVENT: self.rxnb += 1 self.rxok += 1 rx_data = self.lora_sock.recv(256) stats = lora.stats() packet = self._make_node_packet(rx_data, self.rtc.now(), stats.rx_timestamp, stats.sfrx, self.bw, stats.rssi, stats.snr) packet = self.frequency_rounding_fix(packet, self.frequency) self._push_data(packet) self._log('Received packet: {}', packet) self.rxfw += 1 if events & LoRa.TX_PACKET_EVENT: self.txnb += 1 lora.init( mode=LoRa.LORA, frequency=self.frequency, bandwidth=self.bw, sf=self.sf, preamble=8, coding_rate=LoRa.CODING_4_5, tx_iq=True ) def _freq_to_float(self, frequency): \"\"\" MicroPython has some inprecision when doing large float division. To counter this, this method first does integer division until we reach the decimal breaking point. This doesn't completely elimate the issue in all cases, but it does help for a number of commonly used frequencies. \"\"\" divider = 6 while divider > 0 and frequency % 10 == 0: frequency = frequency // 10 divider -= 1 if divider > 0: frequency = frequency / (10 ** divider) return frequency def frequency_rounding_fix(self, packet, frequency): freq = str(frequency)[0:3] + '.' + str(frequency)[3] start = packet.find(\"freq\\\":\") end = packet.find(\",\", start) packet = packet[:start + 7] + freq + packet[end:] return packet def _make_stat_packet(self): now = self.rtc.now() STAT_PK[\"stat\"][\"time\"] = \"%d-%02d-%02d %02d:%02d:%02d GMT\" % (now[0], now[1], now[2], now[3], now[4], now[5]) STAT_PK[\"stat\"][\"rxnb\"] = self.rxnb STAT_PK[\"stat\"][\"rxok\"] = self.rxok STAT_PK[\"stat\"][\"rxfw\"] = self.rxfw STAT_PK[\"stat\"][\"dwnb\"] = self.dwnb STAT_PK[\"stat\"][\"txnb\"] = self.txnb return ujson.dumps(STAT_PK) def _make_node_packet(self, rx_data, rx_time, tmst, sf, bw, rssi, snr): RX_PK[\"rxpk\"][0][\"time\"] = \"%d-%02d-%02dT%02d:%02d:%02d.%dZ\" % (rx_time[0], rx_time[1], rx_time[2], rx_time[3], rx_time[4], rx_time[5], rx_time[6]) RX_PK[\"rxpk\"][0][\"tmst\"] = tmst RX_PK[\"rxpk\"][0][\"freq\"] = self._freq_to_float(self.frequency) RX_PK[\"rxpk\"][0][\"datr\"] = self._sf_bw_to_dr(sf, bw) RX_PK[\"rxpk\"][0][\"rssi\"] = rssi RX_PK[\"rxpk\"][0][\"lsnr\"] = snr RX_PK[\"rxpk\"][0][\"data\"] = ubinascii.b2a_base64(rx_data)[:-1] RX_PK[\"rxpk\"][0][\"size\"] = len(rx_data) return ujson.dumps(RX_PK) def _push_data(self, data): token = uos.urandom(2) packet = bytes([PROTOCOL_VERSION]) + token + bytes([PUSH_DATA]) + ubinascii.unhexlify(self.id) + data with self.udp_lock: try: self.sock.sendto(packet, self.server_ip) except Exception as ex: self._log('Failed to push uplink packet to server: {}', ex) def _pull_data(self): token = uos.urandom(2) packet = bytes([PROTOCOL_VERSION]) + token + bytes([PULL_DATA]) + ubinascii.unhexlify(self.id) with self.udp_lock: try: self.sock.sendto(packet, self.server_ip) except Exception as ex: self._log('Failed to pull downlink packets from server: {}', ex) def _ack_pull_rsp(self, token, error): TX_ACK_PK[\"txpk_ack\"][\"error\"] = error resp = ujson.dumps(TX_ACK_PK) packet = bytes([PROTOCOL_VERSION]) + token + bytes([PULL_ACK]) + ubinascii.unhexlify(self.id) + resp with self.udp_lock: try: self.sock.sendto(packet, self.server_ip) except Exception as ex: self._log('PULL RSP ACK exception: {}', ex) def _send_down_link(self, data, tmst, datarate, frequency): \"\"\" Transmits a downlink message over LoRa. \"\"\" self.lora.init( mode=LoRa.LORA, frequency=frequency, bandwidth=self._dr_to_bw(datarate), sf=self._dr_to_sf(datarate), preamble=8, coding_rate=LoRa.CODING_4_5, tx_iq=True ) #while utime.ticks_cpu() < tmst: # pass self.lora_sock.send(data) self._log( 'Sent downlink packet scheduled on {:.3f}, at {:.3f} Mhz using {}: {}', tmst / 1000000, self._freq_to_float(frequency), datarate, data ) def _send_down_link_class_c(self, data, datarate, frequency): self.lora.init( mode=LoRa.LORA, frequency=frequency, bandwidth=self._dr_to_bw(datarate), sf=self._dr_to_sf(datarate), preamble=8, coding_rate=LoRa.CODING_4_5, tx_iq=True, device_class=LoRa.CLASS_C ) self.lora_sock.send(data) self._log( 'Sent downlink packet scheduled on {:.3f}, at {:.3f} Mhz using {}: {}', utime.time(), self._freq_to_float(frequency), datarate, data ) def _udp_thread(self): \"\"\" UDP thread, reads data from the server and handles it. \"\"\" while not self.udp_stop: try: data, src = self.sock.recvfrom(1024) _token = data[1:3] _type = data[3] if _type == PUSH_ACK: self._log(\"Push ack\") elif _type == PULL_ACK: self._log(\"Pull ack\") elif _type == PULL_RESP: self.dwnb += 1 ack_error = TX_ERR_NONE tx_pk = ujson.loads(data[4:]) if \"tmst\" in data: tmst = tx_pk[\"txpk\"][\"tmst\"] t_us = tmst - utime.ticks_cpu() - 15000 if t_us < 0: t_us += 0xFFFFFFFF if t_us < 20000000: self.uplink_alarm = Timer.Alarm( handler=lambda x: self._send_down_link( ubinascii.a2b_base64(tx_pk[\"txpk\"][\"data\"]), tx_pk[\"txpk\"][\"tmst\"] - 50, tx_pk[\"txpk\"][\"datr\"], int(tx_pk[\"txpk\"][\"freq\"] * 1000) * 1000 ), us=t_us ) else: ack_error = TX_ERR_TOO_LATE self._log('Downlink timestamp error!, t_us: {}', t_us) else: self.uplink_alarm = Timer.Alarm( handler=lambda x: self._send_down_link_class_c( ubinascii.a2b_base64(tx_pk[\"txpk\"][\"data\"]), tx_pk[\"txpk\"][\"datr\"], int(tx_pk[\"txpk\"][\"freq\"] * 1000) * 1000 ), us=50 ) self._ack_pull_rsp(_token, ack_error) self._log(\"Pull rsp\") except usocket.timeout: pass except OSError as ex: if ex.errno != errno.EAGAIN: self._log('UDP recv OSError Exception: {}', ex) except Exception as ex: self._log('UDP recv Exception: {}', ex) # wait before trying to receive again utime.sleep_ms(UDP_THREAD_CYCLE_MS) # we are to close the socket self.sock.close() self.udp_stop = False self._log('UDP thread stopped') def _log(self, message, *args): \"\"\" Outputs a log message to stdout. \"\"\" print('[{:>10.3f}] {}'.format( utime.ticks_ms() / 1000, str(message).format(*args) ))","title":"El fichero/bilioteca nanogateway.py"},{"location":"RPI-I/old/P8/#registro-en-el-servidor-lorawan-the-things-network-ttn","text":"Para configurar nuestro gateway en TTN, navegaremos a su p\u00e1gina web y crearemos una nueva cuenta, introduciendo un nombre de usuario, contrase\u00f1a y direcci\u00f3n de correo que nos permitir\u00e1 validar dicha informaci\u00f3n, como se muestra en la Figura: Con la cuenta ya creada, podemos proceder con el registro del gateway desde la consola TTN.","title":"Registro en el servidor LoRaWAN (The Things Network -- TTN)"},{"location":"RPI-I/old/P8/#registro-del-gateway-en-the-things-network-ttn","text":"En la consola TTN existen dos opciones: applications y gateways , como muestra la Figura: Selecciona la opci\u00f3n gateways y, dentro de ella, Register Gateway . Esto permitir\u00e1 registrar un nuevo gateway . En esta opci\u00f3n, configuraremos los par\u00e1metros que se muestran en la siguiente tabla: Opci\u00f3n Valor Protocolo Packet Forwarder Gateway EUI Definido por el usuario (debe coincidir con el obtenido en config.py ) Description Definido por el usuario Frequency Plan Spain/EU 868 Mhz Location Definido por el usuario Antena Indoor o outdoor Una vez configurado, registramos el gateway con el bot\u00f3n Register Gateway ; una vez registrado, navega a la opci\u00f3n Gateway Settiings y selecciona una direcci\u00f3n de router que coincida con la usada en la configuraci\u00f3n del mismo (en este caso, router.eu.thethings.network , v\u00e9ase la siguiente Figura). En este punto, si todo ha ido bien, el gateway deber\u00eda estar configurado y registrado en TTN. Pasamos a continuaci\u00f3n a la configuraci\u00f3n de los nodos LoRa .","title":"Registro del gateway en (The Things Network -- TTN)"},{"location":"RPI-I/old/P8/#configuracion-del-nodo-lorawan","text":"Existen dos m\u00e9todos para conectar dispositivos LoPy a nuestro gateway : OTAA ( Over The Air Activation ) y ABP ( Activation By Personalization ), cuyas instrucciones de confguraci\u00f3n se muestran en las siguientes secciones.","title":"Configuraci\u00f3n del nodo LoRaWAN"},{"location":"RPI-I/old/P8/#configuracion-del-nodo-via-otaa-over-the-air-activation","text":"Si nuestro nodo LoPy conecta una aplicaci\u00f3n (a trav\u00e9s de TTN) usando OTAA, la configuraci\u00f3n de red se extrae usando un protocolo de handshake entre la LoPy y el servidor de red. Obs\u00e9rvese como las claves de red derivadas usando OTAA son espec\u00edficas para el dispositivo y se utilizan para encriptar y verificar las transmisiones a nivel de red: \"\"\" OTAA Node example compatible with the LoPy Nano Gateway \"\"\" from network import LoRa import socket import ubinascii import struct import time # Initialize LoRa in LORAWAN mode. lora = LoRa(mode=LoRa.LORAWAN) # create an OTA authentication params dev_eui = ubinascii.unhexlify('AABBCCDDEEFF7778') # these settings can be found from TTN app_eui = ubinascii.unhexlify('70B3D57EF0003BFD') # these settings can be found from TTN app_key = ubinascii.unhexlify('36AB7625FE77776881683B495300FFD6') # these settings can be found from TTN # set the 3 default channels to the same frequency (must be before sending the OTAA join request) lora.add_channel(0, frequency=868100000, dr_min=0, dr_max=5) lora.add_channel(1, frequency=868100000, dr_min=0, dr_max=5) lora.add_channel(2, frequency=868100000, dr_min=0, dr_max=5) # join a network using OTAA lora.join(activation=LoRa.OTAA, auth=(dev_eui, app_eui, app_key), timeout=0) # wait until the module has joined the network while not lora.has_joined(): time.sleep(2.5) print('Not joined yet...') # remove all the non-default channels for i in range(3, 16): lora.remove_channel(i) # create a LoRa socket s = socket.socket(socket.AF_LORA, socket.SOCK_RAW) # set the LoRaWAN data rate s.setsockopt(socket.SOL_LORA, socket.SO_DR, 5) # make the socket non-blocking s.setblocking(False) time.sleep(5.0) \"\"\" Your own code can be written below! \"\"\" for i in range (200): s.send(b'PKT #' + bytes([i])) time.sleep(4) rx = s.recv(256) if rx: print(rx) time.sleep(6)","title":"Configuraci\u00f3n del nodo v\u00eda OTAA (Over The Air Activation)"},{"location":"RPI-I/old/P8/#configuracion-del-nodo-via-abp-activation-by-personalization","text":"Si se escoge el modo de uni\u00f3n a la red ABP, se requiere que el usuario defina los siguietnes valores, que deben definirse en el firmware y especificarse en TTN: Direcci\u00f3n del dispositivo. Clave de sesi\u00f3n de aplicaci\u00f3n ( Application Session Key ). Clave de sesi\u00f3n de red ( Network Session Key ). El siguiente c\u00f3digo muestra un ejemplo de configuraci\u00f3n de nodo usando ABP: \"\"\" ABP Node example compatible with the LoPy Nano Gateway \"\"\" from network import LoRa import socket import ubinascii import struct import time # Initialise LoRa in LORAWAN mode. lora = LoRa(mode=LoRa.LORAWAN) # create an ABP authentication params dev_addr = struct.unpack(\">l\", ubinascii.unhexlify('2601147D'))[0] # these settings can be found from TTN nwk_swkey = ubinascii.unhexlify('3C74F4F40CAE2221303BC24284FCF3AF') # these settings can be found from TTN app_swkey = ubinascii.unhexlify('0FFA7072CC6FF69A102A0F39BEB0880F') # these settings can be found from TTN # join a network using ABP (Activation By Personalisation) lora.join(activation=LoRa.ABP, auth=(dev_addr, nwk_swkey, app_swkey)) # remove all the non-default channels for i in range(3, 16): lora.remove_channel(i) # set the 3 default channels to the same frequency lora.add_channel(0, frequency=868100000, dr_min=0, dr_max=5) lora.add_channel(1, frequency=868100000, dr_min=0, dr_max=5) lora.add_channel(2, frequency=868100000, dr_min=0, dr_max=5) # create a LoRa socket s = socket.socket(socket.AF_LORA, socket.SOCK_RAW) # set the LoRaWAN data rate s.setsockopt(socket.SOL_LORA, socket.SO_DR, 5) # make the socket non-blocking s.setblocking(False) \"\"\" Your own code can be written below! \"\"\" for i in range (200): s.send(b'PKT #' + bytes([i])) time.sleep(4) rx = s.recv(256) if rx: print(rx) time.sleep(6)","title":"Configuraci\u00f3n del nodo v\u00eda ABP (Activation By Personalization)"},{"location":"RPI-I/old/P8/#aplicaciones-ttn","text":"Cno los nodos y gateways ya configurados, podemos proceder al desarrollo de una aplicaci\u00f3n en TTN (esto es, el procesamiento que sufren los datos LoRa una vez recibidos por parte de TTN). Aunque existen multitud de configuraciones disponibles, nosotros trabajaremos con una integraci\u00f3n de nuestra aplicaci\u00f3n con peticiones HTTP de salida.","title":"Aplicaciones TTN"},{"location":"RPI-I/old/P8/#registro-de-una-nueva-aplicacion","text":"Seleccionando la pesta\u00f1a Applications en la consola TTN, aparecer\u00e1 una pantalla para el registro de aplicaciones. Al clicar en Register aparecer\u00e1 una nueva ventana como la mostrada en la siguiente Figura. Introduce en el formulario un ID de aplicaci\u00f3n \u00fanico y un descriptor y manejador.","title":"Registro de una nueva aplicaci\u00f3n"},{"location":"RPI-I/old/P8/#registro-de-dispositivos","text":"Para conectar nodos al gateway , los dispositivos deben a\u00f1adirse a la propia aplicaci\u00f3n. Para ello, navega a la pesta\u00f1a Devices en la p\u00e1gina Application y pulsa el bot\u00f3n Register Device . En el panel que aparecer\u00e1, completa los campos Device ID y Device EUI ; el primero es seleccionado por el usuario y es \u00fanica para cada dispositivo en esta aplicaci\u00f3n; el segundo tambi\u00e9n es seleccionable por el usuario y debe consistir en un valor de 8 bytes, dados en hexadecimal. Una vez a\u00f1adido, modifica el m\u00e9todo de activaci\u00f3n ( Activation Method ) y selecciona OTAA o ABP , en funci\u00f3n de tu c\u00f3digo del nodo (pesta\u00f1a Settings ).","title":"Registro de dispositivos"},{"location":"RPI-I/old/P8/#integracion-con-aplicacionesservicios-externos","text":"En este punto, los datos deber\u00edan estar siendo recibidos por el backend TTN. Podemos indicar a TTN c\u00f3mo reenviar estos datos a un servicio externo. Para ello, utilizaremos la pesta\u00f1a Integrations dentro de las preferencias de la nueva aplicaci\u00f3n. A\u00f1adiremos una nueva integraci\u00f3n de tipo HTTP, en la que, entre otros valores, deberemos indicar la URL destino de nuestros env\u00edos, el m\u00e9todo de env\u00edo (por ejemplo, POST) y en caso de ser necesaria, informaci\u00f3n sobre autenticaci\u00f3n. TTN reenviar\u00e1 los datos recibidos al servidor indicado tan pronto como nuestros nodos LoPy comiencen a enviar datos. Tarea Sigue los pasos anteriormente descritos para configurar un gateway LoRaWAN, registr\u00e1ndolo en TTN, y para la configuraci\u00f3n de al menos uno nodo LoRa que, a trav\u00e9s del gateway configurado, env\u00ede datos a TTN.","title":"Integraci\u00f3n con aplicaciones/servicios externos"},{"location":"RPI-II/P10_old/","text":"Pr\u00e1ctica 6. Frameworks IoT y Cloud Objetivos La pr\u00e1ctica presenta los pasos esenciales que permiten hacer interactuar un dispositivo (ESP32) con una infraestructura IoT en la nube. Aunque en este caso utilizaremos Microsoft Azure, los pasos tanto en configuraci\u00f3n remota como a nivel de nodo son muy similares a los que deber\u00edas seguir para otras infraestructuras (Amazon AWS, Google IoT Core, Aliyun IoT, Tencent Iot o cualquier otro). La documentaci\u00f3n de IDF proporciona ejemplos detallados para cada uno. El objetivo de la pr\u00e1ctica es desplegar un sistema de monitorizaci\u00f3n remota en Microsoft Power BI, que permita visualizar datos de telemetr\u00eda emitidos v\u00eda MQTT por el dispositivo a trav\u00e9s de un gateway en la nube (llamado en el caso de Azure IoT Hub ). Introducci\u00f3n El SDK ESP Azure IoT es una infraestructura basada en el SDK de Azure par IoT con soporte para C ( azure-iot-sdk-c ) portado sobre ESP-IDF para dar soporte al ESP32. Adem\u00e1s, proporciona un conjunto de ejemplos que permiten observar y simplificar el proceso de configuraci\u00f3n y conexi\u00f3n al framework Azure IoT Hub. Preparaci\u00f3n del firmware en el ESP32 En la presente pr\u00e1ctica utilizar\u00e1s una placa ESP32 que actuar\u00e1 como cliente ESP32, con un firmware personalizado que implementa la l\u00f3gica de conexi\u00f3n e interacci\u00f3n con Azure. En primer lugar: Configura una instalaci\u00f3n de ESP IDF tal y como has hecho en pr\u00e1cticas anteriores. Si ya la has configurado y es funcional, no es necesario ninguna reinstalaci\u00f3n ni reconfiguraci\u00f3n. En un directorio independiente, clona el repositorio de ESP Azure (f\u00edjate en la opci\u00f3n --recursive , que es imprescindible): git clone --recursive https://github.com/espressif/esp-azure.git Configuraci\u00f3n de Microsoft Azure Los siguientes pasos requieren el uso de una cuenta creada con Microsoft Azure. Los estudiantes UCM pueden adherirse al programa acad\u00e9mico, que otorga suficiente cr\u00e9dito para realizar este tipo de pr\u00e1cticas. Aseg\u00farate de acceder al portal de MS Azure y utilizar tu usuario y credenciales UCM para ello. Creaci\u00f3n de un Centro de IoT ( IoT Hub ) En la p\u00e1gina principal de Azure, selecciona la opci\u00f3n \"Crear un Recurso\" (en el men\u00fa de la parte superior izquierda de la pantalla) y a continuaici\u00f3n selecciona IoT Hub en cuadro \"Buscar en Marketplace\". Selecciona Iot Hub en los resultados de la b\u00fasqueda, y a continuaci\u00f3n \"Crear\". En la pesta\u00f1a Aspectos B\u00e1sicos , completa los campos de la siguiente forma: Suscripci\u00f3n : selecciona la suscripci\u00f3n que desees usar (por defecto, deber\u00eda aparecer Azure para estudiantes ). Grupo de recursos : crea un nuevo grupo de recursos seleccionando la opci\u00f3n Crear nuevo , y ot\u00f3rgale el nombre que desees, por ejemplo MIOTGROUP . Regi\u00f3n : selecciona la regi\u00f3n m\u00e1s cercana a ti (por ejemplo, Oeste de Europa ). Nombre : por \u00faltimo, da un nombre al hub , por ejemplo MIOTHUB . Deja los par\u00e1metros por defecto en la pesta\u00f1a Redes , y elige como Nivel de precios F1 en la pesta\u00f1a Administraci\u00f3n . Asigna las etiquetas que desees y finalmente confirma la creaci\u00f3n del Centro de IoT . Si todo ha ido bien, ver\u00e1s un resumen del recurso creado y podr\u00e1s acceder a \u00e9l pinchando en \"Ir al recurso\" . Ver\u00e1s una pantalla similar a la siguiente: En la secci\u00f3n de Configuraci\u00f3n , elige Directivas de acceso compartido y crea una nueva directiva llamada, por ejemplo MIOTPOLICY , con permisos de lectura y escritura en Registro, y conexi\u00f3n de servicios y dispositivos. Las pol\u00edticas de lectura y escritura en registro otorgan derechos de acceso al registro de indentidades de Azure. Estos permisos ser\u00e1n utilizados por servicios de back-end para gestionar las identidades de dispositivos, por ejemplo. La pol\u00edtica de conexi\u00f3n de servicio otorga permisos para acceder a endpoints de servicio. Los servicios de back-end podr\u00e1n enviar y recibir mensajes de dispositivos. La pol\u00edtica de conexi\u00f3n de dispositivo otorga permisos para enviar y recibir mensajes usando el IoT Hub . Una vez creada, selecci\u00f3nala y copia la Cadena de conexi\u00f3n principal (clave principal) que aparece en pantalla. No es necesario que la muestres, puedes usar el bot\u00f3n de copia directamente. Apunta esta cadena en un fichero de texto. Esta es la clave de acceso para el Hub . Registro de un nuevo dispositivo A continuaci\u00f3n, crearemos una nueva identidad de dispositivo en el Registro de Identidades del hub IoT que acabas de crear. Para ello: En el men\u00fa de navegaci\u00f3n, abre la opci\u00f3n \"Dispositivos de IoT\" y selecciona Nuevo para crear un nuevo dispositivo. Dale el nombre que quieras (por ejemplo MIOTDEVICE), pero recu\u00e9rdalo, y selecciona Guardar . Una vez creado, selecci\u00f3nalo y copia la Cadena de conexi\u00f3n principal que aparece en pantalla. No es necesario que la muestres, puedes usar el bot\u00f3n de copia directamente. Apunta esta cadena en un fichero de texto. Esta es la clave de acceso para el dispositivo . Instalaci\u00f3n de el cliente Azure Para instalar el cliente Azure en Linux, usa la orden: curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash Tienes m\u00e1s opciones de instalaci\u00f3n en la p\u00e1gina . Una vez instalado, desde tu terminal, ejecuta el comando az para comprobar que la instalaci\u00f3n fue correcta. Deber\u00edas ver una salida similar a esta: az Welcome to Azure CLI! --------------------- Use `az -h` to see available commands or go to https://aka.ms/cli. ... Instala la extensi\u00f3n del cliente para Azure IoT: az extension add --name azure-iot Ingresa en el sistema ejecutando (se te pedir\u00e1 autenticaci\u00f3n en navegador, introduce tus credenciales): az login Para usar el cliente como m\u00e9todo de creaci\u00f3n de un dispositivo, puedes utilizar la siguiente orden: az iot hub device-identity create -n [IoTHub Name] -d [Device ID] Tarea Crea un nuevo dispositivo, distinto al que creaste anteriormente, en tu hub. Despu\u00e9s, obt\u00e9n su cadena de conexi\u00f3n usando la orden az iot hub device-identity connection-string show -n [IoTHub Name] -d [Device ID] . Comprueba que, efectivamente, la creaci\u00f3n del dispositivo es visible en la plataforma web. Monitorizaci\u00f3n de valores de telemetr\u00eda del dispositivo y eventos Para observar los datos intercambiados entre el dispositivo y el hub IoT desde l\u00ednea de ocmandos, puedes usar la orden: az iot hub monitor-events -n [IoTHub Name] --login 'cadena de conexion' (Ten en cuenta que las comillas simples deben estar presentes). Despliegue de un cliente MQTT en el ESP32 Dir\u00edgete al ejemplo situado en el directorio esp-azure/examples/iothub_client_sample_mqtt . En \u00e9l, vamos a trabajar con cualquiera de los dos dispositivos que has creado en tu Hub . En cualquier caso, muestra su cadena de conexi\u00f3n principal . Deber\u00e1s ver un valor de devoluci\u00f3n de tipo: { \"connectionString\": \"HostName=<azure-iot-hub-name>.azure-devices.net;DeviceId=<azure-iot-device-id>;SharedAccessKey=<base64-encoded-shared-access-key>\" } Deber\u00e1s apuntar (copiar) \u00fanicamente la parte que comienza por HostName=... , hasta el final de la cadena. No incluyas las comillas dobles. Ejecuta make menuconfig . En el men\u00fa Example Configuration , configura las credenciales de acceso a tu red WiFi, as\u00ed como la cadena de conexi\u00f3n que copiaste en la opci\u00f3n IOT Hub Device Connection String . A continuaci\u00f3n, ejecuta la orden de compilaci\u00f3n, flasheado y monitorizaci\u00f3n: make flash monitor En una ventana separada, puedes monitorizar los eventos IoT en tu hub usando su cadena de conexi\u00f3n: az iot hub monitor-events -n [IoTHub Name] --login 'Cadena de conexi\u00f3n primaria' Una vez arrancado y conectado a Internet el dispositivo comenzar\u00e1 a publicar mensajes MQTT. El monitor que has lanzado los mostrar\u00e1 como: { \"event\": { \"origin\": \"<azure-iot-device-id>\", \"payload\": \"{\\\"deviceId\\\":\\\"MIOTDEVICE\\\",\\\"windSpeed\\\":13.00,\\\"temperature\\\":22.00,\\\"humidity\\\":67.00}\" } } Observa que incluye tres valores: velocidad del viento, temperatura y humedad. Tarea Analiza el c\u00f3digo y observa, en la tarea principal, el uso que hace de la API de Azure SDK C, as\u00ed como el punto en el que genera el mensaje MQTT (y sus valores). Tambi\u00e9n es posible enviar mensajes al dispositivo directamente desde l\u00ednea de comandos (observa que estos mensajes se env\u00edan v\u00eda red, no v\u00eda puerto serie, a trav\u00e9s del Hub ). Por tanto, puedes hacerlo desde cualquier punto, no obligatoriamente desde tu PC: az iot device c2d-message send -d [Device Id] -n [IoTHub Name] --data [Data_to_Send] Nota Si todo ha ido bien, en este punto deber\u00edas estar observando cada uno de los mensajes enviados por tu ESP32 al hub desde el monitor. Visualizaci\u00f3n de datos en Microsoft PowerBI En esta parte, el objetivo es visualizar los datos enviados por tu sensor (temperatura, humedad y velocidad del viento, en la herramienta de visualizaci\u00f3n PowerBI de Microsoft. Aunque PowerBI suele utilizarse en entornos de inteligencia de negocio, resulta tambi\u00e9n \u00fatil para reportar datos de cualquier elemento de Azure, incluido el IoT Hub . Nota Necesitar\u00e1s una cuenta de acceso gratuita a PowerBI, que puedes crear con tus credenciales de usuario UCM directamente en la p\u00e1gina del producto . Adici\u00f3n de un grupo de consumidores Los grupos de consumidores proporcionan vistas independientes en la secuencia de eventos que permiten a las aplicaciones y a los servicios de Azure consumir datos de forma independiente desde el mismo punto de conexi\u00f3n del centro de eventos. Vamos a agregar un grupo de consumidores al punto de conexi\u00f3n integrado de tu instancia de IoT Hub que se usar\u00e1 posteriormente para extraer datos del punto de conexi\u00f3n. Para agregar un grupo de consumidores a su centro de IoT, sigue estos pasos: En el portal de Azure, abre tu IoT Hub . En el panel izquierdo, selecciona Puntos de Conexi\u00f3n Integrados , luego Eventos en el panel superior derecho, y escribe un nombre en Grupos de consumidores (por ejemplo, MIOTGROUP ). A continuaci\u00f3n, selecciona Guardar . Creaci\u00f3n, configuraci\u00f3n y ejecuci\u00f3n de un trabajo de Stream Analytics Comencemos creando un trabajo de Stream Analytics . Despu\u00e9s de crear el trabajo, definiremos las entradas, las salidas y la consulta que se usar\u00e1 para recuperar los datos. Creaci\u00f3n de un trabajo de Stream Analytics En el portal de Azure, selecciona Crear un recurso -> Internet de las Cosas -> Stream Analytics Job . Escribe la siguiente informaci\u00f3n para el trabajo: Nombre del trabajo : Nombre que se asigna al trabajo; debe ser \u00fanico (por ejemplo, MIOTJOB ). Grupo de recursos : Usa el mismo grupo de recursos que definiste para el centro de IoT (por ejemplo, MIOTGROUP ). Ubicaci\u00f3n : Usa la misma que para el grupo de recursos. Selecciona Crear . Adici\u00f3n de una entrada al trabajo de Stream Analytics Abre el trabajo de Stream Analytics . En Topolog\u00eda de trabajo , selecciona Entradas . En el panel Entradas , selecciona Agregar entrada de flujo , y a continuaci\u00f3n, selecciona IoT Hub en la lista desplegable. En el panel de la nueva entrada, escribe la siguiente informaci\u00f3n: Alias de entrada : Un alias \u00fanico para la entrada (por ejemplo, MIOTINPUT ). Seleccionar centro de IoT de entre las suscripciones : Selecciona esta opci\u00f3n. Suscripci\u00f3n : Usa la suscripci\u00f3n que has utilizado en el resto de la pr\u00e1ctica. IoT Hub : Selecciona la instancia de tu Hub IoT tal y como has hecho en el resto de la pr\u00e1ctica. Punto de Conexi\u00f3n : Selecciona Mensajer\u00eda . Nombre de la directiva de acceso compartido : Selecciona el nombre de la directiva de acceso compartido que quieras que utilice el trabajo de Stream Analytics para tu centro de IoT. Para esta pr\u00e1ctica, puedes seleccionar service . La directiva service se crea de forma predeterminada en los centros de IoT nuevos y concede permiso de env\u00edo y recepci\u00f3n para los puntos de conexi\u00f3n de la nube que expone el centro de IoT. Clave de directiva de acceso compartido : Se rellena autom\u00e1ticamente en funci\u00f3n del nombre de directiva de acceso compartido. Grupo de consumidores : Selecciona el gruop de consumidores que se cre\u00f3 anteriormente. El resto de campos pueden dejarse en sus valores predeterminados. Finalmente, selecciona Guardar . Adici\u00f3n de una salida al trabajo de Stream Analytics En Topolog\u00eda de trabajo, selecciona Salidas . En el panel Salidas , selecciona Agregar y Power BI . En el panel Power BI: Nueva salida panel , selecciona Autorizar y sigue las indicaciones para iniciar sesi\u00f3n en tu cuenta de Power BI. Una vez que hayas iniciado sesi\u00f3n en Power BI, escribe la siguiente informaci\u00f3n: Alias de salida : alias \u00fanico para la salida, por ejemplo MIOTOUTPUT . \u00c1rea de trabajo de grupo : selecciona el \u00e1rea de trabajo de grupo de destino. Nombre del conjunto de datos : escribe un nombre para el conjunto de datos, por ejemplo MIOTDATASET . Nombre de la tabla : Escribe un nombre de tabla, por ejemplo MIOTTABLE . Modo de autenticaci\u00f3n : Deja la opci\u00f3n predeterminada. Configuraci\u00f3n de la consulta del trabajo de Stream Analytics En Topolog\u00eda de trabajo , selecciona Consulta . Reemplaza [YourInputAlias] por el alias de entrada del trabajo. Reemplaza [YourOutputAlias] por el alias de salida del trabajo. Selecciona Guardar consulta . Ejecuci\u00f3n del trabajo de Stream Analytics En el trabajo de Stream Analytics , selecciona Informaci\u00f3n general y, a continuaci\u00f3n, elige Iniciar->Ahora->Iniciar . Una vez que el trabajo se inicia correctamente, su estado cambia de Detenido a En ejecuci\u00f3n . Creaci\u00f3n y publicaci\u00f3n de un informe de Power BI para visualizar los datos En los pasos siguientes se muestra c\u00f3mo crear y publicar un informe mediante el servicio Power BI: Aseg\u00farate de que la aplicaci\u00f3n (tu ESP32) est\u00e1 ejecut\u00e1ndose. Inicia sesi\u00f3n en Power BI. Selecciona tu \u00e1rea de trabajo ( workspace ). Selecciona Conjunto de datos usando el conjunto de datos que creaste en pasos anteriores (corresponde al que creaste en el momento de crear la salida para el trabajo de Stream Analytics . Para dicho conjunto de datos, selecciona Agregar Informe (el primer icono a la derecha del nombre del conjunto de datos. Crea un gr\u00e1fico de l\u00edneas para mostrar la temperatura en tiempo real en un per\u00edodo determinado. Para ello: En el panel Visualizaciones de la p\u00e1gina de creaci\u00f3n de informes, selecciona el icono de gr\u00e1fico de l\u00edneas para agregar un gr\u00e1fico de l\u00edneas. En el panel Campos , expande la tabla que especific\u00f3 en el momento de crear la salida para el trabajo de Stream Analytics . Arrastra EventEnqueuedUtcTime (Hora UTC de evento en cola) al Eje en el panel Visualizaciones. Arrastra temperature (temperatura) a Valores . Se ha creado un gr\u00e1fico de l\u00edneas. El eje X muestra la fecha y hora en la zona horaria UTC. El eje Y muestra la temperatura del sensor: Tarea A\u00f1ade ahora informaci\u00f3n sobre humedad y velocidad del viento y refresca (actualiza) la visualizaci\u00f3n. Tarea entregable En esta pr\u00e1ctica, simplemente se pide que entregues alguna evidencia (por ejemplo, una captura de pantalla con tu ESP32 femitiendo eventos y una captura simult\u00e1nea de PowerBI mostr\u00e1ndolos) del correcto funcionamiento de los pasos listados. Opcionalmente, se puede a\u00f1adir, como informaci\u00f3n emitida desde el ESP32, valores reales de temperatura obtenidos desde un sensor en el ESP32.","title":"Pr\u00e1ctica 6. Frameworks IoT y Cloud"},{"location":"RPI-II/P10_old/#practica-6-frameworks-iot-y-cloud","text":"","title":"Pr\u00e1ctica 6. Frameworks IoT y Cloud"},{"location":"RPI-II/P10_old/#objetivos","text":"La pr\u00e1ctica presenta los pasos esenciales que permiten hacer interactuar un dispositivo (ESP32) con una infraestructura IoT en la nube. Aunque en este caso utilizaremos Microsoft Azure, los pasos tanto en configuraci\u00f3n remota como a nivel de nodo son muy similares a los que deber\u00edas seguir para otras infraestructuras (Amazon AWS, Google IoT Core, Aliyun IoT, Tencent Iot o cualquier otro). La documentaci\u00f3n de IDF proporciona ejemplos detallados para cada uno. El objetivo de la pr\u00e1ctica es desplegar un sistema de monitorizaci\u00f3n remota en Microsoft Power BI, que permita visualizar datos de telemetr\u00eda emitidos v\u00eda MQTT por el dispositivo a trav\u00e9s de un gateway en la nube (llamado en el caso de Azure IoT Hub ).","title":"Objetivos"},{"location":"RPI-II/P10_old/#introduccion","text":"El SDK ESP Azure IoT es una infraestructura basada en el SDK de Azure par IoT con soporte para C ( azure-iot-sdk-c ) portado sobre ESP-IDF para dar soporte al ESP32. Adem\u00e1s, proporciona un conjunto de ejemplos que permiten observar y simplificar el proceso de configuraci\u00f3n y conexi\u00f3n al framework Azure IoT Hub.","title":"Introducci\u00f3n"},{"location":"RPI-II/P10_old/#preparacion-del-firmware-en-el-esp32","text":"En la presente pr\u00e1ctica utilizar\u00e1s una placa ESP32 que actuar\u00e1 como cliente ESP32, con un firmware personalizado que implementa la l\u00f3gica de conexi\u00f3n e interacci\u00f3n con Azure. En primer lugar: Configura una instalaci\u00f3n de ESP IDF tal y como has hecho en pr\u00e1cticas anteriores. Si ya la has configurado y es funcional, no es necesario ninguna reinstalaci\u00f3n ni reconfiguraci\u00f3n. En un directorio independiente, clona el repositorio de ESP Azure (f\u00edjate en la opci\u00f3n --recursive , que es imprescindible): git clone --recursive https://github.com/espressif/esp-azure.git","title":"Preparaci\u00f3n del firmware en el ESP32"},{"location":"RPI-II/P10_old/#configuracion-de-microsoft-azure","text":"Los siguientes pasos requieren el uso de una cuenta creada con Microsoft Azure. Los estudiantes UCM pueden adherirse al programa acad\u00e9mico, que otorga suficiente cr\u00e9dito para realizar este tipo de pr\u00e1cticas. Aseg\u00farate de acceder al portal de MS Azure y utilizar tu usuario y credenciales UCM para ello.","title":"Configuraci\u00f3n de Microsoft Azure"},{"location":"RPI-II/P10_old/#creacion-de-un-centro-de-iot-iot-hub","text":"En la p\u00e1gina principal de Azure, selecciona la opci\u00f3n \"Crear un Recurso\" (en el men\u00fa de la parte superior izquierda de la pantalla) y a continuaici\u00f3n selecciona IoT Hub en cuadro \"Buscar en Marketplace\". Selecciona Iot Hub en los resultados de la b\u00fasqueda, y a continuaci\u00f3n \"Crear\". En la pesta\u00f1a Aspectos B\u00e1sicos , completa los campos de la siguiente forma: Suscripci\u00f3n : selecciona la suscripci\u00f3n que desees usar (por defecto, deber\u00eda aparecer Azure para estudiantes ). Grupo de recursos : crea un nuevo grupo de recursos seleccionando la opci\u00f3n Crear nuevo , y ot\u00f3rgale el nombre que desees, por ejemplo MIOTGROUP . Regi\u00f3n : selecciona la regi\u00f3n m\u00e1s cercana a ti (por ejemplo, Oeste de Europa ). Nombre : por \u00faltimo, da un nombre al hub , por ejemplo MIOTHUB . Deja los par\u00e1metros por defecto en la pesta\u00f1a Redes , y elige como Nivel de precios F1 en la pesta\u00f1a Administraci\u00f3n . Asigna las etiquetas que desees y finalmente confirma la creaci\u00f3n del Centro de IoT . Si todo ha ido bien, ver\u00e1s un resumen del recurso creado y podr\u00e1s acceder a \u00e9l pinchando en \"Ir al recurso\" . Ver\u00e1s una pantalla similar a la siguiente: En la secci\u00f3n de Configuraci\u00f3n , elige Directivas de acceso compartido y crea una nueva directiva llamada, por ejemplo MIOTPOLICY , con permisos de lectura y escritura en Registro, y conexi\u00f3n de servicios y dispositivos. Las pol\u00edticas de lectura y escritura en registro otorgan derechos de acceso al registro de indentidades de Azure. Estos permisos ser\u00e1n utilizados por servicios de back-end para gestionar las identidades de dispositivos, por ejemplo. La pol\u00edtica de conexi\u00f3n de servicio otorga permisos para acceder a endpoints de servicio. Los servicios de back-end podr\u00e1n enviar y recibir mensajes de dispositivos. La pol\u00edtica de conexi\u00f3n de dispositivo otorga permisos para enviar y recibir mensajes usando el IoT Hub . Una vez creada, selecci\u00f3nala y copia la Cadena de conexi\u00f3n principal (clave principal) que aparece en pantalla. No es necesario que la muestres, puedes usar el bot\u00f3n de copia directamente. Apunta esta cadena en un fichero de texto. Esta es la clave de acceso para el Hub .","title":"Creaci\u00f3n de un Centro de IoT (IoT Hub)"},{"location":"RPI-II/P10_old/#registro-de-un-nuevo-dispositivo","text":"A continuaci\u00f3n, crearemos una nueva identidad de dispositivo en el Registro de Identidades del hub IoT que acabas de crear. Para ello: En el men\u00fa de navegaci\u00f3n, abre la opci\u00f3n \"Dispositivos de IoT\" y selecciona Nuevo para crear un nuevo dispositivo. Dale el nombre que quieras (por ejemplo MIOTDEVICE), pero recu\u00e9rdalo, y selecciona Guardar . Una vez creado, selecci\u00f3nalo y copia la Cadena de conexi\u00f3n principal que aparece en pantalla. No es necesario que la muestres, puedes usar el bot\u00f3n de copia directamente. Apunta esta cadena en un fichero de texto. Esta es la clave de acceso para el dispositivo .","title":"Registro de un nuevo dispositivo"},{"location":"RPI-II/P10_old/#instalacion-de-el-cliente-azure","text":"Para instalar el cliente Azure en Linux, usa la orden: curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash Tienes m\u00e1s opciones de instalaci\u00f3n en la p\u00e1gina . Una vez instalado, desde tu terminal, ejecuta el comando az para comprobar que la instalaci\u00f3n fue correcta. Deber\u00edas ver una salida similar a esta: az Welcome to Azure CLI! --------------------- Use `az -h` to see available commands or go to https://aka.ms/cli. ... Instala la extensi\u00f3n del cliente para Azure IoT: az extension add --name azure-iot Ingresa en el sistema ejecutando (se te pedir\u00e1 autenticaci\u00f3n en navegador, introduce tus credenciales): az login Para usar el cliente como m\u00e9todo de creaci\u00f3n de un dispositivo, puedes utilizar la siguiente orden: az iot hub device-identity create -n [IoTHub Name] -d [Device ID] Tarea Crea un nuevo dispositivo, distinto al que creaste anteriormente, en tu hub. Despu\u00e9s, obt\u00e9n su cadena de conexi\u00f3n usando la orden az iot hub device-identity connection-string show -n [IoTHub Name] -d [Device ID] . Comprueba que, efectivamente, la creaci\u00f3n del dispositivo es visible en la plataforma web.","title":"Instalaci\u00f3n de el cliente Azure"},{"location":"RPI-II/P10_old/#monitorizacion-de-valores-de-telemetria-del-dispositivo-y-eventos","text":"Para observar los datos intercambiados entre el dispositivo y el hub IoT desde l\u00ednea de ocmandos, puedes usar la orden: az iot hub monitor-events -n [IoTHub Name] --login 'cadena de conexion' (Ten en cuenta que las comillas simples deben estar presentes).","title":"Monitorizaci\u00f3n de valores de telemetr\u00eda del dispositivo y eventos"},{"location":"RPI-II/P10_old/#despliegue-de-un-cliente-mqtt-en-el-esp32","text":"Dir\u00edgete al ejemplo situado en el directorio esp-azure/examples/iothub_client_sample_mqtt . En \u00e9l, vamos a trabajar con cualquiera de los dos dispositivos que has creado en tu Hub . En cualquier caso, muestra su cadena de conexi\u00f3n principal . Deber\u00e1s ver un valor de devoluci\u00f3n de tipo: { \"connectionString\": \"HostName=<azure-iot-hub-name>.azure-devices.net;DeviceId=<azure-iot-device-id>;SharedAccessKey=<base64-encoded-shared-access-key>\" } Deber\u00e1s apuntar (copiar) \u00fanicamente la parte que comienza por HostName=... , hasta el final de la cadena. No incluyas las comillas dobles. Ejecuta make menuconfig . En el men\u00fa Example Configuration , configura las credenciales de acceso a tu red WiFi, as\u00ed como la cadena de conexi\u00f3n que copiaste en la opci\u00f3n IOT Hub Device Connection String . A continuaci\u00f3n, ejecuta la orden de compilaci\u00f3n, flasheado y monitorizaci\u00f3n: make flash monitor En una ventana separada, puedes monitorizar los eventos IoT en tu hub usando su cadena de conexi\u00f3n: az iot hub monitor-events -n [IoTHub Name] --login 'Cadena de conexi\u00f3n primaria' Una vez arrancado y conectado a Internet el dispositivo comenzar\u00e1 a publicar mensajes MQTT. El monitor que has lanzado los mostrar\u00e1 como: { \"event\": { \"origin\": \"<azure-iot-device-id>\", \"payload\": \"{\\\"deviceId\\\":\\\"MIOTDEVICE\\\",\\\"windSpeed\\\":13.00,\\\"temperature\\\":22.00,\\\"humidity\\\":67.00}\" } } Observa que incluye tres valores: velocidad del viento, temperatura y humedad. Tarea Analiza el c\u00f3digo y observa, en la tarea principal, el uso que hace de la API de Azure SDK C, as\u00ed como el punto en el que genera el mensaje MQTT (y sus valores). Tambi\u00e9n es posible enviar mensajes al dispositivo directamente desde l\u00ednea de comandos (observa que estos mensajes se env\u00edan v\u00eda red, no v\u00eda puerto serie, a trav\u00e9s del Hub ). Por tanto, puedes hacerlo desde cualquier punto, no obligatoriamente desde tu PC: az iot device c2d-message send -d [Device Id] -n [IoTHub Name] --data [Data_to_Send] Nota Si todo ha ido bien, en este punto deber\u00edas estar observando cada uno de los mensajes enviados por tu ESP32 al hub desde el monitor.","title":"Despliegue de un cliente MQTT en el ESP32"},{"location":"RPI-II/P10_old/#visualizacion-de-datos-en-microsoft-powerbi","text":"En esta parte, el objetivo es visualizar los datos enviados por tu sensor (temperatura, humedad y velocidad del viento, en la herramienta de visualizaci\u00f3n PowerBI de Microsoft. Aunque PowerBI suele utilizarse en entornos de inteligencia de negocio, resulta tambi\u00e9n \u00fatil para reportar datos de cualquier elemento de Azure, incluido el IoT Hub . Nota Necesitar\u00e1s una cuenta de acceso gratuita a PowerBI, que puedes crear con tus credenciales de usuario UCM directamente en la p\u00e1gina del producto .","title":"Visualizaci\u00f3n de datos en Microsoft PowerBI"},{"location":"RPI-II/P10_old/#adicion-de-un-grupo-de-consumidores","text":"Los grupos de consumidores proporcionan vistas independientes en la secuencia de eventos que permiten a las aplicaciones y a los servicios de Azure consumir datos de forma independiente desde el mismo punto de conexi\u00f3n del centro de eventos. Vamos a agregar un grupo de consumidores al punto de conexi\u00f3n integrado de tu instancia de IoT Hub que se usar\u00e1 posteriormente para extraer datos del punto de conexi\u00f3n. Para agregar un grupo de consumidores a su centro de IoT, sigue estos pasos: En el portal de Azure, abre tu IoT Hub . En el panel izquierdo, selecciona Puntos de Conexi\u00f3n Integrados , luego Eventos en el panel superior derecho, y escribe un nombre en Grupos de consumidores (por ejemplo, MIOTGROUP ). A continuaci\u00f3n, selecciona Guardar .","title":"Adici\u00f3n de un grupo de consumidores"},{"location":"RPI-II/P10_old/#creacion-configuracion-y-ejecucion-de-un-trabajo-de-stream-analytics","text":"Comencemos creando un trabajo de Stream Analytics . Despu\u00e9s de crear el trabajo, definiremos las entradas, las salidas y la consulta que se usar\u00e1 para recuperar los datos.","title":"Creaci\u00f3n, configuraci\u00f3n y ejecuci\u00f3n de un trabajo de Stream Analytics"},{"location":"RPI-II/P10_old/#creacion-de-un-trabajo-de-stream-analytics","text":"En el portal de Azure, selecciona Crear un recurso -> Internet de las Cosas -> Stream Analytics Job . Escribe la siguiente informaci\u00f3n para el trabajo: Nombre del trabajo : Nombre que se asigna al trabajo; debe ser \u00fanico (por ejemplo, MIOTJOB ). Grupo de recursos : Usa el mismo grupo de recursos que definiste para el centro de IoT (por ejemplo, MIOTGROUP ). Ubicaci\u00f3n : Usa la misma que para el grupo de recursos. Selecciona Crear .","title":"Creaci\u00f3n de un trabajo de Stream Analytics"},{"location":"RPI-II/P10_old/#adicion-de-una-entrada-al-trabajo-de-stream-analytics","text":"Abre el trabajo de Stream Analytics . En Topolog\u00eda de trabajo , selecciona Entradas . En el panel Entradas , selecciona Agregar entrada de flujo , y a continuaci\u00f3n, selecciona IoT Hub en la lista desplegable. En el panel de la nueva entrada, escribe la siguiente informaci\u00f3n: Alias de entrada : Un alias \u00fanico para la entrada (por ejemplo, MIOTINPUT ). Seleccionar centro de IoT de entre las suscripciones : Selecciona esta opci\u00f3n. Suscripci\u00f3n : Usa la suscripci\u00f3n que has utilizado en el resto de la pr\u00e1ctica. IoT Hub : Selecciona la instancia de tu Hub IoT tal y como has hecho en el resto de la pr\u00e1ctica. Punto de Conexi\u00f3n : Selecciona Mensajer\u00eda . Nombre de la directiva de acceso compartido : Selecciona el nombre de la directiva de acceso compartido que quieras que utilice el trabajo de Stream Analytics para tu centro de IoT. Para esta pr\u00e1ctica, puedes seleccionar service . La directiva service se crea de forma predeterminada en los centros de IoT nuevos y concede permiso de env\u00edo y recepci\u00f3n para los puntos de conexi\u00f3n de la nube que expone el centro de IoT. Clave de directiva de acceso compartido : Se rellena autom\u00e1ticamente en funci\u00f3n del nombre de directiva de acceso compartido. Grupo de consumidores : Selecciona el gruop de consumidores que se cre\u00f3 anteriormente. El resto de campos pueden dejarse en sus valores predeterminados. Finalmente, selecciona Guardar .","title":"Adici\u00f3n de una entrada al trabajo de Stream Analytics"},{"location":"RPI-II/P10_old/#adicion-de-una-salida-al-trabajo-de-stream-analytics","text":"En Topolog\u00eda de trabajo, selecciona Salidas . En el panel Salidas , selecciona Agregar y Power BI . En el panel Power BI: Nueva salida panel , selecciona Autorizar y sigue las indicaciones para iniciar sesi\u00f3n en tu cuenta de Power BI. Una vez que hayas iniciado sesi\u00f3n en Power BI, escribe la siguiente informaci\u00f3n: Alias de salida : alias \u00fanico para la salida, por ejemplo MIOTOUTPUT . \u00c1rea de trabajo de grupo : selecciona el \u00e1rea de trabajo de grupo de destino. Nombre del conjunto de datos : escribe un nombre para el conjunto de datos, por ejemplo MIOTDATASET . Nombre de la tabla : Escribe un nombre de tabla, por ejemplo MIOTTABLE . Modo de autenticaci\u00f3n : Deja la opci\u00f3n predeterminada.","title":"Adici\u00f3n de una salida al trabajo de Stream Analytics"},{"location":"RPI-II/P10_old/#configuracion-de-la-consulta-del-trabajo-de-stream-analytics","text":"En Topolog\u00eda de trabajo , selecciona Consulta . Reemplaza [YourInputAlias] por el alias de entrada del trabajo. Reemplaza [YourOutputAlias] por el alias de salida del trabajo. Selecciona Guardar consulta .","title":"Configuraci\u00f3n de la consulta del trabajo de Stream Analytics"},{"location":"RPI-II/P10_old/#ejecucion-del-trabajo-de-stream-analytics","text":"En el trabajo de Stream Analytics , selecciona Informaci\u00f3n general y, a continuaci\u00f3n, elige Iniciar->Ahora->Iniciar . Una vez que el trabajo se inicia correctamente, su estado cambia de Detenido a En ejecuci\u00f3n .","title":"Ejecuci\u00f3n del trabajo de Stream Analytics"},{"location":"RPI-II/P10_old/#creacion-y-publicacion-de-un-informe-de-power-bi-para-visualizar-los-datos","text":"En los pasos siguientes se muestra c\u00f3mo crear y publicar un informe mediante el servicio Power BI: Aseg\u00farate de que la aplicaci\u00f3n (tu ESP32) est\u00e1 ejecut\u00e1ndose. Inicia sesi\u00f3n en Power BI. Selecciona tu \u00e1rea de trabajo ( workspace ). Selecciona Conjunto de datos usando el conjunto de datos que creaste en pasos anteriores (corresponde al que creaste en el momento de crear la salida para el trabajo de Stream Analytics . Para dicho conjunto de datos, selecciona Agregar Informe (el primer icono a la derecha del nombre del conjunto de datos. Crea un gr\u00e1fico de l\u00edneas para mostrar la temperatura en tiempo real en un per\u00edodo determinado. Para ello: En el panel Visualizaciones de la p\u00e1gina de creaci\u00f3n de informes, selecciona el icono de gr\u00e1fico de l\u00edneas para agregar un gr\u00e1fico de l\u00edneas. En el panel Campos , expande la tabla que especific\u00f3 en el momento de crear la salida para el trabajo de Stream Analytics . Arrastra EventEnqueuedUtcTime (Hora UTC de evento en cola) al Eje en el panel Visualizaciones. Arrastra temperature (temperatura) a Valores . Se ha creado un gr\u00e1fico de l\u00edneas. El eje X muestra la fecha y hora en la zona horaria UTC. El eje Y muestra la temperatura del sensor: Tarea A\u00f1ade ahora informaci\u00f3n sobre humedad y velocidad del viento y refresca (actualiza) la visualizaci\u00f3n. Tarea entregable En esta pr\u00e1ctica, simplemente se pide que entregues alguna evidencia (por ejemplo, una captura de pantalla con tu ESP32 femitiendo eventos y una captura simult\u00e1nea de PowerBI mostr\u00e1ndolos) del correcto funcionamiento de los pasos listados. Opcionalmente, se puede a\u00f1adir, como informaci\u00f3n emitida desde el ESP32, valores reales de temperatura obtenidos desde un sensor en el ESP32.","title":"Creaci\u00f3n y publicaci\u00f3n de un informe de Power BI para visualizar los datos"},{"location":"RPI-II/P11_old/","text":"Pr\u00e1ctica 6 (opcional). Eclipse Ditto Objetivos Conocer el funcionamiento b\u00e1sico de Ditto como software de soporte para gemelos digitales. Ejercitar el concepto de Thing y su representaci\u00f3n en Ditto. Interactuar con un entorno de gemelos digitales v\u00eda una API REST. Desplegar un entorno IoT basado en MQTT sobre Ditto. Introducci\u00f3n Eclipse Ditto es un proyecto dentro de Eclipse IoT que implementa un patr\u00f3n de software llamado gemelos digitales . Un gemelo digital es una representaci\u00f3n virtual, basada en la nube, de su contraparte del mundo real ( cosas del mundo real, por ejemplo, dispositivos como sensores, calefacci\u00f3n inteligente, autom\u00f3viles conectados, redes inteligentes, estaciones de carga para veh\u00edculos el\u00e9ctricos, ...). Ditto simplifica el desarrollo de soluciones IoT para desarrolladores de software, ya que no necesitan saber c\u00f3mo o d\u00f3nde est\u00e1n conectadas exactamente las \"cosas\" f\u00edsicas. Con Ditto, una cosa puede usarse como cualquier otro servicio web a trav\u00e9s de su gemelo digital. Ditto no es plataforma IoT completa. No proporciona software que se ejecute en gateways IoT y no define ni implementa un protocolo de IoT para comunicarse con los dispositivos. Su enfoque radica en escenarios de backend , al proporcionar una API web para simplificar el trabajo con dispositivos conectados (por ejemplo, a trav\u00e9s de MQTT) u otro software de backend . Con Ditto, es posible obtener una API completa y consciente de la autorizaci\u00f3n (HTTP, WebSocket y otros protocolos de mensajer\u00eda) para interactuar con sus gemelos digitales y todos los aspectos que los rodean. Considerando que el desarrollador planeta la creaci\u00f3n de una soluci\u00f3n de IoT, y suponiendo que utiliza tanto hardware (por ejemplo, sensores o actuadores) como software (por ejemplo, una aplicaci\u00f3n m\u00f3vil o web) para resolver el problema de su cliente, \u00e9ste tiene varios lugares donde implementar el software: En o cerca del hardware, por ejemplo, en una placa Arduino usando C/C++ o en una Raspberry PI usando Python, opcionalmente en un gateway que establece la conectividad a Internet (por ejemplo, basado en Eclipse Kura), En la aplicaci\u00f3n m\u00f3vil o web usando Java, Javascript, etc., En el backend cumpliendo varias responsabilidades como proporcionar una API que se abstrae del hardware, enrutamiento de solicitudes entre el hardware y las aplicaciones de los clientes, asegurando solo el acceso autorizado, conservando el \u00faltimo estado informado del hardware como cach\u00e9 y proporcionando los datos cuando el hardware no est\u00e1 conectado actualmente, notificar a las partes interesadas (por ejemplo, otros servicios de backend ) sobre los cambios. Ditto se enfoca en resolver las responsabilidades que tiene un backend t\u00edpico en tales escenarios. Su objetivo es liberar las soluciones IoT de la necesidad de implementar y operar un back-end personalizado. En cambio, al usar Eclipse Ditto, pueden concentrarse en los requisitos comerciales, en conectar dispositivos a la nube/back-end y en implementar aplicaciones comerciales. Instalaci\u00f3n de prerequisitos (Docker) La instalaci\u00f3n de Ditto que utilizaremos en esta pr\u00e1ctica se basa en un despliegue de microserviciios confinados en contenedores Docker. Por tanto, la instalaci\u00f3n de Docker es un requisito indispensable para el desarrollo de la pr\u00e1ctica. Si ya dispones de una instalaci\u00f3n funcional de Docker en tu PC o en la m\u00e1quina virtual del curso, puedes obviar esta secci\u00f3n. En caso contrario, instala y comprueba el funcionamiento de Docker siguiendo las instrucciones de su p\u00e1gina oficial para la distribuci\u00f3n Linux que est\u00e9s utilizando (o incluso para otros sistemas operativos). En el caso de la M\u00e1quina Virtual (Ubuntu), se recomienda seguir la instalaci\u00f3n paso a paso detallada en la p\u00e1gina oficial de Docker . Concretamente, se sugiere utilizar el m\u00e9todo de instalaci\u00f3n basado en repositorio ( Install using the repository ). En el caso de Linux es muy aconsejable, para ejecutar el software con permisos de usuario, finalizar la instalaci\u00f3n con los pasos post-instalaci\u00f3n sugeridos en la propia p\u00e1gina . Tarea Si todo ha ido bien, en este punto deber\u00edas poder ejecutar, sin permisos de superusuario ( sudo ) el contenedor sencillo Hello, world indicado en la documentaci\u00f3n. Instalaci\u00f3n y despliegue de Eclipse Ditto utilizando Docker Eclipse Ditto se basa en un despliegue de microservicios, cada uno de ellos dedicado a una tarea espec\u00edfica (gesti\u00f3n de conexiones, autorizaci\u00f3n, almacenamiento de datos, etc.). M\u00e1s concretamente, los microservicios se encargan de la gesti\u00f3n de: Pol\u00edticas de acceso ( Policies ). Things. Conectividad. B\u00fasqueda. Gesti\u00f3n de Ditto como canalizador de mensajes ( Gateway ). En su versi\u00f3n m\u00e1s operativa, estos microservicios se despliegan y comunican entre ellos utilizando contenedores Docker, y pueden ser gestionados de forma manual (como nosotros haremos), o integrados en orquestadores de m\u00e1s alto nivel, como Kubernetes. La \u00fanica dependencia externa exigida por Ditto es el uso de MongoDB para gestionar el almacenamiento de logs, conexiones, eventos y otros registros de inter\u00e9s, y el uso de NginX para dar soporte a la interfaz Web (opcional) y a tareas de autenticaci\u00f3n b\u00e1sica de usuarios.o Obtenci\u00f3n del software En primer lugar, clona el repositorio que aloja el c\u00f3digo fuente de Eclipse Ditto utilizando git : git clone https://github.com/eclipse-ditto/ditto.git Esto crear\u00e1 un directorio ditto con todo lo necesario para el despliegue del sistema. Podr\u00edamos directamente construir Ditto desde este c\u00f3digo fuente, pero haremos uso de una forma de despliegue basada en im\u00e1genes Docker precompiladas y combinadas v\u00eda docker-compose . Despliegue del sistema Para comenzar, dir\u00edgete al directorio deployment/docker . Los pasos que se listan a continuaci\u00f3n son los que se describen en la documentaci\u00f3n oficial (fichero README.md del directorio). En primer lugar, configuraremos el servidor web que dar\u00e1 soporte a la interacci\u00f3n b\u00e1sica con Ditto y a las tareas de autenticaci\u00f3n de usuarios contra la API REST proporcionada por Ditto. En primer lugar, configuraremos las credenciales que permitir\u00e1n a los usuarios interactuar con Ditto v\u00eda HTTP. Para ello, utiliza la herramienta openssl passwd para crear un hash de la contrase\u00f1a a utilizar por parte del usuario ditto (si no tienes instalado openssl , hazlo utilizando el sistema de paqueter\u00eda de Ubuntu o cualquier otro mecanismo disponible en tu distribuci\u00f3n): openssl passwd -quiet Password: <enter password> Verifying - Password: <enter password> Es importante que anotes la contrase\u00f1a que vas a utilizar. En el resto de la pr\u00e1ctica asumiremos que has utilizado masteriot como contrase\u00f1a, pero puedes usar la que desees. Como resultado de la anterior ejecuci\u00f3n, se mostrar\u00e1 por pantalla el hash de la contrase\u00f1a elegida, por ejemplo A6BgmB8IEtPTs . Edita el fichero nginx.htpasswd y a\u00f1ade la siguiente l\u00ednea: ditto:A6BgmB8IEtPTs Esto permitir\u00e1 la autenticaci\u00f3n de un usuario llamado ditto utilizando la contrase\u00f1a escogida. A continuaci\u00f3n, despliega los servicios utilizando docker-compose : docker-compose up -d Deber\u00edas observar una salida similar a la siguiente: ubuntu@ubuntu2004:~/Work/ditto/deployment/docker$ sudo docker-compose up -d Starting docker_policies_1 ... done Starting docker_mongodb_1 ... done Starting docker_swagger-ui_1 ... done Starting docker_connectivity_1 ... done Starting docker_things_1 ... done Starting docker_things-search_1 ... done Starting docker_gateway_1 ... done Starting docker_nginx_1 ... done En el anterior caso, estamos utilizando sudo , aunque esto no deber\u00eda ser necesario si has configurado correctamente docker . No hay mayor problema en hacerlo as\u00ed en esta pr\u00e1ctica. Si deseas detener los servicios, puedes simplemente ejecutar: ubuntu@ubuntu2004:~/Work/ditto/deployment/docker$ sudo docker-compose stop Stopping docker_nginx_1 ... done Stopping docker_things_1 ... done Stopping docker_things-search_1 ... done Stopping docker_gateway_1 ... done Stopping docker_connectivity_1 ... done Stopping docker_policies_1 ... done Stopping docker_mongodb_1 ... done Stopping docker_swagger-ui_1 ... done En este punto, Ditto deber\u00eda estar funcionando correctamente. Por cuestiones de facilidad de uso, y aunque su uso es totalmente opcional y de hecho no recomendado en entornos en producci\u00f3n, Ditto ofrece una interfaz de usuario web que utilizaremos para verificar su correcta instalaci\u00f3n y para realizar los pasos b\u00e1sicos de interacci\u00f3n con el sistema. Para ello, abre un navegador en la m\u00e1quina donde has desplegado el entorno, y navega a la direcci\u00f3n http://localhost:8080 . Deber\u00edas observar una p\u00e1gina similar a la siguiente: Para acceder a la interfaz de usuario (UI) que utilizaremos, navega a http://localhost:8080/ui o pincha en el enlace correspondiente. En la p\u00e1gina anterior tienes tambi\u00e9n un enlace descriptivo de la API REST ofrecida por Ditto. Una vez m\u00e1s, el uso de la UI es opcional. Un entorno en producci\u00f3n interactuar\u00eda con Ditto a trav\u00e9s de la API REST que ofrece (tal y como hace la UI de forma gr\u00e1fica), pero por practicidad la utilizaremos en algunas partes de la pr\u00e1ctica. Por \u00faltimo, deber\u00e1s configurar la UI para que autentique al usuario principal ( ditto ) usando la contrase\u00f1a que estableciste previamente en el proceso de instalaci\u00f3n. Para ello, pincha en el bot\u00f3n Authorize de la parte superior derecha de la UI, y a\u00f1ade la contrase\u00f1a elegida para el usuario principal: Una vez hecho esto, pincha en el primero de los tres botones Authorize y podr\u00e1s comenzar a trabajar. Primeros pasos con Ditto Elementos principales de la UI La UI dispone de cuatro pantallas (pesta\u00f1as principales), seleccionables a trav\u00e9s de la barra superior: Things : para visualizar y gestionar las Things existentes en el sistema. Policies : para visualizar y gestionar las pol\u00edticas de acceso existentes en el sistema. Connections : para gestionar las comunicaciones externas del sistema (por ejemplo, su interacci\u00f3n con MQTT). Environments : para gestionar los entornos que definen condiciones de acceso al sistema (no los utilizaremos). Pincha en la opci\u00f3n Things . Deber\u00edas ver una pantalla dividida en cuatro \u00e1reas, en tu caso vac\u00edas: En la parte superior izquierda ver\u00e1s las Things creadas. En este punto, estar\u00e1n vac\u00edas, pero la captura anterior muestra una situaci\u00f3n con dos entidades ya creadas. Observa sus nombres: por convenio, la nomenclatura de Things es jer\u00e1rquica, con el s\u00edmbolo : como separaci\u00f3n entre entidades. En la pr\u00f3xima secci\u00f3n aprender\u00e1s a crear estas entidades, pero de momento la captura muestra c\u00f3mo, seleccionando una de ellas, podr\u00e1s observar sus atributos (descripciones est\u00e1ticas de alguna caracter\u00edstica del Thing ) y caracter\u00edsticas (entidades din\u00e1micas que pueden ir variando con el ciclo de vida del mismo). En la parte superior derecha dispones de la descripci\u00f3n formal de Thing en tres formatos distintos (visual, CRUD y Web of Things). Se deja como ejercicio la profundizaci\u00f3n en cada uno de estos formatos si fuera de inter\u00e9s para el/la estudiante. Por \u00faltimo, en la parte inferior derecha dispones de la informaci\u00f3n, en varios formatos, asociada a cada caracter\u00edstica. A continuaci\u00f3n, pincha en la opci\u00f3n Policies . Deber\u00edas ver una pantalla dividida en cuatro \u00e1reas, en tu caso vac\u00edas: En la captura puedes observar las pol\u00edticas de acceso asociadas a una de las Things creadas para el usuario web ditto (el que est\u00e1s utilizando). Observa que, a grandes rasgos, este usuario tiene permisos de lectura y escritura concedidos sobre la Thing por lo que podr\u00e1 modificarla y consultarla. Aprenderemos a gestionar estos permisos m\u00e1s adelante. Por \u00faltimo, la pesta\u00f1a Connections permite configurar conexiones (por ejemplo MQTT) entrantes y salientes, para gestionar la comunicaci\u00f3n entre el gemelo digital (Ditto) y dispositivos o entidades externas. M\u00e1s adelante describiremos algunos de sus campos m\u00e1s interesantes y crearemos las conexiones necesarias para recibir datos del gemelo f\u00edsico v\u00eda MQTT: Creaci\u00f3n de Things La creaci\u00f3n de Things puede realizarse v\u00eda un endpoint espec\u00edfico proporcionado por la API REST de Ditto. Asumamos que deseamos crear un gemelo digital para un coche. Este gemelo podr\u00eda alojar metadatos est\u00e1ticos y datos de estado din\u00e1micos, actualizados constantemente desde el gemelo f\u00edsico. Es decir, la representaci\u00f3n digital ( Features ) de la Thing deber\u00eda cambiar tan pronto como lo hace su representaci\u00f3n f\u00edsica. Estos tipos est\u00e1ticos y din\u00e1micos de datos se mapean en Ditto como atributos (attributes) y caracter\u00edsticas (features) . Opcionalmente, puede utilizarse una definici\u00f3n (definition) del objeto, utilizando por ejemplo el modelo de informaci\u00f3n de Eclipse Vorto , aunque esto queda fuera del alcance de esta pr\u00e1ctica). A continuaci\u00f3n se muestra la representaci\u00f3n, en formato JSON, de un objeto de este tipo: { \"definition\": \"digitaltwin:DigitaltwinExample:1.0.0\", \"attributes\": { \"manufacturer\": \"ACME\", \"VIN\": \"0815666337\" }, \"features\": { \"transmission\": { \"properties\": { \"automatic\": true, \"mode\": \"eco\", \"cur_speed\": 90, \"gear\": 5 } }, \"environment-scanner\": { \"properties\": { \"temperature\": 20.8, \"humidity\": 73, \"barometricPressure\": 970.7, \"location\": { \"longitude\": 47.682170, \"latitude\": 9.386372 }, \"altitude\": 399 } } } } Dentro de Attributes , podemos a\u00f1adir tantas caracter\u00edsticas como deseemos en forma de pares clave:valor JSON. Dentro de Features , podemos a\u00f1adir tantas caracter\u00edsticas como deseemos en forma de pares clave:valor JSON, pero cada una debe tener un objeto JSON llamado properties , que contenga tantos pares clave:valor como deseemos para describir a nuestro objeto. Utilizaremos curl para interactuar con Ditto y crear entidades de tipo Thing . La autenticaci\u00f3n que usaremos para ello es la definida para el usuario ditto con la contrase\u00f1a que elegiste en el proceso de instalaci\u00f3n, siguiendo este esquema de consulta: curl -u ditto:masteriot -X PUT -H 'Content-Type: application/json' -d '{ \"definition\": \"digitaltwin:DigitaltwinExample:1.0.0\", \"attributes\": { \"manufacturer\": \"ACME\", \"VIN\": \"0815666337\" }, \"features\": { \"transmission\": { \"properties\": { \"automatic\": true, \"mode\": \"eco\", \"cur_speed\": 90, \"gear\": 5 } }, \"environment-scanner\": { \"properties\": { \"temperature\": 20.8, \"humidity\": 73, \"barometricPressure\": 970.7, \"location\": { \"longitude\": 47.682170, \"latitude\": 9.386372 }, \"altitude\": 399 } } } }' 'http://localhost:8080/api/2/things/org.eclipse.ditto:fancy-car' Observa que usamos la contrase\u00f1a masteriot , un verbo PUT para modificar el estado y una petici\u00f3n en formato JSON utilizando la estructura anteriormente descrita. El endpoint utilizado indica el identificador de objeto a crear. Puedes encontrar (y utilizar) toda la informaci\u00f3n relativa a la API de Ditto en http://localhost:8080/apidoc/ . Tarea Crea un conjunto de Things similar al mostrado y observa/experimenta a trav\u00e9s de la UI para determinar si la informaci\u00f3n proporcionada es correcta. Crea al menos una de ellas tal y como se especifica m\u00e1s arriba, porque la necesitar\u00e1s con dicha estructura para el resto de la pr\u00e1ctica. \u00bfQu\u00e9 ocurre si creas de nuevo una Thing ya existente, variando alguno de sus datos asociados? (compru\u00e9balo a trav\u00e9s de la UI). Consulta de Things La consulta de Things se realiza a trav\u00e9s del endpoint correspondiente. En el caso de desear consultar los datos relativos a una entidad creada anteriormente, podr\u00edamos hacerlo de la siguiente manera: curl -u ditto:masteriot -X GET 'http://localhost:8080/api/2/things/org.eclipse.ditto:fancy-car' Tarea Consulta los datos relativos a las entidades que has creado anteriormente, y muestra al menos el contenido de la respuesta HTTP devuelta para una de ellas. Consulta de valores de estado espec\u00edficos La consulta de valores espec\u00edficos para una Thing no resulta m\u00e1s complicada, por ejemplo: curl -u ditto:masteriot -X GET 'http://localhost:8080/api/2/things/org.eclipse.ditto:fancy-car/features/transmission/properties/cur_speed' Tarea Experimenta y muestra la respuesta para la consulta de valores espec\u00edficos para las entidades que has creado. Actualizaci\u00f3n de valores de estado espec\u00edficos Es posible incluso modificar directamente el valor de una caracter\u00edstica v\u00eda HTTP: curl -u ditto:masteriot -X PUT -H 'Content-Type: application/json' -d '77' 'http://localhost:8080/api/2/things/org.eclipse.ditto:fancy-car/features/transmission/properties/cur_speed' Tarea Experimenta y muestra la respuesta para la modificaci\u00f3n de valores espec\u00edficos para las entidades que has creado. Despu\u00e9s, consulta a trav\u00e9s de la UI o bien utilizando la API directamente si los valores efectivamente se han modificado. B\u00fasqueda Por \u00faltimo, puedes realizar b\u00fasquedas espec\u00edficas utilizando filtros. As\u00ed, para consultar todas las Things cuyo fabricante sea ACME, podr\u00edamos ejecutar: curl -u ditto:masteriot -X GET 'http://localhost:8080/api/2/search/things?filter=eq(attributes/manufacturer,\"ACME\")' Tarea Experimenta con los filtros de b\u00fasqueda ofrecidos por Ditto, y muestra alg\u00fan ejemplo usando las entidades que hayas creado anteriormente. A trav\u00e9s de la UI, puedes hacerlo usando el cuadro de texto en la parte superior izquierda de la p\u00e1gina. Gesti\u00f3n b\u00e1sica de pol\u00edticas Ditto ofrece la posibilidad de personalizar el acceso a usuarios espec\u00edficos a ciertas partes de los objetos creados, limitando por ejemplo su capacidad de lectura o de escritura sobre ellos. Estas condiciones, llamadas Policy , permiten definir c\u00f3mo se puede acceder a un objeto o conjunto de objetos que compartan la misma pol\u00edtica de acceso. En este caso, utilizaremos la UI para la gesti\u00f3n de pol\u00edticas, pero este tipo de operaciones se pueden realizar a trav\u00e9s de la API REST de Ditto. Navega hacia la pesta\u00f1a Policies de la UI. En la parte superior izquierda podr\u00e1s seleccionar la pol\u00edtica que deseas consultar o editar. En este caso, y ya que por defecto se asignan pol\u00edticas con el mismo nombre las Things creadas, deber\u00edas poder editar una pol\u00edtica llamada org.eclipse.ditt:fancy-car . Pincha sobre ella y aparecer\u00e1 una entrada DEFAULT en el panel inferior izquierdo; seleccion\u00e1ndola, observar\u00e1s las caracter\u00edsticas de esta pol\u00edtica. En este caso, para el Recurso thing:/ , ver\u00e1s que la pol\u00edtica permite leer y escribir (panel inferior derecho): { \"grant\": [ \"READ\", \"WRITE\" ], \"revoke\": [] } Tarea Revoca en primer lugar el permiso de lectura (READ) sobre un objeto que siga esta pol\u00edtica. Guarda los cambios (bot\u00f3n que muestra una caja con una flecha en el panel inferior derecho) e intenta consultar v\u00eda API alguna caracter\u00edstica de dicha Thing . A continuaci\u00f3n, haz lo propio con el permiso de escritura e intenta modificar la Thing . Creaci\u00f3n de una conexi\u00f3n MQTT e interacci\u00f3n con Ditto Hasta este punto, el extremo backend de nuestro entorno interactuaba con su gemelo digital utilizando la API REST, pero una de las ventajas de Ditto radica en su capacidad para unificar protocolos utilizados por los dispositivos f\u00edsicos. Por ejemplo, un dispositivo podr\u00eda utilizar MQTT para, a trav\u00e9s de un broker , comunicarse con Ditto, que podr\u00eda analizar el contenido del mensaje y \"enrutarlo\" hacia el Thing asociado. Para gestionar este tipo de despliegues, podemos crear conexiones (Connections) a trav\u00e9s de la UI. Dir\u00edgete hacia la pesta\u00f1a Connections . En el panel central, observar\u00e1s un campo en blanco donde definiremos las caracter\u00edsticas de la conexi\u00f3n que deseamos crear. Aunque Ditto permite utilizar plantillas para distintos tipos de conexiones (MQTT, MQTT5, Kafka, AMQP, ...) a trav\u00e9s de la opci\u00f3n Template , nosotros definiremos nuestra propia conexi\u00f3n MQTT, pegando el siguiente fragmento JSON: { \"id\": \"9279185c-4bcc-4d66-a3e1-0971ce4376f9\", \"name\": \"RPI-demo\", \"connectionType\": \"mqtt\", \"connectionStatus\": \"open\", \"uri\": \"tcp://test.mosquitto.org:1883\", \"sources\": [ { \"addresses\": [ \"eclipse-ditto-sandbox/#\" ], \"consumerCount\": 1, \"qos\": 0, \"authorizationContext\": [ \"nginx:ditto\" ], \"headerMapping\": {}, \"payloadMapping\": [ \"javascript\" ], \"replyTarget\": { \"enabled\": false } } ], \"targets\": [ { \"address\": \"eclipse-ditto-sandbox/{{ thing:id }}\", \"topics\": [ \"_/_/things/twin/events\" ], \"qos\": 0, \"authorizationContext\": [ \"ditto:outbound-auth-subject\" ], \"headerMapping\": {}, \"payloadMapping\": [ \"javascript\" ] } ], \"clientCount\": 1, \"failoverEnabled\": true, \"validateCertificates\": true, \"processorPoolSize\": 1, \"mappingDefinitions\": { \"javascript\": { \"mappingEngine\": \"JavaScript\", \"options\": { \"incomingScript\": \"/**\\n * Maps the passed parameters to a Ditto Protocol message.\\n * @param {Object.<string, string>} headers - The headers Object containing all received header values\\n * @param {string} [textPayload] - The String to be mapped\\n * @param {ArrayBuffer} [bytePayload] - The bytes to be mapped as ArrayBuffer\\n * @param {string} [contentType] - The received Content-Type, e.g. \\\"application/json\\\"\\n * @returns {(DittoProtocolMessage|Array<DittoProtocolMessage>)} dittoProtocolMessage(s) -\\n * The mapped Ditto Protocol message,\\n * an array of Ditto Protocol messages or\\n * <code>null</code> if the message could/should not be mapped\\n */\\nfunction mapToDittoProtocolMsg(\\n headers,\\n textPayload,\\n bytePayload,\\n contentType\\n) {\\n\\n // ### Insert/adapt your mapping logic here.\\n // Use helper function Ditto.buildDittoProtocolMsg to build Ditto protocol message\\n // based on incoming payload.\\n // See https://www.eclipse.org/ditto/connectivity-mapping.html#helper-functions for details.\\n\\n // ### example code assuming the Ditto protocol content type for incoming messages.\\n const jsonString = String.fromCharCode.apply(null, new Uint8Array(bytePayload));\\n const jsonData = JSON.parse(jsonString); \\n const thingId = jsonData.thingId.split(':'); \\n const value = { \\n transmission: { \\n properties: { \\n automatic: jsonData.automatic,\\n cur_speed: jsonData.cur_speed,\\n mode: jsonData.mode,\\n gear: jsonData.gear\\n } \\n } \\n }; \\n return Ditto.buildDittoProtocolMsg(\\n thingId[0], // your namespace \\n thingId[1], \\n 'things', // we deal with a thing\\n 'twin', // we want to update the twin\\n 'commands', // create a command to update the twin\\n 'modify', // modify the twin\\n '/features', // modify all features at once\\n headers, \\n value\\n );\\n}\", \"outgoingScript\": \"/**\\n * Maps the passed parameters which originated from a Ditto Protocol message to an external message.\\n * @param {string} namespace - The namespace of the entity in java package notation, e.g.: \\\"org.eclipse.ditto\\\". Or \\\"_\\\"\\n * (underscore) for connection announcements.\\n * @param {string} name - The name of the entity, e.g.: \\\"device\\\".\\n * @param {string} group - The affected group/entity: \\\"things\\\"|\\\"policies\\\"|\\\"connections\\\".\\n * @param {string} channel - The channel for the signal: \\\"twin\\\"|\\\"live\\\"|\\\"none\\\"\\n * @param {string} criterion - The criterion to apply: \\\"commands\\\"|\\\"events\\\"|\\\"search\\\"|\\\"messages\\\"|\\\"announcements\\\"|\\\"errors\\\".\\n * @param {string} action - The action to perform: \\\"create\\\"|\\\"retrieve\\\"|\\\"modify\\\"|\\\"delete\\\". Or the announcement name:\\n * \\\"opened\\\"|\\\"closed\\\"|\\\"subjectDeletion\\\". Or the subject of the message.\\n * @param {string} path - The path which is affected by the message (e.g.: \\\"/attributes\\\"), or the destination\\n * of a message (e.g.: \\\"inbox\\\"|\\\"outbox\\\").\\n * @param {Object.<string, string>} dittoHeaders - The headers Object containing all Ditto Protocol header values.\\n * @param {*} [value] - The value to apply / which was applied (e.g. in a \\\"modify\\\" action).\\n * @param {number} [status] - The status code that indicates the result of the command. When this field is set,\\n * it indicates that the Ditto Protocol Message contains a response.\\n * @param {Object} [extra] - The enriched extra fields when selected via \\\"extraFields\\\" option.\\n * @returns {(ExternalMessage|Array<ExternalMessage>)} externalMessage - The mapped external message, an array of\\n * external messages or <code>null</code> if the message could/should not be mapped.\\n */\\nfunction mapFromDittoProtocolMsg(\\n namespace,\\n name,\\n group,\\n channel,\\n criterion,\\n action,\\n path,\\n dittoHeaders,\\n value,\\n status,\\n extra\\n) {\\n\\n // ###\\n // Insert your mapping logic here\\n\\n // ### example code using the Ditto protocol content type.\\n let headers = dittoHeaders;\\n let textPayload = JSON.stringify(Ditto.buildDittoProtocolMsg(namespace, name, group, channel, criterion, action,\\n path, dittoHeaders, value, status, extra));\\n let bytePayload = null;\\n let contentType = 'application/vnd.eclipse.ditto+json';\\n\\n return Ditto.buildExternalMsg(\\n headers, // The external headers Object containing header values\\n textPayload, // The external mapped String\\n bytePayload, // The external mapped byte[]\\n contentType // The returned Content-Type\\n );\\n}\", \"loadBytebufferJS\": \"false\", \"loadLongJS\": \"false\" } } }, \"tags\": [] } Copia y pega el objeto en el panel, y pincha sobre el bot\u00f3n central de carga. Pese a la longitud del objeto, lo que nos interesan son s\u00f3lo ciertas partes del mismo, a saber: Definici\u00f3n del tipo de conexi\u00f3n: \"connectionType\": \"mqtt\" . Definici\u00f3n del tipo de persistencia de la conexi\u00f3n, en este caso open para una conectividad y actualizaciones en tiempo real. Definici\u00f3n del broker MQTT: \"uri\": \"tcp://test.mosquitto.org:1883\" . Definici\u00f3n del mapeado, en forma de scripts Javascript que se realizar\u00e1 de los mensajes entrantes y salientes. En este caso, los scripts de pre y post procesamiento se muestran en los paneles de la derecha de la pantalla. Despliega la conexi\u00f3n utilizando el bot\u00f3n central en el panel central. En el panel de la izquierda, observar\u00e1s que la conexi\u00f3n con nombre RPI-demo se ha creado y permanece abierta. Ahora, cualquier mensaje MQTT enviado al broker especificado ser\u00e1 recibido por Ditto a trav\u00e9s de \u00e9l, que lo procesar\u00e1 utilizando el script correspondiente. En este caso, el script simplemente mapea el mensaje (JSON) recibido y lo convierte en un mensaje utilizando el protocolo de Ditto para su procesamiento. Hagamos una prueba. Considerando que has creado una Thing con nombre org.eclipse.ditt:fancy-car , prepara un fichero de texto llamado message.json con el siguiente contenido: { \"automatic\":true, \"mode\": \"gasoil\", \"cur_speed\": 82, \"gear\":8, \"thingId\":\"org.eclipse.ditto:fancy-car\" } El objetivo es modificar el estado del objeto correspondiente, por ejemplo fijando nuevos valores para alguna de sus caracter\u00edsticas. Una vez listo, lo enviaremos al broker utilizando cualquier cliente MQTT: mosquitto_pub -t \"eclipse-ditto-sandbox/org.eclipse.ditto:fancy-car\" -f message.json -h test.mosquitto.org Observa el topic utilizado y el broker , necesarios para la comunicaci\u00f3n con Ditto. Tarea Experimenta con el env\u00edo de mensajes MQTT desde la terminal, y su repercusi\u00f3n en Ditto. Tras el env\u00edo, consulta v\u00eda la API REST el estado de la Thing correspondiente. \u00bfHa variado? Activa los logs desde la UI (panel inferior central) e intenta entender el proceso que sigue un mensaje MQTT desde que es recibido hasta que llega a la Thing correspondiente. Tarea adicional Dise\u00f1a, en uno o varios nodos ESP32, clientes MQTT que expongan cierto valor a trav\u00e9s de MQTT, y \u00e9ste sea mapeado a una Thing tambi\u00e9n dise\u00f1ada por ti.","title":"Pr\u00e1ctica 6 (opcional). Eclipse Ditto"},{"location":"RPI-II/P11_old/#practica-6-opcional-eclipse-ditto","text":"","title":"Pr\u00e1ctica 6 (opcional). Eclipse Ditto"},{"location":"RPI-II/P11_old/#objetivos","text":"Conocer el funcionamiento b\u00e1sico de Ditto como software de soporte para gemelos digitales. Ejercitar el concepto de Thing y su representaci\u00f3n en Ditto. Interactuar con un entorno de gemelos digitales v\u00eda una API REST. Desplegar un entorno IoT basado en MQTT sobre Ditto.","title":"Objetivos"},{"location":"RPI-II/P11_old/#introduccion","text":"Eclipse Ditto es un proyecto dentro de Eclipse IoT que implementa un patr\u00f3n de software llamado gemelos digitales . Un gemelo digital es una representaci\u00f3n virtual, basada en la nube, de su contraparte del mundo real ( cosas del mundo real, por ejemplo, dispositivos como sensores, calefacci\u00f3n inteligente, autom\u00f3viles conectados, redes inteligentes, estaciones de carga para veh\u00edculos el\u00e9ctricos, ...). Ditto simplifica el desarrollo de soluciones IoT para desarrolladores de software, ya que no necesitan saber c\u00f3mo o d\u00f3nde est\u00e1n conectadas exactamente las \"cosas\" f\u00edsicas. Con Ditto, una cosa puede usarse como cualquier otro servicio web a trav\u00e9s de su gemelo digital. Ditto no es plataforma IoT completa. No proporciona software que se ejecute en gateways IoT y no define ni implementa un protocolo de IoT para comunicarse con los dispositivos. Su enfoque radica en escenarios de backend , al proporcionar una API web para simplificar el trabajo con dispositivos conectados (por ejemplo, a trav\u00e9s de MQTT) u otro software de backend . Con Ditto, es posible obtener una API completa y consciente de la autorizaci\u00f3n (HTTP, WebSocket y otros protocolos de mensajer\u00eda) para interactuar con sus gemelos digitales y todos los aspectos que los rodean. Considerando que el desarrollador planeta la creaci\u00f3n de una soluci\u00f3n de IoT, y suponiendo que utiliza tanto hardware (por ejemplo, sensores o actuadores) como software (por ejemplo, una aplicaci\u00f3n m\u00f3vil o web) para resolver el problema de su cliente, \u00e9ste tiene varios lugares donde implementar el software: En o cerca del hardware, por ejemplo, en una placa Arduino usando C/C++ o en una Raspberry PI usando Python, opcionalmente en un gateway que establece la conectividad a Internet (por ejemplo, basado en Eclipse Kura), En la aplicaci\u00f3n m\u00f3vil o web usando Java, Javascript, etc., En el backend cumpliendo varias responsabilidades como proporcionar una API que se abstrae del hardware, enrutamiento de solicitudes entre el hardware y las aplicaciones de los clientes, asegurando solo el acceso autorizado, conservando el \u00faltimo estado informado del hardware como cach\u00e9 y proporcionando los datos cuando el hardware no est\u00e1 conectado actualmente, notificar a las partes interesadas (por ejemplo, otros servicios de backend ) sobre los cambios. Ditto se enfoca en resolver las responsabilidades que tiene un backend t\u00edpico en tales escenarios. Su objetivo es liberar las soluciones IoT de la necesidad de implementar y operar un back-end personalizado. En cambio, al usar Eclipse Ditto, pueden concentrarse en los requisitos comerciales, en conectar dispositivos a la nube/back-end y en implementar aplicaciones comerciales.","title":"Introducci\u00f3n"},{"location":"RPI-II/P11_old/#instalacion-de-prerequisitos-docker","text":"La instalaci\u00f3n de Ditto que utilizaremos en esta pr\u00e1ctica se basa en un despliegue de microserviciios confinados en contenedores Docker. Por tanto, la instalaci\u00f3n de Docker es un requisito indispensable para el desarrollo de la pr\u00e1ctica. Si ya dispones de una instalaci\u00f3n funcional de Docker en tu PC o en la m\u00e1quina virtual del curso, puedes obviar esta secci\u00f3n. En caso contrario, instala y comprueba el funcionamiento de Docker siguiendo las instrucciones de su p\u00e1gina oficial para la distribuci\u00f3n Linux que est\u00e9s utilizando (o incluso para otros sistemas operativos). En el caso de la M\u00e1quina Virtual (Ubuntu), se recomienda seguir la instalaci\u00f3n paso a paso detallada en la p\u00e1gina oficial de Docker . Concretamente, se sugiere utilizar el m\u00e9todo de instalaci\u00f3n basado en repositorio ( Install using the repository ). En el caso de Linux es muy aconsejable, para ejecutar el software con permisos de usuario, finalizar la instalaci\u00f3n con los pasos post-instalaci\u00f3n sugeridos en la propia p\u00e1gina . Tarea Si todo ha ido bien, en este punto deber\u00edas poder ejecutar, sin permisos de superusuario ( sudo ) el contenedor sencillo Hello, world indicado en la documentaci\u00f3n.","title":"Instalaci\u00f3n de prerequisitos (Docker)"},{"location":"RPI-II/P11_old/#instalacion-y-despliegue-de-eclipse-ditto-utilizando-docker","text":"Eclipse Ditto se basa en un despliegue de microservicios, cada uno de ellos dedicado a una tarea espec\u00edfica (gesti\u00f3n de conexiones, autorizaci\u00f3n, almacenamiento de datos, etc.). M\u00e1s concretamente, los microservicios se encargan de la gesti\u00f3n de: Pol\u00edticas de acceso ( Policies ). Things. Conectividad. B\u00fasqueda. Gesti\u00f3n de Ditto como canalizador de mensajes ( Gateway ). En su versi\u00f3n m\u00e1s operativa, estos microservicios se despliegan y comunican entre ellos utilizando contenedores Docker, y pueden ser gestionados de forma manual (como nosotros haremos), o integrados en orquestadores de m\u00e1s alto nivel, como Kubernetes. La \u00fanica dependencia externa exigida por Ditto es el uso de MongoDB para gestionar el almacenamiento de logs, conexiones, eventos y otros registros de inter\u00e9s, y el uso de NginX para dar soporte a la interfaz Web (opcional) y a tareas de autenticaci\u00f3n b\u00e1sica de usuarios.o","title":"Instalaci\u00f3n y despliegue de Eclipse Ditto utilizando Docker"},{"location":"RPI-II/P11_old/#obtencion-del-software","text":"En primer lugar, clona el repositorio que aloja el c\u00f3digo fuente de Eclipse Ditto utilizando git : git clone https://github.com/eclipse-ditto/ditto.git Esto crear\u00e1 un directorio ditto con todo lo necesario para el despliegue del sistema. Podr\u00edamos directamente construir Ditto desde este c\u00f3digo fuente, pero haremos uso de una forma de despliegue basada en im\u00e1genes Docker precompiladas y combinadas v\u00eda docker-compose .","title":"Obtenci\u00f3n del software"},{"location":"RPI-II/P11_old/#despliegue-del-sistema","text":"Para comenzar, dir\u00edgete al directorio deployment/docker . Los pasos que se listan a continuaci\u00f3n son los que se describen en la documentaci\u00f3n oficial (fichero README.md del directorio). En primer lugar, configuraremos el servidor web que dar\u00e1 soporte a la interacci\u00f3n b\u00e1sica con Ditto y a las tareas de autenticaci\u00f3n de usuarios contra la API REST proporcionada por Ditto. En primer lugar, configuraremos las credenciales que permitir\u00e1n a los usuarios interactuar con Ditto v\u00eda HTTP. Para ello, utiliza la herramienta openssl passwd para crear un hash de la contrase\u00f1a a utilizar por parte del usuario ditto (si no tienes instalado openssl , hazlo utilizando el sistema de paqueter\u00eda de Ubuntu o cualquier otro mecanismo disponible en tu distribuci\u00f3n): openssl passwd -quiet Password: <enter password> Verifying - Password: <enter password> Es importante que anotes la contrase\u00f1a que vas a utilizar. En el resto de la pr\u00e1ctica asumiremos que has utilizado masteriot como contrase\u00f1a, pero puedes usar la que desees. Como resultado de la anterior ejecuci\u00f3n, se mostrar\u00e1 por pantalla el hash de la contrase\u00f1a elegida, por ejemplo A6BgmB8IEtPTs . Edita el fichero nginx.htpasswd y a\u00f1ade la siguiente l\u00ednea: ditto:A6BgmB8IEtPTs Esto permitir\u00e1 la autenticaci\u00f3n de un usuario llamado ditto utilizando la contrase\u00f1a escogida. A continuaci\u00f3n, despliega los servicios utilizando docker-compose : docker-compose up -d Deber\u00edas observar una salida similar a la siguiente: ubuntu@ubuntu2004:~/Work/ditto/deployment/docker$ sudo docker-compose up -d Starting docker_policies_1 ... done Starting docker_mongodb_1 ... done Starting docker_swagger-ui_1 ... done Starting docker_connectivity_1 ... done Starting docker_things_1 ... done Starting docker_things-search_1 ... done Starting docker_gateway_1 ... done Starting docker_nginx_1 ... done En el anterior caso, estamos utilizando sudo , aunque esto no deber\u00eda ser necesario si has configurado correctamente docker . No hay mayor problema en hacerlo as\u00ed en esta pr\u00e1ctica. Si deseas detener los servicios, puedes simplemente ejecutar: ubuntu@ubuntu2004:~/Work/ditto/deployment/docker$ sudo docker-compose stop Stopping docker_nginx_1 ... done Stopping docker_things_1 ... done Stopping docker_things-search_1 ... done Stopping docker_gateway_1 ... done Stopping docker_connectivity_1 ... done Stopping docker_policies_1 ... done Stopping docker_mongodb_1 ... done Stopping docker_swagger-ui_1 ... done En este punto, Ditto deber\u00eda estar funcionando correctamente. Por cuestiones de facilidad de uso, y aunque su uso es totalmente opcional y de hecho no recomendado en entornos en producci\u00f3n, Ditto ofrece una interfaz de usuario web que utilizaremos para verificar su correcta instalaci\u00f3n y para realizar los pasos b\u00e1sicos de interacci\u00f3n con el sistema. Para ello, abre un navegador en la m\u00e1quina donde has desplegado el entorno, y navega a la direcci\u00f3n http://localhost:8080 . Deber\u00edas observar una p\u00e1gina similar a la siguiente: Para acceder a la interfaz de usuario (UI) que utilizaremos, navega a http://localhost:8080/ui o pincha en el enlace correspondiente. En la p\u00e1gina anterior tienes tambi\u00e9n un enlace descriptivo de la API REST ofrecida por Ditto. Una vez m\u00e1s, el uso de la UI es opcional. Un entorno en producci\u00f3n interactuar\u00eda con Ditto a trav\u00e9s de la API REST que ofrece (tal y como hace la UI de forma gr\u00e1fica), pero por practicidad la utilizaremos en algunas partes de la pr\u00e1ctica. Por \u00faltimo, deber\u00e1s configurar la UI para que autentique al usuario principal ( ditto ) usando la contrase\u00f1a que estableciste previamente en el proceso de instalaci\u00f3n. Para ello, pincha en el bot\u00f3n Authorize de la parte superior derecha de la UI, y a\u00f1ade la contrase\u00f1a elegida para el usuario principal: Una vez hecho esto, pincha en el primero de los tres botones Authorize y podr\u00e1s comenzar a trabajar.","title":"Despliegue del sistema"},{"location":"RPI-II/P11_old/#primeros-pasos-con-ditto","text":"","title":"Primeros pasos con Ditto"},{"location":"RPI-II/P11_old/#elementos-principales-de-la-ui","text":"La UI dispone de cuatro pantallas (pesta\u00f1as principales), seleccionables a trav\u00e9s de la barra superior: Things : para visualizar y gestionar las Things existentes en el sistema. Policies : para visualizar y gestionar las pol\u00edticas de acceso existentes en el sistema. Connections : para gestionar las comunicaciones externas del sistema (por ejemplo, su interacci\u00f3n con MQTT). Environments : para gestionar los entornos que definen condiciones de acceso al sistema (no los utilizaremos). Pincha en la opci\u00f3n Things . Deber\u00edas ver una pantalla dividida en cuatro \u00e1reas, en tu caso vac\u00edas: En la parte superior izquierda ver\u00e1s las Things creadas. En este punto, estar\u00e1n vac\u00edas, pero la captura anterior muestra una situaci\u00f3n con dos entidades ya creadas. Observa sus nombres: por convenio, la nomenclatura de Things es jer\u00e1rquica, con el s\u00edmbolo : como separaci\u00f3n entre entidades. En la pr\u00f3xima secci\u00f3n aprender\u00e1s a crear estas entidades, pero de momento la captura muestra c\u00f3mo, seleccionando una de ellas, podr\u00e1s observar sus atributos (descripciones est\u00e1ticas de alguna caracter\u00edstica del Thing ) y caracter\u00edsticas (entidades din\u00e1micas que pueden ir variando con el ciclo de vida del mismo). En la parte superior derecha dispones de la descripci\u00f3n formal de Thing en tres formatos distintos (visual, CRUD y Web of Things). Se deja como ejercicio la profundizaci\u00f3n en cada uno de estos formatos si fuera de inter\u00e9s para el/la estudiante. Por \u00faltimo, en la parte inferior derecha dispones de la informaci\u00f3n, en varios formatos, asociada a cada caracter\u00edstica. A continuaci\u00f3n, pincha en la opci\u00f3n Policies . Deber\u00edas ver una pantalla dividida en cuatro \u00e1reas, en tu caso vac\u00edas: En la captura puedes observar las pol\u00edticas de acceso asociadas a una de las Things creadas para el usuario web ditto (el que est\u00e1s utilizando). Observa que, a grandes rasgos, este usuario tiene permisos de lectura y escritura concedidos sobre la Thing por lo que podr\u00e1 modificarla y consultarla. Aprenderemos a gestionar estos permisos m\u00e1s adelante. Por \u00faltimo, la pesta\u00f1a Connections permite configurar conexiones (por ejemplo MQTT) entrantes y salientes, para gestionar la comunicaci\u00f3n entre el gemelo digital (Ditto) y dispositivos o entidades externas. M\u00e1s adelante describiremos algunos de sus campos m\u00e1s interesantes y crearemos las conexiones necesarias para recibir datos del gemelo f\u00edsico v\u00eda MQTT:","title":"Elementos principales de la UI"},{"location":"RPI-II/P11_old/#creacion-de-things","text":"La creaci\u00f3n de Things puede realizarse v\u00eda un endpoint espec\u00edfico proporcionado por la API REST de Ditto. Asumamos que deseamos crear un gemelo digital para un coche. Este gemelo podr\u00eda alojar metadatos est\u00e1ticos y datos de estado din\u00e1micos, actualizados constantemente desde el gemelo f\u00edsico. Es decir, la representaci\u00f3n digital ( Features ) de la Thing deber\u00eda cambiar tan pronto como lo hace su representaci\u00f3n f\u00edsica. Estos tipos est\u00e1ticos y din\u00e1micos de datos se mapean en Ditto como atributos (attributes) y caracter\u00edsticas (features) . Opcionalmente, puede utilizarse una definici\u00f3n (definition) del objeto, utilizando por ejemplo el modelo de informaci\u00f3n de Eclipse Vorto , aunque esto queda fuera del alcance de esta pr\u00e1ctica). A continuaci\u00f3n se muestra la representaci\u00f3n, en formato JSON, de un objeto de este tipo: { \"definition\": \"digitaltwin:DigitaltwinExample:1.0.0\", \"attributes\": { \"manufacturer\": \"ACME\", \"VIN\": \"0815666337\" }, \"features\": { \"transmission\": { \"properties\": { \"automatic\": true, \"mode\": \"eco\", \"cur_speed\": 90, \"gear\": 5 } }, \"environment-scanner\": { \"properties\": { \"temperature\": 20.8, \"humidity\": 73, \"barometricPressure\": 970.7, \"location\": { \"longitude\": 47.682170, \"latitude\": 9.386372 }, \"altitude\": 399 } } } } Dentro de Attributes , podemos a\u00f1adir tantas caracter\u00edsticas como deseemos en forma de pares clave:valor JSON. Dentro de Features , podemos a\u00f1adir tantas caracter\u00edsticas como deseemos en forma de pares clave:valor JSON, pero cada una debe tener un objeto JSON llamado properties , que contenga tantos pares clave:valor como deseemos para describir a nuestro objeto. Utilizaremos curl para interactuar con Ditto y crear entidades de tipo Thing . La autenticaci\u00f3n que usaremos para ello es la definida para el usuario ditto con la contrase\u00f1a que elegiste en el proceso de instalaci\u00f3n, siguiendo este esquema de consulta: curl -u ditto:masteriot -X PUT -H 'Content-Type: application/json' -d '{ \"definition\": \"digitaltwin:DigitaltwinExample:1.0.0\", \"attributes\": { \"manufacturer\": \"ACME\", \"VIN\": \"0815666337\" }, \"features\": { \"transmission\": { \"properties\": { \"automatic\": true, \"mode\": \"eco\", \"cur_speed\": 90, \"gear\": 5 } }, \"environment-scanner\": { \"properties\": { \"temperature\": 20.8, \"humidity\": 73, \"barometricPressure\": 970.7, \"location\": { \"longitude\": 47.682170, \"latitude\": 9.386372 }, \"altitude\": 399 } } } }' 'http://localhost:8080/api/2/things/org.eclipse.ditto:fancy-car' Observa que usamos la contrase\u00f1a masteriot , un verbo PUT para modificar el estado y una petici\u00f3n en formato JSON utilizando la estructura anteriormente descrita. El endpoint utilizado indica el identificador de objeto a crear. Puedes encontrar (y utilizar) toda la informaci\u00f3n relativa a la API de Ditto en http://localhost:8080/apidoc/ . Tarea Crea un conjunto de Things similar al mostrado y observa/experimenta a trav\u00e9s de la UI para determinar si la informaci\u00f3n proporcionada es correcta. Crea al menos una de ellas tal y como se especifica m\u00e1s arriba, porque la necesitar\u00e1s con dicha estructura para el resto de la pr\u00e1ctica. \u00bfQu\u00e9 ocurre si creas de nuevo una Thing ya existente, variando alguno de sus datos asociados? (compru\u00e9balo a trav\u00e9s de la UI).","title":"Creaci\u00f3n de Things"},{"location":"RPI-II/P11_old/#consulta-de-things","text":"La consulta de Things se realiza a trav\u00e9s del endpoint correspondiente. En el caso de desear consultar los datos relativos a una entidad creada anteriormente, podr\u00edamos hacerlo de la siguiente manera: curl -u ditto:masteriot -X GET 'http://localhost:8080/api/2/things/org.eclipse.ditto:fancy-car' Tarea Consulta los datos relativos a las entidades que has creado anteriormente, y muestra al menos el contenido de la respuesta HTTP devuelta para una de ellas.","title":"Consulta de Things"},{"location":"RPI-II/P11_old/#consulta-de-valores-de-estado-especificos","text":"La consulta de valores espec\u00edficos para una Thing no resulta m\u00e1s complicada, por ejemplo: curl -u ditto:masteriot -X GET 'http://localhost:8080/api/2/things/org.eclipse.ditto:fancy-car/features/transmission/properties/cur_speed' Tarea Experimenta y muestra la respuesta para la consulta de valores espec\u00edficos para las entidades que has creado.","title":"Consulta de valores de estado espec\u00edficos"},{"location":"RPI-II/P11_old/#actualizacion-de-valores-de-estado-especificos","text":"Es posible incluso modificar directamente el valor de una caracter\u00edstica v\u00eda HTTP: curl -u ditto:masteriot -X PUT -H 'Content-Type: application/json' -d '77' 'http://localhost:8080/api/2/things/org.eclipse.ditto:fancy-car/features/transmission/properties/cur_speed' Tarea Experimenta y muestra la respuesta para la modificaci\u00f3n de valores espec\u00edficos para las entidades que has creado. Despu\u00e9s, consulta a trav\u00e9s de la UI o bien utilizando la API directamente si los valores efectivamente se han modificado.","title":"Actualizaci\u00f3n de valores de estado espec\u00edficos"},{"location":"RPI-II/P11_old/#busqueda","text":"Por \u00faltimo, puedes realizar b\u00fasquedas espec\u00edficas utilizando filtros. As\u00ed, para consultar todas las Things cuyo fabricante sea ACME, podr\u00edamos ejecutar: curl -u ditto:masteriot -X GET 'http://localhost:8080/api/2/search/things?filter=eq(attributes/manufacturer,\"ACME\")' Tarea Experimenta con los filtros de b\u00fasqueda ofrecidos por Ditto, y muestra alg\u00fan ejemplo usando las entidades que hayas creado anteriormente. A trav\u00e9s de la UI, puedes hacerlo usando el cuadro de texto en la parte superior izquierda de la p\u00e1gina.","title":"B\u00fasqueda"},{"location":"RPI-II/P11_old/#gestion-basica-de-politicas","text":"Ditto ofrece la posibilidad de personalizar el acceso a usuarios espec\u00edficos a ciertas partes de los objetos creados, limitando por ejemplo su capacidad de lectura o de escritura sobre ellos. Estas condiciones, llamadas Policy , permiten definir c\u00f3mo se puede acceder a un objeto o conjunto de objetos que compartan la misma pol\u00edtica de acceso. En este caso, utilizaremos la UI para la gesti\u00f3n de pol\u00edticas, pero este tipo de operaciones se pueden realizar a trav\u00e9s de la API REST de Ditto. Navega hacia la pesta\u00f1a Policies de la UI. En la parte superior izquierda podr\u00e1s seleccionar la pol\u00edtica que deseas consultar o editar. En este caso, y ya que por defecto se asignan pol\u00edticas con el mismo nombre las Things creadas, deber\u00edas poder editar una pol\u00edtica llamada org.eclipse.ditt:fancy-car . Pincha sobre ella y aparecer\u00e1 una entrada DEFAULT en el panel inferior izquierdo; seleccion\u00e1ndola, observar\u00e1s las caracter\u00edsticas de esta pol\u00edtica. En este caso, para el Recurso thing:/ , ver\u00e1s que la pol\u00edtica permite leer y escribir (panel inferior derecho): { \"grant\": [ \"READ\", \"WRITE\" ], \"revoke\": [] } Tarea Revoca en primer lugar el permiso de lectura (READ) sobre un objeto que siga esta pol\u00edtica. Guarda los cambios (bot\u00f3n que muestra una caja con una flecha en el panel inferior derecho) e intenta consultar v\u00eda API alguna caracter\u00edstica de dicha Thing . A continuaci\u00f3n, haz lo propio con el permiso de escritura e intenta modificar la Thing .","title":"Gesti\u00f3n b\u00e1sica de pol\u00edticas"},{"location":"RPI-II/P11_old/#creacion-de-una-conexion-mqtt-e-interaccion-con-ditto","text":"Hasta este punto, el extremo backend de nuestro entorno interactuaba con su gemelo digital utilizando la API REST, pero una de las ventajas de Ditto radica en su capacidad para unificar protocolos utilizados por los dispositivos f\u00edsicos. Por ejemplo, un dispositivo podr\u00eda utilizar MQTT para, a trav\u00e9s de un broker , comunicarse con Ditto, que podr\u00eda analizar el contenido del mensaje y \"enrutarlo\" hacia el Thing asociado. Para gestionar este tipo de despliegues, podemos crear conexiones (Connections) a trav\u00e9s de la UI. Dir\u00edgete hacia la pesta\u00f1a Connections . En el panel central, observar\u00e1s un campo en blanco donde definiremos las caracter\u00edsticas de la conexi\u00f3n que deseamos crear. Aunque Ditto permite utilizar plantillas para distintos tipos de conexiones (MQTT, MQTT5, Kafka, AMQP, ...) a trav\u00e9s de la opci\u00f3n Template , nosotros definiremos nuestra propia conexi\u00f3n MQTT, pegando el siguiente fragmento JSON: { \"id\": \"9279185c-4bcc-4d66-a3e1-0971ce4376f9\", \"name\": \"RPI-demo\", \"connectionType\": \"mqtt\", \"connectionStatus\": \"open\", \"uri\": \"tcp://test.mosquitto.org:1883\", \"sources\": [ { \"addresses\": [ \"eclipse-ditto-sandbox/#\" ], \"consumerCount\": 1, \"qos\": 0, \"authorizationContext\": [ \"nginx:ditto\" ], \"headerMapping\": {}, \"payloadMapping\": [ \"javascript\" ], \"replyTarget\": { \"enabled\": false } } ], \"targets\": [ { \"address\": \"eclipse-ditto-sandbox/{{ thing:id }}\", \"topics\": [ \"_/_/things/twin/events\" ], \"qos\": 0, \"authorizationContext\": [ \"ditto:outbound-auth-subject\" ], \"headerMapping\": {}, \"payloadMapping\": [ \"javascript\" ] } ], \"clientCount\": 1, \"failoverEnabled\": true, \"validateCertificates\": true, \"processorPoolSize\": 1, \"mappingDefinitions\": { \"javascript\": { \"mappingEngine\": \"JavaScript\", \"options\": { \"incomingScript\": \"/**\\n * Maps the passed parameters to a Ditto Protocol message.\\n * @param {Object.<string, string>} headers - The headers Object containing all received header values\\n * @param {string} [textPayload] - The String to be mapped\\n * @param {ArrayBuffer} [bytePayload] - The bytes to be mapped as ArrayBuffer\\n * @param {string} [contentType] - The received Content-Type, e.g. \\\"application/json\\\"\\n * @returns {(DittoProtocolMessage|Array<DittoProtocolMessage>)} dittoProtocolMessage(s) -\\n * The mapped Ditto Protocol message,\\n * an array of Ditto Protocol messages or\\n * <code>null</code> if the message could/should not be mapped\\n */\\nfunction mapToDittoProtocolMsg(\\n headers,\\n textPayload,\\n bytePayload,\\n contentType\\n) {\\n\\n // ### Insert/adapt your mapping logic here.\\n // Use helper function Ditto.buildDittoProtocolMsg to build Ditto protocol message\\n // based on incoming payload.\\n // See https://www.eclipse.org/ditto/connectivity-mapping.html#helper-functions for details.\\n\\n // ### example code assuming the Ditto protocol content type for incoming messages.\\n const jsonString = String.fromCharCode.apply(null, new Uint8Array(bytePayload));\\n const jsonData = JSON.parse(jsonString); \\n const thingId = jsonData.thingId.split(':'); \\n const value = { \\n transmission: { \\n properties: { \\n automatic: jsonData.automatic,\\n cur_speed: jsonData.cur_speed,\\n mode: jsonData.mode,\\n gear: jsonData.gear\\n } \\n } \\n }; \\n return Ditto.buildDittoProtocolMsg(\\n thingId[0], // your namespace \\n thingId[1], \\n 'things', // we deal with a thing\\n 'twin', // we want to update the twin\\n 'commands', // create a command to update the twin\\n 'modify', // modify the twin\\n '/features', // modify all features at once\\n headers, \\n value\\n );\\n}\", \"outgoingScript\": \"/**\\n * Maps the passed parameters which originated from a Ditto Protocol message to an external message.\\n * @param {string} namespace - The namespace of the entity in java package notation, e.g.: \\\"org.eclipse.ditto\\\". Or \\\"_\\\"\\n * (underscore) for connection announcements.\\n * @param {string} name - The name of the entity, e.g.: \\\"device\\\".\\n * @param {string} group - The affected group/entity: \\\"things\\\"|\\\"policies\\\"|\\\"connections\\\".\\n * @param {string} channel - The channel for the signal: \\\"twin\\\"|\\\"live\\\"|\\\"none\\\"\\n * @param {string} criterion - The criterion to apply: \\\"commands\\\"|\\\"events\\\"|\\\"search\\\"|\\\"messages\\\"|\\\"announcements\\\"|\\\"errors\\\".\\n * @param {string} action - The action to perform: \\\"create\\\"|\\\"retrieve\\\"|\\\"modify\\\"|\\\"delete\\\". Or the announcement name:\\n * \\\"opened\\\"|\\\"closed\\\"|\\\"subjectDeletion\\\". Or the subject of the message.\\n * @param {string} path - The path which is affected by the message (e.g.: \\\"/attributes\\\"), or the destination\\n * of a message (e.g.: \\\"inbox\\\"|\\\"outbox\\\").\\n * @param {Object.<string, string>} dittoHeaders - The headers Object containing all Ditto Protocol header values.\\n * @param {*} [value] - The value to apply / which was applied (e.g. in a \\\"modify\\\" action).\\n * @param {number} [status] - The status code that indicates the result of the command. When this field is set,\\n * it indicates that the Ditto Protocol Message contains a response.\\n * @param {Object} [extra] - The enriched extra fields when selected via \\\"extraFields\\\" option.\\n * @returns {(ExternalMessage|Array<ExternalMessage>)} externalMessage - The mapped external message, an array of\\n * external messages or <code>null</code> if the message could/should not be mapped.\\n */\\nfunction mapFromDittoProtocolMsg(\\n namespace,\\n name,\\n group,\\n channel,\\n criterion,\\n action,\\n path,\\n dittoHeaders,\\n value,\\n status,\\n extra\\n) {\\n\\n // ###\\n // Insert your mapping logic here\\n\\n // ### example code using the Ditto protocol content type.\\n let headers = dittoHeaders;\\n let textPayload = JSON.stringify(Ditto.buildDittoProtocolMsg(namespace, name, group, channel, criterion, action,\\n path, dittoHeaders, value, status, extra));\\n let bytePayload = null;\\n let contentType = 'application/vnd.eclipse.ditto+json';\\n\\n return Ditto.buildExternalMsg(\\n headers, // The external headers Object containing header values\\n textPayload, // The external mapped String\\n bytePayload, // The external mapped byte[]\\n contentType // The returned Content-Type\\n );\\n}\", \"loadBytebufferJS\": \"false\", \"loadLongJS\": \"false\" } } }, \"tags\": [] } Copia y pega el objeto en el panel, y pincha sobre el bot\u00f3n central de carga. Pese a la longitud del objeto, lo que nos interesan son s\u00f3lo ciertas partes del mismo, a saber: Definici\u00f3n del tipo de conexi\u00f3n: \"connectionType\": \"mqtt\" . Definici\u00f3n del tipo de persistencia de la conexi\u00f3n, en este caso open para una conectividad y actualizaciones en tiempo real. Definici\u00f3n del broker MQTT: \"uri\": \"tcp://test.mosquitto.org:1883\" . Definici\u00f3n del mapeado, en forma de scripts Javascript que se realizar\u00e1 de los mensajes entrantes y salientes. En este caso, los scripts de pre y post procesamiento se muestran en los paneles de la derecha de la pantalla. Despliega la conexi\u00f3n utilizando el bot\u00f3n central en el panel central. En el panel de la izquierda, observar\u00e1s que la conexi\u00f3n con nombre RPI-demo se ha creado y permanece abierta. Ahora, cualquier mensaje MQTT enviado al broker especificado ser\u00e1 recibido por Ditto a trav\u00e9s de \u00e9l, que lo procesar\u00e1 utilizando el script correspondiente. En este caso, el script simplemente mapea el mensaje (JSON) recibido y lo convierte en un mensaje utilizando el protocolo de Ditto para su procesamiento. Hagamos una prueba. Considerando que has creado una Thing con nombre org.eclipse.ditt:fancy-car , prepara un fichero de texto llamado message.json con el siguiente contenido: { \"automatic\":true, \"mode\": \"gasoil\", \"cur_speed\": 82, \"gear\":8, \"thingId\":\"org.eclipse.ditto:fancy-car\" } El objetivo es modificar el estado del objeto correspondiente, por ejemplo fijando nuevos valores para alguna de sus caracter\u00edsticas. Una vez listo, lo enviaremos al broker utilizando cualquier cliente MQTT: mosquitto_pub -t \"eclipse-ditto-sandbox/org.eclipse.ditto:fancy-car\" -f message.json -h test.mosquitto.org Observa el topic utilizado y el broker , necesarios para la comunicaci\u00f3n con Ditto. Tarea Experimenta con el env\u00edo de mensajes MQTT desde la terminal, y su repercusi\u00f3n en Ditto. Tras el env\u00edo, consulta v\u00eda la API REST el estado de la Thing correspondiente. \u00bfHa variado? Activa los logs desde la UI (panel inferior central) e intenta entender el proceso que sigue un mensaje MQTT desde que es recibido hasta que llega a la Thing correspondiente. Tarea adicional Dise\u00f1a, en uno o varios nodos ESP32, clientes MQTT que expongan cierto valor a trav\u00e9s de MQTT, y \u00e9ste sea mapeado a una Thing tambi\u00e9n dise\u00f1ada por ti.","title":"Creaci\u00f3n de una conexi\u00f3n MQTT e interacci\u00f3n con Ditto"},{"location":"RPI-II/P1_I/","text":"Pr\u00e1ctica 1 (Parte 1). Programaci\u00f3n con sockets en C Objetivos Familiarizarse con la API de sockets en C. Desarrollar esquemas b\u00e1sicos de sistemas cliente/servidor TCP y UDP utilizando C. Ser capaces de analizar el tr\u00e1fico generado en una conexi\u00f3n TCP y UDP a trav\u00e9s de Wireshark. Dise\u00f1ar un protocolo de capa de aplicaci\u00f3n sencillo para simular una aplicaci\u00f3n cliente/servidor utilizando TCP y UDP para interactuar entre un cliente y un servidor bajo un sistema operativo de tipo Linux. Introducci\u00f3n La historia de los sockets se remonta al origen de ARPANET, en 1971, y su posterior estandarizaci\u00f3n en forma de API dentro del sistema operativo Berkeley Software Distribution (BSD) , liberado en 1983, bajo el nombre de sockets de Berkeley . Con la popularizaci\u00f3n de Internet en los a\u00f1os 90, y de la mano de la World Wide Web , la programaci\u00f3n de red sufri\u00f3 tambi\u00e9n una notable evoluci\u00f3n. Los servidores web y los navegadores no fueron (ni son) las \u00fanicas aplicaciones basadas en sockets . De hecho, los sistemas cliente/servidor son a d\u00eda de hoy ubicuos e incluyen, por supuesto, a todos los protocolos de alto nivel que dan soporte a Internet de las Cosas. De hecho, a d\u00eda de hoy, aunque los potocolos de alto nivel (capa de aplicaci\u00f3n) han evolucionado hasta niveles de sofisticaci\u00f3n no considerados en sus inicios, la API de bajo nivel sobre la que se basan se mantiene inalterada. El tipo m\u00e1s com\u00fan de aplicaciones basadas en sockets se basa en el paradigma cliente/servidor, donde una de las partes act\u00faa como servidor , esperando pasivamente conexiones desde un conjunto de uno o m\u00e1s clientes . A continuaci\u00f3n, veremos c\u00f3mo desarrollar este tipo de paradigma desde C, utilizando sockets Berkeley . Existen tambi\u00e9n los llamados Unix domain sockets , que permiten la comunicaci\u00f3n directa entre procesos en el mismo host , aunque quedan fuera de nuestro inter\u00e9s en el \u00e1mbito de IoT. El objetivo de la presente pr\u00e1ctica es estudiar y desarrollar componentes de red (clientes y servidores TCP y UDP) que puedan ejecutarse sobre el ESP32 haciendo uso de las facilidades propuestas por ESP-IDF. Adem\u00e1s, demostraremos que es posible hacer interactuar clientes y servidores ejecut\u00e1ndose indistintamente en un PC (programados v\u00eda C) y en la propia placa (utilizando la API de sockets de C). Para ello, en esta primera parte de la pr\u00e1ctica, comenzaremos analizando y desarrollando sencillos despliegues de tipo cliente/servidor haciendo uso de los protocolos de transporte TCP y UDP, analizando sus pros y sus contras desde el punto de vista del tr\u00e1fico generado y de las caracter\u00edsticas soportadas. La API de sockets en C Funciones para ordenacion de bytes Como TCP/IP es un est\u00e1ndar universal, y permite comunicaciones entre cualquier plataforma y arquitectura, es necesario disponer de un m\u00e9todo de ordenaci\u00f3n de los bytes para que m\u00e1quinas big-endian y little-endian puedan comunicarse de forma transparente y correcta. Para ello, se suelen proporcionar rutinas de reordenaci\u00f3n de bytes. En plataformas donde los datos ya est\u00e1n correctamente ordenados, estas funciones no tienen ninguna funcionalidad especial, pero en cualquier caso, es necesario utilizarlas siempre para que la comunicaci\u00f3n entre pares sea correcta. Las funciones t\u00edpicas de reordenaci\u00f3n de datos son cuatro: htons , htonl , ntohs y ntohl . Su nombre explica correctamente su sem\u00e1ntica: host to network (short) host to network (long) , network to host (short) y network to host (long) , convirtiendo tipos de datos short y long desde el formato utilizado en transmisiones de red ( network ) a representaci\u00f3n en el host . As\u00ed, siempre que enviemos un dato binario por la red, deber\u00e1 ser transformado utilizando hton* y cuando lo recibamos y debamos procesarlo, utilizando ntoh* . Estructuras de datos Antes de estudiar la API de sockets b\u00e1sica, es necesario mostrar el cometido de un conjunto de estructuras de datos utilizadas com\u00fanmente en todas ellas. La m\u00e1s importante es sockaddr_in , que se define como sigue: struct sockaddr_in { short sin_family; u_short sin_port; struct in_addr sin_addr; char sin_zero[8]; }; La estructura in_addr utilizada en sockaddr_in se define como: struct in_addr { u_long s_addr; }; \u00c9sta consiste en un campo de tipo unsigned long int que contiene la direcci\u00f3n IP que se asociar\u00e1 con el socket. La estructura sockaddr_in contiene dos campos importantes: sin_family : que indica al socket qu\u00e9 familia de protocolos se utilizar\u00e1n (usaremos la constante AF_INET para IPv4). sin_port : que indica el puerto asociado al socket. API b\u00e1sica socket() Prototipo: int socket(int family, int type, int protocol); Descripci\u00f3n: Crea un endpoint de comunicaci\u00f3n y devuelve un descriptor de fichero para manejarlo. Par\u00e1metros: family : AF_INET (IPv4), AF_INET6 (IPv6). type : SOCK_DGRAM (UDP), SOCK_STREAM (TCP), SOCK_RAW . protocol : T\u00edpicamente 0 (no usado en sockets de Internet). Valor de retorno: Si tiene \u00e9xito, devuelve el descriptor de socket . Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de socket ( man socket ). bind() Prototipo: int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); Descripci\u00f3n: Asocia un socket a una direcci\u00f3n especificada por addr . Normalmente, es necesario asignar una direcci\u00f3n local v\u00eda esta funci\u00f3n antes de que un socket TCP pueda recibir conexiones. Par\u00e1metros: sockfd : descriptor de socket (devuelto por socket ). addr : direcci\u00f3n a asociar (v\u00e9ase estructura en secci\u00f3n anterior). addrlen : longitud (en bytes) de la anterior estructura. Valor de retorno: Si tiene \u00e9xito, devuelve 0. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de bind ( man bind ). listen() Prototipo: int listen(int sockfd, int backlog); Descripci\u00f3n: Marca el socket proporcionado como pasivo , esto es, un socket que podr\u00e1 ser utilizado para aceptar conexiones entrantes usando la llamada accept . Par\u00e1metros: sockfd : descriptor de socket (devuelto por socket ). backlog : longitud m\u00e1xima que podr\u00e1 tener la cola de conexiones pendientes para el socket . Si se sobrepasa, el cliente recibir\u00e1 un error en su intento de conexi\u00f3n. Valor de retorno: Si tiene \u00e9xito, devuelve 0. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de listen ( man listen ). accept() Prototipo: int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); Descripci\u00f3n: En sockets orientados a conexi\u00f3n, extrae la primera solicitud de conexi\u00f3n de la cola de conexiones pendientes para el socket proporcionado, crea un nuevo socket conectado y devuelve su descriptor. Par\u00e1metros: sockfd : descriptor de socket (devuelto por socket ). addr : es un puntero a una estructura de tipo sockaddr , cuyos campos ser\u00e1n rellenados con los datos de direcci\u00f3n del socket remoto. addrlen : tama\u00f1o de la estructura addr . Valor de retorno: Si tiene \u00e9xito, devuelve el descriptor de socket. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de accept ( man accept ). connect() Prototipo: int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); Descripci\u00f3n: Conecta el socket proporcionada a la direcci\u00f3n especificada por addr . Si el socket es UDP, addr ser\u00e1 la direcci\u00f3n a la que se enviar\u00e1n los datagramas por defecto, y la \u00fanica desde la que se recibir\u00e1n datagramas. En caso de TCP, esta llamada inicia el proceso de conexi\u00f3n a la direcci\u00f3n especificada. Par\u00e1metros: sockfd : descriptor de socket (devuelto por socket ). addr : es un puntero a una estructura de tipo sockaddr , cuyos campos indican la direcci\u00f3n de conexi\u00f3n destino. addrlen : tama\u00f1o de la estructura addr . Valor de retorno: Si tiene \u00e9xito, devuelve el descriptor de socket. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de connect ( man connect ). send() Prototipo: ssize_t send(int sockfd, const void *buf, size_t len, int flags); Descripci\u00f3n: En un socket en estado conectado (con receptor conocido) transmite mensajes a un socket remoto. Par\u00e1metros: sockfd : descriptor de socket de env\u00edo. buf : buffer de env\u00edo donde se almacena el mensaje a enviar. len : n\u00famero de bytes a enviar. Valor de retorno: Si tiene \u00e9xito, devuelve el n\u00famero de bytes enviados. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de send ( man send ). recv() / recvfrom() Prototipos: ssize_t recv(int sockfd, void *buf, size_t len, int flags); ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen); Descripci\u00f3n: Reciben mensajes desde un socket , tanto en sockets orientados como no orientados a conexi\u00f3n. recvfrom , a diferencia de recv , recibe par\u00e1metros de salida adicionales que almacenan informaci\u00f3n sobre la direcci\u00f3n origen del mensaje. Par\u00e1metros: sockfd : descriptor de socket de recepci\u00f3n. buf : buffer de recepci\u00f3n donde se almacena el mensaje a recibir. len : n\u00famero de bytes a recibir. src_addr : direcci\u00f3n del extremo remoto del socket (origen de la comunicaci\u00f3n). addrlen : tama\u00f1o de la estructura src_addr . Valor de retorno: Si tiene \u00e9xito, devuelve el n\u00famero de bytes recibidos. Devuelve -1 si se produce un error. Detalles: consultad las p\u00e1ginas de manual de recv y recv_from ( man recv y man recv_from ). close() Prototipo: int close(int fd); Descripci\u00f3n: Cierra un socket. Par\u00e1metros: fd : descriptor de socket . Detalles: consultad la p\u00e1gina de manual de close ( man close ). Ejemplos Descarga el paquete con los c\u00f3digos de ejemplo para el resto de la pr\u00e1ctica en este enlace . En \u00e9l, se proporcionan ejemplos completos de uso de la API de sockets en C para el desarrollo de sistemas cliente/servidor sencillos. Para cada uno de ellos, comprueba que, efectivamente, el uso y secuencia de aplicaci\u00f3n de cada llamada sigue las directivas de la figura: Tarea 1.1 Compila (utilizando por ejemplo la orden gcc ejemplo.c -o ejemplo.x desde una terminal) y a continuaci\u00f3n ejecuta ( ./ejemplo.x ) cada par de c\u00f3digos y comprueba su funcionamiento. Estudia con detenimiento el uso de cada rutina y como efectivamente siguen las directivas marcadas anteriormente. Si no tienes experiencia en desarrollo en C, consulta las p\u00e1ginas de manual correspondientes, o con tu profesor, para resolver todas tus dudas. Aseg\u00farate de entender el proceso de compilaci\u00f3n, enlazado y ejecuci\u00f3n de un binario. Capturas de tr\u00e1fico v\u00eda Wireshark Wireshark es una herramienta de c\u00f3digo abierto ampliamente utilizada para analizar protocolos de comunicaci\u00f3n de red en cualquiera de las capas de la pila TCP/IP (como tambi\u00e9n en otros protocolos). Wireshark implementa un amplio abanico de filtros para definir criterios de b\u00fasqueda en las capturas de tr\u00e1fico, aunque de momento, en nuestro caso, no ser\u00e1 necesario utilizar filtros espec\u00edficos. Para arrancar Wireshark en la m\u00e1quina virtual proporcionada (o en cualquier instalaci\u00f3n b\u00e1sica Linux), teclea en tu terminal: $ sudo wireshark Tras el arranque, podemos comenzar una nueva captura de tr\u00e1fico a trav\u00e9s del men\u00fa Capture , opci\u00f3n Start . La pantalla de selecci\u00f3n de interfaz nos permitir\u00e1 definir en qu\u00e9 interfaz de red se realizar\u00e1 la captura. En nuestro caso, ya que vamos a comunicar dos procesos en la misma m\u00e1quina, elegiremos la interfaz de Loopback (lo) y comenzaremos la captura. Tarea 1.2 Arranca Wireshark y prepara una captura sobre la interfaz de loopback de tu m\u00e1quina. Ejecuta el servidor echo TCP y el cliente correspondiente, y analiza el tr\u00e1fico generado. Especialmente, f\u00edjate en el proceso de establecimiento de conexi\u00f3n en tres v\u00edas, paquetes de Acknowledge tras el env\u00edo de cada mensaje y, en general, en cualquier otro aspecto que consideres de inter\u00e9s. Repite a continuaci\u00f3n el mismo proceso para el protocolo UDP. Construcci\u00f3n de mensajes Para enviar mensajes que encapsulen distintos tipos de datos en una sola invocaci\u00f3n, puedes definir un mensaje como el siguiente: typedef struct { int x; int y; } mensaje; Dando valor a cada campo y a continuaci\u00f3n envi\u00e1ndolo proporcionando la direcci\u00f3n de inicio de la estructura, del siguiente modo: mensaje.x = x; mensaje.y = y; send( socketfd, &mensaje, sizeof( mensaje ), 0 ); Tarea 1.3 (entregable) Se pide dise\u00f1ar un sistema cliente/servidor programado en C, que simule el env\u00edo de un conjunto de datos sensorizados desde un cliente hacia un servidor. El protocolo a utilizar (formato de datos enviado por la red a nivel de aplicaci\u00f3n) debe ser propuesto por el alumno/a y descrito previamente al desarrollo. Se valorar\u00e1 el uso de m\u00faltiples tipos de datos tanto en el env\u00edo de datos sensorizados como de posibles respuestas por parte del servidor. Se desarrollar\u00e1 una versi\u00f3n utilizando TCP y otra equivalente usando UDP. El cliente enviar\u00e1 los datos de forma peri\u00f3dica y \u00e9stos se generar\u00e1n de modo aleatorio. A modo de entrega, se solicitan los c\u00f3digos desarrollados, as\u00ed como un an\u00e1lisis del tr\u00e1fico generado, considerando la sobrecarga (en bytes reales enviados) introducida por cada protocolo de capa de transporte.","title":"Pr\u00e1ctica 1 (I)"},{"location":"RPI-II/P1_I/#practica-1-parte-1-programacion-con-sockets-en-c","text":"","title":"Pr\u00e1ctica 1 (Parte 1). Programaci\u00f3n con sockets en C"},{"location":"RPI-II/P1_I/#objetivos","text":"Familiarizarse con la API de sockets en C. Desarrollar esquemas b\u00e1sicos de sistemas cliente/servidor TCP y UDP utilizando C. Ser capaces de analizar el tr\u00e1fico generado en una conexi\u00f3n TCP y UDP a trav\u00e9s de Wireshark. Dise\u00f1ar un protocolo de capa de aplicaci\u00f3n sencillo para simular una aplicaci\u00f3n cliente/servidor utilizando TCP y UDP para interactuar entre un cliente y un servidor bajo un sistema operativo de tipo Linux.","title":"Objetivos"},{"location":"RPI-II/P1_I/#introduccion","text":"La historia de los sockets se remonta al origen de ARPANET, en 1971, y su posterior estandarizaci\u00f3n en forma de API dentro del sistema operativo Berkeley Software Distribution (BSD) , liberado en 1983, bajo el nombre de sockets de Berkeley . Con la popularizaci\u00f3n de Internet en los a\u00f1os 90, y de la mano de la World Wide Web , la programaci\u00f3n de red sufri\u00f3 tambi\u00e9n una notable evoluci\u00f3n. Los servidores web y los navegadores no fueron (ni son) las \u00fanicas aplicaciones basadas en sockets . De hecho, los sistemas cliente/servidor son a d\u00eda de hoy ubicuos e incluyen, por supuesto, a todos los protocolos de alto nivel que dan soporte a Internet de las Cosas. De hecho, a d\u00eda de hoy, aunque los potocolos de alto nivel (capa de aplicaci\u00f3n) han evolucionado hasta niveles de sofisticaci\u00f3n no considerados en sus inicios, la API de bajo nivel sobre la que se basan se mantiene inalterada. El tipo m\u00e1s com\u00fan de aplicaciones basadas en sockets se basa en el paradigma cliente/servidor, donde una de las partes act\u00faa como servidor , esperando pasivamente conexiones desde un conjunto de uno o m\u00e1s clientes . A continuaci\u00f3n, veremos c\u00f3mo desarrollar este tipo de paradigma desde C, utilizando sockets Berkeley . Existen tambi\u00e9n los llamados Unix domain sockets , que permiten la comunicaci\u00f3n directa entre procesos en el mismo host , aunque quedan fuera de nuestro inter\u00e9s en el \u00e1mbito de IoT. El objetivo de la presente pr\u00e1ctica es estudiar y desarrollar componentes de red (clientes y servidores TCP y UDP) que puedan ejecutarse sobre el ESP32 haciendo uso de las facilidades propuestas por ESP-IDF. Adem\u00e1s, demostraremos que es posible hacer interactuar clientes y servidores ejecut\u00e1ndose indistintamente en un PC (programados v\u00eda C) y en la propia placa (utilizando la API de sockets de C). Para ello, en esta primera parte de la pr\u00e1ctica, comenzaremos analizando y desarrollando sencillos despliegues de tipo cliente/servidor haciendo uso de los protocolos de transporte TCP y UDP, analizando sus pros y sus contras desde el punto de vista del tr\u00e1fico generado y de las caracter\u00edsticas soportadas.","title":"Introducci\u00f3n"},{"location":"RPI-II/P1_I/#la-api-de-sockets-en-c","text":"","title":"La API de sockets en C"},{"location":"RPI-II/P1_I/#funciones-para-ordenacion-de-bytes","text":"Como TCP/IP es un est\u00e1ndar universal, y permite comunicaciones entre cualquier plataforma y arquitectura, es necesario disponer de un m\u00e9todo de ordenaci\u00f3n de los bytes para que m\u00e1quinas big-endian y little-endian puedan comunicarse de forma transparente y correcta. Para ello, se suelen proporcionar rutinas de reordenaci\u00f3n de bytes. En plataformas donde los datos ya est\u00e1n correctamente ordenados, estas funciones no tienen ninguna funcionalidad especial, pero en cualquier caso, es necesario utilizarlas siempre para que la comunicaci\u00f3n entre pares sea correcta. Las funciones t\u00edpicas de reordenaci\u00f3n de datos son cuatro: htons , htonl , ntohs y ntohl . Su nombre explica correctamente su sem\u00e1ntica: host to network (short) host to network (long) , network to host (short) y network to host (long) , convirtiendo tipos de datos short y long desde el formato utilizado en transmisiones de red ( network ) a representaci\u00f3n en el host . As\u00ed, siempre que enviemos un dato binario por la red, deber\u00e1 ser transformado utilizando hton* y cuando lo recibamos y debamos procesarlo, utilizando ntoh* .","title":"Funciones para ordenacion de bytes"},{"location":"RPI-II/P1_I/#estructuras-de-datos","text":"Antes de estudiar la API de sockets b\u00e1sica, es necesario mostrar el cometido de un conjunto de estructuras de datos utilizadas com\u00fanmente en todas ellas. La m\u00e1s importante es sockaddr_in , que se define como sigue: struct sockaddr_in { short sin_family; u_short sin_port; struct in_addr sin_addr; char sin_zero[8]; }; La estructura in_addr utilizada en sockaddr_in se define como: struct in_addr { u_long s_addr; }; \u00c9sta consiste en un campo de tipo unsigned long int que contiene la direcci\u00f3n IP que se asociar\u00e1 con el socket. La estructura sockaddr_in contiene dos campos importantes: sin_family : que indica al socket qu\u00e9 familia de protocolos se utilizar\u00e1n (usaremos la constante AF_INET para IPv4). sin_port : que indica el puerto asociado al socket.","title":"Estructuras de datos"},{"location":"RPI-II/P1_I/#api-basica","text":"","title":"API b\u00e1sica"},{"location":"RPI-II/P1_I/#socket","text":"Prototipo: int socket(int family, int type, int protocol); Descripci\u00f3n: Crea un endpoint de comunicaci\u00f3n y devuelve un descriptor de fichero para manejarlo. Par\u00e1metros: family : AF_INET (IPv4), AF_INET6 (IPv6). type : SOCK_DGRAM (UDP), SOCK_STREAM (TCP), SOCK_RAW . protocol : T\u00edpicamente 0 (no usado en sockets de Internet). Valor de retorno: Si tiene \u00e9xito, devuelve el descriptor de socket . Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de socket ( man socket ).","title":"socket()"},{"location":"RPI-II/P1_I/#bind","text":"Prototipo: int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); Descripci\u00f3n: Asocia un socket a una direcci\u00f3n especificada por addr . Normalmente, es necesario asignar una direcci\u00f3n local v\u00eda esta funci\u00f3n antes de que un socket TCP pueda recibir conexiones. Par\u00e1metros: sockfd : descriptor de socket (devuelto por socket ). addr : direcci\u00f3n a asociar (v\u00e9ase estructura en secci\u00f3n anterior). addrlen : longitud (en bytes) de la anterior estructura. Valor de retorno: Si tiene \u00e9xito, devuelve 0. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de bind ( man bind ).","title":"bind()"},{"location":"RPI-II/P1_I/#listen","text":"Prototipo: int listen(int sockfd, int backlog); Descripci\u00f3n: Marca el socket proporcionado como pasivo , esto es, un socket que podr\u00e1 ser utilizado para aceptar conexiones entrantes usando la llamada accept . Par\u00e1metros: sockfd : descriptor de socket (devuelto por socket ). backlog : longitud m\u00e1xima que podr\u00e1 tener la cola de conexiones pendientes para el socket . Si se sobrepasa, el cliente recibir\u00e1 un error en su intento de conexi\u00f3n. Valor de retorno: Si tiene \u00e9xito, devuelve 0. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de listen ( man listen ).","title":"listen()"},{"location":"RPI-II/P1_I/#accept","text":"Prototipo: int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); Descripci\u00f3n: En sockets orientados a conexi\u00f3n, extrae la primera solicitud de conexi\u00f3n de la cola de conexiones pendientes para el socket proporcionado, crea un nuevo socket conectado y devuelve su descriptor. Par\u00e1metros: sockfd : descriptor de socket (devuelto por socket ). addr : es un puntero a una estructura de tipo sockaddr , cuyos campos ser\u00e1n rellenados con los datos de direcci\u00f3n del socket remoto. addrlen : tama\u00f1o de la estructura addr . Valor de retorno: Si tiene \u00e9xito, devuelve el descriptor de socket. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de accept ( man accept ).","title":"accept()"},{"location":"RPI-II/P1_I/#connect","text":"Prototipo: int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); Descripci\u00f3n: Conecta el socket proporcionada a la direcci\u00f3n especificada por addr . Si el socket es UDP, addr ser\u00e1 la direcci\u00f3n a la que se enviar\u00e1n los datagramas por defecto, y la \u00fanica desde la que se recibir\u00e1n datagramas. En caso de TCP, esta llamada inicia el proceso de conexi\u00f3n a la direcci\u00f3n especificada. Par\u00e1metros: sockfd : descriptor de socket (devuelto por socket ). addr : es un puntero a una estructura de tipo sockaddr , cuyos campos indican la direcci\u00f3n de conexi\u00f3n destino. addrlen : tama\u00f1o de la estructura addr . Valor de retorno: Si tiene \u00e9xito, devuelve el descriptor de socket. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de connect ( man connect ).","title":"connect()"},{"location":"RPI-II/P1_I/#send","text":"Prototipo: ssize_t send(int sockfd, const void *buf, size_t len, int flags); Descripci\u00f3n: En un socket en estado conectado (con receptor conocido) transmite mensajes a un socket remoto. Par\u00e1metros: sockfd : descriptor de socket de env\u00edo. buf : buffer de env\u00edo donde se almacena el mensaje a enviar. len : n\u00famero de bytes a enviar. Valor de retorno: Si tiene \u00e9xito, devuelve el n\u00famero de bytes enviados. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de send ( man send ).","title":"send()"},{"location":"RPI-II/P1_I/#recvrecvfrom","text":"Prototipos: ssize_t recv(int sockfd, void *buf, size_t len, int flags); ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen); Descripci\u00f3n: Reciben mensajes desde un socket , tanto en sockets orientados como no orientados a conexi\u00f3n. recvfrom , a diferencia de recv , recibe par\u00e1metros de salida adicionales que almacenan informaci\u00f3n sobre la direcci\u00f3n origen del mensaje. Par\u00e1metros: sockfd : descriptor de socket de recepci\u00f3n. buf : buffer de recepci\u00f3n donde se almacena el mensaje a recibir. len : n\u00famero de bytes a recibir. src_addr : direcci\u00f3n del extremo remoto del socket (origen de la comunicaci\u00f3n). addrlen : tama\u00f1o de la estructura src_addr . Valor de retorno: Si tiene \u00e9xito, devuelve el n\u00famero de bytes recibidos. Devuelve -1 si se produce un error. Detalles: consultad las p\u00e1ginas de manual de recv y recv_from ( man recv y man recv_from ).","title":"recv()/recvfrom()"},{"location":"RPI-II/P1_I/#close","text":"Prototipo: int close(int fd); Descripci\u00f3n: Cierra un socket. Par\u00e1metros: fd : descriptor de socket . Detalles: consultad la p\u00e1gina de manual de close ( man close ).","title":"close()"},{"location":"RPI-II/P1_I/#ejemplos","text":"Descarga el paquete con los c\u00f3digos de ejemplo para el resto de la pr\u00e1ctica en este enlace . En \u00e9l, se proporcionan ejemplos completos de uso de la API de sockets en C para el desarrollo de sistemas cliente/servidor sencillos. Para cada uno de ellos, comprueba que, efectivamente, el uso y secuencia de aplicaci\u00f3n de cada llamada sigue las directivas de la figura: Tarea 1.1 Compila (utilizando por ejemplo la orden gcc ejemplo.c -o ejemplo.x desde una terminal) y a continuaci\u00f3n ejecuta ( ./ejemplo.x ) cada par de c\u00f3digos y comprueba su funcionamiento. Estudia con detenimiento el uso de cada rutina y como efectivamente siguen las directivas marcadas anteriormente. Si no tienes experiencia en desarrollo en C, consulta las p\u00e1ginas de manual correspondientes, o con tu profesor, para resolver todas tus dudas. Aseg\u00farate de entender el proceso de compilaci\u00f3n, enlazado y ejecuci\u00f3n de un binario.","title":"Ejemplos"},{"location":"RPI-II/P1_I/#capturas-de-trafico-via-wireshark","text":"Wireshark es una herramienta de c\u00f3digo abierto ampliamente utilizada para analizar protocolos de comunicaci\u00f3n de red en cualquiera de las capas de la pila TCP/IP (como tambi\u00e9n en otros protocolos). Wireshark implementa un amplio abanico de filtros para definir criterios de b\u00fasqueda en las capturas de tr\u00e1fico, aunque de momento, en nuestro caso, no ser\u00e1 necesario utilizar filtros espec\u00edficos. Para arrancar Wireshark en la m\u00e1quina virtual proporcionada (o en cualquier instalaci\u00f3n b\u00e1sica Linux), teclea en tu terminal: $ sudo wireshark Tras el arranque, podemos comenzar una nueva captura de tr\u00e1fico a trav\u00e9s del men\u00fa Capture , opci\u00f3n Start . La pantalla de selecci\u00f3n de interfaz nos permitir\u00e1 definir en qu\u00e9 interfaz de red se realizar\u00e1 la captura. En nuestro caso, ya que vamos a comunicar dos procesos en la misma m\u00e1quina, elegiremos la interfaz de Loopback (lo) y comenzaremos la captura. Tarea 1.2 Arranca Wireshark y prepara una captura sobre la interfaz de loopback de tu m\u00e1quina. Ejecuta el servidor echo TCP y el cliente correspondiente, y analiza el tr\u00e1fico generado. Especialmente, f\u00edjate en el proceso de establecimiento de conexi\u00f3n en tres v\u00edas, paquetes de Acknowledge tras el env\u00edo de cada mensaje y, en general, en cualquier otro aspecto que consideres de inter\u00e9s. Repite a continuaci\u00f3n el mismo proceso para el protocolo UDP.","title":"Capturas de tr\u00e1fico v\u00eda Wireshark"},{"location":"RPI-II/P1_I/#construccion-de-mensajes","text":"Para enviar mensajes que encapsulen distintos tipos de datos en una sola invocaci\u00f3n, puedes definir un mensaje como el siguiente: typedef struct { int x; int y; } mensaje; Dando valor a cada campo y a continuaci\u00f3n envi\u00e1ndolo proporcionando la direcci\u00f3n de inicio de la estructura, del siguiente modo: mensaje.x = x; mensaje.y = y; send( socketfd, &mensaje, sizeof( mensaje ), 0 ); Tarea 1.3 (entregable) Se pide dise\u00f1ar un sistema cliente/servidor programado en C, que simule el env\u00edo de un conjunto de datos sensorizados desde un cliente hacia un servidor. El protocolo a utilizar (formato de datos enviado por la red a nivel de aplicaci\u00f3n) debe ser propuesto por el alumno/a y descrito previamente al desarrollo. Se valorar\u00e1 el uso de m\u00faltiples tipos de datos tanto en el env\u00edo de datos sensorizados como de posibles respuestas por parte del servidor. Se desarrollar\u00e1 una versi\u00f3n utilizando TCP y otra equivalente usando UDP. El cliente enviar\u00e1 los datos de forma peri\u00f3dica y \u00e9stos se generar\u00e1n de modo aleatorio. A modo de entrega, se solicitan los c\u00f3digos desarrollados, as\u00ed como un an\u00e1lisis del tr\u00e1fico generado, considerando la sobrecarga (en bytes reales enviados) introducida por cada protocolo de capa de transporte.","title":"Construcci\u00f3n de mensajes"},{"location":"RPI-II/P1_II/","text":"Pr\u00e1ctica 1 (ap\u00e9ndice). Introducci\u00f3n a Node-RED Objetivos Familiarizarse con la herramienta Node-RED para gesti\u00f3n de flujos, que ser\u00e1 utilizada durante el resto de pr\u00e1cticas como herramienta r\u00e1pida de despliegue de aplicaciones IoT. Desarrollar esquemas b\u00e1sicos de sistemas cliente/servidor TCP y UDP utilizando Node-RED. Introducci\u00f3n Node-RED es una herramienta de c\u00f3digo abierto desarrollada inicialmente por IBM y que, estando orientada a flujos de datos, proporciona mecanismos para asociar dispositivos hardware, APIs y servicios online dentro de un ecosistema IoT. Node-RED es una herramienta gr\u00e1fica, utilizable desde cualquier navegador web, que permite la craci\u00f3n y edici\u00f3n de flujos de datos que tomen datos de entrada (mediante nodos de entrada), los procesen (mediante nodos de procesamiento) y proporcionen salidas (mediante nodos de salida). Todos los elementos, incluyendo flujos complejos definidos por el usuario, pueden almacenarse en formato JSON para ser importados a continuaci\u00f3n en otras instalaciones. Node-RED permite la interconexi\u00f3n de elementos software y hardware mediante virtualmente cualquier protocolo conocido, facilitando el despliegue de infraestructuras IoT. El presente bolet\u00edn \u00fanicamente incluye informaci\u00f3n e instrucciones para la instalaci\u00f3n de la herramienta Node-RED en la m\u00e1quina virtual del curso (alternativamente, es posible instalar Node-RED en cualquier m\u00e1quina f\u00edsica), as\u00ed como la propuesta de ejercicio entregable a dise\u00f1ar e implementar. Se proporcionar\u00e1n las explicaciones y demostraciones necesarias durante la sesi\u00f3n de laboratorio para entender los conceptos b\u00e1sicos relativos a la instalaci\u00f3n y uso b\u00e1sico de la herramienta Node-RED. Instalaci\u00f3n y puesta en marcha Las presentes instrucciones son v\u00e1lidas para cualquier distribuci\u00f3n basada en Debian (incluida Ubuntu). Para otras distribuciones o sistemas operativos, consultad la documentaci\u00f3n oficial de Node-RED. Para instalar Node-RED en la m\u00e1quina virtual del curso, es suficiente con seguir los siguientes pasos. En primer lugar, si no lo est\u00e1n ya, instala los requisitos b\u00e1sicos del paquete: sudo apt install build-essential git curl La siguiente l\u00ednea descarga y ejecuta un script que realizar\u00e1 toda la instalaci\u00f3n de dependencias (desinstalando versiones antiguas si es necesario) por ti: bash <(curl -sL https://raw.githubusercontent.com/node-red/linux-installers/master/deb/update-nodejs-and-nodered) Para ejecutar Node-RED, una vez instalado, es posible utilizar la orden node-red-start desde cualquier terminal. Para detener el proceso, es suficiente con utilizar Ctrl-C : $ node-red Welcome to Node-RED =================== 30 Jun 23:43:39 - [info] Node-RED version: v1.1.0 30 Jun 23:43:39 - [info] Node.js version: v10.21.0 30 Jun 23:43:39 - [info] Darwin 18.7.0 x64 LE 30 Jun 23:43:39 - [info] Loading palette nodes 30 Jun 23:43:44 - [warn] rpi-gpio : Raspberry Pi specific node set inactive 30 Jun 23:43:44 - [info] Settings file : /Users/nol/.node-red/settings.js 30 Jun 23:43:44 - [info] HTTP Static : /Users/nol/node-red/web 30 Jun 23:43:44 - [info] Context store : 'default' [module=localfilesystem] 30 Jun 23:43:44 - [info] User directory : /Users/nol/.node-red 30 Jun 23:43:44 - [warn] Projects disabled : set editorTheme.projects.enabled=true to enable 30 Jun 23:43:44 - [info] Creating new flows file : flows_noltop.json 30 Jun 23:43:44 - [info] Starting flows 30 Jun 23:43:44 - [info] Started flows 30 Jun 23:43:44 - [info] Server now running at http://127.0.0.1:1880/red/ Con el software arrancado, es posible acceder al editor Node-RED a trav\u00e9s de la direcci\u00f3n http://localhost:1880 en cualquier navegador. Tras arrancarlo, observar\u00e1s cuatro \u00e1reas en el editor: Barra principal , en la parte superior, con los botones Deploy y de Men\u00fa principal . Panel de nodos , en la parte izquierda, que proporciona acceso directo a todos los nodos disponibles en Node-RED. Es posible instalar nuevos nodos a trav\u00e9s de la Paleta de Nodos, disponible a trav\u00e9s del men\u00fa principal ( Manage Palette ). Estos nodos pueden ser arrastrados al editor para conformar nuevos flujos de datos. Panel de edici\u00f3n o espacio de trabajo , en la parte central de la pantalla, donde podr\u00e1s arrastrar y unir nuevos nodos. Es posible crear nuevos flujos en pesta\u00f1as independientes. Panel de informaci\u00f3n , en la parte derecha de la pantalla, donde destaca el bot\u00f3n Debug , mediante el cual veremos la salida de los nodos de tipo Debug en nuestros flujos. Ejemplo 1 Se muestra a continuaci\u00f3n un breve ejemplo b\u00e1sico de utilizaci\u00f3n del editor Node-RED, que incluye el uso de nodos Inject , Debug y Function . Nodo Inject El nodo Inject permite inyectar mensajes en un flujo, bien pulsando en el bot\u00f3n asociado al nodo, o estableciendo un intervalo de tiempo entre inyecciones. Busca en el panel izquierdo un nodo de tipo Inject y arr\u00e1stralo al espacio de trabajo. En el panel de informaci\u00f3n podr\u00e1s consultar los datos asociados al nodo, as\u00ed como informaci\u00f3n de ayuda para utilizarlo. Nodo Debug El nodo Debug permite que cualquier mensaje entrante se muestre en el panel de depuraci\u00f3n, en la parte derecha de la pantalla. Por defecto, \u00fanicamente muestra el payload del mensaje, aunque puede configurarse para mostrar el objeto completo. Arrastra un nodo de tipo Debug al espacio de trabajo. Uni\u00f3n y despliegue ( Deploy ) Conecta los nodos Inject y Debug estableciendo un enlace ( Wire ) entre ambos. Despliega el flujo usando el bot\u00f3n Deploy en la barra principal de Node-RED. Esto desplegar\u00e1 el fujo en el servidor. Selecciona la opci\u00f3n Debug en el panel de informaci\u00f3n, y presiona el bot\u00f3n del nodo Inject . Deber\u00edas ver n\u00fameros aparecer en el panel. Por defecto, el nodo Inject emite el n\u00famero de milisegundos desde el 1 de enero de 1970 como payload . Modifica (temporalmente) el nodo Debug para que muestre todo el mensaje en lugar del payload . Despliega de nuevo el flujo y observa las diferencias. Vuelve a configurar el nodo Debug tal y como estaba cuando lo insertaste. Nodo Function El nodo Function permite procesar el mensaje de entrada mediante una funci\u00f3n JavaScript. Borra el Wire existente y a\u00f1ade un nodo Function entre los nodos Inject y Debug . Haz doble clic en el nuevo nodo para abrir el di\u00e1logo de edici\u00f3n. Copia el siguiente c\u00f3digo en el campo Function : // Create a Date object from the payload var date = new Date(msg.payload); // Change the payload to be a formatted Date string msg.payload = date.toString(); // Return the message so it can be sent on return msg; Clica en Done y despliega el flujo. Observa que, ahora, los mensajes de depuraci\u00f3n muestran marcas de tiempo en formato visible. Ten en cuenta que un nodo siempre recibe un mensaje ( msg ) de entrada y devuelve un mensaje ( msg ) de salida. Ambos objetos contienen, por convenio, un campo payload . Para m\u00e1s informaci\u00f3n sobre el uso de funciones y trabajo con mensajes, incluyendo m\u00faltiples valores de retorno y trabajo con valores globales a todo el entorno, se recomienda estudiar la siguiente documentaci\u00f3n: Trabajo con mensajes : enlace a documentaci\u00f3n . Trabajo con funciones : enlace a documentaci\u00f3n . Ejemplo 2 Nodo Inject En el anterior ejemplo, vimos c\u00f3mo crear un nodo Inject para activar el flujo cuando se pulsaba su bot\u00f3n asociado. En este ejemplo, vamos a configurar el nodo Inject para que active el flujo en intervalos regulares. Arrastra un nuevo nodo Inject en el espacio de trabajo. Clica en \u00e9l dos veces y, en el di\u00e1logo de edici\u00f3n, usala opci\u00f3n Repeat interval , fij\u00e1ndolo en un intervalo regular. Cierra el di\u00e1logo de edici\u00f3n. Nodo HTTP Request El nodo de tipo HTTP Request puede utilizarse para descargar una p\u00e1gina web o recurso HTTP. A\u00f1ade uno al espacio de trabajo, y ed\u00edtalo para que su propiedad URL apunte a https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/significant_month.csv . Esta URL es un repositorio de terremotos en el \u00faltimo mes, pulicado por el organismo oficial correspondiente, devueltos en formato CSV. Nodo CSV A\u00f1ade un nuevo nodo CSV y edita sus propiedades. Activa la opci\u00f3n First row contains column names y finaliza la edici\u00f3n. Nodo Debug y cableado A\u00f1ade un nodo Debug y une los nodos creados: Conecta la salida del nodo Inject a la entrada del nodo HTTP Request . Conecta la salida del nodo HTTP Request a la entrada del nodo CSV . Conecta la salida del nodo CSV a la entrada del nodo Debug . Nodo Switch A\u00f1ade un nodo Switch al espacio de trabajo. Edita sus propiedades y configuralo para comprobar la propiedad msg.payload.mag , usando la operaci\u00f3n >= sobre un valor num\u00e9rico y el valor 6.2 , por ejemplo. A\u00f1ade un segundo Wire entre el nodo CSV y el nodo Switch . Nodo Change A\u00f1ade un nodo Change , conectado a la salida del nodo Switch . Configuralo para establecer el valor de msg.payload a ALARMA . Nodo Debug A\u00f1ade un nodo Debug y despliega el flujo. En el panel de Debug , deber\u00e1s obsevar, para cada activaci\u00f3n del nodo Inject , una salida similar a esta: msg.payload : Object {\"time\":\"2017-11-19T15:09:03.120Z\",\"latitude\":-21.5167,\"longitude\":168.5426,\"depth\":14.19,\"mag\":6.6,\"magType\":\"mww\",\"gap\":21,\"dmin\":0.478,\"rms\":0.86,\"net\":\"us\",\"id\":\"us2000brgk\",\"updated\":\"2017-11-19T17:10:58.449Z\",\"place\":\"68km E of Tadine, New Caledonia\",\"type\":\"earthquake\",\"horizontalError\":6.2,\"depthError\":2.8,\"magError\":0.037,\"magNst\":72,\"status\":\"reviewed\",\"locationSource\":\"us\",\"magSource\":\"us\"} Puedes clicar en la peque\u00f1a flecha a la izquierda de cada propiedad para expandirla y examinar sus contenidos. Si existe cualquier terremoto de magnitud mayor a 6.2 , observar\u00e1s una salida adicional: msg.payload : string(6) \"ALARMA\" Para m\u00e1s informaci\u00f3n sobre los nodos b\u00e1sicos en Node-RED, puedes consultar: The Core Nodes : enlace a documentaci\u00f3n . Documentaci\u00f3n adicional Las gu\u00edas de usuario oficiales de Node-RED son un buen punto de partida para profundizar en el uso de la infraestructura. De entre ellas, la parte m\u00e1s importante para comenzar es la que introduce los conceptos b\u00e1sicos de Node-RED, incluyendo el trabajo con nodos, flujos, contexto (importante para trabajar con valores globales y compartidos por todos los nodos en un flujo, por ejemplo), mensajes, wires , etc.: Node-RED Concepts : enlace a documentaci\u00f3n . La gu\u00eda Node-RED Guide contiene interesante documentaci\u00f3n adicional/avanzada tanto en el despliegue de flujos como en el uso de paneles de control locales o usando servicios remotos (por ejemplo, Freeboard ): Node-RED Guide : enlace a documentaci\u00f3n . Tarea 1.3bis Se pide estudiar la documentaci\u00f3n asociada a Node-RED, tanto en su web oficial como en la gu\u00eda de programaci\u00f3n Node-RED Guide (espec\u00edficamente sus cuatro primeras partes). Junto con la explicaci\u00f3n proporcionada por el profesor y los anteriores ejemplos, este estudio permitir\u00e1 el desarrollo de la tarea. Se sugiere experimentar con los nodos TCP (in/out/request) y sus correspondientes versiones UDP. La tarea consiste en el dise\u00f1o y desarrollo de un sistema cliente/servidor similar al desarrollado en la tarea 1.3, pero que, en esta ocasi\u00f3n, despliegue sus componentes utilizando exclusivamente Node-RED. El objetivo final de la tarea es que sea posible interactuar entre un cliente/servidor desarrollado en C y un servidor/cliente desarrollado en Node-RED. Se aceptar\u00e1 simplificar el protocolo de aplicaci\u00f3n desarrollado en la tarea 1.3 si ello facilita el dearrollo de la tarea. Puede ser de ayuda el estudio del nodo buffer-parser . Se entregar\u00e1 el fichero o ficheros JSON que describen los nodos, as\u00ed como una breve memoria que describa el sistema dise\u00f1ado y el trabajo realizado, haciendo hincapi\u00e9 en las dificultades encontradas y aquellos aspectos que se consideren de inter\u00e9s por parte del alumno/a.","title":"Pr\u00e1ctica 1 (ap\u00e9ndice). Introducci\u00f3n a Node-RED"},{"location":"RPI-II/P1_II/#practica-1-apendice-introduccion-a-node-red","text":"","title":"Pr\u00e1ctica 1 (ap\u00e9ndice). Introducci\u00f3n a Node-RED"},{"location":"RPI-II/P1_II/#objetivos","text":"Familiarizarse con la herramienta Node-RED para gesti\u00f3n de flujos, que ser\u00e1 utilizada durante el resto de pr\u00e1cticas como herramienta r\u00e1pida de despliegue de aplicaciones IoT. Desarrollar esquemas b\u00e1sicos de sistemas cliente/servidor TCP y UDP utilizando Node-RED.","title":"Objetivos"},{"location":"RPI-II/P1_II/#introduccion","text":"Node-RED es una herramienta de c\u00f3digo abierto desarrollada inicialmente por IBM y que, estando orientada a flujos de datos, proporciona mecanismos para asociar dispositivos hardware, APIs y servicios online dentro de un ecosistema IoT. Node-RED es una herramienta gr\u00e1fica, utilizable desde cualquier navegador web, que permite la craci\u00f3n y edici\u00f3n de flujos de datos que tomen datos de entrada (mediante nodos de entrada), los procesen (mediante nodos de procesamiento) y proporcionen salidas (mediante nodos de salida). Todos los elementos, incluyendo flujos complejos definidos por el usuario, pueden almacenarse en formato JSON para ser importados a continuaci\u00f3n en otras instalaciones. Node-RED permite la interconexi\u00f3n de elementos software y hardware mediante virtualmente cualquier protocolo conocido, facilitando el despliegue de infraestructuras IoT. El presente bolet\u00edn \u00fanicamente incluye informaci\u00f3n e instrucciones para la instalaci\u00f3n de la herramienta Node-RED en la m\u00e1quina virtual del curso (alternativamente, es posible instalar Node-RED en cualquier m\u00e1quina f\u00edsica), as\u00ed como la propuesta de ejercicio entregable a dise\u00f1ar e implementar. Se proporcionar\u00e1n las explicaciones y demostraciones necesarias durante la sesi\u00f3n de laboratorio para entender los conceptos b\u00e1sicos relativos a la instalaci\u00f3n y uso b\u00e1sico de la herramienta Node-RED.","title":"Introducci\u00f3n"},{"location":"RPI-II/P1_II/#instalacion-y-puesta-en-marcha","text":"Las presentes instrucciones son v\u00e1lidas para cualquier distribuci\u00f3n basada en Debian (incluida Ubuntu). Para otras distribuciones o sistemas operativos, consultad la documentaci\u00f3n oficial de Node-RED. Para instalar Node-RED en la m\u00e1quina virtual del curso, es suficiente con seguir los siguientes pasos. En primer lugar, si no lo est\u00e1n ya, instala los requisitos b\u00e1sicos del paquete: sudo apt install build-essential git curl La siguiente l\u00ednea descarga y ejecuta un script que realizar\u00e1 toda la instalaci\u00f3n de dependencias (desinstalando versiones antiguas si es necesario) por ti: bash <(curl -sL https://raw.githubusercontent.com/node-red/linux-installers/master/deb/update-nodejs-and-nodered) Para ejecutar Node-RED, una vez instalado, es posible utilizar la orden node-red-start desde cualquier terminal. Para detener el proceso, es suficiente con utilizar Ctrl-C : $ node-red Welcome to Node-RED =================== 30 Jun 23:43:39 - [info] Node-RED version: v1.1.0 30 Jun 23:43:39 - [info] Node.js version: v10.21.0 30 Jun 23:43:39 - [info] Darwin 18.7.0 x64 LE 30 Jun 23:43:39 - [info] Loading palette nodes 30 Jun 23:43:44 - [warn] rpi-gpio : Raspberry Pi specific node set inactive 30 Jun 23:43:44 - [info] Settings file : /Users/nol/.node-red/settings.js 30 Jun 23:43:44 - [info] HTTP Static : /Users/nol/node-red/web 30 Jun 23:43:44 - [info] Context store : 'default' [module=localfilesystem] 30 Jun 23:43:44 - [info] User directory : /Users/nol/.node-red 30 Jun 23:43:44 - [warn] Projects disabled : set editorTheme.projects.enabled=true to enable 30 Jun 23:43:44 - [info] Creating new flows file : flows_noltop.json 30 Jun 23:43:44 - [info] Starting flows 30 Jun 23:43:44 - [info] Started flows 30 Jun 23:43:44 - [info] Server now running at http://127.0.0.1:1880/red/ Con el software arrancado, es posible acceder al editor Node-RED a trav\u00e9s de la direcci\u00f3n http://localhost:1880 en cualquier navegador. Tras arrancarlo, observar\u00e1s cuatro \u00e1reas en el editor: Barra principal , en la parte superior, con los botones Deploy y de Men\u00fa principal . Panel de nodos , en la parte izquierda, que proporciona acceso directo a todos los nodos disponibles en Node-RED. Es posible instalar nuevos nodos a trav\u00e9s de la Paleta de Nodos, disponible a trav\u00e9s del men\u00fa principal ( Manage Palette ). Estos nodos pueden ser arrastrados al editor para conformar nuevos flujos de datos. Panel de edici\u00f3n o espacio de trabajo , en la parte central de la pantalla, donde podr\u00e1s arrastrar y unir nuevos nodos. Es posible crear nuevos flujos en pesta\u00f1as independientes. Panel de informaci\u00f3n , en la parte derecha de la pantalla, donde destaca el bot\u00f3n Debug , mediante el cual veremos la salida de los nodos de tipo Debug en nuestros flujos.","title":"Instalaci\u00f3n y puesta en marcha"},{"location":"RPI-II/P1_II/#ejemplo-1","text":"Se muestra a continuaci\u00f3n un breve ejemplo b\u00e1sico de utilizaci\u00f3n del editor Node-RED, que incluye el uso de nodos Inject , Debug y Function .","title":"Ejemplo 1"},{"location":"RPI-II/P1_II/#nodo-inject","text":"El nodo Inject permite inyectar mensajes en un flujo, bien pulsando en el bot\u00f3n asociado al nodo, o estableciendo un intervalo de tiempo entre inyecciones. Busca en el panel izquierdo un nodo de tipo Inject y arr\u00e1stralo al espacio de trabajo. En el panel de informaci\u00f3n podr\u00e1s consultar los datos asociados al nodo, as\u00ed como informaci\u00f3n de ayuda para utilizarlo.","title":"Nodo Inject"},{"location":"RPI-II/P1_II/#nodo-debug","text":"El nodo Debug permite que cualquier mensaje entrante se muestre en el panel de depuraci\u00f3n, en la parte derecha de la pantalla. Por defecto, \u00fanicamente muestra el payload del mensaje, aunque puede configurarse para mostrar el objeto completo. Arrastra un nodo de tipo Debug al espacio de trabajo.","title":"Nodo Debug"},{"location":"RPI-II/P1_II/#union-y-despliegue-deploy","text":"Conecta los nodos Inject y Debug estableciendo un enlace ( Wire ) entre ambos. Despliega el flujo usando el bot\u00f3n Deploy en la barra principal de Node-RED. Esto desplegar\u00e1 el fujo en el servidor. Selecciona la opci\u00f3n Debug en el panel de informaci\u00f3n, y presiona el bot\u00f3n del nodo Inject . Deber\u00edas ver n\u00fameros aparecer en el panel. Por defecto, el nodo Inject emite el n\u00famero de milisegundos desde el 1 de enero de 1970 como payload . Modifica (temporalmente) el nodo Debug para que muestre todo el mensaje en lugar del payload . Despliega de nuevo el flujo y observa las diferencias. Vuelve a configurar el nodo Debug tal y como estaba cuando lo insertaste.","title":"Uni\u00f3n y despliegue (Deploy)"},{"location":"RPI-II/P1_II/#nodo-function","text":"El nodo Function permite procesar el mensaje de entrada mediante una funci\u00f3n JavaScript. Borra el Wire existente y a\u00f1ade un nodo Function entre los nodos Inject y Debug . Haz doble clic en el nuevo nodo para abrir el di\u00e1logo de edici\u00f3n. Copia el siguiente c\u00f3digo en el campo Function : // Create a Date object from the payload var date = new Date(msg.payload); // Change the payload to be a formatted Date string msg.payload = date.toString(); // Return the message so it can be sent on return msg; Clica en Done y despliega el flujo. Observa que, ahora, los mensajes de depuraci\u00f3n muestran marcas de tiempo en formato visible. Ten en cuenta que un nodo siempre recibe un mensaje ( msg ) de entrada y devuelve un mensaje ( msg ) de salida. Ambos objetos contienen, por convenio, un campo payload . Para m\u00e1s informaci\u00f3n sobre el uso de funciones y trabajo con mensajes, incluyendo m\u00faltiples valores de retorno y trabajo con valores globales a todo el entorno, se recomienda estudiar la siguiente documentaci\u00f3n: Trabajo con mensajes : enlace a documentaci\u00f3n . Trabajo con funciones : enlace a documentaci\u00f3n .","title":"Nodo Function"},{"location":"RPI-II/P1_II/#ejemplo-2","text":"","title":"Ejemplo 2"},{"location":"RPI-II/P1_II/#nodo-inject_1","text":"En el anterior ejemplo, vimos c\u00f3mo crear un nodo Inject para activar el flujo cuando se pulsaba su bot\u00f3n asociado. En este ejemplo, vamos a configurar el nodo Inject para que active el flujo en intervalos regulares. Arrastra un nuevo nodo Inject en el espacio de trabajo. Clica en \u00e9l dos veces y, en el di\u00e1logo de edici\u00f3n, usala opci\u00f3n Repeat interval , fij\u00e1ndolo en un intervalo regular. Cierra el di\u00e1logo de edici\u00f3n.","title":"Nodo Inject"},{"location":"RPI-II/P1_II/#nodo-http-request","text":"El nodo de tipo HTTP Request puede utilizarse para descargar una p\u00e1gina web o recurso HTTP. A\u00f1ade uno al espacio de trabajo, y ed\u00edtalo para que su propiedad URL apunte a https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/significant_month.csv . Esta URL es un repositorio de terremotos en el \u00faltimo mes, pulicado por el organismo oficial correspondiente, devueltos en formato CSV.","title":"Nodo HTTP Request"},{"location":"RPI-II/P1_II/#nodo-csv","text":"A\u00f1ade un nuevo nodo CSV y edita sus propiedades. Activa la opci\u00f3n First row contains column names y finaliza la edici\u00f3n.","title":"Nodo CSV"},{"location":"RPI-II/P1_II/#nodo-debug-y-cableado","text":"A\u00f1ade un nodo Debug y une los nodos creados: Conecta la salida del nodo Inject a la entrada del nodo HTTP Request . Conecta la salida del nodo HTTP Request a la entrada del nodo CSV . Conecta la salida del nodo CSV a la entrada del nodo Debug .","title":"Nodo Debug y cableado"},{"location":"RPI-II/P1_II/#nodo-switch","text":"A\u00f1ade un nodo Switch al espacio de trabajo. Edita sus propiedades y configuralo para comprobar la propiedad msg.payload.mag , usando la operaci\u00f3n >= sobre un valor num\u00e9rico y el valor 6.2 , por ejemplo. A\u00f1ade un segundo Wire entre el nodo CSV y el nodo Switch .","title":"Nodo Switch"},{"location":"RPI-II/P1_II/#nodo-change","text":"A\u00f1ade un nodo Change , conectado a la salida del nodo Switch . Configuralo para establecer el valor de msg.payload a ALARMA .","title":"Nodo Change"},{"location":"RPI-II/P1_II/#nodo-debug_1","text":"A\u00f1ade un nodo Debug y despliega el flujo. En el panel de Debug , deber\u00e1s obsevar, para cada activaci\u00f3n del nodo Inject , una salida similar a esta: msg.payload : Object {\"time\":\"2017-11-19T15:09:03.120Z\",\"latitude\":-21.5167,\"longitude\":168.5426,\"depth\":14.19,\"mag\":6.6,\"magType\":\"mww\",\"gap\":21,\"dmin\":0.478,\"rms\":0.86,\"net\":\"us\",\"id\":\"us2000brgk\",\"updated\":\"2017-11-19T17:10:58.449Z\",\"place\":\"68km E of Tadine, New Caledonia\",\"type\":\"earthquake\",\"horizontalError\":6.2,\"depthError\":2.8,\"magError\":0.037,\"magNst\":72,\"status\":\"reviewed\",\"locationSource\":\"us\",\"magSource\":\"us\"} Puedes clicar en la peque\u00f1a flecha a la izquierda de cada propiedad para expandirla y examinar sus contenidos. Si existe cualquier terremoto de magnitud mayor a 6.2 , observar\u00e1s una salida adicional: msg.payload : string(6) \"ALARMA\" Para m\u00e1s informaci\u00f3n sobre los nodos b\u00e1sicos en Node-RED, puedes consultar: The Core Nodes : enlace a documentaci\u00f3n .","title":"Nodo Debug"},{"location":"RPI-II/P1_II/#documentacion-adicional","text":"Las gu\u00edas de usuario oficiales de Node-RED son un buen punto de partida para profundizar en el uso de la infraestructura. De entre ellas, la parte m\u00e1s importante para comenzar es la que introduce los conceptos b\u00e1sicos de Node-RED, incluyendo el trabajo con nodos, flujos, contexto (importante para trabajar con valores globales y compartidos por todos los nodos en un flujo, por ejemplo), mensajes, wires , etc.: Node-RED Concepts : enlace a documentaci\u00f3n . La gu\u00eda Node-RED Guide contiene interesante documentaci\u00f3n adicional/avanzada tanto en el despliegue de flujos como en el uso de paneles de control locales o usando servicios remotos (por ejemplo, Freeboard ): Node-RED Guide : enlace a documentaci\u00f3n . Tarea 1.3bis Se pide estudiar la documentaci\u00f3n asociada a Node-RED, tanto en su web oficial como en la gu\u00eda de programaci\u00f3n Node-RED Guide (espec\u00edficamente sus cuatro primeras partes). Junto con la explicaci\u00f3n proporcionada por el profesor y los anteriores ejemplos, este estudio permitir\u00e1 el desarrollo de la tarea. Se sugiere experimentar con los nodos TCP (in/out/request) y sus correspondientes versiones UDP. La tarea consiste en el dise\u00f1o y desarrollo de un sistema cliente/servidor similar al desarrollado en la tarea 1.3, pero que, en esta ocasi\u00f3n, despliegue sus componentes utilizando exclusivamente Node-RED. El objetivo final de la tarea es que sea posible interactuar entre un cliente/servidor desarrollado en C y un servidor/cliente desarrollado en Node-RED. Se aceptar\u00e1 simplificar el protocolo de aplicaci\u00f3n desarrollado en la tarea 1.3 si ello facilita el dearrollo de la tarea. Puede ser de ayuda el estudio del nodo buffer-parser . Se entregar\u00e1 el fichero o ficheros JSON que describen los nodos, as\u00ed como una breve memoria que describa el sistema dise\u00f1ado y el trabajo realizado, haciendo hincapi\u00e9 en las dificultades encontradas y aquellos aspectos que se consideren de inter\u00e9s por parte del alumno/a.","title":"Documentaci\u00f3n adicional"},{"location":"RPI-II/P1_III/","text":"Pr\u00e1ctica 1 (Parte 3). Programaci\u00f3n con sockets en el ESP32 Objetivos Familiarizarse con la API de sockets en ESP-IDF. Desarrollar esquemas b\u00e1sicos de sistemas cliente/servidor TCP y UDP utilizando ESP-IDF. Dise\u00f1ar un protocolo de capa de aplicaci\u00f3n para simular una aplicaci\u00f3n cliente/servidor utilizando TCP y UDP para interactuar entre un host y la placa ESP32 Sistemas cliente/servidor en el ESP32 La raz\u00f3n por la que hemos ejercitado el uso de la API de sockets desde C en Linux es que la implementaci\u00f3n de la pila TCP/IP en ESP-IDF (llamada Lightweight TCP/IP (lwIP) ) implementa al 100% dicha API. Por tanto, tanto la estructura b\u00e1sica de un firmware que implemente un cliente o servidor como la API utilizada permanece inalterada. En esta \u00faltima secci\u00f3n, se pide trabajar con dos ejemplos b\u00e1sicos de implementaci\u00f3n de sistemas cliente/servidor UDP y TCP sobre el ESP32, con el objetivo de estudiar su funcionalidad, comprobar su interoperabilidad y realizar modificaciones para adaptarlas a una hipot\u00e9tica aplicaci\u00f3n IoT. Cliente/servidor UDP en el ESP32 En esta parte, trabajar\u00e1s con dos ejemplos proporcionados dentro de la colecci\u00f3n de ejemplos de ESP-IDF. Por tanto, copia en tu espacio de trabajo (fuera del \u00e1rbol principal de ESP-IDF) los ejemplos: Servidor UDP : examples/protocols/sockets/udp_server/ Cliente UDP : examples/protocols/sockets/udp_client/ Estructura general Observa sus c\u00f3digos ( udp_server.c para el servidor, y udp_client.c para el cliente). Comprueba que, tanto la estructura b\u00e1sica de ambos componentes como las invocaciones a la API de sockets concuerdan con las que vimos para el sistema echo programado en C. Acerca de la tarea principal (funci\u00f3n app_main ) observa que realiza una serie de llamadas a APIs de configuraci\u00f3n de algunos subsistemas de FreeRTOS, principalmente: // Inicializa la partici\u00f3n NVS (Non-volatile storage) por defecto. ESP_ERROR_CHECK(nvs_flash_init()); // Inicializa la infraestructura ESP-NETIF. ESP_ERROR_CHECK(esp_netif_init()); // Crea un bucle de eventos por defecto. ESP_ERROR_CHECK(esp_event_loop_create_default()); /* Esta funci\u00f3n configura WiFi o Ethernet, tal y como seleccionemos via menuconfig. */ ESP_ERROR_CHECK(example_connect()); xTaskCreate(udp_server_task, \"udp_server\", 4096, NULL, 5, NULL); example_connect() , funci\u00f3n que no forma parte de ESP-IDF, establece una conexi\u00f3n WiFi o Ethernet. La funci\u00f3n es bloqueante, y retorna cuando se ha conseguido establecer una conexi\u00f3n. Las caracter\u00edsticas de la conexi\u00f3n WiFi (SSID y contrase\u00f1a) se deben proporcionar a trav\u00e9s de menuconfig . El objetivo de ESP-NETIF es proporcionar una capa de abstracci\u00f3n por encima de la pila TCP/IP, de modo que pueda migrarse la pila sin que los c\u00f3digos del usuario cambien. Puedes consultar su documentaci\u00f3n en la p\u00e1gina oficial . Por \u00faltimo, se crea una tarea que ejecutar\u00e1 la l\u00f3gica del servidor (lo mismo ocurre en el cliente). Observa que, en todo el c\u00f3digo, los mensajes de error se anotan utilizando la macro ESP_LOGE y los informativos con ESP_LOGI ; intenta seguir este convenio en tus c\u00f3digos. Despliegue. Opci\u00f3n 1 En este caso, desplegar\u00e1s el cliente en un ESP32 y el servidor en otro. Si no dispones de dos ESP32, puedes trabajar con un compa\u00f1ero. En cualquier caso, ambos ESP32 deben pertenecer a la misma red inal\u00e1mbrica, por lo que deber\u00e1n conectarse a un mismo punto de acceso (el profesor te proporcionar\u00e1 los datos, o simplemente puedes utilizar tu punto de acceso dom\u00e9stico). Configura los siguientes puntos de la infraestructura: Configura el SSID y contrase\u00f1a del punto de acceso v\u00eda menuconfig antes de compilar y flashear el c\u00f3digo tanto en el cliente como en el servidor. En el servidor, configura v\u00eda menuconfig el puerto sobre el que escuchar\u00e1. Arranca primero el nodo servidor y apunta la IP proporcionada por el punto de acceso; util\u00edzala en el cliente para configurar la IP destino de la comunicaci\u00f3n. No olvides configurar tambi\u00e9n el puerto destino de acuerdo al configurado en el servidor v\u00eda menuconfig . \u00can este punto, podr\u00e1s arrancar el cliente y deber\u00edas estar comunicando dos nodos ESP32 v\u00eda UDP. Despliegue. Opci\u00f3n 2 Si s\u00f3lo dispones de un nodo, o si simplemente quieres probar otra forma de comunicaci\u00f3n en la que uno de los equipos es un PC, puedes utilizar alguna de las herramientas del sistema: Nota Ten en cuenta que port\u00e1til (es decir, m\u00e1quina virtual) y ESP32 deben pertenecer\u00e1 la misma red. Para conseguirlo, para tu m\u00e1quina virtual y a\u00f1ade una nueva interfaz de red de tipo bridge conectada a la interfaz Wifi f\u00edsica de tu PC. As\u00ed, tendr\u00e1s una interfaz con IP en la misma red, otorgada directamente por tu punto de acceso. Para recibir un paquete UDP a trav\u00e9s de un puerto (es decir, emular un servidor UDP): nc -ul -p 3333 Para enviar un paquete UDP a una IP/puerto remotos (es decir, emular un cliente): nc -u IP_REMOTA 3333 En el directorio scripts dispones tambi\u00e9n de peque\u00f1os ejemplos de clientes y servidores UDP Python que puedes tambi\u00e9n utilizar. Cliente/servidor TCP en el ESP32 El despliegue de cliente y servidor TCP es equivalente al UDP. Para recibir un paquete TCP a trav\u00e9s de un puerto (es decir, emular un servidor TCP): nc -l IP -p 3333 Para enviar un paquete TCP a una IP/puerto remotos (es decir, emular un cliente): nc IP 3333 En el directorio scripts dispones tambi\u00e9n de peque\u00f1os ejemplos de clientes y servidores TCP Python que puedes tambi\u00e9n utilizar. Tarea 1.4 Experimenta con los ejemplos proporcionados en ESP-IDF (cliente/servidor TCP y UDP) y consigue ejecutar todos los elementos en la placa. Si s\u00f3lo dispones de una placa, utiliza tu m\u00e1quina (o una m\u00e1quina virtual) como cliente/servidor para comprobar el correcto funcionamiento de cada c\u00f3digo. Tarea 1.5 (entregable) En este punto, deber\u00edas disponer de un conjunto de c\u00f3digos que implementan sistemas cliente/servidor tanto en un host (utilizando C, y en Node-RED, as\u00ed como en Python si has seguido el anexo opcional a la pr\u00e1ctica) como en la placa ESP32 (utilizando C y ESP-IDF), y deber\u00edas haber comprobado su correcto funcionamiento. Espec\u00edficamente, dispondr\u00e1s de: C\u00f3digo b\u00e1sico en C para implementaci\u00f3n de un servidor/cliente echo programado en C, cuyos c\u00f3digos se proporcionan en este bolet\u00edn. C\u00f3digos b\u00e1sicos en C/ESP-IDF para implementar servidores/clientes echo sobre el ESP32. Como tarea, se pide que adaptes tu entrega de la tarea 1.3 para que tanto cliente como servidor puedan funcionar en el host (bien usando tu implementaci\u00f3n Node-RED (o Python), o bien utilizando una implementaci\u00f3n en C) o en el ESP32. Se entregar\u00e1n los c\u00f3digos y una breve memoria con capturas de tr\u00e1fico que demuestren el correcto funcionamiento del sistema.","title":"Pr\u00e1ctica 1 (II)"},{"location":"RPI-II/P1_III/#practica-1-parte-3-programacion-con-sockets-en-el-esp32","text":"","title":"Pr\u00e1ctica 1 (Parte 3). Programaci\u00f3n con sockets en el ESP32"},{"location":"RPI-II/P1_III/#objetivos","text":"Familiarizarse con la API de sockets en ESP-IDF. Desarrollar esquemas b\u00e1sicos de sistemas cliente/servidor TCP y UDP utilizando ESP-IDF. Dise\u00f1ar un protocolo de capa de aplicaci\u00f3n para simular una aplicaci\u00f3n cliente/servidor utilizando TCP y UDP para interactuar entre un host y la placa ESP32","title":"Objetivos"},{"location":"RPI-II/P1_III/#sistemas-clienteservidor-en-el-esp32","text":"La raz\u00f3n por la que hemos ejercitado el uso de la API de sockets desde C en Linux es que la implementaci\u00f3n de la pila TCP/IP en ESP-IDF (llamada Lightweight TCP/IP (lwIP) ) implementa al 100% dicha API. Por tanto, tanto la estructura b\u00e1sica de un firmware que implemente un cliente o servidor como la API utilizada permanece inalterada. En esta \u00faltima secci\u00f3n, se pide trabajar con dos ejemplos b\u00e1sicos de implementaci\u00f3n de sistemas cliente/servidor UDP y TCP sobre el ESP32, con el objetivo de estudiar su funcionalidad, comprobar su interoperabilidad y realizar modificaciones para adaptarlas a una hipot\u00e9tica aplicaci\u00f3n IoT.","title":"Sistemas cliente/servidor en el ESP32"},{"location":"RPI-II/P1_III/#clienteservidor-udp-en-el-esp32","text":"En esta parte, trabajar\u00e1s con dos ejemplos proporcionados dentro de la colecci\u00f3n de ejemplos de ESP-IDF. Por tanto, copia en tu espacio de trabajo (fuera del \u00e1rbol principal de ESP-IDF) los ejemplos: Servidor UDP : examples/protocols/sockets/udp_server/ Cliente UDP : examples/protocols/sockets/udp_client/","title":"Cliente/servidor UDP en el ESP32"},{"location":"RPI-II/P1_III/#estructura-general","text":"Observa sus c\u00f3digos ( udp_server.c para el servidor, y udp_client.c para el cliente). Comprueba que, tanto la estructura b\u00e1sica de ambos componentes como las invocaciones a la API de sockets concuerdan con las que vimos para el sistema echo programado en C. Acerca de la tarea principal (funci\u00f3n app_main ) observa que realiza una serie de llamadas a APIs de configuraci\u00f3n de algunos subsistemas de FreeRTOS, principalmente: // Inicializa la partici\u00f3n NVS (Non-volatile storage) por defecto. ESP_ERROR_CHECK(nvs_flash_init()); // Inicializa la infraestructura ESP-NETIF. ESP_ERROR_CHECK(esp_netif_init()); // Crea un bucle de eventos por defecto. ESP_ERROR_CHECK(esp_event_loop_create_default()); /* Esta funci\u00f3n configura WiFi o Ethernet, tal y como seleccionemos via menuconfig. */ ESP_ERROR_CHECK(example_connect()); xTaskCreate(udp_server_task, \"udp_server\", 4096, NULL, 5, NULL); example_connect() , funci\u00f3n que no forma parte de ESP-IDF, establece una conexi\u00f3n WiFi o Ethernet. La funci\u00f3n es bloqueante, y retorna cuando se ha conseguido establecer una conexi\u00f3n. Las caracter\u00edsticas de la conexi\u00f3n WiFi (SSID y contrase\u00f1a) se deben proporcionar a trav\u00e9s de menuconfig . El objetivo de ESP-NETIF es proporcionar una capa de abstracci\u00f3n por encima de la pila TCP/IP, de modo que pueda migrarse la pila sin que los c\u00f3digos del usuario cambien. Puedes consultar su documentaci\u00f3n en la p\u00e1gina oficial . Por \u00faltimo, se crea una tarea que ejecutar\u00e1 la l\u00f3gica del servidor (lo mismo ocurre en el cliente). Observa que, en todo el c\u00f3digo, los mensajes de error se anotan utilizando la macro ESP_LOGE y los informativos con ESP_LOGI ; intenta seguir este convenio en tus c\u00f3digos.","title":"Estructura general"},{"location":"RPI-II/P1_III/#despliegue-opcion-1","text":"En este caso, desplegar\u00e1s el cliente en un ESP32 y el servidor en otro. Si no dispones de dos ESP32, puedes trabajar con un compa\u00f1ero. En cualquier caso, ambos ESP32 deben pertenecer a la misma red inal\u00e1mbrica, por lo que deber\u00e1n conectarse a un mismo punto de acceso (el profesor te proporcionar\u00e1 los datos, o simplemente puedes utilizar tu punto de acceso dom\u00e9stico). Configura los siguientes puntos de la infraestructura: Configura el SSID y contrase\u00f1a del punto de acceso v\u00eda menuconfig antes de compilar y flashear el c\u00f3digo tanto en el cliente como en el servidor. En el servidor, configura v\u00eda menuconfig el puerto sobre el que escuchar\u00e1. Arranca primero el nodo servidor y apunta la IP proporcionada por el punto de acceso; util\u00edzala en el cliente para configurar la IP destino de la comunicaci\u00f3n. No olvides configurar tambi\u00e9n el puerto destino de acuerdo al configurado en el servidor v\u00eda menuconfig . \u00can este punto, podr\u00e1s arrancar el cliente y deber\u00edas estar comunicando dos nodos ESP32 v\u00eda UDP.","title":"Despliegue. Opci\u00f3n 1"},{"location":"RPI-II/P1_III/#despliegue-opcion-2","text":"Si s\u00f3lo dispones de un nodo, o si simplemente quieres probar otra forma de comunicaci\u00f3n en la que uno de los equipos es un PC, puedes utilizar alguna de las herramientas del sistema: Nota Ten en cuenta que port\u00e1til (es decir, m\u00e1quina virtual) y ESP32 deben pertenecer\u00e1 la misma red. Para conseguirlo, para tu m\u00e1quina virtual y a\u00f1ade una nueva interfaz de red de tipo bridge conectada a la interfaz Wifi f\u00edsica de tu PC. As\u00ed, tendr\u00e1s una interfaz con IP en la misma red, otorgada directamente por tu punto de acceso. Para recibir un paquete UDP a trav\u00e9s de un puerto (es decir, emular un servidor UDP): nc -ul -p 3333 Para enviar un paquete UDP a una IP/puerto remotos (es decir, emular un cliente): nc -u IP_REMOTA 3333 En el directorio scripts dispones tambi\u00e9n de peque\u00f1os ejemplos de clientes y servidores UDP Python que puedes tambi\u00e9n utilizar.","title":"Despliegue. Opci\u00f3n 2"},{"location":"RPI-II/P1_III/#clienteservidor-tcp-en-el-esp32","text":"El despliegue de cliente y servidor TCP es equivalente al UDP. Para recibir un paquete TCP a trav\u00e9s de un puerto (es decir, emular un servidor TCP): nc -l IP -p 3333 Para enviar un paquete TCP a una IP/puerto remotos (es decir, emular un cliente): nc IP 3333 En el directorio scripts dispones tambi\u00e9n de peque\u00f1os ejemplos de clientes y servidores TCP Python que puedes tambi\u00e9n utilizar. Tarea 1.4 Experimenta con los ejemplos proporcionados en ESP-IDF (cliente/servidor TCP y UDP) y consigue ejecutar todos los elementos en la placa. Si s\u00f3lo dispones de una placa, utiliza tu m\u00e1quina (o una m\u00e1quina virtual) como cliente/servidor para comprobar el correcto funcionamiento de cada c\u00f3digo. Tarea 1.5 (entregable) En este punto, deber\u00edas disponer de un conjunto de c\u00f3digos que implementan sistemas cliente/servidor tanto en un host (utilizando C, y en Node-RED, as\u00ed como en Python si has seguido el anexo opcional a la pr\u00e1ctica) como en la placa ESP32 (utilizando C y ESP-IDF), y deber\u00edas haber comprobado su correcto funcionamiento. Espec\u00edficamente, dispondr\u00e1s de: C\u00f3digo b\u00e1sico en C para implementaci\u00f3n de un servidor/cliente echo programado en C, cuyos c\u00f3digos se proporcionan en este bolet\u00edn. C\u00f3digos b\u00e1sicos en C/ESP-IDF para implementar servidores/clientes echo sobre el ESP32. Como tarea, se pide que adaptes tu entrega de la tarea 1.3 para que tanto cliente como servidor puedan funcionar en el host (bien usando tu implementaci\u00f3n Node-RED (o Python), o bien utilizando una implementaci\u00f3n en C) o en el ESP32. Se entregar\u00e1n los c\u00f3digos y una breve memoria con capturas de tr\u00e1fico que demuestren el correcto funcionamiento del sistema.","title":"Cliente/servidor TCP en el ESP32"},{"location":"RPI-II/P1_IV/","text":"Pr\u00e1ctica 1 (Ap\u00e9ndice). Programaci\u00f3n con sockets en Python Objetivos Familiarizarse con la API de sockets en Python. Desarrollar esquemas b\u00e1sicos de sistemas cliente/servidor TCP y UDP utilizando Python. Ser capaces de analizar el tr\u00e1fico generado en una conexi\u00f3n TCP y UDP a trav\u00e9s de Wireshark. Dise\u00f1ar un protocolo de capa de aplicaci\u00f3n para simular una aplicaci\u00f3n cliente/servidor utilizando TCP y UDP. Observar la diferencia en tr\u00e1fico generado para una misma aplicaci\u00f3n utilizando TCP y UDP. Implementar servidores multi-hilo en Python. Nota Ofrecemos esta pr\u00e1ctica como anexo y referencia para complementar los contenidos ofrecidos en la Pr\u00e1ctica 1. Su comprensi\u00f3n y desarrollo es opcional, aunque puede ser de utilidad para alumnos con poca experiencia en el lenguaje C o en programaci\u00f3n con sockets, o para prototipar r\u00e1pidamente sistemas cliente/servidor utilizando Python. La API de sockets en Python El m\u00f3dulo socket de Python proporciona una interfaz completa para trabajar con la API de sockets de Berkeley . En la presente pr\u00e1ctica, trabajaremos exclusivamente con esta API para desarrollar aplicaciones cliente/servidor utilizando los protocolos TCP y UDP. Las funciones y m\u00e9todos principales de la API de sockets son: socket() - bind() - listen() - accept() - connect() - connect_ex() - send() - recv() - close() - Python prorpociona una API consistente y completa mapeada directamente a las anteriores llamadas al sistema, t\u00edpicamente escritas en lenguaje C. Como parte de su biblioteca est\u00e1ndar, Python tambi\u00e9n proporciona clases que facilitan el trabajo con las funciones de bajo nivel. Aunque no lo cubriremos, el m\u00f3dulo socketserver proporciona una forma sencilla de crear servidores de red. Existen tambi\u00e9n numerosos m\u00f3dulos disponibles para implementar protocolos de alto nivel (por ejemplo HTTP o SMTP), v\u00e9ase . Sockets TCP En Python, los sockets TCP se crean en Python utilizando socket.socket() , especificando el tipo de socket como socket.SOCK_STREAM . El protocolo de control de transmisi\u00f3n (TCP) se caracteriza por dos rasgos principales: Es confiable : se implementan mecanismos de detecci\u00f3n de p\u00e9rdidas en la red y reenv\u00edo de paquetes perdidos. Garantiza una entrega de paquetes en orden : los datos se entregan a las capas superiores (aplicaciones) en el mismo orden en el que fueron enviados. En contra, los sockets UDP se crean a trav\u00e9s de socket.SOCK_DGRAM , y no son confiables ni garantizan la entrega de paquetes en orden. Por tanto, es el desarrollador de aplicaciones quien, en caso de as\u00ed desearlo en el dise\u00f1o de la aplicaci\u00f3n, debe implementar estos mecanismos de forma espec\u00edfica. En el siguiente diagrama se muestra la secuencia t\u00edpica de invocaciones a la API de sockets para TCP: En la figura, la columna de la izquierda representa al servidor, mientras que la columna de la derecha representa al cliente en la conexi\u00f3n TCP. Observa las invocaciones necesarias para configurar un socket a la escucha de conexiones entrantes: socket() bind() listen() accept() En este extremo, un socket escucha ( listen ) potenciales conexiones entrantes desde clientes. Cuando un cliente solicita conectar, el servidor acepta ( accept ) la conexi\u00f3n, complet\u00e1ndola. El cliente invoca a connect() para establecer una conexi\u00f3n con el servidor e inicia el proceso de conexi\u00f3n a tres v\u00edas ( three-way connection ). Una vez establecida la conexi\u00f3n, los datos se intercambian entre cliente y servidor a trav\u00e9s de invocaciones a send() y recv() . Finalmente, el socket se destruye (esto es, la conexi\u00f3n entre ambos extremos se cierra) a trav\u00e9s de una invocaci\u00f3n a close() en cada extremo. Cliente/servidor echo TCP Veamos un ejemplo sencillo para crear un par cliente-servidor. En este caso, el servidor simplemente responder\u00e1 con la misma cadena que reciba desde el cliente. Servidor echo #!/usr/bin/env python3 #### servidor_echo.py import socket HOST = '127.0.0.1' # Interfaz est\u00e1ndar de loopback (localhost) PORT = 65432 # Puerto de escucha (los puertos mayores a 1023 son no privilegiados) with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: s.bind((HOST, PORT)) s.listen() conn, addr = s.accept() with conn: print('Conectado ', addr) while True: data = conn.recv(1024) if not data: break conn.sendall(data) Nota De momento, no importa si no entiendes todas las l\u00edneas en el anterior c\u00f3digo. Simplemente se trata de un punto de partida para desarrollar un servidor sencillo. Sin embargo, es conveniente que copies el c\u00f3digo en un fichero de texto (por ejemplo, llamado servidor_echo.py ) para que podeamos probarlo. Veamos l\u00ednea a l\u00ednea las partes m\u00e1s importantes del anterior c\u00f3digo. socket.socket() crea un objeto socket . Observa que, al crearse a trav\u00e9s de una construcci\u00f3n with , no es necesario invocar expl\u00edcitamente a s.close() , aunque debes tener en cuenta que el objeto es destruido al finalizar la construcci\u00f3n: with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: pass # Es posible usar el socket win invocar a s.close(). Los argumentos que se proporcionan a socket() especifican la familia de direcciones ( AF_INET ) y tipo de socket ( SOCK_STREAM ). AF_INET es la familia de direcciones de Internet para IPv4. SOCK_STREAM es el tipo de socket que permite la creaci\u00f3n de conexiones TCP. bind() se utiliza para asociar el socket a una interfaz de red y n\u00famero de puerto espec\u00edficos: HOST = '127.0.0.1' # Interfaz est\u00e1ndar de loopback (localhost) PORT = 65432 # Puerto de escucha (los puertos mayores a 1023 son no privilegiados) # ... s.bind((HOST, PORT)) Los valores proporcionados a bind() dependen de la familia de direcciones seleccionada para el socket . En este ejemplo, al utilizar AF_INET , espera una tupla con \u00fanicamente dos valores (host, puerto) . Para determinar el host , es posible utilizar un nombre de host , una direcci\u00f3n IP o una cadena vac\u00eda. Si utilizamos una direcci\u00f3n IP, \u00e9sta debe ser especificarse mediante una cadena que contenga una direcci\u00f3n IPv4 bien formada. La direcci\u00f3n 127.0.0.1 es la direcci\u00f3n IPv4 est\u00e1ndar para la interfaz de loopback , por lo que \u00fanicamente procesos que est\u00e9n ejecut\u00e1ndose en el propio host podr\u00e1n comunicar con el servidor. Si proporcionamos una cadena vac\u00eda, el servidro aceptar\u00e1 conexiones entrantes a trav\u00e9s de todas las interfaces IPv4 disponibles en el sistema. El n\u00famero de puerto ( port ) se especifica con un valor entero entre 1 y 65535, y espcifica el puerto (en este caso, TCP) a trav\u00e9s del cual el servidor aceptar\u00e1 conexiones desde los clientes. La mayor\u00eda de sistemas requieren permisos de superusuario para escuchar a trav\u00e9s de los puertos ( well-known ), es decir, con valor inferior a 1024. Continuando con el ejemplo, listen() posibilita que un servidor pueda, en el futuro, aceptar ( accept() ) conexiones entrantes. En otras palabras, pone a la escucha al socket : s.listen() conn, addr = s.accept() La invocaci\u00f3n a accept() bloquea el proceso y espera a una conexi\u00f3n entrante. Cuando un cliente conecta, devuelve un objeto socket que representa la conexi\u00f3n, as\u00ed como una tupla ( addr ) que contiene la direcci\u00f3n del cliente. Concretamente, esta tupla contiene los valores (host, port) que almacenan la direcci\u00f3n IPv4 y puerto del cliente que solicita la conexi\u00f3n. Observa que, en el ejemplo, conn es el objeto socket que usaremos para comunicar con el cliente: conn, addr = s.accept() with conn: print('Conectado ', addr) while True: data = conn.recv(1024) if not data: break conn.sendall(data) Tras obtener el objeto devuelto por accept() , dise\u00f1amos el servidor como un bucle infinito que invoca repetidamente a llamadas bloqueantes a conn.recv() . As\u00ed, leemos los datos enviados por el cliente y los reenviamos sin modificaci\u00f3n utilizando conn.sendall() . Si conn.recv() devuelve un objeto de tipo bytes vac\u00edo ( b'' ) significa que el cliente cerr\u00f3 la conexi\u00f3n, en cuyo caso el bucle termina, destruy\u00e9ndose el socket al salir de la sentencia with . Cliente echo Veamos a continuaci\u00f3n la estructura general del cliente (puedes usar, por ejemplo, cliente_echo.py como nombre para el fichero): #!/usr/bin/env python3 ### cliente_echo.py import socket HOST = '127.0.0.1' # IP del servidor PORT = 65432 # Puerto de escucha del servidor with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: s.connect((HOST, PORT)) s.sendall(b'Hola, mundo') data = s.recv(1024) print('Recibido ', repr(data)) En comparaci\u00f3n con el servidor, la estructura del cliente es m\u00e1s simple; simplemente crea un nuevo objeto socket , conecta con el servidor e invoca a s.sendall() para enviar el mensaje. Finalmente, espera la recepci\u00f3n de la respuesta utilizando s.recv() y la imprime por pantalla. Ejecuci\u00f3n del cliente y servidor echo A continuaci\u00f3n, ejecutaremos cliente y servidor para observar el estado de las conexiones durante su ciclo de vida. Ejecuta en una terminal el servidor: $ python3 ./servidor_echo.py Como ves, la terminal se bloquea (de hecho, el servidor permanece en estado bloqueado) en la invocaci\u00f3n: conn, addr = s.accept() Realmente, el servidor est\u00e1 esperando a que haya conexiones entrantes por parte de un cliente. Abre otra terminal y ejecuta el cliente: $ python3 cliente_echo.py Recibido 'Hola, mundo' En la ventana del servidor, deber\u00edas ver algo similar a: $ python3 ./servidor_echo.py Conectado ('127.0.0.1, 61234') En esta salida, el servidor ha mostrado por pantalla la tupla devuelta por s.accept() , que incluye la direcci\u00f3n IP y el n\u00famero de puerto TCP. Dicho n\u00famero de puerto (en el ejemplo anterior, 61234) es seleccionado aleatoriamente por el sistema operativo y puede variar en tu ejecuci\u00f3n. Herramientas para observar el estado del socket Podemos utilizar la herramienta netstat para observar el estado actual de los sockets en cualquier sistema operativo (macOS, Linux e incluso Windows). Por ejemplo, esta ser\u00eda la salida de netstat en Linux tras ejecutar el servidor: netstat -an | grep 65432 Conexiones activas de Internet (servidores y establecidos) Proto Recib Enviad Direcci\u00f3n local Direcci\u00f3n remota Estado tcp 0 0 127.0.0.1:65432 0.0.0.0:* ESCUCHAR Observa que hemos filtrado la salida de la orden netcat seg\u00fan el n\u00famero de puerto utilizado. Observa el valor de las columnas Proto, Direcci\u00f3n local y Estado . Nota Otra forma de observar el estado de las conexiones es a trav\u00e9s de la orden lsof -i -n . Ejec\u00fatala y observa su salida. Capturas de tr\u00e1fico v\u00eda Wireshark Wireshark es una herramienta de c\u00f3digo abierto ampliamente utilizada para analizar protocolos de comunicaci\u00f3n de red en cualquiera de las capas de la pila TCP/IP (como tambi\u00e9n en otros protocolos). Wireshark implementa un amplio abanico de filtros para definir criterios de b\u00fasqueda en las capturas de tr\u00e1fico, aunque de momento, en nuestro caso, no ser\u00e1 necesario utilizar filtros espec\u00edficos. Para arrancar Wireshark en la m\u00e1quina virtual proporcionada (o en cualquier instalaci\u00f3n b\u00e1sica Linux), teclea en tu terminal: $ sudo wireshark Tras el arranque, podemos comenzar una nueva captura de tr\u00e1fico a trav\u00e9s del men\u00fa Capture , opci\u00f3n Start . La pantalla de selecci\u00f3n de interfaz nos permitir\u00e1 definir en qu\u00e9 interfaz de red se realizar\u00e1 la captura. En nuestro caso, ya que vamos a comunicar dos procesos en la misma m\u00e1quina, elegiremos la interfaz de Loopback (lo) y comenzaremos la captura. Tarea Arranca Wireshark y prepara una captura sobre la interfaz de loopback . Ejecuta el servidor echo TCP y el cliente correspondiente, y analiza el tr\u00e1fico generado. Especialmente, f\u00edjate en el proceso de establecimiento de conexi\u00f3n en tres v\u00edas, paquetes de Acknowledge tras el env\u00edo de cada mensaje y, en general, en cualquier otro aspecto que consideres de inter\u00e9s. Sockets UDP La creaci\u00f3n y gesti\u00f3n de sockets UDP en Python resulta todav\u00eda m\u00e1s sencilla. Observa el siguiente c\u00f3digo, que crea un servidor UDP utilizando la API de sockets Python: import socket udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) udp_socket.bind((\"localhost\", 5005)) data = udp_socket.recv(512) print(data) Primero, importamos la biblioteca socket de recepci\u00f3n, igual que en el caso de TCP. Obviamente, en este caso el tipo de socket pasa a ser socket.DOCK_DGRAM , para indicar que deseamos utilizar UDP en la comunicaci\u00f3n. El programa espera a la recepci\u00f3n de un paquete utilizando el m\u00e9todo bloqueante recv , cuyo \u00fanico par\u00e1metro indica el n\u00famero m\u00e1ximo de bytes que deseamos recibir. Cuando un paquete llega al socket, el metodo recv devolver\u00e1 un array de bytes, que ser\u00e1 almacenado en la variable que deseemos. El env\u00edo de datos a trav\u00e9s de un socket UDP es tambi\u00e9n sencillo: import socket udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) udp_socket.bind((\"localhost\", 0)) data = b\"Hola, mundo!\" udp_socket.sendto(data,(\"localhost\", 5005)) Observa que, en este caso, asociamos ( bind ) el socket a un puerto especificado como 0. Este valor especial indica al sistema operativo que elija para la transimisi\u00f3n un puerto origen aleatorio de entre los disponibles en el sistema. A continuaci\u00f3n, creamos los datos a enviar y los enviamos utilizando el m\u00e9todo sendto() . Este m\u00e9todo tomados argumentos: datos a enviar, y precisamente la direcci\u00f3n de env\u00edo. Los datos enviados a trav\u00e9s del socket deben formar parte de un array de bytes (por ello, la cadena a enviar viene precedida por el car\u00e1cter b ). Tarea Comprueba que, efectivamente, los c\u00f3digos de env\u00edo y recepci\u00f3n a trav\u00e9s de UDP funcionan como se espera. Nota Desde la versi\u00f3n 3 de Python, las cadenas se codifican utilizando Unicode. Al contrario que ASCII, conde cada caracter tiene una representaci\u00f3n en byte directa, Unicode utiliza enteros par representar cada caracter, que deben ser codificados para obtener una representaci\u00f3n en forma de byte. Uno de esos esquemas de codificaci\u00f3n es UTF-8. Por ejemplo, el siguiente c\u00f3digo muestra c\u00f3mo codificar una cadena Unicode en una representaci\u00f3n de bytes: cadena= \"Hola\" data = cadena.encode(\"UTF-8\") print(data, type(data)) lo cual genera b\"Hola\" <class 'bytes'> que puede ya ser enviado directamente por red. Hasta este punto, los programas UDP han sido totalmente unidireccionales en el env\u00edo/recepci\u00f3n de datos, pero obviamente, un socket UDP es un canal de comunicaci\u00f3n bidireccional. Tarea Implementa una funcionalidad similar al servidor echo que vimos para TCP, pero utilizando en este caso UDP. Realiza una captura de tr\u00e1fico en Wireshark similar a la realizada en el caso de TCP, y observa las principales diferencias entre ellas a nivel de tr\u00e1fico generado. Env\u00edo de datos binarios a trav\u00e9s de sockets Hasta este punto, hemos visto \u00fanicamente c\u00f3mo enviar cadenas de texto a trav\u00e9s de sockets TCP o UDP, pero es muy probable que sea necesario (o conveniente), en ocasiones, enviar datos directamente en formato binario (por ejemplo, valores num\u00e9ricos en punto flotante o enteros). Utilizando el m\u00f3dulo struct de Python podemos especificar qu\u00e9 tipo o tipos de datos se almacenan en una secuencia de bytes y c\u00f3mo decodificarlos. Tambi\u00e9n es posible especificar en qu\u00e9 lugar de la secuencia se alojan dichos datos, permitiendo el empaquetado de m\u00faltiples datos de distintos tipos de forma sencilla, y su posterior decodificaci\u00f3n en el otro extremo de la comunicaci\u00f3n. Nota Para todos los detalles del m\u00f3dulo struct , consulta la p\u00e1gina oficial de documentaci\u00f3n . El m\u00f3dulo struct proporciona dos m\u00e9todos de inter\u00e9s: pack y unpack . La siguiente sentencia: struct.pack(\">iii\", 1, 2, 3) utiliza el m\u00e9todo pack para realizar un empaquetado de datos. Concretamente, observa como el m\u00e9todo recibe dos par\u00e1metros: En primer lugar, el par\u00e1metro de formato \">iii\" . Define como debe codificarse cada valor en la secuencia de bytes. El primer car\u00e1cter indica el endianness utilizado, en este caso big endian (utilizar\u00edamos \">\" para big endian , \"<\" para little endian y \"=\" para network (big) endian). En segundo lugar, los valores a empaquetar. Observa que el formato, adem\u00e1s, incluye el n\u00famero y tipo de los datos a empaquetar (en este caso, tres valores detipo entero). Para otros tipos de datos, consulta la documentaci\u00f3n del m\u00f3dulo. Desempaquetar los datos enviados en el extremo opuesto es intuitivo: a, b, c = struct.unpack( \">iii\" ) A continuaci\u00f3n, mostramos un ejemplo de sistema cliente/servidor TCP que hace uso del m\u00f3dulo struct para realizar el env\u00edo de dos datos enteros y uno flotante entre un cliente y un servidor. # Cliente import binascii import socket import struct import sys # Socket TCP sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_address = ('localhost', 10001) sock.connect(server_address) packed_data = struct.pack(\"=iif\", 1, 4, 2.7) try: # Envio de datos print('Enviando \"%s\"' % binascii.hexlify(packed_data)) sock.sendall(packed_data) finally: print('Cerrando socket') sock.close() # Servidor import binascii import socket import struct import sys # Socket TCP sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_address = ('localhost', 10001) sock.bind(server_address) sock.listen(1) while True: print('Esperando conexiones entrantes') connection, client_address = sock.accept() try: data = connection.recv(1024) print('Recibido \"%s\"' % binascii.hexlify(data)) unpacked_data = struct.unpack(\"=iif\", data) print('Desempaquetado:', unpacked_data) finally: connection.close() Tarea Ejecuta el anterior sistema cliente servidor y analiza el tr\u00e1fico generado, en busca de los datos binarios empaquetados. Experimenta con otros tipos de datos y endianess y observa las diferencias. Tarea Tarea Se pide dise\u00f1ar un sistema cliente/servidor programado en Python, que simule el env\u00edo de un conjunto de datos sensorizados desde un cliente hacia un servidor. El protocolo a utilizar (formato de datos enviado por la red a nivel de aplicaci\u00f3n) debe ser propuesto por el propio alumno y descrito previamente al desarrollo. Se valorar\u00e1 el uso de m\u00faltiples tipos de datos tanto en el env\u00edo de datos sensorizados como de posibles respuestas por parte del servidor. Se desarrollar\u00e1 una versi\u00f3n utilizando TCP y otra equivalente usando UDP. El cliente enviar\u00e1 los datos de forma peri\u00f3dica y se \u00e9stos generar\u00e1n de modo aleatorio. A modo de entrega, se solicitan los c\u00f3digos desarrollados, as\u00ed como un an\u00e1lisis del tr\u00e1fico generado, considerando la sobrecarga (en bytes reales enviados) introducida por cada protocolo de capa de transporte. Ejemplo de sistema cliente/servidor multi-hilo Los ejemplos anteriormente descritos, aunque funcionales, adolecen en su dise\u00f1o de una caracter\u00edstica esencial: el servidor deja de atender peticiones entrantes mientras trata cada nuevo env\u00edo por parte del cliente. Los siguientes ejemplos muestran implementaciones sencillas con soporte multi-hilo para un sistema cliente/servidor escrito en Python. # Servidor TCP concurrente import socket, threading class ClientThread(threading.Thread): def __init__(self,clientAddress,clientsocket): threading.Thread.__init__(self) self.csocket = clientsocket print (\"Nueva conexion anyadida: \", clientAddress) def run(self): print (\"Conexion desde: \", clientAddress) #self.csocket.send(bytes(\"Hi, This is from Server..\",'utf-8')) msg = '' while True: data = self.csocket.recv(2048) msg = data.decode() if msg=='bye': break print (\"Desde el cliente\", msg) self.csocket.send(bytes(msg,'UTF-8')) print (\"Cliente \", clientAddress , \" desconectado...\") LOCALHOST = \"127.0.0.1\" PORT = 8080 server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) server.bind((LOCALHOST, PORT)) print(\"Servidor arrancado...\") print(\"Esperando petici\u00f3n de clientes...\") server.listen(1) while True: clientsock, clientAddress = server.accept() newthread = ClientThread(clientAddress, clientsock) newthread.start() # Cliente TCP. El env\u00edo de la cadena bye indica petici\u00f3n de desconexi\u00f3n. import socket SERVER = \"127.0.0.1\" PORT = 8080 client = socket.socket(socket.AF_INET, socket.SOCK_STREAM) client.connect((SERVER, PORT)) client.sendall(bytes(\"Hola, soy un cliente!!\",'UTF-8')) while True: in_data = client.recv(1024) print(\"Desde el servidor :\" ,in_data.decode()) out_data = input() client.sendall(bytes(out_data,'UTF-8')) if out_data=='end': break client.close() Tarea Estudia el c\u00f3digo del servidor concurrente y observa c\u00f3mo gestiona la creaci\u00f3n de hilos para atender cada petici\u00f3n entrante. Conecta simult\u00e1neamente m\u00faltiples clientes y observa el estado de los sockets mediante las herramientas correspondientes. Tarea opcional Tarea opcional Modifica tu primer entregable para considerar una implementaci\u00f3n multihilo del servidor TCP, siguiendo las directrices de los c\u00f3digos de ejemplo anteriormente proporcionados. Tarea opcional Tarea opcional Modifica el protocolo de env\u00edo para que tu aplicaci\u00f3n cliente/servidor UDP garantice en la medida de lo posible la recepci\u00f3n de los paquetes enviados desde el cliente, as\u00ed como su recepci\u00f3n en orden. Vuelve a analizar el tr\u00e1fico necesario en este caso comparado con una comunicaci\u00f3n b\u00e1sica basada en TCP (donde s\u00ed se garantizan, a nivel de transporte, dichas caracter\u00edsticas).","title":"Pr\u00e1ctica 1 (Ap\u00e9ndice). Programaci\u00f3n con sockets en Python"},{"location":"RPI-II/P1_IV/#practica-1-apendice-programacion-con-sockets-en-python","text":"","title":"Pr\u00e1ctica 1 (Ap\u00e9ndice). Programaci\u00f3n con sockets en Python"},{"location":"RPI-II/P1_IV/#objetivos","text":"Familiarizarse con la API de sockets en Python. Desarrollar esquemas b\u00e1sicos de sistemas cliente/servidor TCP y UDP utilizando Python. Ser capaces de analizar el tr\u00e1fico generado en una conexi\u00f3n TCP y UDP a trav\u00e9s de Wireshark. Dise\u00f1ar un protocolo de capa de aplicaci\u00f3n para simular una aplicaci\u00f3n cliente/servidor utilizando TCP y UDP. Observar la diferencia en tr\u00e1fico generado para una misma aplicaci\u00f3n utilizando TCP y UDP. Implementar servidores multi-hilo en Python. Nota Ofrecemos esta pr\u00e1ctica como anexo y referencia para complementar los contenidos ofrecidos en la Pr\u00e1ctica 1. Su comprensi\u00f3n y desarrollo es opcional, aunque puede ser de utilidad para alumnos con poca experiencia en el lenguaje C o en programaci\u00f3n con sockets, o para prototipar r\u00e1pidamente sistemas cliente/servidor utilizando Python.","title":"Objetivos"},{"location":"RPI-II/P1_IV/#la-api-de-sockets-en-python","text":"El m\u00f3dulo socket de Python proporciona una interfaz completa para trabajar con la API de sockets de Berkeley . En la presente pr\u00e1ctica, trabajaremos exclusivamente con esta API para desarrollar aplicaciones cliente/servidor utilizando los protocolos TCP y UDP. Las funciones y m\u00e9todos principales de la API de sockets son: socket() - bind() - listen() - accept() - connect() - connect_ex() - send() - recv() - close() - Python prorpociona una API consistente y completa mapeada directamente a las anteriores llamadas al sistema, t\u00edpicamente escritas en lenguaje C. Como parte de su biblioteca est\u00e1ndar, Python tambi\u00e9n proporciona clases que facilitan el trabajo con las funciones de bajo nivel. Aunque no lo cubriremos, el m\u00f3dulo socketserver proporciona una forma sencilla de crear servidores de red. Existen tambi\u00e9n numerosos m\u00f3dulos disponibles para implementar protocolos de alto nivel (por ejemplo HTTP o SMTP), v\u00e9ase .","title":"La API de sockets en Python"},{"location":"RPI-II/P1_IV/#sockets-tcp","text":"En Python, los sockets TCP se crean en Python utilizando socket.socket() , especificando el tipo de socket como socket.SOCK_STREAM . El protocolo de control de transmisi\u00f3n (TCP) se caracteriza por dos rasgos principales: Es confiable : se implementan mecanismos de detecci\u00f3n de p\u00e9rdidas en la red y reenv\u00edo de paquetes perdidos. Garantiza una entrega de paquetes en orden : los datos se entregan a las capas superiores (aplicaciones) en el mismo orden en el que fueron enviados. En contra, los sockets UDP se crean a trav\u00e9s de socket.SOCK_DGRAM , y no son confiables ni garantizan la entrega de paquetes en orden. Por tanto, es el desarrollador de aplicaciones quien, en caso de as\u00ed desearlo en el dise\u00f1o de la aplicaci\u00f3n, debe implementar estos mecanismos de forma espec\u00edfica. En el siguiente diagrama se muestra la secuencia t\u00edpica de invocaciones a la API de sockets para TCP: En la figura, la columna de la izquierda representa al servidor, mientras que la columna de la derecha representa al cliente en la conexi\u00f3n TCP. Observa las invocaciones necesarias para configurar un socket a la escucha de conexiones entrantes: socket() bind() listen() accept() En este extremo, un socket escucha ( listen ) potenciales conexiones entrantes desde clientes. Cuando un cliente solicita conectar, el servidor acepta ( accept ) la conexi\u00f3n, complet\u00e1ndola. El cliente invoca a connect() para establecer una conexi\u00f3n con el servidor e inicia el proceso de conexi\u00f3n a tres v\u00edas ( three-way connection ). Una vez establecida la conexi\u00f3n, los datos se intercambian entre cliente y servidor a trav\u00e9s de invocaciones a send() y recv() . Finalmente, el socket se destruye (esto es, la conexi\u00f3n entre ambos extremos se cierra) a trav\u00e9s de una invocaci\u00f3n a close() en cada extremo.","title":"Sockets TCP"},{"location":"RPI-II/P1_IV/#clienteservidor-echo-tcp","text":"Veamos un ejemplo sencillo para crear un par cliente-servidor. En este caso, el servidor simplemente responder\u00e1 con la misma cadena que reciba desde el cliente.","title":"Cliente/servidor echo TCP"},{"location":"RPI-II/P1_IV/#servidor-echo","text":"#!/usr/bin/env python3 #### servidor_echo.py import socket HOST = '127.0.0.1' # Interfaz est\u00e1ndar de loopback (localhost) PORT = 65432 # Puerto de escucha (los puertos mayores a 1023 son no privilegiados) with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: s.bind((HOST, PORT)) s.listen() conn, addr = s.accept() with conn: print('Conectado ', addr) while True: data = conn.recv(1024) if not data: break conn.sendall(data) Nota De momento, no importa si no entiendes todas las l\u00edneas en el anterior c\u00f3digo. Simplemente se trata de un punto de partida para desarrollar un servidor sencillo. Sin embargo, es conveniente que copies el c\u00f3digo en un fichero de texto (por ejemplo, llamado servidor_echo.py ) para que podeamos probarlo. Veamos l\u00ednea a l\u00ednea las partes m\u00e1s importantes del anterior c\u00f3digo. socket.socket() crea un objeto socket . Observa que, al crearse a trav\u00e9s de una construcci\u00f3n with , no es necesario invocar expl\u00edcitamente a s.close() , aunque debes tener en cuenta que el objeto es destruido al finalizar la construcci\u00f3n: with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: pass # Es posible usar el socket win invocar a s.close(). Los argumentos que se proporcionan a socket() especifican la familia de direcciones ( AF_INET ) y tipo de socket ( SOCK_STREAM ). AF_INET es la familia de direcciones de Internet para IPv4. SOCK_STREAM es el tipo de socket que permite la creaci\u00f3n de conexiones TCP. bind() se utiliza para asociar el socket a una interfaz de red y n\u00famero de puerto espec\u00edficos: HOST = '127.0.0.1' # Interfaz est\u00e1ndar de loopback (localhost) PORT = 65432 # Puerto de escucha (los puertos mayores a 1023 son no privilegiados) # ... s.bind((HOST, PORT)) Los valores proporcionados a bind() dependen de la familia de direcciones seleccionada para el socket . En este ejemplo, al utilizar AF_INET , espera una tupla con \u00fanicamente dos valores (host, puerto) . Para determinar el host , es posible utilizar un nombre de host , una direcci\u00f3n IP o una cadena vac\u00eda. Si utilizamos una direcci\u00f3n IP, \u00e9sta debe ser especificarse mediante una cadena que contenga una direcci\u00f3n IPv4 bien formada. La direcci\u00f3n 127.0.0.1 es la direcci\u00f3n IPv4 est\u00e1ndar para la interfaz de loopback , por lo que \u00fanicamente procesos que est\u00e9n ejecut\u00e1ndose en el propio host podr\u00e1n comunicar con el servidor. Si proporcionamos una cadena vac\u00eda, el servidro aceptar\u00e1 conexiones entrantes a trav\u00e9s de todas las interfaces IPv4 disponibles en el sistema. El n\u00famero de puerto ( port ) se especifica con un valor entero entre 1 y 65535, y espcifica el puerto (en este caso, TCP) a trav\u00e9s del cual el servidor aceptar\u00e1 conexiones desde los clientes. La mayor\u00eda de sistemas requieren permisos de superusuario para escuchar a trav\u00e9s de los puertos ( well-known ), es decir, con valor inferior a 1024. Continuando con el ejemplo, listen() posibilita que un servidor pueda, en el futuro, aceptar ( accept() ) conexiones entrantes. En otras palabras, pone a la escucha al socket : s.listen() conn, addr = s.accept() La invocaci\u00f3n a accept() bloquea el proceso y espera a una conexi\u00f3n entrante. Cuando un cliente conecta, devuelve un objeto socket que representa la conexi\u00f3n, as\u00ed como una tupla ( addr ) que contiene la direcci\u00f3n del cliente. Concretamente, esta tupla contiene los valores (host, port) que almacenan la direcci\u00f3n IPv4 y puerto del cliente que solicita la conexi\u00f3n. Observa que, en el ejemplo, conn es el objeto socket que usaremos para comunicar con el cliente: conn, addr = s.accept() with conn: print('Conectado ', addr) while True: data = conn.recv(1024) if not data: break conn.sendall(data) Tras obtener el objeto devuelto por accept() , dise\u00f1amos el servidor como un bucle infinito que invoca repetidamente a llamadas bloqueantes a conn.recv() . As\u00ed, leemos los datos enviados por el cliente y los reenviamos sin modificaci\u00f3n utilizando conn.sendall() . Si conn.recv() devuelve un objeto de tipo bytes vac\u00edo ( b'' ) significa que el cliente cerr\u00f3 la conexi\u00f3n, en cuyo caso el bucle termina, destruy\u00e9ndose el socket al salir de la sentencia with .","title":"Servidor echo"},{"location":"RPI-II/P1_IV/#cliente-echo","text":"Veamos a continuaci\u00f3n la estructura general del cliente (puedes usar, por ejemplo, cliente_echo.py como nombre para el fichero): #!/usr/bin/env python3 ### cliente_echo.py import socket HOST = '127.0.0.1' # IP del servidor PORT = 65432 # Puerto de escucha del servidor with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: s.connect((HOST, PORT)) s.sendall(b'Hola, mundo') data = s.recv(1024) print('Recibido ', repr(data)) En comparaci\u00f3n con el servidor, la estructura del cliente es m\u00e1s simple; simplemente crea un nuevo objeto socket , conecta con el servidor e invoca a s.sendall() para enviar el mensaje. Finalmente, espera la recepci\u00f3n de la respuesta utilizando s.recv() y la imprime por pantalla.","title":"Cliente echo"},{"location":"RPI-II/P1_IV/#ejecucion-del-cliente-y-servidor-echo","text":"A continuaci\u00f3n, ejecutaremos cliente y servidor para observar el estado de las conexiones durante su ciclo de vida. Ejecuta en una terminal el servidor: $ python3 ./servidor_echo.py Como ves, la terminal se bloquea (de hecho, el servidor permanece en estado bloqueado) en la invocaci\u00f3n: conn, addr = s.accept() Realmente, el servidor est\u00e1 esperando a que haya conexiones entrantes por parte de un cliente. Abre otra terminal y ejecuta el cliente: $ python3 cliente_echo.py Recibido 'Hola, mundo' En la ventana del servidor, deber\u00edas ver algo similar a: $ python3 ./servidor_echo.py Conectado ('127.0.0.1, 61234') En esta salida, el servidor ha mostrado por pantalla la tupla devuelta por s.accept() , que incluye la direcci\u00f3n IP y el n\u00famero de puerto TCP. Dicho n\u00famero de puerto (en el ejemplo anterior, 61234) es seleccionado aleatoriamente por el sistema operativo y puede variar en tu ejecuci\u00f3n.","title":"Ejecuci\u00f3n del cliente y servidor echo"},{"location":"RPI-II/P1_IV/#herramientas-para-observar-el-estado-del-socket","text":"Podemos utilizar la herramienta netstat para observar el estado actual de los sockets en cualquier sistema operativo (macOS, Linux e incluso Windows). Por ejemplo, esta ser\u00eda la salida de netstat en Linux tras ejecutar el servidor: netstat -an | grep 65432 Conexiones activas de Internet (servidores y establecidos) Proto Recib Enviad Direcci\u00f3n local Direcci\u00f3n remota Estado tcp 0 0 127.0.0.1:65432 0.0.0.0:* ESCUCHAR Observa que hemos filtrado la salida de la orden netcat seg\u00fan el n\u00famero de puerto utilizado. Observa el valor de las columnas Proto, Direcci\u00f3n local y Estado . Nota Otra forma de observar el estado de las conexiones es a trav\u00e9s de la orden lsof -i -n . Ejec\u00fatala y observa su salida.","title":"Herramientas para observar el estado del socket"},{"location":"RPI-II/P1_IV/#capturas-de-trafico-via-wireshark","text":"Wireshark es una herramienta de c\u00f3digo abierto ampliamente utilizada para analizar protocolos de comunicaci\u00f3n de red en cualquiera de las capas de la pila TCP/IP (como tambi\u00e9n en otros protocolos). Wireshark implementa un amplio abanico de filtros para definir criterios de b\u00fasqueda en las capturas de tr\u00e1fico, aunque de momento, en nuestro caso, no ser\u00e1 necesario utilizar filtros espec\u00edficos. Para arrancar Wireshark en la m\u00e1quina virtual proporcionada (o en cualquier instalaci\u00f3n b\u00e1sica Linux), teclea en tu terminal: $ sudo wireshark Tras el arranque, podemos comenzar una nueva captura de tr\u00e1fico a trav\u00e9s del men\u00fa Capture , opci\u00f3n Start . La pantalla de selecci\u00f3n de interfaz nos permitir\u00e1 definir en qu\u00e9 interfaz de red se realizar\u00e1 la captura. En nuestro caso, ya que vamos a comunicar dos procesos en la misma m\u00e1quina, elegiremos la interfaz de Loopback (lo) y comenzaremos la captura. Tarea Arranca Wireshark y prepara una captura sobre la interfaz de loopback . Ejecuta el servidor echo TCP y el cliente correspondiente, y analiza el tr\u00e1fico generado. Especialmente, f\u00edjate en el proceso de establecimiento de conexi\u00f3n en tres v\u00edas, paquetes de Acknowledge tras el env\u00edo de cada mensaje y, en general, en cualquier otro aspecto que consideres de inter\u00e9s.","title":"Capturas de tr\u00e1fico v\u00eda Wireshark"},{"location":"RPI-II/P1_IV/#sockets-udp","text":"La creaci\u00f3n y gesti\u00f3n de sockets UDP en Python resulta todav\u00eda m\u00e1s sencilla. Observa el siguiente c\u00f3digo, que crea un servidor UDP utilizando la API de sockets Python: import socket udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) udp_socket.bind((\"localhost\", 5005)) data = udp_socket.recv(512) print(data) Primero, importamos la biblioteca socket de recepci\u00f3n, igual que en el caso de TCP. Obviamente, en este caso el tipo de socket pasa a ser socket.DOCK_DGRAM , para indicar que deseamos utilizar UDP en la comunicaci\u00f3n. El programa espera a la recepci\u00f3n de un paquete utilizando el m\u00e9todo bloqueante recv , cuyo \u00fanico par\u00e1metro indica el n\u00famero m\u00e1ximo de bytes que deseamos recibir. Cuando un paquete llega al socket, el metodo recv devolver\u00e1 un array de bytes, que ser\u00e1 almacenado en la variable que deseemos. El env\u00edo de datos a trav\u00e9s de un socket UDP es tambi\u00e9n sencillo: import socket udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) udp_socket.bind((\"localhost\", 0)) data = b\"Hola, mundo!\" udp_socket.sendto(data,(\"localhost\", 5005)) Observa que, en este caso, asociamos ( bind ) el socket a un puerto especificado como 0. Este valor especial indica al sistema operativo que elija para la transimisi\u00f3n un puerto origen aleatorio de entre los disponibles en el sistema. A continuaci\u00f3n, creamos los datos a enviar y los enviamos utilizando el m\u00e9todo sendto() . Este m\u00e9todo tomados argumentos: datos a enviar, y precisamente la direcci\u00f3n de env\u00edo. Los datos enviados a trav\u00e9s del socket deben formar parte de un array de bytes (por ello, la cadena a enviar viene precedida por el car\u00e1cter b ). Tarea Comprueba que, efectivamente, los c\u00f3digos de env\u00edo y recepci\u00f3n a trav\u00e9s de UDP funcionan como se espera. Nota Desde la versi\u00f3n 3 de Python, las cadenas se codifican utilizando Unicode. Al contrario que ASCII, conde cada caracter tiene una representaci\u00f3n en byte directa, Unicode utiliza enteros par representar cada caracter, que deben ser codificados para obtener una representaci\u00f3n en forma de byte. Uno de esos esquemas de codificaci\u00f3n es UTF-8. Por ejemplo, el siguiente c\u00f3digo muestra c\u00f3mo codificar una cadena Unicode en una representaci\u00f3n de bytes: cadena= \"Hola\" data = cadena.encode(\"UTF-8\") print(data, type(data)) lo cual genera b\"Hola\" <class 'bytes'> que puede ya ser enviado directamente por red. Hasta este punto, los programas UDP han sido totalmente unidireccionales en el env\u00edo/recepci\u00f3n de datos, pero obviamente, un socket UDP es un canal de comunicaci\u00f3n bidireccional. Tarea Implementa una funcionalidad similar al servidor echo que vimos para TCP, pero utilizando en este caso UDP. Realiza una captura de tr\u00e1fico en Wireshark similar a la realizada en el caso de TCP, y observa las principales diferencias entre ellas a nivel de tr\u00e1fico generado.","title":"Sockets UDP"},{"location":"RPI-II/P1_IV/#envio-de-datos-binarios-a-traves-de-sockets","text":"Hasta este punto, hemos visto \u00fanicamente c\u00f3mo enviar cadenas de texto a trav\u00e9s de sockets TCP o UDP, pero es muy probable que sea necesario (o conveniente), en ocasiones, enviar datos directamente en formato binario (por ejemplo, valores num\u00e9ricos en punto flotante o enteros). Utilizando el m\u00f3dulo struct de Python podemos especificar qu\u00e9 tipo o tipos de datos se almacenan en una secuencia de bytes y c\u00f3mo decodificarlos. Tambi\u00e9n es posible especificar en qu\u00e9 lugar de la secuencia se alojan dichos datos, permitiendo el empaquetado de m\u00faltiples datos de distintos tipos de forma sencilla, y su posterior decodificaci\u00f3n en el otro extremo de la comunicaci\u00f3n. Nota Para todos los detalles del m\u00f3dulo struct , consulta la p\u00e1gina oficial de documentaci\u00f3n . El m\u00f3dulo struct proporciona dos m\u00e9todos de inter\u00e9s: pack y unpack . La siguiente sentencia: struct.pack(\">iii\", 1, 2, 3) utiliza el m\u00e9todo pack para realizar un empaquetado de datos. Concretamente, observa como el m\u00e9todo recibe dos par\u00e1metros: En primer lugar, el par\u00e1metro de formato \">iii\" . Define como debe codificarse cada valor en la secuencia de bytes. El primer car\u00e1cter indica el endianness utilizado, en este caso big endian (utilizar\u00edamos \">\" para big endian , \"<\" para little endian y \"=\" para network (big) endian). En segundo lugar, los valores a empaquetar. Observa que el formato, adem\u00e1s, incluye el n\u00famero y tipo de los datos a empaquetar (en este caso, tres valores detipo entero). Para otros tipos de datos, consulta la documentaci\u00f3n del m\u00f3dulo. Desempaquetar los datos enviados en el extremo opuesto es intuitivo: a, b, c = struct.unpack( \">iii\" ) A continuaci\u00f3n, mostramos un ejemplo de sistema cliente/servidor TCP que hace uso del m\u00f3dulo struct para realizar el env\u00edo de dos datos enteros y uno flotante entre un cliente y un servidor. # Cliente import binascii import socket import struct import sys # Socket TCP sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_address = ('localhost', 10001) sock.connect(server_address) packed_data = struct.pack(\"=iif\", 1, 4, 2.7) try: # Envio de datos print('Enviando \"%s\"' % binascii.hexlify(packed_data)) sock.sendall(packed_data) finally: print('Cerrando socket') sock.close() # Servidor import binascii import socket import struct import sys # Socket TCP sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_address = ('localhost', 10001) sock.bind(server_address) sock.listen(1) while True: print('Esperando conexiones entrantes') connection, client_address = sock.accept() try: data = connection.recv(1024) print('Recibido \"%s\"' % binascii.hexlify(data)) unpacked_data = struct.unpack(\"=iif\", data) print('Desempaquetado:', unpacked_data) finally: connection.close() Tarea Ejecuta el anterior sistema cliente servidor y analiza el tr\u00e1fico generado, en busca de los datos binarios empaquetados. Experimenta con otros tipos de datos y endianess y observa las diferencias.","title":"Env\u00edo de datos binarios a trav\u00e9s de sockets"},{"location":"RPI-II/P1_IV/#tarea","text":"Tarea Se pide dise\u00f1ar un sistema cliente/servidor programado en Python, que simule el env\u00edo de un conjunto de datos sensorizados desde un cliente hacia un servidor. El protocolo a utilizar (formato de datos enviado por la red a nivel de aplicaci\u00f3n) debe ser propuesto por el propio alumno y descrito previamente al desarrollo. Se valorar\u00e1 el uso de m\u00faltiples tipos de datos tanto en el env\u00edo de datos sensorizados como de posibles respuestas por parte del servidor. Se desarrollar\u00e1 una versi\u00f3n utilizando TCP y otra equivalente usando UDP. El cliente enviar\u00e1 los datos de forma peri\u00f3dica y se \u00e9stos generar\u00e1n de modo aleatorio. A modo de entrega, se solicitan los c\u00f3digos desarrollados, as\u00ed como un an\u00e1lisis del tr\u00e1fico generado, considerando la sobrecarga (en bytes reales enviados) introducida por cada protocolo de capa de transporte.","title":"Tarea"},{"location":"RPI-II/P1_IV/#ejemplo-de-sistema-clienteservidor-multi-hilo","text":"Los ejemplos anteriormente descritos, aunque funcionales, adolecen en su dise\u00f1o de una caracter\u00edstica esencial: el servidor deja de atender peticiones entrantes mientras trata cada nuevo env\u00edo por parte del cliente. Los siguientes ejemplos muestran implementaciones sencillas con soporte multi-hilo para un sistema cliente/servidor escrito en Python. # Servidor TCP concurrente import socket, threading class ClientThread(threading.Thread): def __init__(self,clientAddress,clientsocket): threading.Thread.__init__(self) self.csocket = clientsocket print (\"Nueva conexion anyadida: \", clientAddress) def run(self): print (\"Conexion desde: \", clientAddress) #self.csocket.send(bytes(\"Hi, This is from Server..\",'utf-8')) msg = '' while True: data = self.csocket.recv(2048) msg = data.decode() if msg=='bye': break print (\"Desde el cliente\", msg) self.csocket.send(bytes(msg,'UTF-8')) print (\"Cliente \", clientAddress , \" desconectado...\") LOCALHOST = \"127.0.0.1\" PORT = 8080 server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) server.bind((LOCALHOST, PORT)) print(\"Servidor arrancado...\") print(\"Esperando petici\u00f3n de clientes...\") server.listen(1) while True: clientsock, clientAddress = server.accept() newthread = ClientThread(clientAddress, clientsock) newthread.start() # Cliente TCP. El env\u00edo de la cadena bye indica petici\u00f3n de desconexi\u00f3n. import socket SERVER = \"127.0.0.1\" PORT = 8080 client = socket.socket(socket.AF_INET, socket.SOCK_STREAM) client.connect((SERVER, PORT)) client.sendall(bytes(\"Hola, soy un cliente!!\",'UTF-8')) while True: in_data = client.recv(1024) print(\"Desde el servidor :\" ,in_data.decode()) out_data = input() client.sendall(bytes(out_data,'UTF-8')) if out_data=='end': break client.close() Tarea Estudia el c\u00f3digo del servidor concurrente y observa c\u00f3mo gestiona la creaci\u00f3n de hilos para atender cada petici\u00f3n entrante. Conecta simult\u00e1neamente m\u00faltiples clientes y observa el estado de los sockets mediante las herramientas correspondientes.","title":"Ejemplo de sistema cliente/servidor multi-hilo"},{"location":"RPI-II/P1_IV/#tarea-opcional","text":"Tarea opcional Modifica tu primer entregable para considerar una implementaci\u00f3n multihilo del servidor TCP, siguiendo las directrices de los c\u00f3digos de ejemplo anteriormente proporcionados.","title":"Tarea opcional"},{"location":"RPI-II/P1_IV/#tarea-opcional_1","text":"Tarea opcional Modifica el protocolo de env\u00edo para que tu aplicaci\u00f3n cliente/servidor UDP garantice en la medida de lo posible la recepci\u00f3n de los paquetes enviados desde el cliente, as\u00ed como su recepci\u00f3n en orden. Vuelve a analizar el tr\u00e1fico necesario en este caso comparado con una comunicaci\u00f3n b\u00e1sica basada en TCP (donde s\u00ed se garantizan, a nivel de transporte, dichas caracter\u00edsticas).","title":"Tarea opcional"},{"location":"RPI-II/P2/","text":"Pr\u00e1ctica 2. Seguridad (TLS y DTLS) Objetivos Observar el comportamiento de TLS y DTLS para el intercambio cifrado de mensajes. Conocer las diferencias b\u00e1sicas entre TLS y DTLS. Conocer una API b\u00e1sica de programaci\u00f3n de sistemas cliente/servidor usando TLS y DTLS (WolfSSL). Conocer una API b\u00e1sica de programaci\u00f3n de sistemas cliente/servidor en ESP-IDF (ESP-TLS/WolfSSL). WolfSSL De las principales librer\u00edas que implementan protocolos de seguridad, sin duda alguna la m\u00e1s eficiente es WolfSSL y es por ello que esta pr\u00e1ctica se centra en ella. Instalaci\u00f3n (Linux) Aunque se pueden emplear paquetes binarios de la propia distribuci\u00f3n de Linux, es recomendable partir del c\u00f3digo fuente y compilarlo/instalarlo. Por lo tanto, lo primero es descargar el fichero wolfssl-5.7.2.zip de este enlace y descomprimirlo en una ruta sin espacios (esta recomendaci\u00f3n es aplicable a todas las pr\u00e1cticas) . Antes de proceder a su compilaci\u00f3n es necesario instalar una serie de pre-requisitos: sudo apt install build-essential libtool-bin autoconf libevent-dev Moverse al directorio descomprimido para configurar y construir la librer\u00eda: ./configure --enable-dtls --enable-dtls13 make sudo make install Dependiendo de la versi\u00f3n del fichero comprimido que se emplee es posible que el fichero ./configure no este presente y sea preciso generarlo mediante el script ./autogen.sh . Cabe destacar el siguiente mensaje que aparece tras realizar la instalaci\u00f3n mediante make install : ---------------------------------------------------------------------- Libraries have been installed in: /usr/local/lib If you ever happen to want to link against installed libraries in a given directory, LIBDIR, you must either use libtool, and specify the full pathname of the library, or use the '-LLIBDIR' flag during linking and do at least one of the following: - add LIBDIR to the 'LD_LIBRARY_PATH' environment variable during execution - add LIBDIR to the 'LD_RUN_PATH' environment variable during linking - use the '-Wl,-rpath -Wl,LIBDIR' linker flag - have your system administrator add LIBDIR to '/etc/ld.so.conf' See any operating system documentation about shared libraries for more information, such as the ld(1) and ld.so(8) manual pages. ---------------------------------------------------------------------- Esta informaci\u00f3n es preciso tenerla en cuenta a la hora compilar y ejecutar binarios que empleen esta librer\u00eda. En particular si no estuviese ya el directorio /usr/local/lib en las rutas de b\u00fasqueda establecidas por la variable de entorno LD_LIBRARY_PATH ser\u00eda preciso a\u00f1adirlo con el siguiente comando: export LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH Esto puede realizarse cada vez que sea preciso o de forma autom\u00e1tica al inicio de sesi\u00f3n modificando el fichero .bashrc : echo \"export LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH\" >> $HOME/.bashrc Cliente/servidor TLS. Ejemplo b\u00e1sico en host El repositorio wolfssl-examples contiene aplicaciones de ejemplo, escritas en C, que demuestran c\u00f3mo usar la biblioteca WolfSSL. Aunque s\u00f3lo vamos a usar un par de ellas, lo m\u00e1s sencillo es clonar el repositorio completo: git clone https://github.com/wolfSSL/wolfssl-examples.git cd wolfssl-examples/ Servidor TLS Analizaremos en primer lugar el c\u00f3digo b\u00e1sico del servidor TLS. Para ello, observa el contenido del fichero tls/server-tls.c . Cabeceras y constantes El uso de WolfSSL requiere la inclusi\u00f3n de dos cabeceras b\u00e1sicas: #include <wolfssl/options.h> #include <wolfssl/ssl.h> Adem\u00e1s, ya que ser\u00e1n necesarios en el desarrollo, definiremos las rutas al certificado (clave p\u00fablica) del servidor y su clave privada: #define CERT_FILE \"../certs/server-cert.pem\" #define KEY_FILE \"../certs/server-key.pem\" Observa adem\u00e1s que el puerto de escucha del servidor ser\u00e1 el 11111 . Objetos b\u00e1sicos WolfSSL. Contexto y objeto SSL Definiremos dos objetos b\u00e1sicos que se utilizar\u00e1n de forma recurrente en el c\u00f3digo: WOLFSSL_CTX* ctx; WOLFSSL* ssl; El contexto ( ctx ) incluye valores globales para cada conexi\u00f3n SSL, incluyendo informaci\u00f3n sobre certificados. Es posible utilizar un mismo contexto para m\u00faltiples conexiones, siempre que compartan caracter\u00edsticas. Para crear un nuevo contexto, utilizaremos la funci\u00f3n wolfSSL_CTX_new como sigue: /* Create and initialize WOLFSSL_CTX */ if ((ctx = wolfSSL_CTX_new(wolfTLSv1_2_server_method())) == NULL) { fprintf(stderr, \"ERROR: failed to create WOLFSSL_CTX\\n\"); return -1; } El argumento proporcionado incluye informaci\u00f3n sobre la versi\u00f3n de protocolo a utilizar. Actualmente, WolfSSL soporta SSL 3.0, TLS 1.1, TLS 1.2, DTLS 1.0 y DTLS 1.2. En este caso, para la parte cliente, las funciones a utilizar como argumento ser\u00edan: wolfSSLv3_server_method(); // SSLv3 wolfTLSv1_server_method(); // TLSv1 wolfTLSv1_1_server_method(); // TLSv1.1 wolfTLSv1_2_server_method(); // TLSv1.2 wolfDTLSv1_server_method(); // DTLS wolfDTLSv1_2_server_method(); // DTLS 1.2 En segundo lugar, es necesario cargar nuestra CA (Autoridad Certificadora) en el contexto, para que cualquier cliente pueda verificar, en el momento de su conexi\u00f3n, la identidad del servidor. Para ello, usamos la funci\u00f3n wolfSSL_CTX_use_certificate_file de la siguiente manera: /* Load server certificates into WOLFSSL_CTX */ if (wolfSSL_CTX_use_certificate_file(ctx, CERT_FILE, SSL_FILETYPE_PEM) != SSL_SUCCESS) { fprintf(stderr, \"ERROR: failed to load %s, please check the file.\\n\", CERT_FILE); return -1; } Del mismo modo, el servidor deber\u00e1 incluir su clave privada en formato PEM: /* Load server key into WOLFSSL_CTX */ if (wolfSSL_CTX_use_PrivateKey_file(ctx, KEY_FILE, SSL_FILETYPE_PEM) != SSL_SUCCESS) { fprintf(stderr, \"ERROR: failed to load %s, please check the file.\\n\", KEY_FILE); return -1; } A continuaci\u00f3n, observa como el c\u00f3digo de escucha y aceptaci\u00f3n de conexiones entrantes no difieren de cualquier c\u00f3digo que hayas desarrollado previamente para aceptar conexiones entrantes TCP ( bind , + listen + accept ). Justo tras la conexi\u00f3n ( accept ), resulta necesario crear un nuevo objeto SSL, as\u00ed como asociar el descriptor de socket con la nueva sesi\u00f3n (conexi\u00f3n) TLS: /* Create a WOLFSSL object */ if ((ssl = wolfSSL_new(ctx)) == NULL) { fprintf(stderr, \"ERROR: failed to create WOLFSSL object\\n\"); return -1; } /* Attach wolfSSL to the socket */ wolfSSL_set_fd(ssl, connd); /* Establish TLS connection */ ret = wolfSSL_accept(ssl); if (ret != SSL_SUCCESS) { fprintf(stderr, \"wolfSSL_accept error = %d\\n\", wolfSSL_get_error(ssl, ret)); return -1; } A partir de este punto, podemos enviar y recibir datos a trav\u00e9s del socket (y por tanto de la conexi\u00f3n TLS) de forma muy similar a como lo hacemos con el enfoque cl\u00e1sico. As\u00ed, para recibir datos: if (wolfSSL_read(ssl, buff, sizeof(buff)-1) == -1) { fprintf(stderr, \"ERROR: failed to read\\n\"); return -1; } Y para enviar datos de vuelta: /* Reply back to the client */ if (wolfSSL_write(ssl, buff, len) != len) { fprintf(stderr, \"ERROR: failed to write\\n\"); return -1; } Por \u00faltimo, finalizaremos la conexi\u00f3n con la invocaci\u00f3n de la funci\u00f3n wolfSSL_free(ssl) . Note El cliente proporcionado sigue una estrategia de implementaci\u00f3n similar. Compara ambos c\u00f3digos (cliente y servidor) y aseg\u00farate de entender las diferencias entre ellos. Tarea entregable Compila y ejecuta el sistema cliente/servidor TLS y obt\u00e9n capturas de tr\u00e1fico tanto de las fases de establecimiento de conexi\u00f3n como de las fases de transferencia de datos. En base a lo aprendido en las clases de teor\u00eda y la documentaci\u00f3n adicional sobre TLS y wolfSSL, redacta un breve informe que resuma el proceso de handshake y transferencia de datos en TLS tomando como base los paquetes reales observados para esta conexi\u00f3n. Cliente/servidor DTLS. Ejemplo b\u00e1sico en host El desarrollo de un sistema b\u00e1sico cliente/servidor con soporte DTLS utilizando WolfSSL es muy similar al visto anteriormente para TLS. Observa el contenido del fichero dtls/server-dtls.c . Eel c\u00f3digo sigue una filosof\u00eda similar a TLS, adaptado, obviamente, a las caracter\u00edsticas de UDP (tipo de socket, ausencia de conexi\u00f3n, etc.), por lo que se deja como ejercicio su an\u00e1lisis y ejecuci\u00f3n. Tarea entregable Analiza, compila y ejecuta los c\u00f3digos correspondientes al sistema cliente/servidor DTLS. Realiza capturas de tr\u00e1fico y comp\u00e1ralas, paquete a paquete, con las generadas para un patr\u00f3n de tr\u00e1fico similar en el caso de TLS. Incide en sus similitudes y diferencias, tanto a nivel de handshake como de transferencia de datos. Observa, en este \u00faltimo caso, la aparici\u00f3n de nuevos campos de encabezado en los env\u00edos de datos DTLS. \u00bfCu\u00e1l/cu\u00e1les son esos campos y por qu\u00e9 aparecen? Realiza una comparativa del tr\u00e1fico total generado en ambos casos para exactamente la misma cantidad de datos transferidos. TLS en el ESP32. El componente wolfSSL (version 5.7.2) La librer\u00eda WolfSSL est\u00e1 disponible como componente de Espressif . A continuaci\u00f3n veremos un ejemplo de uso de cliente TLS apto para conectarse el servidor anterior. Aunque es posible usar el GUI de la Extensi\u00f3n de ESP-IDF de VSCode, por brevedad vamos a realizar los pasos desde l\u00ednea de comandos en el terminal ESP-IDF Terminal . Moverse a la carpeta d\u00f3nde se quiera importar el ejemplo y ejecutar el siguiente comando. idf.py create-project-from-example \"wolfssl/wolfssl^5.7.2:wolfssl_client\" cd wolfssl_client` Ejecuta la utilidad menuconfig : idf.py menuconfig Y configura los diferentes par\u00e1metros para el dispositivo objetivo, junto con la configuraci\u00f3n local de WiFi: Host de destino: CONFIG_WOLFSSL_TARGET_HOST (en nuestro caso del del host en el que se ejecute el servidor TLS) Puerto de destino: CONFIG_WOLFSSL_TARGET_PORT (por defecto 11111) SSID de WiFi de ejemplo: CONFIG_EXAMPLE_WIFI_SSID Contrase\u00f1a de WiFi de ejemplo: CONFIG_EXAMPLE_WIFI_PASSWORD Cabe se\u00f1alar que los makefiles de este ejemplo no requieren la instalaci\u00f3n de wolfSSL copiando archivos localmente. Es preciso se\u00f1alar que hay un peque\u00f1o error en el c\u00f3digo de ejemplo y preciso realizar la siguiente modificaci\u00f3n del fichero main\\include\\client-tls.h o de lo contrario no usa la direcci\u00f3n destino configurada previamente: /* See main/Kconfig.projbuild for default configuration settings */ #ifdef CONFIG_WOLFSSL_TARGET_HOST #define TLS_SMP_TARGET_HOST CONFIG_WOLFSSL_TARGET_HOST #else #define TLS_SMP_TARGET_HOST \"192.168.1.41\" #endif A continuaci\u00f3n se puede compilar y cargar el firmware para ver el ejemplo en acci\u00f3n. idf.py build idf.py flash idf.py monitor Tarea entregable Compila y ejecuta el cliente TLS en el ESP32, y consigue que interact\u00fae con el servidor TLS que probaste anteriormente en el host . Comprueba que, efectivamente, los datos se transfieren cifrados entre ambos extremos, y que el intercambio de paquetes es similar al que observaste entre cliente y servidor en el host . Tarea entregable Repite el mismo proceso para el cliente DTLS. TLS en el ESP32. El componente ESP-TLS ESP-IDF proporciona un componente (ESP-TLS) que ofrece una interfaz ( API ) simplificada para acceder a funcionalidad b\u00e1sica TLS. A\u00fan as\u00ed, ofrece una funcionalidad suficientemente amplia como para implementar casos de uso comunes en entornos IoT. La API de ESP-TLS es sencilla, y se basa en el uso de cuatro funciones b\u00e1sicas: Establecimiento de conexi\u00f3n TLS ( esp_tls_conn_new_sync() ) Prototipo: int esp_tls_conn_new_sync(const char *hostname, int hostlen, int port, const esp_tls_cfg_t *cfg, esp_tls_t *tls) Descripci\u00f3n: Crea una nueva conexi\u00f3n TLS/SSL bloqueante, estableciendo dicha conexi\u00f3n contra un servidor establecido. Par\u00e1metros: hostname : Identificaci\u00f3n del host. hostlen : Longitud del par\u00e1metro hostname . port : Puerto de conexi\u00f3n con el host. cfg : Configuraci\u00f3n de la conexi\u00f3n TLS. tls : Puntero a esp_tls_t (manejador de la conexi\u00f3n). Devuelve NULL si se produce un error en la conexi\u00f3n. Destrucci\u00f3n de conexi\u00f3n TLS ( esp_tls_conn_delete() ) void esp_tls_server_session_delete(esp_tls_t *tls) Descripci\u00f3n: Cierra la conexi\u00f3n TLS/SSL. Par\u00e1metros: tls : Manejador de la conexi\u00f3n. Escritura de datos ( esp_tls_conn_read() ) ssize_t esp_tls_conn_write(esp_tls_t *tls, const void *data, size_t datalen) Descripci\u00f3n: Escribe en la conexi\u00f3n TLS/SSL indicada el contenido del buffer data . Par\u00e1metros: tls : Manejador de la conexi\u00f3n. data : Buffer de env\u00edo. datalen : Longitud del buffer de env\u00edo (o n\u00famero m\u00e1ximo de bytes a escribir). Valor de retorno: >=0 : \u00e9xito en el env\u00edo. N\u00famero de bytes efectivamente enviados. <0 : error en el env\u00edo. Lectura de datos ( esp_tls_conn_read() ) ssize_t esp_tls_conn_read(esp_tls_t *tls, void *data, size_t datalen) Descripci\u00f3n: Lee desde la conexi\u00f3n TLS/SSL indicada hacia el buffer data . Par\u00e1metros: tls : Manejador de la conexi\u00f3n. data : Buffer de recepci\u00f3n. datalen : Longitud del buffer de recepci\u00f3n (o n\u00famero m\u00e1ximo de bytes a leer). Valor de retorno: >0 : \u00e9xito en la recepci\u00f3n. N\u00famero de bytes efectivamente le\u00eddos. =0 : error en la recepci\u00f3n. La conexi\u00f3n se cerr\u00f3. <0 : error en la recepci\u00f3n. Estructura b\u00e1sica de un cliente TCP usando ESP-IDF Un cliente TCP implementado sobre ESP-IDF para dar soporte TLS, requiere ciertas modificaciones con respecto a la versi\u00f3n sin TLS. De hecho, el uso de ESP-IDF simplifica el c\u00f3digo del cliente. La estructura b\u00e1sica resultar\u00eda: /// Includes anteriores. #include \"esp_tls.h\" // Puede tomarse desde menuconfig. #define HOST_IP_ADDR DIRECCION_DE_HOST #define PORT PUERTO static const char *payload = \"Hola, mundo via TLS\"; // ... static void tls_client_task( void *pvParameters ) { // ... // Configuraci\u00f3n de ESP-TLS (vac\u00edo para opciones defecto). esp_tls_cfg_t cfg = { }; // Creaci\u00f3n de conexi\u00f3n. struct esp_tls tls; ret = esp_tls_conn_new_sync( HOST_IP_ADDR, longitud, PORT, &cfg, &tls); // Chequeo de errores. // ... // Env\u00edo de datos. ret = esp_tls_conn_write(tls, payload, strlen(payload)); // Chequeo de errores. // ... // Lectura de datos ret = esp_tls_conn_read(tls, (char *)rx_buffer, 128); // Chequeo de errores. // ... // Destrucci\u00f3n de la conexi\u00f3n esp_tls_server_session_delete( tls ); vTaskDelete( NULL ); } void app_main( void ) { // ... } Tarea entregable Estudia y prueba el ejemplo base examples/protocols/https_request . Opcionalmente, modifica este ejemplo para que interactue con el servidor TLS empleando previamente. Desactivaci\u00f3n de la comprobaci\u00f3n de certificado de servidor Basta con modificar la configuraci\u00f3n del proyecto del siguiente modo: # CONFIG_EXAMPLE_CLIENT_SESSION_TICKETS is not set CONFIG_ESP_TLS_INSECURE=y CONFIG_ESP_TLS_SKIP_SERVER_CERT_VERIFY=y # CONFIG_MBEDTLS_CERTIFICATE_BUNDLE is not set Y comentar est\u00e1s l\u00edneas del fichero https_request_example_main.c para borrar la configuraci\u00f3n de la entidad de certificaci\u00f3n (de lo contrario prevalecer\u00eda sobre la opci\u00f3n CONFIG_ESP_TLS_SKIP_SERVER_CERT_VERIFY ): esp_tls_cfg_t cfg = { // .cacert_buf = (const unsigned char *) server_root_cert_pem_start, // .cacert_bytes = server_root_cert_pem_end - server_root_cert_pem_start, ... }; Servidor web de test con certificado autofirmado Para comprobar el ejemplo examples/protocols/https_request con un servidor https local con certificado autofirmado se pueden emplear los siguientes comandos de openssl . Generaci\u00f3n del certificado autofirmado. Es preciso proporciona cierta informaci\u00f3n, entre otras cosas la direcci\u00f3n IP o nombre del host. openssl openssl genrsa -out server.key 2048 openssl openssl req -new -x509 -key server.key -out server.crt -days 365 You are about to be asked to enter information that will be incorporated into your certificate request. What you are about to enter is what is called a Distinguished Name or a DN. There are quite a few fields but you can leave some blank For some fields there will be a default value, If you enter '.', the field will be left blank. ----- Country Name (2 letter code) [AU]:ES State or Province Name (full name) [Some-State]:Madrid Locality Name (eg, city) []:Madrid Organization Name (eg, company) [Internet Widgits Pty Ltd]:UCM Organizational Unit Name (eg, section) []:FDI Common Name (e.g. server FQDN or YOUR name) []:<IP HOST> Email Address []:lpinuel@ucm.es Arranque del servidor web . openssl openssl s_server -accept 8443 -cert server.crt -key server.key -www Using default temp DH parameters ACCEPT","title":"Pr\u00e1ctica 2"},{"location":"RPI-II/P2/#practica-2-seguridad-tls-y-dtls","text":"","title":"Pr\u00e1ctica 2. Seguridad (TLS y DTLS)"},{"location":"RPI-II/P2/#objetivos","text":"Observar el comportamiento de TLS y DTLS para el intercambio cifrado de mensajes. Conocer las diferencias b\u00e1sicas entre TLS y DTLS. Conocer una API b\u00e1sica de programaci\u00f3n de sistemas cliente/servidor usando TLS y DTLS (WolfSSL). Conocer una API b\u00e1sica de programaci\u00f3n de sistemas cliente/servidor en ESP-IDF (ESP-TLS/WolfSSL).","title":"Objetivos"},{"location":"RPI-II/P2/#wolfssl","text":"De las principales librer\u00edas que implementan protocolos de seguridad, sin duda alguna la m\u00e1s eficiente es WolfSSL y es por ello que esta pr\u00e1ctica se centra en ella.","title":"WolfSSL"},{"location":"RPI-II/P2/#instalacion-linux","text":"Aunque se pueden emplear paquetes binarios de la propia distribuci\u00f3n de Linux, es recomendable partir del c\u00f3digo fuente y compilarlo/instalarlo. Por lo tanto, lo primero es descargar el fichero wolfssl-5.7.2.zip de este enlace y descomprimirlo en una ruta sin espacios (esta recomendaci\u00f3n es aplicable a todas las pr\u00e1cticas) . Antes de proceder a su compilaci\u00f3n es necesario instalar una serie de pre-requisitos: sudo apt install build-essential libtool-bin autoconf libevent-dev Moverse al directorio descomprimido para configurar y construir la librer\u00eda: ./configure --enable-dtls --enable-dtls13 make sudo make install Dependiendo de la versi\u00f3n del fichero comprimido que se emplee es posible que el fichero ./configure no este presente y sea preciso generarlo mediante el script ./autogen.sh . Cabe destacar el siguiente mensaje que aparece tras realizar la instalaci\u00f3n mediante make install : ---------------------------------------------------------------------- Libraries have been installed in: /usr/local/lib If you ever happen to want to link against installed libraries in a given directory, LIBDIR, you must either use libtool, and specify the full pathname of the library, or use the '-LLIBDIR' flag during linking and do at least one of the following: - add LIBDIR to the 'LD_LIBRARY_PATH' environment variable during execution - add LIBDIR to the 'LD_RUN_PATH' environment variable during linking - use the '-Wl,-rpath -Wl,LIBDIR' linker flag - have your system administrator add LIBDIR to '/etc/ld.so.conf' See any operating system documentation about shared libraries for more information, such as the ld(1) and ld.so(8) manual pages. ---------------------------------------------------------------------- Esta informaci\u00f3n es preciso tenerla en cuenta a la hora compilar y ejecutar binarios que empleen esta librer\u00eda. En particular si no estuviese ya el directorio /usr/local/lib en las rutas de b\u00fasqueda establecidas por la variable de entorno LD_LIBRARY_PATH ser\u00eda preciso a\u00f1adirlo con el siguiente comando: export LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH Esto puede realizarse cada vez que sea preciso o de forma autom\u00e1tica al inicio de sesi\u00f3n modificando el fichero .bashrc : echo \"export LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH\" >> $HOME/.bashrc","title":"Instalaci\u00f3n (Linux)"},{"location":"RPI-II/P2/#clienteservidor-tls-ejemplo-basico-en-host","text":"El repositorio wolfssl-examples contiene aplicaciones de ejemplo, escritas en C, que demuestran c\u00f3mo usar la biblioteca WolfSSL. Aunque s\u00f3lo vamos a usar un par de ellas, lo m\u00e1s sencillo es clonar el repositorio completo: git clone https://github.com/wolfSSL/wolfssl-examples.git cd wolfssl-examples/","title":"Cliente/servidor TLS. Ejemplo b\u00e1sico en host"},{"location":"RPI-II/P2/#servidor-tls","text":"Analizaremos en primer lugar el c\u00f3digo b\u00e1sico del servidor TLS. Para ello, observa el contenido del fichero tls/server-tls.c .","title":"Servidor TLS"},{"location":"RPI-II/P2/#cabeceras-y-constantes","text":"El uso de WolfSSL requiere la inclusi\u00f3n de dos cabeceras b\u00e1sicas: #include <wolfssl/options.h> #include <wolfssl/ssl.h> Adem\u00e1s, ya que ser\u00e1n necesarios en el desarrollo, definiremos las rutas al certificado (clave p\u00fablica) del servidor y su clave privada: #define CERT_FILE \"../certs/server-cert.pem\" #define KEY_FILE \"../certs/server-key.pem\" Observa adem\u00e1s que el puerto de escucha del servidor ser\u00e1 el 11111 .","title":"Cabeceras y constantes"},{"location":"RPI-II/P2/#objetos-basicos-wolfssl-contexto-y-objeto-ssl","text":"Definiremos dos objetos b\u00e1sicos que se utilizar\u00e1n de forma recurrente en el c\u00f3digo: WOLFSSL_CTX* ctx; WOLFSSL* ssl; El contexto ( ctx ) incluye valores globales para cada conexi\u00f3n SSL, incluyendo informaci\u00f3n sobre certificados. Es posible utilizar un mismo contexto para m\u00faltiples conexiones, siempre que compartan caracter\u00edsticas. Para crear un nuevo contexto, utilizaremos la funci\u00f3n wolfSSL_CTX_new como sigue: /* Create and initialize WOLFSSL_CTX */ if ((ctx = wolfSSL_CTX_new(wolfTLSv1_2_server_method())) == NULL) { fprintf(stderr, \"ERROR: failed to create WOLFSSL_CTX\\n\"); return -1; } El argumento proporcionado incluye informaci\u00f3n sobre la versi\u00f3n de protocolo a utilizar. Actualmente, WolfSSL soporta SSL 3.0, TLS 1.1, TLS 1.2, DTLS 1.0 y DTLS 1.2. En este caso, para la parte cliente, las funciones a utilizar como argumento ser\u00edan: wolfSSLv3_server_method(); // SSLv3 wolfTLSv1_server_method(); // TLSv1 wolfTLSv1_1_server_method(); // TLSv1.1 wolfTLSv1_2_server_method(); // TLSv1.2 wolfDTLSv1_server_method(); // DTLS wolfDTLSv1_2_server_method(); // DTLS 1.2 En segundo lugar, es necesario cargar nuestra CA (Autoridad Certificadora) en el contexto, para que cualquier cliente pueda verificar, en el momento de su conexi\u00f3n, la identidad del servidor. Para ello, usamos la funci\u00f3n wolfSSL_CTX_use_certificate_file de la siguiente manera: /* Load server certificates into WOLFSSL_CTX */ if (wolfSSL_CTX_use_certificate_file(ctx, CERT_FILE, SSL_FILETYPE_PEM) != SSL_SUCCESS) { fprintf(stderr, \"ERROR: failed to load %s, please check the file.\\n\", CERT_FILE); return -1; } Del mismo modo, el servidor deber\u00e1 incluir su clave privada en formato PEM: /* Load server key into WOLFSSL_CTX */ if (wolfSSL_CTX_use_PrivateKey_file(ctx, KEY_FILE, SSL_FILETYPE_PEM) != SSL_SUCCESS) { fprintf(stderr, \"ERROR: failed to load %s, please check the file.\\n\", KEY_FILE); return -1; } A continuaci\u00f3n, observa como el c\u00f3digo de escucha y aceptaci\u00f3n de conexiones entrantes no difieren de cualquier c\u00f3digo que hayas desarrollado previamente para aceptar conexiones entrantes TCP ( bind , + listen + accept ). Justo tras la conexi\u00f3n ( accept ), resulta necesario crear un nuevo objeto SSL, as\u00ed como asociar el descriptor de socket con la nueva sesi\u00f3n (conexi\u00f3n) TLS: /* Create a WOLFSSL object */ if ((ssl = wolfSSL_new(ctx)) == NULL) { fprintf(stderr, \"ERROR: failed to create WOLFSSL object\\n\"); return -1; } /* Attach wolfSSL to the socket */ wolfSSL_set_fd(ssl, connd); /* Establish TLS connection */ ret = wolfSSL_accept(ssl); if (ret != SSL_SUCCESS) { fprintf(stderr, \"wolfSSL_accept error = %d\\n\", wolfSSL_get_error(ssl, ret)); return -1; } A partir de este punto, podemos enviar y recibir datos a trav\u00e9s del socket (y por tanto de la conexi\u00f3n TLS) de forma muy similar a como lo hacemos con el enfoque cl\u00e1sico. As\u00ed, para recibir datos: if (wolfSSL_read(ssl, buff, sizeof(buff)-1) == -1) { fprintf(stderr, \"ERROR: failed to read\\n\"); return -1; } Y para enviar datos de vuelta: /* Reply back to the client */ if (wolfSSL_write(ssl, buff, len) != len) { fprintf(stderr, \"ERROR: failed to write\\n\"); return -1; } Por \u00faltimo, finalizaremos la conexi\u00f3n con la invocaci\u00f3n de la funci\u00f3n wolfSSL_free(ssl) . Note El cliente proporcionado sigue una estrategia de implementaci\u00f3n similar. Compara ambos c\u00f3digos (cliente y servidor) y aseg\u00farate de entender las diferencias entre ellos. Tarea entregable Compila y ejecuta el sistema cliente/servidor TLS y obt\u00e9n capturas de tr\u00e1fico tanto de las fases de establecimiento de conexi\u00f3n como de las fases de transferencia de datos. En base a lo aprendido en las clases de teor\u00eda y la documentaci\u00f3n adicional sobre TLS y wolfSSL, redacta un breve informe que resuma el proceso de handshake y transferencia de datos en TLS tomando como base los paquetes reales observados para esta conexi\u00f3n.","title":"Objetos b\u00e1sicos WolfSSL. Contexto y objeto SSL"},{"location":"RPI-II/P2/#clienteservidor-dtls-ejemplo-basico-en-host","text":"El desarrollo de un sistema b\u00e1sico cliente/servidor con soporte DTLS utilizando WolfSSL es muy similar al visto anteriormente para TLS. Observa el contenido del fichero dtls/server-dtls.c . Eel c\u00f3digo sigue una filosof\u00eda similar a TLS, adaptado, obviamente, a las caracter\u00edsticas de UDP (tipo de socket, ausencia de conexi\u00f3n, etc.), por lo que se deja como ejercicio su an\u00e1lisis y ejecuci\u00f3n. Tarea entregable Analiza, compila y ejecuta los c\u00f3digos correspondientes al sistema cliente/servidor DTLS. Realiza capturas de tr\u00e1fico y comp\u00e1ralas, paquete a paquete, con las generadas para un patr\u00f3n de tr\u00e1fico similar en el caso de TLS. Incide en sus similitudes y diferencias, tanto a nivel de handshake como de transferencia de datos. Observa, en este \u00faltimo caso, la aparici\u00f3n de nuevos campos de encabezado en los env\u00edos de datos DTLS. \u00bfCu\u00e1l/cu\u00e1les son esos campos y por qu\u00e9 aparecen? Realiza una comparativa del tr\u00e1fico total generado en ambos casos para exactamente la misma cantidad de datos transferidos.","title":"Cliente/servidor DTLS. Ejemplo b\u00e1sico en host"},{"location":"RPI-II/P2/#tls-en-el-esp32-el-componente-wolfssl-version-572","text":"La librer\u00eda WolfSSL est\u00e1 disponible como componente de Espressif . A continuaci\u00f3n veremos un ejemplo de uso de cliente TLS apto para conectarse el servidor anterior. Aunque es posible usar el GUI de la Extensi\u00f3n de ESP-IDF de VSCode, por brevedad vamos a realizar los pasos desde l\u00ednea de comandos en el terminal ESP-IDF Terminal . Moverse a la carpeta d\u00f3nde se quiera importar el ejemplo y ejecutar el siguiente comando. idf.py create-project-from-example \"wolfssl/wolfssl^5.7.2:wolfssl_client\" cd wolfssl_client` Ejecuta la utilidad menuconfig : idf.py menuconfig Y configura los diferentes par\u00e1metros para el dispositivo objetivo, junto con la configuraci\u00f3n local de WiFi: Host de destino: CONFIG_WOLFSSL_TARGET_HOST (en nuestro caso del del host en el que se ejecute el servidor TLS) Puerto de destino: CONFIG_WOLFSSL_TARGET_PORT (por defecto 11111) SSID de WiFi de ejemplo: CONFIG_EXAMPLE_WIFI_SSID Contrase\u00f1a de WiFi de ejemplo: CONFIG_EXAMPLE_WIFI_PASSWORD Cabe se\u00f1alar que los makefiles de este ejemplo no requieren la instalaci\u00f3n de wolfSSL copiando archivos localmente. Es preciso se\u00f1alar que hay un peque\u00f1o error en el c\u00f3digo de ejemplo y preciso realizar la siguiente modificaci\u00f3n del fichero main\\include\\client-tls.h o de lo contrario no usa la direcci\u00f3n destino configurada previamente: /* See main/Kconfig.projbuild for default configuration settings */ #ifdef CONFIG_WOLFSSL_TARGET_HOST #define TLS_SMP_TARGET_HOST CONFIG_WOLFSSL_TARGET_HOST #else #define TLS_SMP_TARGET_HOST \"192.168.1.41\" #endif A continuaci\u00f3n se puede compilar y cargar el firmware para ver el ejemplo en acci\u00f3n. idf.py build idf.py flash idf.py monitor Tarea entregable Compila y ejecuta el cliente TLS en el ESP32, y consigue que interact\u00fae con el servidor TLS que probaste anteriormente en el host . Comprueba que, efectivamente, los datos se transfieren cifrados entre ambos extremos, y que el intercambio de paquetes es similar al que observaste entre cliente y servidor en el host . Tarea entregable Repite el mismo proceso para el cliente DTLS.","title":"TLS en el ESP32. El componente wolfSSL (version 5.7.2)"},{"location":"RPI-II/P2/#tls-en-el-esp32-el-componente-esp-tls","text":"ESP-IDF proporciona un componente (ESP-TLS) que ofrece una interfaz ( API ) simplificada para acceder a funcionalidad b\u00e1sica TLS. A\u00fan as\u00ed, ofrece una funcionalidad suficientemente amplia como para implementar casos de uso comunes en entornos IoT. La API de ESP-TLS es sencilla, y se basa en el uso de cuatro funciones b\u00e1sicas:","title":"TLS en el ESP32. El componente ESP-TLS"},{"location":"RPI-II/P2/#establecimiento-de-conexion-tls-esp_tls_conn_new_sync","text":"Prototipo: int esp_tls_conn_new_sync(const char *hostname, int hostlen, int port, const esp_tls_cfg_t *cfg, esp_tls_t *tls) Descripci\u00f3n: Crea una nueva conexi\u00f3n TLS/SSL bloqueante, estableciendo dicha conexi\u00f3n contra un servidor establecido. Par\u00e1metros: hostname : Identificaci\u00f3n del host. hostlen : Longitud del par\u00e1metro hostname . port : Puerto de conexi\u00f3n con el host. cfg : Configuraci\u00f3n de la conexi\u00f3n TLS. tls : Puntero a esp_tls_t (manejador de la conexi\u00f3n). Devuelve NULL si se produce un error en la conexi\u00f3n.","title":"Establecimiento de conexi\u00f3n TLS (esp_tls_conn_new_sync())"},{"location":"RPI-II/P2/#destruccion-de-conexion-tls-esp_tls_conn_delete","text":"void esp_tls_server_session_delete(esp_tls_t *tls) Descripci\u00f3n: Cierra la conexi\u00f3n TLS/SSL. Par\u00e1metros: tls : Manejador de la conexi\u00f3n.","title":"Destrucci\u00f3n de conexi\u00f3n TLS (esp_tls_conn_delete())"},{"location":"RPI-II/P2/#escritura-de-datos-esp_tls_conn_read","text":"ssize_t esp_tls_conn_write(esp_tls_t *tls, const void *data, size_t datalen) Descripci\u00f3n: Escribe en la conexi\u00f3n TLS/SSL indicada el contenido del buffer data . Par\u00e1metros: tls : Manejador de la conexi\u00f3n. data : Buffer de env\u00edo. datalen : Longitud del buffer de env\u00edo (o n\u00famero m\u00e1ximo de bytes a escribir). Valor de retorno: >=0 : \u00e9xito en el env\u00edo. N\u00famero de bytes efectivamente enviados. <0 : error en el env\u00edo.","title":"Escritura de datos (esp_tls_conn_read())"},{"location":"RPI-II/P2/#lectura-de-datos-esp_tls_conn_read","text":"ssize_t esp_tls_conn_read(esp_tls_t *tls, void *data, size_t datalen) Descripci\u00f3n: Lee desde la conexi\u00f3n TLS/SSL indicada hacia el buffer data . Par\u00e1metros: tls : Manejador de la conexi\u00f3n. data : Buffer de recepci\u00f3n. datalen : Longitud del buffer de recepci\u00f3n (o n\u00famero m\u00e1ximo de bytes a leer). Valor de retorno: >0 : \u00e9xito en la recepci\u00f3n. N\u00famero de bytes efectivamente le\u00eddos. =0 : error en la recepci\u00f3n. La conexi\u00f3n se cerr\u00f3. <0 : error en la recepci\u00f3n.","title":"Lectura de datos (esp_tls_conn_read())"},{"location":"RPI-II/P2/#estructura-basica-de-un-cliente-tcp-usando-esp-idf","text":"Un cliente TCP implementado sobre ESP-IDF para dar soporte TLS, requiere ciertas modificaciones con respecto a la versi\u00f3n sin TLS. De hecho, el uso de ESP-IDF simplifica el c\u00f3digo del cliente. La estructura b\u00e1sica resultar\u00eda: /// Includes anteriores. #include \"esp_tls.h\" // Puede tomarse desde menuconfig. #define HOST_IP_ADDR DIRECCION_DE_HOST #define PORT PUERTO static const char *payload = \"Hola, mundo via TLS\"; // ... static void tls_client_task( void *pvParameters ) { // ... // Configuraci\u00f3n de ESP-TLS (vac\u00edo para opciones defecto). esp_tls_cfg_t cfg = { }; // Creaci\u00f3n de conexi\u00f3n. struct esp_tls tls; ret = esp_tls_conn_new_sync( HOST_IP_ADDR, longitud, PORT, &cfg, &tls); // Chequeo de errores. // ... // Env\u00edo de datos. ret = esp_tls_conn_write(tls, payload, strlen(payload)); // Chequeo de errores. // ... // Lectura de datos ret = esp_tls_conn_read(tls, (char *)rx_buffer, 128); // Chequeo de errores. // ... // Destrucci\u00f3n de la conexi\u00f3n esp_tls_server_session_delete( tls ); vTaskDelete( NULL ); } void app_main( void ) { // ... } Tarea entregable Estudia y prueba el ejemplo base examples/protocols/https_request . Opcionalmente, modifica este ejemplo para que interactue con el servidor TLS empleando previamente.","title":"Estructura b\u00e1sica de un cliente TCP usando ESP-IDF"},{"location":"RPI-II/P2/#desactivacion-de-la-comprobacion-de-certificado-de-servidor","text":"Basta con modificar la configuraci\u00f3n del proyecto del siguiente modo: # CONFIG_EXAMPLE_CLIENT_SESSION_TICKETS is not set CONFIG_ESP_TLS_INSECURE=y CONFIG_ESP_TLS_SKIP_SERVER_CERT_VERIFY=y # CONFIG_MBEDTLS_CERTIFICATE_BUNDLE is not set Y comentar est\u00e1s l\u00edneas del fichero https_request_example_main.c para borrar la configuraci\u00f3n de la entidad de certificaci\u00f3n (de lo contrario prevalecer\u00eda sobre la opci\u00f3n CONFIG_ESP_TLS_SKIP_SERVER_CERT_VERIFY ): esp_tls_cfg_t cfg = { // .cacert_buf = (const unsigned char *) server_root_cert_pem_start, // .cacert_bytes = server_root_cert_pem_end - server_root_cert_pem_start, ... };","title":"Desactivaci\u00f3n de la comprobaci\u00f3n de certificado de servidor"},{"location":"RPI-II/P2/#servidor-web-de-test-con-certificado-autofirmado","text":"Para comprobar el ejemplo examples/protocols/https_request con un servidor https local con certificado autofirmado se pueden emplear los siguientes comandos de openssl . Generaci\u00f3n del certificado autofirmado. Es preciso proporciona cierta informaci\u00f3n, entre otras cosas la direcci\u00f3n IP o nombre del host. openssl openssl genrsa -out server.key 2048 openssl openssl req -new -x509 -key server.key -out server.crt -days 365 You are about to be asked to enter information that will be incorporated into your certificate request. What you are about to enter is what is called a Distinguished Name or a DN. There are quite a few fields but you can leave some blank For some fields there will be a default value, If you enter '.', the field will be left blank. ----- Country Name (2 letter code) [AU]:ES State or Province Name (full name) [Some-State]:Madrid Locality Name (eg, city) []:Madrid Organization Name (eg, company) [Internet Widgits Pty Ltd]:UCM Organizational Unit Name (eg, section) []:FDI Common Name (e.g. server FQDN or YOUR name) []:<IP HOST> Email Address []:lpinuel@ucm.es Arranque del servidor web . openssl openssl s_server -accept 8443 -cert server.crt -key server.key -www Using default temp DH parameters ACCEPT","title":"Servidor web de test con certificado autofirmado"},{"location":"RPI-II/P2_old/","text":"Pr\u00e1ctica 1. Programaci\u00f3n con sockets en C Objetivos Familiarizarse con la API de sockets en C. Desarrollar esquemas b\u00e1sicos de sistemas cliente/servidor TCP y UDP utilizando C. Ser capaces de analizar el tr\u00e1fico generado en una conexi\u00f3n TCP y UDP a trav\u00e9s de Wireshark. Dise\u00f1ar un protocolo de capa de aplicaci\u00f3n para simular una aplicaci\u00f3n cliente/servidor utilizando TCP y UDP para interactuar entre un host y la placa ESP32 Introducci\u00f3n La historia de los sockets se remonta al origen de ARPANET, en 1971, y su posterior estandarizaci\u00f3n en forma de API dentro del sistema operativo Berkeley Software Distribution (BSD) , liberado en 1983, bajo el nombre de sockets de Berkeley . Con la popularizaci\u00f3n de Internet en los a\u00f1os 90, y de la mano de la World Wide Web , la programaci\u00f3n de red sufri\u00f3 tambi\u00e9n una notable evoluci\u00f3n. Los servidores web y los navegadores no fueron (ni son) las \u00fanicas aplicaciones basadas en sockets . De hecho, los sistemas cliente/servidor son a d\u00eda de hoy ubicuos e incluyen, por supuesto, a todos los protocolos de alto nivel que dan soporte a Internet de las Cosas. De hecho, a d\u00eda de hoy, aunque los potocolos de alto nivel (capa de aplicaci\u00f3n) han evolucionado hasta niveles de sofisticaci\u00f3n no considerados en sus inicios, la API de bajo nivel sobre la que se basan se mantiene inalterada. El tipo m\u00e1s com\u00fan de aplicaciones basadas en sockets se basa en el paradigma cliente/servidor, donde una de las partes act\u00faa como servidor , esperando pasivamente conexiones desde un conjunto de uno o m\u00e1s clientes . A continuaci\u00f3n, veremos c\u00f3mo desarrollar este tipo de paradigma desde Python, utilizando sockets Berkeley . Existen tambi\u00e9n los llamados Unix domain sockets , que permiten la comunicaci\u00f3n directa entre procesos en el mismo host , aunque quedan fuera de nuestro inter\u00e9s en el \u00e1mbito de IoT. En la pr\u00e1ctica anterior, vimos c\u00f3mo desarrollar sistemas cliente/servidor sencillos utilizando Python, tanto en sus variantes TCP como UDP. El objetivo de la presente pr\u00e1ctica es estudiar y desarrollar componentes de red (clientes y servidores TCP y UDP) que puedan ejecutarse sobre el ESP32 haciendo uso de las facilidades propuestas por ESP-IDF. Adem\u00e1s, demostraremos que es posible hacer interactuar clientes y servidores ejecut\u00e1ndose indistintamente en la m\u00e1quina virtual (programados v\u00eda Python) y en la propia placa (utilizando la API de sockets de C). La API de sockets en C Funciones para ordenacion de bytes Como TCP/IP es un est\u00e1ndar universal, y permite comunicaciones entre cualquier plataforma y arquitectura, es necesario disponer de un m\u00e9todo de ordenaci\u00f3n de los bytes para que m\u00e1quinas big-endian y little-endian puedan comunicarse de forma transparente y correcta. Para ello, se suelen proporcionar rutinas de reordenaci\u00f3n de bytes. En plataformas donde los datos ya est\u00e1n correctamente ordenados, estas funciones no tienen ninguna funcionalidad especial, pero en cualquier caso, es necesario utilizarlas siempre para que la comunicaci\u00f3n entre pares sea correcta. Las funciones t\u00edpicas de reordenaci\u00f3n de datos son cuatro: htons , htonl , ntohs y ntohl . Su nombre explica correctamente su sem\u00e1ntica: host to network (short) host to network (long) , network to host (short) y network to host (long) , convirtiendo tipos de datos short y long desde el formato utilizado en transmisiones de red ( network ) a representaci\u00f3n en el host . As\u00ed, siempre que enviemos un dato binario por la red, deber\u00e1 ser transformado utilizando hton* y cuando lo recibamos y debamos procesarlo, utilizando ntoh* . Estructuras de datos Antes de estudiar la API de sockets b\u00e1sica, es necesario mostrar el cometido de un conjunto de estructuras de datos utilizadas com\u00fanmente en todas ellas. La m\u00e1s importante es sockaddr_in , que se define como sigue: struct sockaddr_in { short sin_family; u_short sin_port; struct in_addr sin_addr; char sin_zero[8]; }; La estructura in_addr utilizada en sockaddr_in se define como: struct in_addr { u_long s_addr; }; \u00c9sta consiste en un campo de tipo unsigned long int que contiene la direcci\u00f3n IP que se asociar\u00e1 con el socket. La estructura sockaddr_in contiene dos campos importantes: sin_family : que indica al socket qu\u00e9 familia de protocolos se utilizar\u00e1n (usaremos la constante AF_INET para IPv4). sin_port : que indica el puerto asociado al socket. API b\u00e1sica socket() Prototipo: int socket(int family, int type, int protocol); Descripci\u00f3n: Crea un endpoint de comunicaci\u00f3n y devuelve un descriptor de fichero para manejarlo. Par\u00e1metros: family : AF_INET (IPv4), AF_INET6 (IPv6). type : SOCK_DGRAM (UDP), SOCK_STREAM (TCP), SOCK_RAW . protocol : T\u00edpicamente 0 (no usado en sockets de Internet). Valor de retorno: Si tiene \u00e9xito, devuelve el descriptor de socket . Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de socket ( man socket ). bind() Prototipo: int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); Descripci\u00f3n: Asocia un socket a una direcci\u00f3n especificada por addr . Normalmente, es necesario asignar una direcci\u00f3n local v\u00eda esta funci\u00f3n antes de que un socket TCP pueda recibir conexiones. Par\u00e1metros: sockfd : descriptor de socket (devuelto por socket ). addr : direcci\u00f3n a asociar (v\u00e9ase estructura en secci\u00f3n anterior). addrlen : longitud (en bytes) de la anterior estructura. Valor de retorno: Si tiene \u00e9xito, devuelve 0. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de bind ( man bind ). listen() Prototipo: int listen(int sockfd, int backlog); Descripci\u00f3n: Marca el socket proporcionado como pasivo , esto es, un socket que podr\u00e1 ser utilizado para aceptar conexiones entrantes usando la llamada accept . Par\u00e1metros: sockfd : descriptor de socket (devuelto por socket ). backlog : longitud m\u00e1xima que podr\u00e1 tener la cola de conexiones pendientes para el socket . Si se sobrepasa, el cliente recibir\u00e1 un error en su intento de conexi\u00f3n. Valor de retorno: Si tiene \u00e9xito, devuelve 0. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de listen ( man listen ). accept() Prototipo: int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); Descripci\u00f3n: En sockets orientados a conexi\u00f3n, extrae la primera solicitud de conexi\u00f3n de la cola de conexiones pendientes para el socket proporcionado, crea un nuevo socket conectado y devuelve su descriptor. Par\u00e1metros: sockfd : descriptor de socket (devuelto por socket ). addr : es un puntero a una estructura de tipo sockaddr , cuyos campos ser\u00e1n rellenados con los datos de direcci\u00f3n del socket remoto. addrlen : tama\u00f1o de la estructura addr . Valor de retorno: Si tiene \u00e9xito, devuelve el descriptor de socket. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de accept ( man accept ). connect() Prototipo: int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); Descripci\u00f3n: Conecta el socket proporcionada a la direcci\u00f3n especificada por addr . Si el socket es UDP, addr ser\u00e1 la direcci\u00f3n a la que se enviar\u00e1n los datagramas por defecto, y la \u00fanica desde la que se recibir\u00e1n datagramas. En caso de TCP, esta llamada inicia el proceso de conexi\u00f3n a la direcci\u00f3n especificada. Par\u00e1metros: sockfd : descriptor de socket (devuelto por socket ). addr : es un puntero a una estructura de tipo sockaddr , cuyos campos indican la direcci\u00f3n de conexi\u00f3n destino. addrlen : tama\u00f1o de la estructura addr . Valor de retorno: Si tiene \u00e9xito, devuelve el descriptor de socket. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de connect ( man connect ). send() Prototipo: ssize_t send(int sockfd, const void *buf, size_t len, int flags); Descripci\u00f3n: En un socket en estado conectado (con receptor conocido) transmite mensajes a un socket remoto. Par\u00e1metros: sockfd : descriptor de socket de env\u00edo. buf : buffer de env\u00edo donde se almacena el mensaje a enviar. len : n\u00famero de bytes a enviar. Valor de retorno: Si tiene \u00e9xito, devuelve el n\u00famero de bytes enviados. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de send ( man send ). recv() / recvfrom() Prototipos: ssize_t recv(int sockfd, void *buf, size_t len, int flags); ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen); Descripci\u00f3n: Reciben mensajes desde un socket , tanto en sockets orientados como no orientados a conexi\u00f3n. recvfrom , a diferencia de recv , recibe par\u00e1metros de salida adicionales que almacenan informaci\u00f3n sobre la direcci\u00f3n origen del mensaje. Par\u00e1metros: sockfd : descriptor de socket de recepci\u00f3n. buf : buffer de recepci\u00f3n donde se almacena el mensaje a recibir. len : n\u00famero de bytes a recibir. src_addr : direcci\u00f3n del extremo remoto del socket (origen de la comunicaci\u00f3n). addrlen : tama\u00f1o de la estructura src_addr . Valor de retorno: Si tiene \u00e9xito, devuelve el n\u00famero de bytes recibidos. Devuelve -1 si se produce un error. Detalles: consultad las p\u00e1ginas de manual de recv y recv_from ( man recv y man recv_from ). close() Prototipo: int close(int fd); Descripci\u00f3n: Cierra un socket. Par\u00e1metros: fd : descriptor de socket . Detalles: consultad la p\u00e1gina de manual de close ( man close ). Ejemplos Se proporcionan a continuaci\u00f3n ejemplos completos de uso de la API de sockets en C para el desarrollo de sistemas cliente/servidor sencillos. Para cada uno de ellos, comprueba que, efectivamente, el uso y secuencia de aplicaci\u00f3n de cada llamada sigue las directivas de la figura: Tarea Compila (utilizando la oren gcc ejemplo.c -o ejemplo.x desde una terminal) y a continuaci\u00f3n ejecuta ( ./ejemplo.x ) cada par de c\u00f3digos y comprueba su funcionamiento. Estudia con detenimiento el uso de cada rutina y como efectivamente siguen las directivas marcadas anteriormente. Si no tienes experiencia en desarrollo en C, consulta las p\u00e1ginas de manual correspondientes, o con tu profesor, para resolver todas tus dudas. Aseg\u00farate de entender el proceso de compilaci\u00f3n, enlazado y ejecuci\u00f3n de un binario. Ejemplo: un cliente TCP #include <arpa/inet.h> #include <stdio.h> #include <string.h> #include <sys/socket.h> #include <unistd.h> #include <netinet/in.h> int main() { const int server_port = 9000; struct sockaddr_in server_address; memset(&server_address, 0, sizeof(server_address)); server_address.sin_family = AF_INET; server_address.sin_addr.s_addr = inet_addr(\"127.0.0.1\"); server_address.sin_port = htons(server_port); int sock; if ((sock = socket(PF_INET, SOCK_STREAM, 0)) < 0) { printf(\"Error en socket\\n\"); return 1; } if (connect(sock, (struct sockaddr*)&server_address, sizeof(server_address)) < 0) { printf(\"Error en connect\\n\"); return 1; } const char* data_to_send = \"Hola, RPI!!\"; send(sock, data_to_send, strlen(data_to_send), 0); int n = 0; int len = 0, maxlen = 100; char buffer[maxlen]; char* pbuffer = buffer; if ((n = recv(sock, pbuffer, maxlen, 0)) > 0) { pbuffer += n; maxlen -= n; len += n; buffer[len] = '\\0'; printf(\"Recibido: '%s'\\n\", buffer); } close(sock); return 0; } Ejemplo: un servidor TCP #include <arpa/inet.h> #include <netinet/in.h> #include <stdbool.h> #include <stdio.h> #include <string.h> #include <unistd.h> int main(int argc, char *argv[]) { int SERVER_PORT = 9000; struct sockaddr_in server_address; memset(&server_address, 0, sizeof(server_address)); server_address.sin_family = AF_INET; server_address.sin_port = htons(SERVER_PORT); server_address.sin_addr.s_addr = htonl(INADDR_ANY); int listen_sock; if ((listen_sock = socket(PF_INET, SOCK_STREAM, 0)) < 0) { printf(\"Error en socket\\n\"); return 1; } if ((bind(listen_sock, (struct sockaddr *)&server_address, sizeof(server_address))) < 0) { printf(\"Error en bind\\n\"); return 1; } int wait_size = 16; if (listen(listen_sock, wait_size) < 0) { printf(\"Error en listen\\n\"); return 1; } struct sockaddr_in client_address; int client_address_len = 0; while (true) { int sock; if ((sock = accept(listen_sock, (struct sockaddr *)&client_address, &client_address_len)) < 0) { printf(\"Error en accept\\n\"); return 1; } int n = 0; int len = 0, maxlen = 100; char buffer[maxlen]; char *pbuffer = buffer; printf(\"Cliente conectado con IP: %s\\n\", inet_ntoa(client_address.sin_addr)); while ((n = recv(sock, pbuffer, maxlen, 0)) > 0) { pbuffer += n; maxlen -= n; len += n; printf(\"Recibido: '%s'\\n\", buffer); send(sock, buffer, len, 0); } close(sock); } close(listen_sock); return 0; } Tarea Reproduce el funcionamiento del anterior sistema cliente/servidor echo utilizando UDP. Capturas de tr\u00e1fico v\u00eda Wireshark Wireshark es una herramienta de c\u00f3digo abierto ampliamente utilizada para analizar protocolos de comunicaci\u00f3n de red en cualquiera de las capas de la pila TCP/IP (como tambi\u00e9n en otros protocolos). Wireshark implementa un amplio abanico de filtros para definir criterios de b\u00fasqueda en las capturas de tr\u00e1fico, aunque de momento, en nuestro caso, no ser\u00e1 necesario utilizar filtros espec\u00edficos. Para arrancar Wireshark en la m\u00e1quina virtual proporcionada (o en cualquier instalaci\u00f3n b\u00e1sica Linux), teclea en tu terminal: $ sudo wireshark Tras el arranque, podemos comenzar una nueva captura de tr\u00e1fico a trav\u00e9s del men\u00fa Capture , opci\u00f3n Start . La pantalla de selecci\u00f3n de interfaz nos permitir\u00e1 definir en qu\u00e9 interfaz de red se realizar\u00e1 la captura. En nuestro caso, ya que vamos a comunicar dos procesos en la misma m\u00e1quina, elegiremos la interfaz de Loopback (lo) y comenzaremos la captura. Tarea Arranca Wireshark y prepara una captura sobre la interfaz de loopback de tu m\u00e1quina. Ejecuta el servidor echo TCP y el cliente correspondiente, y analiza el tr\u00e1fico generado. Especialmente, f\u00edjate en el proceso de establecimiento de conexi\u00f3n en tres v\u00edas, paquetes de Acknowledge tras el env\u00edo de cada mensaje y, en general, en cualquier otro aspecto que consideres de inter\u00e9s. Construcci\u00f3n de mensajes Para enviar mensajes que encapsulen distintos tipos de datos en una sola invocaci\u00f3n, puedes definir un mensaje como el siguiente: typedef struct { int x; int y; } mensaje; Dando valor a cada campo y a continuaci\u00f3n envi\u00e1ndolo proporcionando la direcci\u00f3n de inicio de la estructura, del siguiente modo: mensaje.x = x; mensaje.y = y; send( socketfd, &mensaje, sizeof( mensaje ), 0 ); Tarea entregable Se pide dise\u00f1ar un sistema cliente/servidor programado en C, que simule el env\u00edo de un conjunto de datos sensorizados desde un cliente hacia un servidor. El protocolo a utilizar (formato de datos enviado por la red a nivel de aplicaci\u00f3n) debe ser propuesto por el propio alumno y descrito previamente al desarrollo. Se valorar\u00e1 el uso de m\u00faltiples tipos de datos tanto en el env\u00edo de datos sensorizados como de posibles respuestas por parte del servidor. Se desarrollar\u00e1 una versi\u00f3n utilizando TCP y otra equivalente usando UDP. El cliente enviar\u00e1 los datos de forma peri\u00f3dica y se \u00e9stos generar\u00e1n de modo aleatorio. A modo de entrega, se solicitan los c\u00f3digos desarrollados, as\u00ed como un an\u00e1lisis del tr\u00e1fico generado, considerando la sobrecarga (en bytes reales enviados) introducida por cada protocolo de capa de transporte. Sistemas cliente/servidor en el ESP32 La raz\u00f3n por la que hemos ejercitado el uso de la API de sockets desde C en Linux es que la implementaci\u00f3n de la pila TCP/IP en ESP-IDF (llamada Lightweight TCP/IP (lwIP) ) implementa al 100% dicha API. Por tanto, tanto la estructura b\u00e1sica de un firmware que implemente un cliente o servidor como la API utilizada permanece inalterada. En esta \u00faltima secci\u00f3n, se pide trabajar con dos ejemplos b\u00e1sicos de implementaci\u00f3n de sistemas cliente/servidor UDP y TCP sobre el ESP32, con el objetivo de estudiar su funcionalidad, comprobar su interoperabilidad y realizar modificaciones para adaptarlas a una hipot\u00e9tica aplicaci\u00f3n IoT. Cliente/servidor UDP en el ESP32 En esta parte, trabajar\u00e1s con dos ejemplos proporcionados dentro de la colecci\u00f3n de ejemplos de ESP-IDF. Por tanto, copia en tu espacio de trabajo (fuera del \u00e1rbol principal de ESP-IDF) los ejemplos: Servidor UDP : examples/protocols/sockets/udp_server/ Cliente UDP : examples/protocols/sockets/udp_client/ Estructura general Observa sus c\u00f3digos ( udp_server.c para el servidor, y udp_client.c para el cliente). Comprueba que, tanto la estructura b\u00e1sica de ambos componentes como las invocaciones a la API de sockets concuerdan con las que vimos para el sistema echo programado en C. Acerca de la tarea principal (funci\u00f3n app_main ) observa que realiza una serie de llamadas a APIs de configuraci\u00f3n de algunos subsistemas de FreeRTOS, principalmente: // Inicializa la partici\u00f3n NVS (Non-volatile storage) por defecto. ESP_ERROR_CHECK(nvs_flash_init()); // Inicializa la infraestructura ESP-NETIF. ESP_ERROR_CHECK(esp_netif_init()); // Crea un bucle de eventos por defecto. ESP_ERROR_CHECK(esp_event_loop_create_default()); /* Esta funci\u00f3n configura WiFi o Ethernet, tal y como seleccionemos via menuconfig. */ ESP_ERROR_CHECK(example_connect()); xTaskCreate(udp_server_task, \"udp_server\", 4096, NULL, 5, NULL); example_connect() , funci\u00f3n que no forma parte de ESP-IDF, establece una conexi\u00f3n WiFi o Ethernet. La funci\u00f3n es bloqueante, y retorna cuando se ha conseguido establecer una conexi\u00f3n. Las caracter\u00edsticas de la conexi\u00f3n WiFi (SSID y contrase\u00f1a) se deben proporcionar a trav\u00e9s de menuconfig . El objetivo de ESP-NETIF es proporcionar una capa de abstracci\u00f3n por encima de la pila TCP/IP, de modo que pueda migrarse la pila sin que los c\u00f3digos del usuario cambien. Puedes consultar su documentaci\u00f3n en la p\u00e1gina oficial . Por \u00faltimo, se crea una tarea que ejecutar\u00e1 la l\u00f3gica del servidor (lo mismo ocurre en el cliente). Observa que, en todo el c\u00f3digo, los mensajes de error se anotan utilizando la macro ESP_LOGE y los informativos con ESP_LOGI ; intenta seguir este convenio en tus c\u00f3digos. Despliegue. Opci\u00f3n 1 En este caso, desplegar\u00e1s el cliente en un ESP32 y el servidor en otro. Si no dispones de dos ESP32, puedes trabajar con un compa\u00f1ero. En cualquier caso, ambos ESP32 deben pertenecer a la misma red inal\u00e1mbrica, por lo que deber\u00e1n conectarse a un mismo punto de acceso (el profesor te proporcionar\u00e1 los datos, o simplemente puedes utilizar tu punto de acceso dom\u00e9stico). Configura los siguientes puntos de la infraestructura: Configura el SSID y contrase\u00f1a del punto de acceso v\u00eda menuconfig antes de compilar y flashear el c\u00f3digo tanto en el cliente como en el servidor. En el servidor, configura v\u00eda menuconfig el puerto sobre el que escuchar\u00e1. Arranca primero el nodo servidor y apunta la IP proporcionada por el punto de acceso; util\u00edzala en el cliente para configurar la IP destino de la comunicaci\u00f3n. No olvides configurar tambi\u00e9n el puerto destino de acuerdo al configurado en el servidor v\u00eda menuconfig . \u00can este punto, podr\u00e1s arrancar el cliente y deber\u00edas estar comunicando dos nodos ESP32 v\u00eda UDP. Despliegue. Opci\u00f3n 2 Si s\u00f3lo dispones de un nodo, o si simplemente quieres probar otra forma de comunicaci\u00f3n en la que uno de los equipos es un PC, puedes utilizar alguna de las herramientas del sistema: Nota Ten en cuenta que port\u00e1til (es decir, m\u00e1quina virtual) y ESP32 deben pertenecer\u00e1 la misma red. Para conseguirlo, para tu m\u00e1quina virtual y a\u00f1ade una nueva interfaz de red de tipo bridge conectada a la interfaz Wifi f\u00edsica de tu PC. As\u00ed, tendr\u00e1s una interfaz con IP en la misma red, otorgada directamente por tu punto de acceso. Para recibir un paquete UDP a trav\u00e9s de un puerto (es decir, emular un servidor UDP): nc -ul -p 3333 Para enviar un paquete UDP a una IP/puerto remotos (es decir, emular un cliente): nc -u IP_REMOTA 3333 En el directorio scripts dispones tambi\u00e9n de peque\u00f1os ejemplos de clientes y servidores UDP Python que puedes tambi\u00e9n utilizar. Cliente/servidor TCP en el ESP32 El despliegue de cliente y servidor TCP es equivalente al UDP. Para recibir un paquete TCP a trav\u00e9s de un puerto (es decir, emular un servidor TCP): nc -l IP -p 3333 Para enviar un paquete TCP a una IP/puerto remotos (es decir, emular un cliente): nc IP 3333 En el directorio scripts dispones tambi\u00e9n de peque\u00f1os ejemplos de clientes y servidores TCP Python que puedes tambi\u00e9n utilizar. Tarea Experimenta con los ejemplos proporcionados en ESP-IDF (cliente/servidor TCP y UDP) y consigue ejecutar todos los elementos en la placa. Si s\u00f3lo dispones de una placa, utiliza la m\u00e1quina virtual como cliente/servidor para comprobar el correcto funcionamiento de cada c\u00f3digo. Tarea entregable En este punto, deber\u00edas disponer de un conjunto de c\u00f3digos que implementan sistemas cliente/servidor tanto en un host (utilizando Python y/o C) como en la placa ESP32 (utilizando C y ESP-IDF), y deber\u00edas haber comprobado su correcto funcionamiento. Espec\u00edficamente, dispondr\u00e1s de: Sistema cliente/servidor desarrollado en la Pr\u00e1ctica 1, escrito en Python e implementando un protocolo b\u00e1sico de aplicacion (tipo de mensaje) propuesto por ti. C\u00f3digo b\u00e1sico en C para implementaci\u00f3n de un servidor/cliente echo programado en C, cuyos c\u00f3digos se proporcionan en este bolet\u00edn. C\u00f3digos b\u00e1sicos en C/ESP-IDF para implementar servidores/clientes echo sobre el ESP32. Como tarea entregable, se pide que adaptes tu entrega de la Pr\u00e1ctica 1 para que tanto cliente como servidor puedan funcionar en el host (bien usando tu implementaci\u00f3n Python, o bien utilizando una nueva implementaci\u00f3n en C) o en el ESP32. Se entregar\u00e1n los c\u00f3digos y una breve memoria con capturas de tr\u00e1fico que demuestren el correcto funcionamiento del sistema.","title":"Pr\u00e1ctica 1. Programaci\u00f3n con sockets en C"},{"location":"RPI-II/P2_old/#practica-1-programacion-con-sockets-en-c","text":"","title":"Pr\u00e1ctica 1. Programaci\u00f3n con sockets en C"},{"location":"RPI-II/P2_old/#objetivos","text":"Familiarizarse con la API de sockets en C. Desarrollar esquemas b\u00e1sicos de sistemas cliente/servidor TCP y UDP utilizando C. Ser capaces de analizar el tr\u00e1fico generado en una conexi\u00f3n TCP y UDP a trav\u00e9s de Wireshark. Dise\u00f1ar un protocolo de capa de aplicaci\u00f3n para simular una aplicaci\u00f3n cliente/servidor utilizando TCP y UDP para interactuar entre un host y la placa ESP32","title":"Objetivos"},{"location":"RPI-II/P2_old/#introduccion","text":"La historia de los sockets se remonta al origen de ARPANET, en 1971, y su posterior estandarizaci\u00f3n en forma de API dentro del sistema operativo Berkeley Software Distribution (BSD) , liberado en 1983, bajo el nombre de sockets de Berkeley . Con la popularizaci\u00f3n de Internet en los a\u00f1os 90, y de la mano de la World Wide Web , la programaci\u00f3n de red sufri\u00f3 tambi\u00e9n una notable evoluci\u00f3n. Los servidores web y los navegadores no fueron (ni son) las \u00fanicas aplicaciones basadas en sockets . De hecho, los sistemas cliente/servidor son a d\u00eda de hoy ubicuos e incluyen, por supuesto, a todos los protocolos de alto nivel que dan soporte a Internet de las Cosas. De hecho, a d\u00eda de hoy, aunque los potocolos de alto nivel (capa de aplicaci\u00f3n) han evolucionado hasta niveles de sofisticaci\u00f3n no considerados en sus inicios, la API de bajo nivel sobre la que se basan se mantiene inalterada. El tipo m\u00e1s com\u00fan de aplicaciones basadas en sockets se basa en el paradigma cliente/servidor, donde una de las partes act\u00faa como servidor , esperando pasivamente conexiones desde un conjunto de uno o m\u00e1s clientes . A continuaci\u00f3n, veremos c\u00f3mo desarrollar este tipo de paradigma desde Python, utilizando sockets Berkeley . Existen tambi\u00e9n los llamados Unix domain sockets , que permiten la comunicaci\u00f3n directa entre procesos en el mismo host , aunque quedan fuera de nuestro inter\u00e9s en el \u00e1mbito de IoT. En la pr\u00e1ctica anterior, vimos c\u00f3mo desarrollar sistemas cliente/servidor sencillos utilizando Python, tanto en sus variantes TCP como UDP. El objetivo de la presente pr\u00e1ctica es estudiar y desarrollar componentes de red (clientes y servidores TCP y UDP) que puedan ejecutarse sobre el ESP32 haciendo uso de las facilidades propuestas por ESP-IDF. Adem\u00e1s, demostraremos que es posible hacer interactuar clientes y servidores ejecut\u00e1ndose indistintamente en la m\u00e1quina virtual (programados v\u00eda Python) y en la propia placa (utilizando la API de sockets de C).","title":"Introducci\u00f3n"},{"location":"RPI-II/P2_old/#la-api-de-sockets-en-c","text":"","title":"La API de sockets en C"},{"location":"RPI-II/P2_old/#funciones-para-ordenacion-de-bytes","text":"Como TCP/IP es un est\u00e1ndar universal, y permite comunicaciones entre cualquier plataforma y arquitectura, es necesario disponer de un m\u00e9todo de ordenaci\u00f3n de los bytes para que m\u00e1quinas big-endian y little-endian puedan comunicarse de forma transparente y correcta. Para ello, se suelen proporcionar rutinas de reordenaci\u00f3n de bytes. En plataformas donde los datos ya est\u00e1n correctamente ordenados, estas funciones no tienen ninguna funcionalidad especial, pero en cualquier caso, es necesario utilizarlas siempre para que la comunicaci\u00f3n entre pares sea correcta. Las funciones t\u00edpicas de reordenaci\u00f3n de datos son cuatro: htons , htonl , ntohs y ntohl . Su nombre explica correctamente su sem\u00e1ntica: host to network (short) host to network (long) , network to host (short) y network to host (long) , convirtiendo tipos de datos short y long desde el formato utilizado en transmisiones de red ( network ) a representaci\u00f3n en el host . As\u00ed, siempre que enviemos un dato binario por la red, deber\u00e1 ser transformado utilizando hton* y cuando lo recibamos y debamos procesarlo, utilizando ntoh* .","title":"Funciones para ordenacion de bytes"},{"location":"RPI-II/P2_old/#estructuras-de-datos","text":"Antes de estudiar la API de sockets b\u00e1sica, es necesario mostrar el cometido de un conjunto de estructuras de datos utilizadas com\u00fanmente en todas ellas. La m\u00e1s importante es sockaddr_in , que se define como sigue: struct sockaddr_in { short sin_family; u_short sin_port; struct in_addr sin_addr; char sin_zero[8]; }; La estructura in_addr utilizada en sockaddr_in se define como: struct in_addr { u_long s_addr; }; \u00c9sta consiste en un campo de tipo unsigned long int que contiene la direcci\u00f3n IP que se asociar\u00e1 con el socket. La estructura sockaddr_in contiene dos campos importantes: sin_family : que indica al socket qu\u00e9 familia de protocolos se utilizar\u00e1n (usaremos la constante AF_INET para IPv4). sin_port : que indica el puerto asociado al socket.","title":"Estructuras de datos"},{"location":"RPI-II/P2_old/#api-basica","text":"","title":"API b\u00e1sica"},{"location":"RPI-II/P2_old/#socket","text":"Prototipo: int socket(int family, int type, int protocol); Descripci\u00f3n: Crea un endpoint de comunicaci\u00f3n y devuelve un descriptor de fichero para manejarlo. Par\u00e1metros: family : AF_INET (IPv4), AF_INET6 (IPv6). type : SOCK_DGRAM (UDP), SOCK_STREAM (TCP), SOCK_RAW . protocol : T\u00edpicamente 0 (no usado en sockets de Internet). Valor de retorno: Si tiene \u00e9xito, devuelve el descriptor de socket . Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de socket ( man socket ).","title":"socket()"},{"location":"RPI-II/P2_old/#bind","text":"Prototipo: int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); Descripci\u00f3n: Asocia un socket a una direcci\u00f3n especificada por addr . Normalmente, es necesario asignar una direcci\u00f3n local v\u00eda esta funci\u00f3n antes de que un socket TCP pueda recibir conexiones. Par\u00e1metros: sockfd : descriptor de socket (devuelto por socket ). addr : direcci\u00f3n a asociar (v\u00e9ase estructura en secci\u00f3n anterior). addrlen : longitud (en bytes) de la anterior estructura. Valor de retorno: Si tiene \u00e9xito, devuelve 0. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de bind ( man bind ).","title":"bind()"},{"location":"RPI-II/P2_old/#listen","text":"Prototipo: int listen(int sockfd, int backlog); Descripci\u00f3n: Marca el socket proporcionado como pasivo , esto es, un socket que podr\u00e1 ser utilizado para aceptar conexiones entrantes usando la llamada accept . Par\u00e1metros: sockfd : descriptor de socket (devuelto por socket ). backlog : longitud m\u00e1xima que podr\u00e1 tener la cola de conexiones pendientes para el socket . Si se sobrepasa, el cliente recibir\u00e1 un error en su intento de conexi\u00f3n. Valor de retorno: Si tiene \u00e9xito, devuelve 0. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de listen ( man listen ).","title":"listen()"},{"location":"RPI-II/P2_old/#accept","text":"Prototipo: int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); Descripci\u00f3n: En sockets orientados a conexi\u00f3n, extrae la primera solicitud de conexi\u00f3n de la cola de conexiones pendientes para el socket proporcionado, crea un nuevo socket conectado y devuelve su descriptor. Par\u00e1metros: sockfd : descriptor de socket (devuelto por socket ). addr : es un puntero a una estructura de tipo sockaddr , cuyos campos ser\u00e1n rellenados con los datos de direcci\u00f3n del socket remoto. addrlen : tama\u00f1o de la estructura addr . Valor de retorno: Si tiene \u00e9xito, devuelve el descriptor de socket. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de accept ( man accept ).","title":"accept()"},{"location":"RPI-II/P2_old/#connect","text":"Prototipo: int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); Descripci\u00f3n: Conecta el socket proporcionada a la direcci\u00f3n especificada por addr . Si el socket es UDP, addr ser\u00e1 la direcci\u00f3n a la que se enviar\u00e1n los datagramas por defecto, y la \u00fanica desde la que se recibir\u00e1n datagramas. En caso de TCP, esta llamada inicia el proceso de conexi\u00f3n a la direcci\u00f3n especificada. Par\u00e1metros: sockfd : descriptor de socket (devuelto por socket ). addr : es un puntero a una estructura de tipo sockaddr , cuyos campos indican la direcci\u00f3n de conexi\u00f3n destino. addrlen : tama\u00f1o de la estructura addr . Valor de retorno: Si tiene \u00e9xito, devuelve el descriptor de socket. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de connect ( man connect ).","title":"connect()"},{"location":"RPI-II/P2_old/#send","text":"Prototipo: ssize_t send(int sockfd, const void *buf, size_t len, int flags); Descripci\u00f3n: En un socket en estado conectado (con receptor conocido) transmite mensajes a un socket remoto. Par\u00e1metros: sockfd : descriptor de socket de env\u00edo. buf : buffer de env\u00edo donde se almacena el mensaje a enviar. len : n\u00famero de bytes a enviar. Valor de retorno: Si tiene \u00e9xito, devuelve el n\u00famero de bytes enviados. Devuelve -1 si se produce un error. Detalles: consultad la p\u00e1gina de manual de send ( man send ).","title":"send()"},{"location":"RPI-II/P2_old/#recvrecvfrom","text":"Prototipos: ssize_t recv(int sockfd, void *buf, size_t len, int flags); ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen); Descripci\u00f3n: Reciben mensajes desde un socket , tanto en sockets orientados como no orientados a conexi\u00f3n. recvfrom , a diferencia de recv , recibe par\u00e1metros de salida adicionales que almacenan informaci\u00f3n sobre la direcci\u00f3n origen del mensaje. Par\u00e1metros: sockfd : descriptor de socket de recepci\u00f3n. buf : buffer de recepci\u00f3n donde se almacena el mensaje a recibir. len : n\u00famero de bytes a recibir. src_addr : direcci\u00f3n del extremo remoto del socket (origen de la comunicaci\u00f3n). addrlen : tama\u00f1o de la estructura src_addr . Valor de retorno: Si tiene \u00e9xito, devuelve el n\u00famero de bytes recibidos. Devuelve -1 si se produce un error. Detalles: consultad las p\u00e1ginas de manual de recv y recv_from ( man recv y man recv_from ).","title":"recv()/recvfrom()"},{"location":"RPI-II/P2_old/#close","text":"Prototipo: int close(int fd); Descripci\u00f3n: Cierra un socket. Par\u00e1metros: fd : descriptor de socket . Detalles: consultad la p\u00e1gina de manual de close ( man close ).","title":"close()"},{"location":"RPI-II/P2_old/#ejemplos","text":"Se proporcionan a continuaci\u00f3n ejemplos completos de uso de la API de sockets en C para el desarrollo de sistemas cliente/servidor sencillos. Para cada uno de ellos, comprueba que, efectivamente, el uso y secuencia de aplicaci\u00f3n de cada llamada sigue las directivas de la figura: Tarea Compila (utilizando la oren gcc ejemplo.c -o ejemplo.x desde una terminal) y a continuaci\u00f3n ejecuta ( ./ejemplo.x ) cada par de c\u00f3digos y comprueba su funcionamiento. Estudia con detenimiento el uso de cada rutina y como efectivamente siguen las directivas marcadas anteriormente. Si no tienes experiencia en desarrollo en C, consulta las p\u00e1ginas de manual correspondientes, o con tu profesor, para resolver todas tus dudas. Aseg\u00farate de entender el proceso de compilaci\u00f3n, enlazado y ejecuci\u00f3n de un binario.","title":"Ejemplos"},{"location":"RPI-II/P2_old/#ejemplo-un-cliente-tcp","text":"#include <arpa/inet.h> #include <stdio.h> #include <string.h> #include <sys/socket.h> #include <unistd.h> #include <netinet/in.h> int main() { const int server_port = 9000; struct sockaddr_in server_address; memset(&server_address, 0, sizeof(server_address)); server_address.sin_family = AF_INET; server_address.sin_addr.s_addr = inet_addr(\"127.0.0.1\"); server_address.sin_port = htons(server_port); int sock; if ((sock = socket(PF_INET, SOCK_STREAM, 0)) < 0) { printf(\"Error en socket\\n\"); return 1; } if (connect(sock, (struct sockaddr*)&server_address, sizeof(server_address)) < 0) { printf(\"Error en connect\\n\"); return 1; } const char* data_to_send = \"Hola, RPI!!\"; send(sock, data_to_send, strlen(data_to_send), 0); int n = 0; int len = 0, maxlen = 100; char buffer[maxlen]; char* pbuffer = buffer; if ((n = recv(sock, pbuffer, maxlen, 0)) > 0) { pbuffer += n; maxlen -= n; len += n; buffer[len] = '\\0'; printf(\"Recibido: '%s'\\n\", buffer); } close(sock); return 0; }","title":"Ejemplo: un cliente TCP"},{"location":"RPI-II/P2_old/#ejemplo-un-servidor-tcp","text":"#include <arpa/inet.h> #include <netinet/in.h> #include <stdbool.h> #include <stdio.h> #include <string.h> #include <unistd.h> int main(int argc, char *argv[]) { int SERVER_PORT = 9000; struct sockaddr_in server_address; memset(&server_address, 0, sizeof(server_address)); server_address.sin_family = AF_INET; server_address.sin_port = htons(SERVER_PORT); server_address.sin_addr.s_addr = htonl(INADDR_ANY); int listen_sock; if ((listen_sock = socket(PF_INET, SOCK_STREAM, 0)) < 0) { printf(\"Error en socket\\n\"); return 1; } if ((bind(listen_sock, (struct sockaddr *)&server_address, sizeof(server_address))) < 0) { printf(\"Error en bind\\n\"); return 1; } int wait_size = 16; if (listen(listen_sock, wait_size) < 0) { printf(\"Error en listen\\n\"); return 1; } struct sockaddr_in client_address; int client_address_len = 0; while (true) { int sock; if ((sock = accept(listen_sock, (struct sockaddr *)&client_address, &client_address_len)) < 0) { printf(\"Error en accept\\n\"); return 1; } int n = 0; int len = 0, maxlen = 100; char buffer[maxlen]; char *pbuffer = buffer; printf(\"Cliente conectado con IP: %s\\n\", inet_ntoa(client_address.sin_addr)); while ((n = recv(sock, pbuffer, maxlen, 0)) > 0) { pbuffer += n; maxlen -= n; len += n; printf(\"Recibido: '%s'\\n\", buffer); send(sock, buffer, len, 0); } close(sock); } close(listen_sock); return 0; } Tarea Reproduce el funcionamiento del anterior sistema cliente/servidor echo utilizando UDP.","title":"Ejemplo: un servidor TCP"},{"location":"RPI-II/P2_old/#capturas-de-trafico-via-wireshark","text":"Wireshark es una herramienta de c\u00f3digo abierto ampliamente utilizada para analizar protocolos de comunicaci\u00f3n de red en cualquiera de las capas de la pila TCP/IP (como tambi\u00e9n en otros protocolos). Wireshark implementa un amplio abanico de filtros para definir criterios de b\u00fasqueda en las capturas de tr\u00e1fico, aunque de momento, en nuestro caso, no ser\u00e1 necesario utilizar filtros espec\u00edficos. Para arrancar Wireshark en la m\u00e1quina virtual proporcionada (o en cualquier instalaci\u00f3n b\u00e1sica Linux), teclea en tu terminal: $ sudo wireshark Tras el arranque, podemos comenzar una nueva captura de tr\u00e1fico a trav\u00e9s del men\u00fa Capture , opci\u00f3n Start . La pantalla de selecci\u00f3n de interfaz nos permitir\u00e1 definir en qu\u00e9 interfaz de red se realizar\u00e1 la captura. En nuestro caso, ya que vamos a comunicar dos procesos en la misma m\u00e1quina, elegiremos la interfaz de Loopback (lo) y comenzaremos la captura. Tarea Arranca Wireshark y prepara una captura sobre la interfaz de loopback de tu m\u00e1quina. Ejecuta el servidor echo TCP y el cliente correspondiente, y analiza el tr\u00e1fico generado. Especialmente, f\u00edjate en el proceso de establecimiento de conexi\u00f3n en tres v\u00edas, paquetes de Acknowledge tras el env\u00edo de cada mensaje y, en general, en cualquier otro aspecto que consideres de inter\u00e9s.","title":"Capturas de tr\u00e1fico v\u00eda Wireshark"},{"location":"RPI-II/P2_old/#construccion-de-mensajes","text":"Para enviar mensajes que encapsulen distintos tipos de datos en una sola invocaci\u00f3n, puedes definir un mensaje como el siguiente: typedef struct { int x; int y; } mensaje; Dando valor a cada campo y a continuaci\u00f3n envi\u00e1ndolo proporcionando la direcci\u00f3n de inicio de la estructura, del siguiente modo: mensaje.x = x; mensaje.y = y; send( socketfd, &mensaje, sizeof( mensaje ), 0 ); Tarea entregable Se pide dise\u00f1ar un sistema cliente/servidor programado en C, que simule el env\u00edo de un conjunto de datos sensorizados desde un cliente hacia un servidor. El protocolo a utilizar (formato de datos enviado por la red a nivel de aplicaci\u00f3n) debe ser propuesto por el propio alumno y descrito previamente al desarrollo. Se valorar\u00e1 el uso de m\u00faltiples tipos de datos tanto en el env\u00edo de datos sensorizados como de posibles respuestas por parte del servidor. Se desarrollar\u00e1 una versi\u00f3n utilizando TCP y otra equivalente usando UDP. El cliente enviar\u00e1 los datos de forma peri\u00f3dica y se \u00e9stos generar\u00e1n de modo aleatorio. A modo de entrega, se solicitan los c\u00f3digos desarrollados, as\u00ed como un an\u00e1lisis del tr\u00e1fico generado, considerando la sobrecarga (en bytes reales enviados) introducida por cada protocolo de capa de transporte.","title":"Construcci\u00f3n de mensajes"},{"location":"RPI-II/P2_old/#sistemas-clienteservidor-en-el-esp32","text":"La raz\u00f3n por la que hemos ejercitado el uso de la API de sockets desde C en Linux es que la implementaci\u00f3n de la pila TCP/IP en ESP-IDF (llamada Lightweight TCP/IP (lwIP) ) implementa al 100% dicha API. Por tanto, tanto la estructura b\u00e1sica de un firmware que implemente un cliente o servidor como la API utilizada permanece inalterada. En esta \u00faltima secci\u00f3n, se pide trabajar con dos ejemplos b\u00e1sicos de implementaci\u00f3n de sistemas cliente/servidor UDP y TCP sobre el ESP32, con el objetivo de estudiar su funcionalidad, comprobar su interoperabilidad y realizar modificaciones para adaptarlas a una hipot\u00e9tica aplicaci\u00f3n IoT.","title":"Sistemas cliente/servidor en el ESP32"},{"location":"RPI-II/P2_old/#clienteservidor-udp-en-el-esp32","text":"En esta parte, trabajar\u00e1s con dos ejemplos proporcionados dentro de la colecci\u00f3n de ejemplos de ESP-IDF. Por tanto, copia en tu espacio de trabajo (fuera del \u00e1rbol principal de ESP-IDF) los ejemplos: Servidor UDP : examples/protocols/sockets/udp_server/ Cliente UDP : examples/protocols/sockets/udp_client/","title":"Cliente/servidor UDP en el ESP32"},{"location":"RPI-II/P2_old/#estructura-general","text":"Observa sus c\u00f3digos ( udp_server.c para el servidor, y udp_client.c para el cliente). Comprueba que, tanto la estructura b\u00e1sica de ambos componentes como las invocaciones a la API de sockets concuerdan con las que vimos para el sistema echo programado en C. Acerca de la tarea principal (funci\u00f3n app_main ) observa que realiza una serie de llamadas a APIs de configuraci\u00f3n de algunos subsistemas de FreeRTOS, principalmente: // Inicializa la partici\u00f3n NVS (Non-volatile storage) por defecto. ESP_ERROR_CHECK(nvs_flash_init()); // Inicializa la infraestructura ESP-NETIF. ESP_ERROR_CHECK(esp_netif_init()); // Crea un bucle de eventos por defecto. ESP_ERROR_CHECK(esp_event_loop_create_default()); /* Esta funci\u00f3n configura WiFi o Ethernet, tal y como seleccionemos via menuconfig. */ ESP_ERROR_CHECK(example_connect()); xTaskCreate(udp_server_task, \"udp_server\", 4096, NULL, 5, NULL); example_connect() , funci\u00f3n que no forma parte de ESP-IDF, establece una conexi\u00f3n WiFi o Ethernet. La funci\u00f3n es bloqueante, y retorna cuando se ha conseguido establecer una conexi\u00f3n. Las caracter\u00edsticas de la conexi\u00f3n WiFi (SSID y contrase\u00f1a) se deben proporcionar a trav\u00e9s de menuconfig . El objetivo de ESP-NETIF es proporcionar una capa de abstracci\u00f3n por encima de la pila TCP/IP, de modo que pueda migrarse la pila sin que los c\u00f3digos del usuario cambien. Puedes consultar su documentaci\u00f3n en la p\u00e1gina oficial . Por \u00faltimo, se crea una tarea que ejecutar\u00e1 la l\u00f3gica del servidor (lo mismo ocurre en el cliente). Observa que, en todo el c\u00f3digo, los mensajes de error se anotan utilizando la macro ESP_LOGE y los informativos con ESP_LOGI ; intenta seguir este convenio en tus c\u00f3digos.","title":"Estructura general"},{"location":"RPI-II/P2_old/#despliegue-opcion-1","text":"En este caso, desplegar\u00e1s el cliente en un ESP32 y el servidor en otro. Si no dispones de dos ESP32, puedes trabajar con un compa\u00f1ero. En cualquier caso, ambos ESP32 deben pertenecer a la misma red inal\u00e1mbrica, por lo que deber\u00e1n conectarse a un mismo punto de acceso (el profesor te proporcionar\u00e1 los datos, o simplemente puedes utilizar tu punto de acceso dom\u00e9stico). Configura los siguientes puntos de la infraestructura: Configura el SSID y contrase\u00f1a del punto de acceso v\u00eda menuconfig antes de compilar y flashear el c\u00f3digo tanto en el cliente como en el servidor. En el servidor, configura v\u00eda menuconfig el puerto sobre el que escuchar\u00e1. Arranca primero el nodo servidor y apunta la IP proporcionada por el punto de acceso; util\u00edzala en el cliente para configurar la IP destino de la comunicaci\u00f3n. No olvides configurar tambi\u00e9n el puerto destino de acuerdo al configurado en el servidor v\u00eda menuconfig . \u00can este punto, podr\u00e1s arrancar el cliente y deber\u00edas estar comunicando dos nodos ESP32 v\u00eda UDP.","title":"Despliegue. Opci\u00f3n 1"},{"location":"RPI-II/P2_old/#despliegue-opcion-2","text":"Si s\u00f3lo dispones de un nodo, o si simplemente quieres probar otra forma de comunicaci\u00f3n en la que uno de los equipos es un PC, puedes utilizar alguna de las herramientas del sistema: Nota Ten en cuenta que port\u00e1til (es decir, m\u00e1quina virtual) y ESP32 deben pertenecer\u00e1 la misma red. Para conseguirlo, para tu m\u00e1quina virtual y a\u00f1ade una nueva interfaz de red de tipo bridge conectada a la interfaz Wifi f\u00edsica de tu PC. As\u00ed, tendr\u00e1s una interfaz con IP en la misma red, otorgada directamente por tu punto de acceso. Para recibir un paquete UDP a trav\u00e9s de un puerto (es decir, emular un servidor UDP): nc -ul -p 3333 Para enviar un paquete UDP a una IP/puerto remotos (es decir, emular un cliente): nc -u IP_REMOTA 3333 En el directorio scripts dispones tambi\u00e9n de peque\u00f1os ejemplos de clientes y servidores UDP Python que puedes tambi\u00e9n utilizar.","title":"Despliegue. Opci\u00f3n 2"},{"location":"RPI-II/P2_old/#clienteservidor-tcp-en-el-esp32","text":"El despliegue de cliente y servidor TCP es equivalente al UDP. Para recibir un paquete TCP a trav\u00e9s de un puerto (es decir, emular un servidor TCP): nc -l IP -p 3333 Para enviar un paquete TCP a una IP/puerto remotos (es decir, emular un cliente): nc IP 3333 En el directorio scripts dispones tambi\u00e9n de peque\u00f1os ejemplos de clientes y servidores TCP Python que puedes tambi\u00e9n utilizar. Tarea Experimenta con los ejemplos proporcionados en ESP-IDF (cliente/servidor TCP y UDP) y consigue ejecutar todos los elementos en la placa. Si s\u00f3lo dispones de una placa, utiliza la m\u00e1quina virtual como cliente/servidor para comprobar el correcto funcionamiento de cada c\u00f3digo. Tarea entregable En este punto, deber\u00edas disponer de un conjunto de c\u00f3digos que implementan sistemas cliente/servidor tanto en un host (utilizando Python y/o C) como en la placa ESP32 (utilizando C y ESP-IDF), y deber\u00edas haber comprobado su correcto funcionamiento. Espec\u00edficamente, dispondr\u00e1s de: Sistema cliente/servidor desarrollado en la Pr\u00e1ctica 1, escrito en Python e implementando un protocolo b\u00e1sico de aplicacion (tipo de mensaje) propuesto por ti. C\u00f3digo b\u00e1sico en C para implementaci\u00f3n de un servidor/cliente echo programado en C, cuyos c\u00f3digos se proporcionan en este bolet\u00edn. C\u00f3digos b\u00e1sicos en C/ESP-IDF para implementar servidores/clientes echo sobre el ESP32. Como tarea entregable, se pide que adaptes tu entrega de la Pr\u00e1ctica 1 para que tanto cliente como servidor puedan funcionar en el host (bien usando tu implementaci\u00f3n Python, o bien utilizando una nueva implementaci\u00f3n en C) o en el ESP32. Se entregar\u00e1n los c\u00f3digos y una breve memoria con capturas de tr\u00e1fico que demuestren el correcto funcionamiento del sistema.","title":"Cliente/servidor TCP en el ESP32"},{"location":"RPI-II/P3/","text":"Pr\u00e1ctica 3. Servidores REST y representaci\u00f3n de la informaci\u00f3n. JSON y CBOR Objetivos Entender los mecanismos ofrecidos por ESP-IDF para la creaci\u00f3n de un servidor REST HTTP. Implementar, a trav\u00e9s de los mecanismos ofrecidos por ESP-IDF, una API REST extendida en el ESP32. Entender los conceptos b\u00e1sicos de representaci\u00f3n de datos a trav\u00e9s de JSON. Implementar, a trav\u00e9s de la biblioteca cJSON , un tipo de mensaje personalizado para los intercambios de datos entre cliente y servidor. Entender los conceptos b\u00e1sicos de representaci\u00f3n de datos a trav\u00e9s de CBOR, y evaluar sus ventajas con respecto a JSON. Implementar, a trav\u00e9s de la biblioteca tinycbor , un tipo de mensaje personalizado para los intercambios de datos entre cliente y servidor, comparando los tama\u00f1os de payload con respecto al intercambio JSON. Desarrollo de un servidor REST en ESP-IDF En la primera parte de la pr\u00e1ctica, veremos c\u00f3mo desarrollar, utilizando las funcionalidades ofrecidas por ESP-IDF, un servidor HTTP que exponga una API REST mediante la cual ser\u00e1 posible interactuar, en modos lectura y escritura, con un servidor (en nuestro caso, un dispositivo ESP32). Concretamente, trabajaremos con el ejemplo example/protocols/http_server/restful_server de la distribuci\u00f3n de IDF. Descripci\u00f3n de la API El ejemplo que estudiaremos construye una sencilla interfaz (API) con tres endpoints que permiten interactuar con distintas funcionalidades del ESP32. N\u00f3tese que tanto las URLs como la funcionalidad asociada a ellas es totalmente personalizable, y puede ser ampliada de acuerdo a las necesidades de nuestra aplicaci\u00f3n. La siguiente tabla resume la funcionalidad de cada endpoint , as\u00ed como posibles ejemplos de valores enviados o devueltos a/por el servidor: API M\u00e9todo Ejemplo de recurso le\u00eddo/escrito Descripci\u00f3n URL /api/v1/system/info GET { version:\"v4.0-dev\", cores:2 } Utilizado por los clientes para obtener informaci\u00f3n de la placa (versi\u00f3n, n\u00famero de cores, ...) / /api/v1/temp/raw GET { raw:22 } Utilizado por los clientes para obtener datos de temperatura desde un sensor (no disponible en el ESP32) /chart /api/v1/light/brightness POST { red:160, green:160, blue:160 } Utilizado por los clientes para escribir en la placa valores de control para controlar la luminosidad de LEDs /light Configuraci\u00f3n y compilaci\u00f3n del ejemplo En primer lugar, configura, compila y flashea el ejemplo mencionado. En este caso, las instrucciones se dividen en dos partes: compilaci\u00f3n del firmware para el ESP32, y preparaci\u00f3n de un cliente web sencillo que nos permitir\u00e1 observar la interacci\u00f3n con el mismo. Esta \u00faltima parte no es estrictamente necesaria, pero nos ayudar\u00e1 en la interacci\u00f3n con el dispositivo de forma visual hasta que veamos c\u00f3mo hacerlo a trav\u00e9s de l\u00ednea de comandos. A trav\u00e9s del men\u00fa de configuraci\u00f3n, configura un nombre para el dispositivo (por ejemplo, esp-home-nombre ), e indica que el modo de despliegue ( Website deploy mode ) sea Deploy website to SPI Nor Flash . Por \u00faltimo, configura las credenciales del punto de acceso WiFi al que conectar\u00e1, siguiendo la metodolog\u00eda habitual. En segundo lugar, necesitamos instalar los componentes necesarios para desplegar el cliente web. Para ello, navega al subdirectorio front/web-demo , donde reside el c\u00f3digo fuente del cliente. Ejecuta los siguientes comandos para instalar las dependencias necesarias: sudo apt-get install npm node-vue* npm install npm run build Dependiendo del sistema, en este punto se puede producir un error de openssl (\"digital envelope routines::unsupported\"). Si fuese el caso, es preciso establecer la variable de entorno adecuada y volver a ejecutar el comando npm run build . En Linux/MacOS: export NODE_OPTIONS=--openssl-legacy-provider En Windows: set NODE_OPTIONS=--openssl-legacy-provider Una vez construido el front-end, ya podr\u00e1s ejecutar, desde el directorio base del ejemplo, la orden de compilaci\u00f3n y flasheado: idf.py build idf.py flash idf.py monitor Interacci\u00f3n con el dispositivo v\u00eda interfaz web Si todo ha ido bien, podr\u00e1s observar en la salida de monitorizaci\u00f3n la IP proporcionada al ESP32. Abre un navegador en la m\u00e1quina virtual o en tu PC (estando conectada a la misma red que tu ESP32), navega hacia la direcci\u00f3n IP del ESP32 o simplemente esp-home-nombre si el equipo host soporta mDNS, y deber\u00edas observar una p\u00e1gina como la siguiente: Esta es una p\u00e1gina web servida por el propio ESP32, que te permitir\u00e1 interactuar con \u00e9l. Concretamente, la p\u00e1gina dispone de dos funcionalidades: Chart : consulta peri\u00f3dicamente el valor de temperatura devuelto por el ESP32 a trav\u00e9s del endpoint /api/v1/temp/raw . Light : permite enviar al ESP32 nuevos valores para las tres componentes de luminosidad que hipot\u00e9ticamente podr\u00eda equipar el ESP32. Tarea 3.1 Interact\u00faa con el sensor de luminosidad del ESP32 enviando distintos valores. Observa c\u00f3mo la salida de monitorizaci\u00f3n del ESP32 responde mostrando los valores recibidos. Analiza el tr\u00e1fico generado para una de dichas peticiones utilizando Wireshark. \u00bfC\u00f3mo se codifican los datos en el env\u00edo? \u00bfC\u00f3mo se codifican los datos peri\u00f3dicos de temperatura recibidos? Interacci\u00f3n con el dispositivo v\u00eda l\u00ednea de comandos ( curl ) curl es una herramienta orientada a la transferencia de archivos por red. Entre otras (muchas) funcionalidades, curl soporta los m\u00e9todos GET y PUT del protocolo HTTP, justo las necesarias para realizar peticiones de lectura y escritura sobre nuestro servidor HTTP REST. Nota La versi\u00f3n de curl de PowerShell en Windows hace uso de Invoke-WebRequest y es mejor evitarla. Es preferible usar la versi\u00f3n de curl de CMD que es m\u00e1s compatible con las versiones UNIX (Linux/MacOS). Concretamente, para realizar una petici\u00f3n HTTP GET sobre nuestro servidor, podemos ejecutar: curl http://IP/URI Por ejemplo, la petici\u00f3n: curl http://192.168.1.26/api/v1/temp/raw (siendo 192.168.1.26 la IP del ESP32) nos responder\u00e1 con el valor de temperatura instant\u00e1nea. Del mismo modo, para escribir (m\u00e9todo POST ) sobre el servidor, utilizaremos el par\u00e1metro -d , seguido del recurso que queramos enviar. Ten en cuenta que es responsabilidad del cliente enviar un recurso bien formado e interpretable por el dispositivo: curl -d '{\"red\":70,\"green\":80,\"blue\":99}' -H \"Content-Type: application/json\" -X POST http://192.168.1.26/api/v1/light/brightness Observa que hemos incluido el tipo de recurso enviado ( JSON ) y la operaci\u00f3n solicitada ( POST ). Volveremos a esto en breve. Tarea 3.2 Comprueba que, efectivamente, el tr\u00e1fico generado por las anteriores \u00f3rdenes es el mismo que el que observaste en el caso del cliente web. Observa qu\u00e9 ocurre si consultas un endpoint inexistente, o si env\u00edas un JSON mal formado o con informaci\u00f3n incorrecta. Interacci\u00f3n con el dispositivo v\u00eda Node-RED Para interactuar con el dispositivo v\u00eda Node-RED, simplemente despliega un flujo que contenga un nodo de tipo HTTP Request . En su cuadro de di\u00e1logo de configuraci\u00f3n, podr\u00e1s incluir tanto el m\u00e9todo a utilizar (e.g. GET o POST ) como el endpoint (URL) destino y, opcionalmente, los datos a enviar si esto es necesario. Tarea 3.3 Comprueba que, efectivamente, el tr\u00e1fico generado por un flujo que utilice un nodo de interacci\u00f3n HTTP es el esperado, y el comportamiento del ESP32 tambi\u00e9n. En el caso de necesitar enviar un objeto JSON, puedes investigar c\u00f3mo formarlo con los nodos correspondientes, aunque esto lo veremos en las siguientes secciones. Implementaci\u00f3n de un servidor HTTP con API REST La implementaci\u00f3n de un servidor HTTP en ESP-IDF se delega al componente HTTP Server , que implementa toda la funcionalidad necesaria para tal fin de forma eficiente y ligera. La construcci\u00f3n de un servidor puede resumirse en tres funciones principales (observa la implementaci\u00f3n de la funci\u00f3n start_rest_server en el fichero rest_server.c ) del ejemplo: httpd_start : crea una instancia de servidor HTTP, y aloja recursos para ella seg\u00fan la configuraci\u00f3n proporcionada. En funci\u00f3n del tr\u00e1fico generado (URIs solicitadas), se utilizar\u00e1n manejadores espec\u00edficos definidos por el usuario para analizarlo y, en caso necesario, enviar respuestas al cliente correspondiente. httpd_stop : finaliza el servidor HTTP, cerrando cualquier conexi\u00f3n previamente establecida con clientes. httpd_register_uri_handler : registra un manejador (una funci\u00f3n definida por el usuario) para tratar una petici\u00f3n sobre una URI determinada. La estructura proporcionada dispone de campos para indicar la URI destino ( uri ), el m\u00e9todo que se espera recibir ( method , por ejemplo HTTPD_GET o HTTPD_POST ) y un puntero a una funci\u00f3n que procesar\u00e1 la petici\u00f3n recibida a trav\u00e9s de la URI indicada. Dicha funci\u00f3n s\u00f3lo se ejecutar\u00e1 si el m\u00e9todo coincide con el indicado. La funci\u00f3n start_rest_server del ejemplo proporciona los mecanismos b\u00e1sicos para la creaci\u00f3n de la API anteriormente descrita. As\u00ed, para crear el endpoint /api/v1/system/info , procederemos, en primer lugar, registr\u00e1ndolo en el servidor, preparando previamente la estructura de tipo httpd_uri_t : httpd_uri_t system_info_get_uri = { .uri = \"/api/v1/system/info\", .method = HTTP_GET, .handler = system_info_get_handler, .user_ctx = rest_context }; httpd_register_uri_handler(server, &system_info_get_uri); En este caso, la operaci\u00f3n asociada a la invocaci\u00f3n del handler ser\u00e1, exclusivamente GET ; de hecho, si invocamos a un m\u00e9todo POST sobre este endpoint , el servidor nos responder\u00e1 autom\u00e1ticamente con un aviso que indicar\u00e1 que dicho m\u00e9todo no est\u00e1 soportado. El procesamiento de la petici\u00f3n GET se realiza en la funci\u00f3n system_info_get_handler , y el esquema que se sigue es, en cualquier caso, sencillo: static esp_err_t system_info_get_handler(httpd_req_t *req) { // Preparaci\u00f3n del tipo de respuesta. httpd_resp_set_type(req, \"application/json\"); // Preparaci\u00f3n del buffer de respuesta. char * buffer = // En el ejemplo preparamos un buffer JSON. // Env\u00edo de respuesta. https_resp_sendstr( req, buffer ); return ESP_OK; Alternativamente, si la respuesta es binaria, podr\u00edamos utilizar la funci\u00f3n https_resp_send( req, buffer, buffer_len ) para procesarla y enviarla (lo necesitar\u00e1s para enviar un buffer binario CBOR). La creaci\u00f3n de un endpoint con soporte para m\u00e9todo POST resulta algo m\u00e1s larga, aunque el registro del mismo no difiere del ejemplo anterior: /* URI handler for light brightness control */ httpd_uri_t light_brightness_post_uri = { .uri = \"/api/v1/light/brightness\", .method = HTTP_POST, .handler = light_brightness_post_handler, .user_ctx = rest_context }; httpd_register_uri_handler(server, &light_brightness_post_uri); Observa el cuerpo de la funci\u00f3n light_brightness_post_handler . La recepci\u00f3n del objeto enviado por parte del cliente se realiza en base a m\u00faltiples invocaciones a la rutina httpd_req_recv : /* Simple handler for light brightness control */ static esp_err_t light_brightness_post_handler(httpd_req_t *req) { int total_len = req->content_len; int cur_len = 0; char *buf = ((rest_server_context_t *)(req->user_ctx))->scratch; int received = 0; if (total_len >= SCRATCH_BUFSIZE) { /* Respond with 500 Internal Server Error */ httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, \"content too long\"); return ESP_FAIL; } while (cur_len < total_len) { received = httpd_req_recv(req, buf + cur_len, total_len); if (received <= 0) { /* Respond with 500 Internal Server Error */ httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, \"Failed to post control value\"); return ESP_FAIL; } cur_len += received; } buf[total_len] = '\\0'; /// A partir de este punto, disponemos en buf del objeto recibido v\u00eda HTTP. /// ... Tarea entregable Observa y estudia los c\u00f3digos de los manejadores implementados en el ejemplo. Extiende la API proporcionada para crear un nuevo endpoint que permita obtener la temperatura (n\u00famero aleatorio), pero transform\u00e1ndola a grados Fahrenheit. En este caso, el valor devuelto en el fichero JSON ser\u00e1 un n\u00famero en punto flotante (en la siguiente secci\u00f3n te se explicar\u00e1 c\u00f3mo hacerlo, por lo que de momento puedes enviar \u00fanicamente la parte entera del mismo). Representaci\u00f3n de la informaci\u00f3n. JSON JSON es un formato de representaci\u00f3n de datos en modo texto para el intercambio de datos entre sistemas inform\u00e1ticos. Se cre\u00f3 inicialmente como una notaci\u00f3n literal de los objetos Javascript, pero dada su amplia aceptaci\u00f3n (realmente como alternativa a XML), se considera a d\u00eda de hoy un componente totalmente independiente al lenguaje. Los tipos de datos soportados por JSON incluyen: Valores num\u00e9ricos: permitiendo n\u00fameros con y sin signo, y con parte decimal en notaci\u00f3n separada por puntos. Cadenas: secuencias de cero o m\u00e1s caracteres. Booleanos: true y false . Arrays: listas ordenadas de cero o m\u00e1s valores de cualquier tipo, separados por comas y encerrados entre corchetes. Objetos: colecciones no ordenadas de pares <nombre>:<valor> , separados por comas y encerrados entre llaves. ESP-IDF incluye el componente cJSON para parsear y construir objetos de tipo JSON de forma sencilla y consistente. La biblioteca cJSON representa datos JSON utilizando una estructura sencilla, v\u00e9ase: /* The cJSON structure: */ typedef struct cJSON { struct cJSON *next; struct cJSON *prev; struct cJSON *child; int type; char *valuestring; /* writing to valueint is DEPRECATED, use cJSON_SetNumberValue instead */ int valueint; double valuedouble; char *string; } cJSON; El campo type informa sobre el tipo de dato contenido en el objeto, v\u00e9ase: cJSON_False ( cJSON_IsFalse() ): representa un valor booleano falso. cJSON_True ( cJSON_IsTrue() ): representa un valor booleano verdadero. cJSON_NULL ( cJSON_IsNULL() ): representa un valor nulo. cJSON_Number ( cJSON_IsNumber() ): representa un valor num\u00e9rico. Dicho valor se almacena en el campo valuedouble como flotante y en valueint como entero. cJSON_String ( cJSON_IsString() ): representa un valor cadena, y se almacena en el campo valuestring como un array de bytes terminado por el car\u00e1cter nulo ('\\0'). cJSON_Array ( cJSON_IsArray() ): representa un array de valores. En el campo child se almacena una lista enlazada con los elementos del array, terminada en NULL. cJSON_Object ( cJSON_IsObject() ): representa un valor objeto. Sus valores se almacenan de la misma manera que el array anterior, pero en el campo string se almacenan adem\u00e1s las claves del objeto a modo de lista. Creaci\u00f3n y parseado de una estructura JSON Para cada tipo de datos, existe una rutina asociada con nombre cJSON_Create... que permite crear un item del tipo correspondiente. Todas estas funciones alojan memoria suficiente como para albergar el dato creado. Dado un objeto JSON en forma de cadena, es posible analizarlo (parsearlo) utilizando la funci\u00f3n cJSON_Parse : cJSON * json = cJSON_Parse( string ); Para imprimir el contenido de una estructura JSON en modo texto, podemos hacer uso de la funci\u00f3n cJSON_Print(json) : char * string = cJSON_Print( json ); Ejemplos Observa de nuevo el contenido de las funciones manejadoras en nuestro servidor REST. Concretamente, c\u00e9ntrate en la funci\u00f3n system_info_get_handler , que construye un objeto JSON con dos campos, de tipo cadena (\"version\") y num\u00e9rico (\"cores\"): /* Simple handler for getting system handler */ static esp_err_t system_info_get_handler(httpd_req_t *req) { // Preparaci\u00f3n del tipo de datos de la respuesta. httpd_resp_set_type(req, \"application/json\"); // Creaci\u00f3n del objeto JSON. cJSON *root = cJSON_CreateObject(); // Obtenci\u00f3n del dato. esp_chip_info_t chip_info; esp_chip_info(&chip_info); // Anyadimos un campo de tipo cadena. cJSON_AddStringToObject(root, \"version\", IDF_VER); // Anyadimos un campo de tipo num\u00e9rico. cJSON_AddNumberToObject(root, \"cores\", chip_info.cores); // Imprimimos a cadena previo al env\u00edo. const char *sys_info = cJSON_Print(root); // Enviamos cabecera + objeto JSON en modo texto v\u00eda HTTP. httpd_resp_sendstr(req, sys_info); // Liberamos recursos. free((void *)sys_info); // Liberamos recursos del objeto JSON. cJSON_Delete(root); return ESP_OK; } La funci\u00f3n light_brightness_post_handler realiza un parseado del objeto JSON recibido. Observa su cuerpo: // buf contiene la cadena recibida a trav\u00e9s de HTTP (m\u00e9todo POST). // ... // Parseamos el objeto JSON. cJSON *root = cJSON_Parse(buf); // Obtenemos tres valores num\u00e9ricos (RGB). int red = cJSON_GetObjectItem(root, \"red\")->valueint; int green = cJSON_GetObjectItem(root, \"green\")->valueint; int blue = cJSON_GetObjectItem(root, \"blue\")->valueint; // Mostramos por pantalla los valores parseados. ESP_LOGI(REST_TAG, \"Light control: red = %d, green = %d, blue = %d\", red, green, blue); // Liberamos recursos JSON. cJSON_Delete(root); // Enviamos una respuesta generica en modo texto. httpd_resp_sendstr(req, \"Post control value successfully\"); return ESP_OK; Tarea entregable Extiende la tarea anterior para a\u00f1adir el dato en formato punto flotante de la temperatura en grados Fahrenheit. Tarea entregable Crea un nuevo endpoint que utilice un formato m\u00e1s complejo de objetos JSON, incluyendo distintos tipos de datos que puedan dar respuesta a un hipot\u00e9tico entorno IoT. Documenta la API generada y el formato de los objetos que has dise\u00f1ado. Puedes, si as\u00ed lo deseas, incluir capturas Wireshark para ilustrar el intercambio de mensajes producido. Nos interesar\u00e1, especialmente, el n\u00famero de bytes transportados para enviar/recibir tus mensajes JSON. Representaci\u00f3n de la informaci\u00f3n. CBOR CBOR ( Concise Binary Object Representation ) es el formato de serializaci\u00f3n de datos recomendado en muchos de los stacks IoT, espec\u00edficamente en aquellos basados en CoAP. Pese a ser un formato binario, CBOR guarda similitudes con JSON, ya que sigue su mismo modelo de datos: valores num\u00e9ricos, strings , arrays, mapas (objetos en JSON) y valores booleanos y nulos. Sin embargo, a diferencia de JSON, un objeto CBOR es autodescriptivo, y en este punto radica una de sus ventajas: es posible intercambiar datos entre un cliente y un servidor sin ce\u00f1irse a un esquema de datos concreto conocido por ambas partes. El hecho de ser un formato binario implica mejoras sustanciales con respecto a JSON, por ejemplo al transportar datos binarios (claves de cifrado, datos gr\u00e1ficos, o valores flotantes sensorizados, entre otros muchos); estos datos sol\u00edan codificarse en JSON utilizando, por ejemplo, formato base64 , a\u00f1adiendo complejidad al proceso de codificaci\u00f3n/decodificaci\u00f3n. En general, el uso de un formato binario implica menor complejidad a la hora de ser integrado en aplicaciones, y es por esta raz\u00f3n por la que se considera \u00f3ptimo para nodos de bajas prestaciones, t\u00edpicos en IoT. El formato CBOR est\u00e1 documentado en el RFC 7049 , y por tanto se considera un est\u00e1ndar bien documentado y estable de cara al futuro. CBOR en el ESP32 ESP-IDF incluye la biblioteca tinyCBOR como implementaci\u00f3n ligera del est\u00e1ndar, que permite tanto codificar distintos tipos de datos a formato CBOR, parsear estructuras CBOR y convertir dichas estructuras tanto a formato texto visualizable como a JSON. TinyCBOR est\u00e1 mantenido como proyecto de software libre por parte de Intel, y su documentaci\u00f3n detallada (se sugiere consultarla) se encuentra disponible en el siguiente enlace . Estudiaremos el funcionamiento de tinyCBOR a trav\u00e9s de un ejemplo funcional (lo puedes encontrar en examples/protocols/cbor ). El ejemplo muestra los mecanismos necesarios para, en primer lugar, crear un objeto CBOR completo utilizando la biblioteca, y en segundo lugar, el mecanismo para convertir dicho objeto a representaci\u00f3n JSON, as\u00ed como para parsearlo manualmente. En primer lugar, compila, flashea y ejecuta el ejemplo. Ver\u00e1s que la salida deber\u00eda ser similar a la siguiente: I (320) example: encoded buffer size 67 I (320) example: convert CBOR to JSON [{\"chip\":\"esp32\",\"unicore\":false,\"ip\":[192,168,1,100]},3.1400001049041748,\"simple(99)\",\"2019-07-10 09:00:00+0000\",\"undefined\"] I (340) example: decode CBOR manually Array[ Map{ chip esp32 unicore false ip Array[ 192 168 1 100 ] } 3.14 simple(99) 2019-07-10 09:00:00+0000 undefined ] Observa que la estructura del objeto CBOR ser\u00e1 medianamente compleja: constar\u00e1 de un array formado por cinco elementos: Un mapa (conjunto no ordenado de pares clave-valor ), combinando cadenas, booleanos y un segundo array para especificar una direcci\u00f3n IP. Un valor flotante (3.14). Un valor num\u00e9rico \"simple\" (99). Una fecha (en forma de cadena). Un valor indefinido. El firmware procede en tres etapas: Etapa 1: creaci\u00f3n (codificaci\u00f3n) del objeto CBOR Observa el cuerpo de la tarea principal ( app_main ). El codificador CBOR se basa en dos variables: CborEncoder Root_encoder; // Codificador CBOR. uint8_t buf[100]; // Buffer para alojar el objeto CBOR (array de bytes). En segundo lugar, y ya que utilizaremos un array y un mapa, necesitaremos constructores especiales para dichos objetos: // Creaci\u00f3n de Array. CborEncoder array_encoder; CborEncoder map_encoder; cbor_encoder_create_array(&root_encoder, &array_encoder, 5); // [ // 1. Creaci\u00f3n del Mapa. cbor_encoder_create_map(&array_encoder, &map_encoder, 3); // { A partir de este punto, podemos proceder con la construcci\u00f3n de los objetos siguiendo el esquema deseado: // chip: esp32 (cadena:cadena) cbor_encode_text_stringz(&map_encoder, \"chip\"); cbor_encode_text_stringz(&map_encoder, \"esp32\"); // unicore: false (cadena:booleano) cbor_encode_text_stringz(&map_encoder, \"unicore\"); cbor_encode_boolean(&map_encoder, false); // IP:[192,168,1,100] (cadena:array) cbor_encode_text_stringz(&map_encoder, \"ip\"); CborEncoder array2; cbor_encoder_create_array(&map_encoder, &array2, 4); // [ // Valores num\u00e9ricos. cbor_encode_uint(&array2, 192); cbor_encode_uint(&array2, 168); cbor_encode_uint(&array2, 1); cbor_encode_uint(&array2, 100); cbor_encoder_close_container(&map_encoder, &array2); // ] cbor_encoder_close_container(&array_encoder, &map_encoder); // } // 2. Flotante cbor_encode_float(&array_encoder, 3.14); // 3. Valor simple cbor_encode_simple_value(&array_encoder, 99); // 4. Cadena cbor_encode_text_stringz(&array_encoder, \"2019-07-10 09:00:00+0000\"); // 5. Undefined value. cbor_encode_undefined(&array_encoder); cbor_encoder_close_container(&root_encoder, &array_encoder); // ] // Mostramos el tama\u00f1o del buffer creado. ESP_LOGI(TAG, \"encoded buffer size %d\", cbor_encoder_get_buffer_size(&root_encoder, buf)); Etapa 2: conversi\u00f3n a JSON La conversi\u00f3n a JSON (t\u00edpicamente por motivos de visualizaci\u00f3n o depuraci\u00f3n), puede realizarse del siguiente modo: // Initialize the cbor parser and the value iterator cbor_parser_init(buf, sizeof(buf), 0, &root_parser, &it); ESP_LOGI(TAG, \"convert CBOR to JSON\"); // Dump the values in JSON format cbor_value_to_json(stdout, &it, 0); Etapa 3: parseado manual de un objeto CBOR Por \u00faltimo, el parseado manual del objeto CBOR se deja como ejercicio de estudio para el alumno, y est\u00e1 implementado en la funci\u00f3n example_dump_cbor_buffer del ejemplo. B\u00e1sicamente, la funci\u00f3n itera por cada uno de los elementos del objeto CBOR, consultando el tipo de cada elemento y actuando en consecuencia. Para aquellos tipos complejos (e.g. arrays o mapas), la funci\u00f3n se invoca recursivamente hasta encontrar un elemento de tipo b\u00e1sico. En este caso, simplemente imprime por pantalla su valor (e.g. en el caso de un entero, caso CborIntegerType ). Tarea entregable Se pide extender la API REST con un nuevo endpoint que permita obtener la misma informaci\u00f3n que el endpoint JSON desarrollado en la anterior tarea, pero en esta ocasi\u00f3n, utilizando formato CBOR. El objetivo del ejercicio es comparar la cantidad de tr\u00e1fico generado en cada representaci\u00f3n, por lo que se sugiere que el objeto intercambiado sea relativamente complejo (es decir, incluya disintos tipos de datos num\u00e9ricos, arrays, o mapas). A continuaci\u00f3n se incluyen notas adicionales que te permitir\u00e1n depurar tu desarrollo, observando los valores devueltos por el servidor HTTP. Notas adicionales: creaci\u00f3n y consulta de un endpoint CBOR en la API REST Las modificaciones a realizar en la funci\u00f3n manejadora del endpoint para responder con un objeto CBOR son m\u00ednimas. De hecho, se centran simplemente en el tipo de respuesta y el mecanismo a usar para enviarla, v\u00e9ase: static esp_err_t system_info_get_handler(httpd_req_t *req) { // Tipo de respuesta. httpd_resp_set_type(req, \"application/cbor\"); CborEncoder root_encoder; uint8_t buf[100]; // Codificador CBOR. cbor_encoder_init(&root_encoder, buf, sizeof(buf), 0); // Codificamos CBOR. // ... // Enviamos respuesta, consultando previamente el tama\u00f1o del buffer codificado. httpd_resp_send(req, (char*)buf, cbor_encoder_get_buffer_size( &root_encoder, buf)); return ESP_OK; Para consultar desde l\u00ednea de comandos sobre este endpoint , podemos utilizar directamente curl , volcando la salida recibida a un fichero (por ejemplo, output.cbor ): curl http://192.168.1.26/api/v1/system/info > output.cbor Si visualizas el contenido del fichero, ver\u00e1s que contiene datos binarios dif\u00edcilmente interpretables. A continuaci\u00f3n veremos distintos mecanismos de visualizaci\u00f3n. Notas adicionales: visualizaci\u00f3n de datos CBOR Una opci\u00f3n de visualizaci\u00f3n consiste en utilizar la web cbor.me . En el panel derecho, podr\u00e1s pegar el contenido binario le\u00eddo. Si necesitas realizar la conversi\u00f3n antes de pegarlo en la web, puedes hacerlo con la orden: xxd -ps output.cbor Un ejemplo de salida (a pegar en el panel derecho de la web), podr\u00eda ser: $ xxd -ps output.cbor 85a3646368697065657370333267756e69636f7265f46269708418c018a8 011864fa4048f5c3f8637818323031392d30372d31302030393a30303a30 302b30303030f7 Deber\u00edas observar una salida similar a la siguiente (ten en cuenta que la herramiente autom\u00e1ticamente indenta el contenido del panel derecho; recuerda que simplemente debes pegar la salida generada por xxd ):","title":"Pr\u00e1ctica 3"},{"location":"RPI-II/P3/#practica-3-servidores-rest-y-representacion-de-la-informacion-json-y-cbor","text":"","title":"Pr\u00e1ctica 3. Servidores REST y representaci\u00f3n de la informaci\u00f3n. JSON y CBOR"},{"location":"RPI-II/P3/#objetivos","text":"Entender los mecanismos ofrecidos por ESP-IDF para la creaci\u00f3n de un servidor REST HTTP. Implementar, a trav\u00e9s de los mecanismos ofrecidos por ESP-IDF, una API REST extendida en el ESP32. Entender los conceptos b\u00e1sicos de representaci\u00f3n de datos a trav\u00e9s de JSON. Implementar, a trav\u00e9s de la biblioteca cJSON , un tipo de mensaje personalizado para los intercambios de datos entre cliente y servidor. Entender los conceptos b\u00e1sicos de representaci\u00f3n de datos a trav\u00e9s de CBOR, y evaluar sus ventajas con respecto a JSON. Implementar, a trav\u00e9s de la biblioteca tinycbor , un tipo de mensaje personalizado para los intercambios de datos entre cliente y servidor, comparando los tama\u00f1os de payload con respecto al intercambio JSON.","title":"Objetivos"},{"location":"RPI-II/P3/#desarrollo-de-un-servidor-rest-en-esp-idf","text":"En la primera parte de la pr\u00e1ctica, veremos c\u00f3mo desarrollar, utilizando las funcionalidades ofrecidas por ESP-IDF, un servidor HTTP que exponga una API REST mediante la cual ser\u00e1 posible interactuar, en modos lectura y escritura, con un servidor (en nuestro caso, un dispositivo ESP32). Concretamente, trabajaremos con el ejemplo example/protocols/http_server/restful_server de la distribuci\u00f3n de IDF.","title":"Desarrollo de un servidor REST en ESP-IDF"},{"location":"RPI-II/P3/#descripcion-de-la-api","text":"El ejemplo que estudiaremos construye una sencilla interfaz (API) con tres endpoints que permiten interactuar con distintas funcionalidades del ESP32. N\u00f3tese que tanto las URLs como la funcionalidad asociada a ellas es totalmente personalizable, y puede ser ampliada de acuerdo a las necesidades de nuestra aplicaci\u00f3n. La siguiente tabla resume la funcionalidad de cada endpoint , as\u00ed como posibles ejemplos de valores enviados o devueltos a/por el servidor: API M\u00e9todo Ejemplo de recurso le\u00eddo/escrito Descripci\u00f3n URL /api/v1/system/info GET { version:\"v4.0-dev\", cores:2 } Utilizado por los clientes para obtener informaci\u00f3n de la placa (versi\u00f3n, n\u00famero de cores, ...) / /api/v1/temp/raw GET { raw:22 } Utilizado por los clientes para obtener datos de temperatura desde un sensor (no disponible en el ESP32) /chart /api/v1/light/brightness POST { red:160, green:160, blue:160 } Utilizado por los clientes para escribir en la placa valores de control para controlar la luminosidad de LEDs /light","title":"Descripci\u00f3n de la API"},{"location":"RPI-II/P3/#configuracion-y-compilacion-del-ejemplo","text":"En primer lugar, configura, compila y flashea el ejemplo mencionado. En este caso, las instrucciones se dividen en dos partes: compilaci\u00f3n del firmware para el ESP32, y preparaci\u00f3n de un cliente web sencillo que nos permitir\u00e1 observar la interacci\u00f3n con el mismo. Esta \u00faltima parte no es estrictamente necesaria, pero nos ayudar\u00e1 en la interacci\u00f3n con el dispositivo de forma visual hasta que veamos c\u00f3mo hacerlo a trav\u00e9s de l\u00ednea de comandos. A trav\u00e9s del men\u00fa de configuraci\u00f3n, configura un nombre para el dispositivo (por ejemplo, esp-home-nombre ), e indica que el modo de despliegue ( Website deploy mode ) sea Deploy website to SPI Nor Flash . Por \u00faltimo, configura las credenciales del punto de acceso WiFi al que conectar\u00e1, siguiendo la metodolog\u00eda habitual. En segundo lugar, necesitamos instalar los componentes necesarios para desplegar el cliente web. Para ello, navega al subdirectorio front/web-demo , donde reside el c\u00f3digo fuente del cliente. Ejecuta los siguientes comandos para instalar las dependencias necesarias: sudo apt-get install npm node-vue* npm install npm run build Dependiendo del sistema, en este punto se puede producir un error de openssl (\"digital envelope routines::unsupported\"). Si fuese el caso, es preciso establecer la variable de entorno adecuada y volver a ejecutar el comando npm run build . En Linux/MacOS: export NODE_OPTIONS=--openssl-legacy-provider En Windows: set NODE_OPTIONS=--openssl-legacy-provider Una vez construido el front-end, ya podr\u00e1s ejecutar, desde el directorio base del ejemplo, la orden de compilaci\u00f3n y flasheado: idf.py build idf.py flash idf.py monitor","title":"Configuraci\u00f3n y compilaci\u00f3n del ejemplo"},{"location":"RPI-II/P3/#interaccion-con-el-dispositivo-via-interfaz-web","text":"Si todo ha ido bien, podr\u00e1s observar en la salida de monitorizaci\u00f3n la IP proporcionada al ESP32. Abre un navegador en la m\u00e1quina virtual o en tu PC (estando conectada a la misma red que tu ESP32), navega hacia la direcci\u00f3n IP del ESP32 o simplemente esp-home-nombre si el equipo host soporta mDNS, y deber\u00edas observar una p\u00e1gina como la siguiente: Esta es una p\u00e1gina web servida por el propio ESP32, que te permitir\u00e1 interactuar con \u00e9l. Concretamente, la p\u00e1gina dispone de dos funcionalidades: Chart : consulta peri\u00f3dicamente el valor de temperatura devuelto por el ESP32 a trav\u00e9s del endpoint /api/v1/temp/raw . Light : permite enviar al ESP32 nuevos valores para las tres componentes de luminosidad que hipot\u00e9ticamente podr\u00eda equipar el ESP32. Tarea 3.1 Interact\u00faa con el sensor de luminosidad del ESP32 enviando distintos valores. Observa c\u00f3mo la salida de monitorizaci\u00f3n del ESP32 responde mostrando los valores recibidos. Analiza el tr\u00e1fico generado para una de dichas peticiones utilizando Wireshark. \u00bfC\u00f3mo se codifican los datos en el env\u00edo? \u00bfC\u00f3mo se codifican los datos peri\u00f3dicos de temperatura recibidos?","title":"Interacci\u00f3n con el dispositivo v\u00eda interfaz web"},{"location":"RPI-II/P3/#interaccion-con-el-dispositivo-via-linea-de-comandos-curl","text":"curl es una herramienta orientada a la transferencia de archivos por red. Entre otras (muchas) funcionalidades, curl soporta los m\u00e9todos GET y PUT del protocolo HTTP, justo las necesarias para realizar peticiones de lectura y escritura sobre nuestro servidor HTTP REST. Nota La versi\u00f3n de curl de PowerShell en Windows hace uso de Invoke-WebRequest y es mejor evitarla. Es preferible usar la versi\u00f3n de curl de CMD que es m\u00e1s compatible con las versiones UNIX (Linux/MacOS). Concretamente, para realizar una petici\u00f3n HTTP GET sobre nuestro servidor, podemos ejecutar: curl http://IP/URI Por ejemplo, la petici\u00f3n: curl http://192.168.1.26/api/v1/temp/raw (siendo 192.168.1.26 la IP del ESP32) nos responder\u00e1 con el valor de temperatura instant\u00e1nea. Del mismo modo, para escribir (m\u00e9todo POST ) sobre el servidor, utilizaremos el par\u00e1metro -d , seguido del recurso que queramos enviar. Ten en cuenta que es responsabilidad del cliente enviar un recurso bien formado e interpretable por el dispositivo: curl -d '{\"red\":70,\"green\":80,\"blue\":99}' -H \"Content-Type: application/json\" -X POST http://192.168.1.26/api/v1/light/brightness Observa que hemos incluido el tipo de recurso enviado ( JSON ) y la operaci\u00f3n solicitada ( POST ). Volveremos a esto en breve. Tarea 3.2 Comprueba que, efectivamente, el tr\u00e1fico generado por las anteriores \u00f3rdenes es el mismo que el que observaste en el caso del cliente web. Observa qu\u00e9 ocurre si consultas un endpoint inexistente, o si env\u00edas un JSON mal formado o con informaci\u00f3n incorrecta.","title":"Interacci\u00f3n con el dispositivo v\u00eda l\u00ednea de comandos (curl)"},{"location":"RPI-II/P3/#interaccion-con-el-dispositivo-via-node-red","text":"Para interactuar con el dispositivo v\u00eda Node-RED, simplemente despliega un flujo que contenga un nodo de tipo HTTP Request . En su cuadro de di\u00e1logo de configuraci\u00f3n, podr\u00e1s incluir tanto el m\u00e9todo a utilizar (e.g. GET o POST ) como el endpoint (URL) destino y, opcionalmente, los datos a enviar si esto es necesario. Tarea 3.3 Comprueba que, efectivamente, el tr\u00e1fico generado por un flujo que utilice un nodo de interacci\u00f3n HTTP es el esperado, y el comportamiento del ESP32 tambi\u00e9n. En el caso de necesitar enviar un objeto JSON, puedes investigar c\u00f3mo formarlo con los nodos correspondientes, aunque esto lo veremos en las siguientes secciones.","title":"Interacci\u00f3n con el dispositivo v\u00eda Node-RED"},{"location":"RPI-II/P3/#implementacion-de-un-servidor-http-con-api-rest","text":"La implementaci\u00f3n de un servidor HTTP en ESP-IDF se delega al componente HTTP Server , que implementa toda la funcionalidad necesaria para tal fin de forma eficiente y ligera. La construcci\u00f3n de un servidor puede resumirse en tres funciones principales (observa la implementaci\u00f3n de la funci\u00f3n start_rest_server en el fichero rest_server.c ) del ejemplo: httpd_start : crea una instancia de servidor HTTP, y aloja recursos para ella seg\u00fan la configuraci\u00f3n proporcionada. En funci\u00f3n del tr\u00e1fico generado (URIs solicitadas), se utilizar\u00e1n manejadores espec\u00edficos definidos por el usuario para analizarlo y, en caso necesario, enviar respuestas al cliente correspondiente. httpd_stop : finaliza el servidor HTTP, cerrando cualquier conexi\u00f3n previamente establecida con clientes. httpd_register_uri_handler : registra un manejador (una funci\u00f3n definida por el usuario) para tratar una petici\u00f3n sobre una URI determinada. La estructura proporcionada dispone de campos para indicar la URI destino ( uri ), el m\u00e9todo que se espera recibir ( method , por ejemplo HTTPD_GET o HTTPD_POST ) y un puntero a una funci\u00f3n que procesar\u00e1 la petici\u00f3n recibida a trav\u00e9s de la URI indicada. Dicha funci\u00f3n s\u00f3lo se ejecutar\u00e1 si el m\u00e9todo coincide con el indicado. La funci\u00f3n start_rest_server del ejemplo proporciona los mecanismos b\u00e1sicos para la creaci\u00f3n de la API anteriormente descrita. As\u00ed, para crear el endpoint /api/v1/system/info , procederemos, en primer lugar, registr\u00e1ndolo en el servidor, preparando previamente la estructura de tipo httpd_uri_t : httpd_uri_t system_info_get_uri = { .uri = \"/api/v1/system/info\", .method = HTTP_GET, .handler = system_info_get_handler, .user_ctx = rest_context }; httpd_register_uri_handler(server, &system_info_get_uri); En este caso, la operaci\u00f3n asociada a la invocaci\u00f3n del handler ser\u00e1, exclusivamente GET ; de hecho, si invocamos a un m\u00e9todo POST sobre este endpoint , el servidor nos responder\u00e1 autom\u00e1ticamente con un aviso que indicar\u00e1 que dicho m\u00e9todo no est\u00e1 soportado. El procesamiento de la petici\u00f3n GET se realiza en la funci\u00f3n system_info_get_handler , y el esquema que se sigue es, en cualquier caso, sencillo: static esp_err_t system_info_get_handler(httpd_req_t *req) { // Preparaci\u00f3n del tipo de respuesta. httpd_resp_set_type(req, \"application/json\"); // Preparaci\u00f3n del buffer de respuesta. char * buffer = // En el ejemplo preparamos un buffer JSON. // Env\u00edo de respuesta. https_resp_sendstr( req, buffer ); return ESP_OK; Alternativamente, si la respuesta es binaria, podr\u00edamos utilizar la funci\u00f3n https_resp_send( req, buffer, buffer_len ) para procesarla y enviarla (lo necesitar\u00e1s para enviar un buffer binario CBOR). La creaci\u00f3n de un endpoint con soporte para m\u00e9todo POST resulta algo m\u00e1s larga, aunque el registro del mismo no difiere del ejemplo anterior: /* URI handler for light brightness control */ httpd_uri_t light_brightness_post_uri = { .uri = \"/api/v1/light/brightness\", .method = HTTP_POST, .handler = light_brightness_post_handler, .user_ctx = rest_context }; httpd_register_uri_handler(server, &light_brightness_post_uri); Observa el cuerpo de la funci\u00f3n light_brightness_post_handler . La recepci\u00f3n del objeto enviado por parte del cliente se realiza en base a m\u00faltiples invocaciones a la rutina httpd_req_recv : /* Simple handler for light brightness control */ static esp_err_t light_brightness_post_handler(httpd_req_t *req) { int total_len = req->content_len; int cur_len = 0; char *buf = ((rest_server_context_t *)(req->user_ctx))->scratch; int received = 0; if (total_len >= SCRATCH_BUFSIZE) { /* Respond with 500 Internal Server Error */ httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, \"content too long\"); return ESP_FAIL; } while (cur_len < total_len) { received = httpd_req_recv(req, buf + cur_len, total_len); if (received <= 0) { /* Respond with 500 Internal Server Error */ httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, \"Failed to post control value\"); return ESP_FAIL; } cur_len += received; } buf[total_len] = '\\0'; /// A partir de este punto, disponemos en buf del objeto recibido v\u00eda HTTP. /// ... Tarea entregable Observa y estudia los c\u00f3digos de los manejadores implementados en el ejemplo. Extiende la API proporcionada para crear un nuevo endpoint que permita obtener la temperatura (n\u00famero aleatorio), pero transform\u00e1ndola a grados Fahrenheit. En este caso, el valor devuelto en el fichero JSON ser\u00e1 un n\u00famero en punto flotante (en la siguiente secci\u00f3n te se explicar\u00e1 c\u00f3mo hacerlo, por lo que de momento puedes enviar \u00fanicamente la parte entera del mismo).","title":"Implementaci\u00f3n de un servidor HTTP con API REST"},{"location":"RPI-II/P3/#representacion-de-la-informacion-json","text":"JSON es un formato de representaci\u00f3n de datos en modo texto para el intercambio de datos entre sistemas inform\u00e1ticos. Se cre\u00f3 inicialmente como una notaci\u00f3n literal de los objetos Javascript, pero dada su amplia aceptaci\u00f3n (realmente como alternativa a XML), se considera a d\u00eda de hoy un componente totalmente independiente al lenguaje. Los tipos de datos soportados por JSON incluyen: Valores num\u00e9ricos: permitiendo n\u00fameros con y sin signo, y con parte decimal en notaci\u00f3n separada por puntos. Cadenas: secuencias de cero o m\u00e1s caracteres. Booleanos: true y false . Arrays: listas ordenadas de cero o m\u00e1s valores de cualquier tipo, separados por comas y encerrados entre corchetes. Objetos: colecciones no ordenadas de pares <nombre>:<valor> , separados por comas y encerrados entre llaves. ESP-IDF incluye el componente cJSON para parsear y construir objetos de tipo JSON de forma sencilla y consistente. La biblioteca cJSON representa datos JSON utilizando una estructura sencilla, v\u00e9ase: /* The cJSON structure: */ typedef struct cJSON { struct cJSON *next; struct cJSON *prev; struct cJSON *child; int type; char *valuestring; /* writing to valueint is DEPRECATED, use cJSON_SetNumberValue instead */ int valueint; double valuedouble; char *string; } cJSON; El campo type informa sobre el tipo de dato contenido en el objeto, v\u00e9ase: cJSON_False ( cJSON_IsFalse() ): representa un valor booleano falso. cJSON_True ( cJSON_IsTrue() ): representa un valor booleano verdadero. cJSON_NULL ( cJSON_IsNULL() ): representa un valor nulo. cJSON_Number ( cJSON_IsNumber() ): representa un valor num\u00e9rico. Dicho valor se almacena en el campo valuedouble como flotante y en valueint como entero. cJSON_String ( cJSON_IsString() ): representa un valor cadena, y se almacena en el campo valuestring como un array de bytes terminado por el car\u00e1cter nulo ('\\0'). cJSON_Array ( cJSON_IsArray() ): representa un array de valores. En el campo child se almacena una lista enlazada con los elementos del array, terminada en NULL. cJSON_Object ( cJSON_IsObject() ): representa un valor objeto. Sus valores se almacenan de la misma manera que el array anterior, pero en el campo string se almacenan adem\u00e1s las claves del objeto a modo de lista.","title":"Representaci\u00f3n de la informaci\u00f3n. JSON"},{"location":"RPI-II/P3/#creacion-y-parseado-de-una-estructura-json","text":"Para cada tipo de datos, existe una rutina asociada con nombre cJSON_Create... que permite crear un item del tipo correspondiente. Todas estas funciones alojan memoria suficiente como para albergar el dato creado. Dado un objeto JSON en forma de cadena, es posible analizarlo (parsearlo) utilizando la funci\u00f3n cJSON_Parse : cJSON * json = cJSON_Parse( string ); Para imprimir el contenido de una estructura JSON en modo texto, podemos hacer uso de la funci\u00f3n cJSON_Print(json) : char * string = cJSON_Print( json );","title":"Creaci\u00f3n y parseado de una estructura JSON"},{"location":"RPI-II/P3/#ejemplos","text":"Observa de nuevo el contenido de las funciones manejadoras en nuestro servidor REST. Concretamente, c\u00e9ntrate en la funci\u00f3n system_info_get_handler , que construye un objeto JSON con dos campos, de tipo cadena (\"version\") y num\u00e9rico (\"cores\"): /* Simple handler for getting system handler */ static esp_err_t system_info_get_handler(httpd_req_t *req) { // Preparaci\u00f3n del tipo de datos de la respuesta. httpd_resp_set_type(req, \"application/json\"); // Creaci\u00f3n del objeto JSON. cJSON *root = cJSON_CreateObject(); // Obtenci\u00f3n del dato. esp_chip_info_t chip_info; esp_chip_info(&chip_info); // Anyadimos un campo de tipo cadena. cJSON_AddStringToObject(root, \"version\", IDF_VER); // Anyadimos un campo de tipo num\u00e9rico. cJSON_AddNumberToObject(root, \"cores\", chip_info.cores); // Imprimimos a cadena previo al env\u00edo. const char *sys_info = cJSON_Print(root); // Enviamos cabecera + objeto JSON en modo texto v\u00eda HTTP. httpd_resp_sendstr(req, sys_info); // Liberamos recursos. free((void *)sys_info); // Liberamos recursos del objeto JSON. cJSON_Delete(root); return ESP_OK; } La funci\u00f3n light_brightness_post_handler realiza un parseado del objeto JSON recibido. Observa su cuerpo: // buf contiene la cadena recibida a trav\u00e9s de HTTP (m\u00e9todo POST). // ... // Parseamos el objeto JSON. cJSON *root = cJSON_Parse(buf); // Obtenemos tres valores num\u00e9ricos (RGB). int red = cJSON_GetObjectItem(root, \"red\")->valueint; int green = cJSON_GetObjectItem(root, \"green\")->valueint; int blue = cJSON_GetObjectItem(root, \"blue\")->valueint; // Mostramos por pantalla los valores parseados. ESP_LOGI(REST_TAG, \"Light control: red = %d, green = %d, blue = %d\", red, green, blue); // Liberamos recursos JSON. cJSON_Delete(root); // Enviamos una respuesta generica en modo texto. httpd_resp_sendstr(req, \"Post control value successfully\"); return ESP_OK; Tarea entregable Extiende la tarea anterior para a\u00f1adir el dato en formato punto flotante de la temperatura en grados Fahrenheit. Tarea entregable Crea un nuevo endpoint que utilice un formato m\u00e1s complejo de objetos JSON, incluyendo distintos tipos de datos que puedan dar respuesta a un hipot\u00e9tico entorno IoT. Documenta la API generada y el formato de los objetos que has dise\u00f1ado. Puedes, si as\u00ed lo deseas, incluir capturas Wireshark para ilustrar el intercambio de mensajes producido. Nos interesar\u00e1, especialmente, el n\u00famero de bytes transportados para enviar/recibir tus mensajes JSON.","title":"Ejemplos"},{"location":"RPI-II/P3/#representacion-de-la-informacion-cbor","text":"CBOR ( Concise Binary Object Representation ) es el formato de serializaci\u00f3n de datos recomendado en muchos de los stacks IoT, espec\u00edficamente en aquellos basados en CoAP. Pese a ser un formato binario, CBOR guarda similitudes con JSON, ya que sigue su mismo modelo de datos: valores num\u00e9ricos, strings , arrays, mapas (objetos en JSON) y valores booleanos y nulos. Sin embargo, a diferencia de JSON, un objeto CBOR es autodescriptivo, y en este punto radica una de sus ventajas: es posible intercambiar datos entre un cliente y un servidor sin ce\u00f1irse a un esquema de datos concreto conocido por ambas partes. El hecho de ser un formato binario implica mejoras sustanciales con respecto a JSON, por ejemplo al transportar datos binarios (claves de cifrado, datos gr\u00e1ficos, o valores flotantes sensorizados, entre otros muchos); estos datos sol\u00edan codificarse en JSON utilizando, por ejemplo, formato base64 , a\u00f1adiendo complejidad al proceso de codificaci\u00f3n/decodificaci\u00f3n. En general, el uso de un formato binario implica menor complejidad a la hora de ser integrado en aplicaciones, y es por esta raz\u00f3n por la que se considera \u00f3ptimo para nodos de bajas prestaciones, t\u00edpicos en IoT. El formato CBOR est\u00e1 documentado en el RFC 7049 , y por tanto se considera un est\u00e1ndar bien documentado y estable de cara al futuro.","title":"Representaci\u00f3n de la informaci\u00f3n. CBOR"},{"location":"RPI-II/P3/#cbor-en-el-esp32","text":"ESP-IDF incluye la biblioteca tinyCBOR como implementaci\u00f3n ligera del est\u00e1ndar, que permite tanto codificar distintos tipos de datos a formato CBOR, parsear estructuras CBOR y convertir dichas estructuras tanto a formato texto visualizable como a JSON. TinyCBOR est\u00e1 mantenido como proyecto de software libre por parte de Intel, y su documentaci\u00f3n detallada (se sugiere consultarla) se encuentra disponible en el siguiente enlace . Estudiaremos el funcionamiento de tinyCBOR a trav\u00e9s de un ejemplo funcional (lo puedes encontrar en examples/protocols/cbor ). El ejemplo muestra los mecanismos necesarios para, en primer lugar, crear un objeto CBOR completo utilizando la biblioteca, y en segundo lugar, el mecanismo para convertir dicho objeto a representaci\u00f3n JSON, as\u00ed como para parsearlo manualmente. En primer lugar, compila, flashea y ejecuta el ejemplo. Ver\u00e1s que la salida deber\u00eda ser similar a la siguiente: I (320) example: encoded buffer size 67 I (320) example: convert CBOR to JSON [{\"chip\":\"esp32\",\"unicore\":false,\"ip\":[192,168,1,100]},3.1400001049041748,\"simple(99)\",\"2019-07-10 09:00:00+0000\",\"undefined\"] I (340) example: decode CBOR manually Array[ Map{ chip esp32 unicore false ip Array[ 192 168 1 100 ] } 3.14 simple(99) 2019-07-10 09:00:00+0000 undefined ] Observa que la estructura del objeto CBOR ser\u00e1 medianamente compleja: constar\u00e1 de un array formado por cinco elementos: Un mapa (conjunto no ordenado de pares clave-valor ), combinando cadenas, booleanos y un segundo array para especificar una direcci\u00f3n IP. Un valor flotante (3.14). Un valor num\u00e9rico \"simple\" (99). Una fecha (en forma de cadena). Un valor indefinido. El firmware procede en tres etapas:","title":"CBOR en el ESP32"},{"location":"RPI-II/P3/#etapa-1-creacion-codificacion-del-objeto-cbor","text":"Observa el cuerpo de la tarea principal ( app_main ). El codificador CBOR se basa en dos variables: CborEncoder Root_encoder; // Codificador CBOR. uint8_t buf[100]; // Buffer para alojar el objeto CBOR (array de bytes). En segundo lugar, y ya que utilizaremos un array y un mapa, necesitaremos constructores especiales para dichos objetos: // Creaci\u00f3n de Array. CborEncoder array_encoder; CborEncoder map_encoder; cbor_encoder_create_array(&root_encoder, &array_encoder, 5); // [ // 1. Creaci\u00f3n del Mapa. cbor_encoder_create_map(&array_encoder, &map_encoder, 3); // { A partir de este punto, podemos proceder con la construcci\u00f3n de los objetos siguiendo el esquema deseado: // chip: esp32 (cadena:cadena) cbor_encode_text_stringz(&map_encoder, \"chip\"); cbor_encode_text_stringz(&map_encoder, \"esp32\"); // unicore: false (cadena:booleano) cbor_encode_text_stringz(&map_encoder, \"unicore\"); cbor_encode_boolean(&map_encoder, false); // IP:[192,168,1,100] (cadena:array) cbor_encode_text_stringz(&map_encoder, \"ip\"); CborEncoder array2; cbor_encoder_create_array(&map_encoder, &array2, 4); // [ // Valores num\u00e9ricos. cbor_encode_uint(&array2, 192); cbor_encode_uint(&array2, 168); cbor_encode_uint(&array2, 1); cbor_encode_uint(&array2, 100); cbor_encoder_close_container(&map_encoder, &array2); // ] cbor_encoder_close_container(&array_encoder, &map_encoder); // } // 2. Flotante cbor_encode_float(&array_encoder, 3.14); // 3. Valor simple cbor_encode_simple_value(&array_encoder, 99); // 4. Cadena cbor_encode_text_stringz(&array_encoder, \"2019-07-10 09:00:00+0000\"); // 5. Undefined value. cbor_encode_undefined(&array_encoder); cbor_encoder_close_container(&root_encoder, &array_encoder); // ] // Mostramos el tama\u00f1o del buffer creado. ESP_LOGI(TAG, \"encoded buffer size %d\", cbor_encoder_get_buffer_size(&root_encoder, buf));","title":"Etapa 1: creaci\u00f3n (codificaci\u00f3n) del objeto CBOR"},{"location":"RPI-II/P3/#etapa-2-conversion-a-json","text":"La conversi\u00f3n a JSON (t\u00edpicamente por motivos de visualizaci\u00f3n o depuraci\u00f3n), puede realizarse del siguiente modo: // Initialize the cbor parser and the value iterator cbor_parser_init(buf, sizeof(buf), 0, &root_parser, &it); ESP_LOGI(TAG, \"convert CBOR to JSON\"); // Dump the values in JSON format cbor_value_to_json(stdout, &it, 0);","title":"Etapa 2: conversi\u00f3n a JSON"},{"location":"RPI-II/P3/#etapa-3-parseado-manual-de-un-objeto-cbor","text":"Por \u00faltimo, el parseado manual del objeto CBOR se deja como ejercicio de estudio para el alumno, y est\u00e1 implementado en la funci\u00f3n example_dump_cbor_buffer del ejemplo. B\u00e1sicamente, la funci\u00f3n itera por cada uno de los elementos del objeto CBOR, consultando el tipo de cada elemento y actuando en consecuencia. Para aquellos tipos complejos (e.g. arrays o mapas), la funci\u00f3n se invoca recursivamente hasta encontrar un elemento de tipo b\u00e1sico. En este caso, simplemente imprime por pantalla su valor (e.g. en el caso de un entero, caso CborIntegerType ). Tarea entregable Se pide extender la API REST con un nuevo endpoint que permita obtener la misma informaci\u00f3n que el endpoint JSON desarrollado en la anterior tarea, pero en esta ocasi\u00f3n, utilizando formato CBOR. El objetivo del ejercicio es comparar la cantidad de tr\u00e1fico generado en cada representaci\u00f3n, por lo que se sugiere que el objeto intercambiado sea relativamente complejo (es decir, incluya disintos tipos de datos num\u00e9ricos, arrays, o mapas). A continuaci\u00f3n se incluyen notas adicionales que te permitir\u00e1n depurar tu desarrollo, observando los valores devueltos por el servidor HTTP.","title":"Etapa 3: parseado manual de un objeto CBOR"},{"location":"RPI-II/P3/#notas-adicionales-creacion-y-consulta-de-un-endpoint-cbor-en-la-api-rest","text":"Las modificaciones a realizar en la funci\u00f3n manejadora del endpoint para responder con un objeto CBOR son m\u00ednimas. De hecho, se centran simplemente en el tipo de respuesta y el mecanismo a usar para enviarla, v\u00e9ase: static esp_err_t system_info_get_handler(httpd_req_t *req) { // Tipo de respuesta. httpd_resp_set_type(req, \"application/cbor\"); CborEncoder root_encoder; uint8_t buf[100]; // Codificador CBOR. cbor_encoder_init(&root_encoder, buf, sizeof(buf), 0); // Codificamos CBOR. // ... // Enviamos respuesta, consultando previamente el tama\u00f1o del buffer codificado. httpd_resp_send(req, (char*)buf, cbor_encoder_get_buffer_size( &root_encoder, buf)); return ESP_OK; Para consultar desde l\u00ednea de comandos sobre este endpoint , podemos utilizar directamente curl , volcando la salida recibida a un fichero (por ejemplo, output.cbor ): curl http://192.168.1.26/api/v1/system/info > output.cbor Si visualizas el contenido del fichero, ver\u00e1s que contiene datos binarios dif\u00edcilmente interpretables. A continuaci\u00f3n veremos distintos mecanismos de visualizaci\u00f3n.","title":"Notas adicionales: creaci\u00f3n y consulta de un endpoint CBOR en la API REST"},{"location":"RPI-II/P3/#notas-adicionales-visualizacion-de-datos-cbor","text":"Una opci\u00f3n de visualizaci\u00f3n consiste en utilizar la web cbor.me . En el panel derecho, podr\u00e1s pegar el contenido binario le\u00eddo. Si necesitas realizar la conversi\u00f3n antes de pegarlo en la web, puedes hacerlo con la orden: xxd -ps output.cbor Un ejemplo de salida (a pegar en el panel derecho de la web), podr\u00eda ser: $ xxd -ps output.cbor 85a3646368697065657370333267756e69636f7265f46269708418c018a8 011864fa4048f5c3f8637818323031392d30372d31302030393a30303a30 302b30303030f7 Deber\u00edas observar una salida similar a la siguiente (ten en cuenta que la herramiente autom\u00e1ticamente indenta el contenido del panel derecho; recuerda que simplemente debes pegar la salida generada por xxd ):","title":"Notas adicionales: visualizaci\u00f3n de datos CBOR"},{"location":"RPI-II/P3_old/","text":"Pr\u00e1ctica 5. Seguridad (TLS y DTLS) Objetivos Observar el comportamiento de TLS y DTLS para el intercambio cifrado de mensajes. Conocer las diferencias b\u00e1sicas entre TLS y DTLS. Conocer una API b\u00e1sica de programaci\u00f3n de sistemas cliente/servidor usando TLS y DTLS (WolfSSL). Conocer una API b\u00e1sica de programaci\u00f3n de sistemas cliente/servidor en ESP-IDF (ESP-TLS). Contenido del paquete proporcionado y setup b\u00e1sico El paquete proporcionado (puedes descargarlo aqu\u00ed ) incluye ejemplos de sistemas cliente/servidor programados utilizando TLS y DTLS mediante el uso de la biblioteca WolfSSL. Estos c\u00f3digos est\u00e1n dise\u00f1ados para ejecutarse exclusivamente en un sistema Linux, y requieren la instalaci\u00f3n de los paquetes de desarrollo WolfSSL. Para realizar la instalaci\u00f3n, ejecuta en tu m\u00e1quina virtual (esta l\u00ednea podr\u00eda cambiar si usas otra distribuci\u00f3n de Linux, en cuyo caso deber\u00e1s buscar los paquetes equivalentes): sudo apt-get install libwolfssl-dev libwolfssl* Una vez hecho esto, prueba a realizar la compilaci\u00f3n tanto del ejemplo TLS como DTLS utilizando la orden make en el directorio correspondiente. Si todo ha ido bien, puedes continuar con el an\u00e1lisis de los c\u00f3digos en la siguiente secci\u00f3n. Cliente/servidor TLS. Ejemplo b\u00e1sico en host Servidor TLS Analizaremos en primer lugar el c\u00f3digo b\u00e1sico del servidor TLS. Para ello, observa el contenido del fchero tls/server-tls.c . Cabeceras y constantes El uso de WolfSSL requiere la inclusi\u00f3n de dos cabeceras b\u00e1sicas: #include <wolfssl/options.h> #include <wolfssl/ssl.h> Adem\u00e1s, ya que ser\u00e1n necesarios en el desarrollo, definiremos las rutas al certificado (clave p\u00fablica) del servidor y su clave privada: #define CERT_FILE \"../certs/server-cert.pem\" #define KEY_FILE \"../certs/server-key.pem\" Observa adem\u00e1s que el puerto de escucha del servidor ser\u00e1 el 11111 . Objetos b\u00e1sicos WolfSSL. Contexto y objeto SSL Definiremos dos objetos b\u00e1sicos que se utilizar\u00e1n de forma recurrente en el c\u00f3digo: WOLFSSL_CTX* ctx; WOLFSSL* ssl; El contexto ( ctx ) incluye valores globales para cada conexi\u00f3n SSL, incluyendo informaci\u00f3n sobre certificados. Es posible utilizar un mismo contexto para m\u00faltiples conexiones, siempre que compartan caracter\u00edsticas. Para crear un nuevo contexto, utilizaremos la funci\u00f3n wolfSSL_CTX_new como sigue: /* Create and initialize WOLFSSL_CTX */ if ((ctx = wolfSSL_CTX_new(wolfTLSv1_2_server_method())) == NULL) { fprintf(stderr, \"ERROR: failed to create WOLFSSL_CTX\\n\"); return -1; } El argumento proporcionado incluye informaci\u00f3n sobre la versi\u00f3n de protocolo a utilizar. Actualmente, WolfSSL soporta SSL 3.0, TLS 1.1, TLS 1.2, DTLS 1.0 y DTLS 1.2. En este caso, para la parte cliente, las funciones a utilizar como argumento ser\u00edan: wolfSSLv3_server_method(); // SSLv3 wolfTLSv1_server_method(); // TLSv1 wolfTLSv1_1_server_method(); // TLSv1.1 wolfTLSv1_2_server_method(); // TLSv1.2 wolfDTLSv1_server_method(); // DTLS wolfDTLSv1_2_server_method(); // DTLS 1.2 En segundo lugar, es necesario cargar nuestra CA (Autoridad Certificadora) en el contexto, para que cualquier cliente pueda verificar, en el momento de su conexi\u00f3n, la identidad del sevidor. Para ello, usamos la funci\u00f3n wolfSSL_CTX_use_certificate_file de la siguiente manera: /* Load server certificates into WOLFSSL_CTX */ if (wolfSSL_CTX_use_certificate_file(ctx, CERT_FILE, SSL_FILETYPE_PEM) != SSL_SUCCESS) { fprintf(stderr, \"ERROR: failed to load %s, please check the file.\\n\", CERT_FILE); return -1; } Del mismo modo, el servidor deber\u00e1 incluir su clave privada en formato PEM: /* Load server key into WOLFSSL_CTX */ if (wolfSSL_CTX_use_PrivateKey_file(ctx, KEY_FILE, SSL_FILETYPE_PEM) != SSL_SUCCESS) { fprintf(stderr, \"ERROR: failed to load %s, please check the file.\\n\", KEY_FILE); return -1; } A continuaci\u00f3n, observa como el c\u00f3digo de escucha y aceptaci\u00f3n de conexiones entrantes no difier de cualquier c\u00f3digo que hayas desarrollado previamente para aceptar conexiones entrantes TCP ( bind , + listen + accept ). Justo tras la conexi\u00f3n ( accept ), resulta necesario crear un nuevo objeto SSL, as\u00ed como asociar el descriptor de socket con la nueva sesi\u00f3n (conexi\u00f3n) TLS: /* Create a WOLFSSL object */ if ((ssl = wolfSSL_new(ctx)) == NULL) { fprintf(stderr, \"ERROR: failed to create WOLFSSL object\\n\"); return -1; } /* Attach wolfSSL to the socket */ wolfSSL_set_fd(ssl, connd); /* Establish TLS connection */ ret = wolfSSL_accept(ssl); if (ret != SSL_SUCCESS) { fprintf(stderr, \"wolfSSL_accept error = %d\\n\", wolfSSL_get_error(ssl, ret)); return -1; } A partir de este punto, podemos enviar y recibir datos a trav\u00e9s del socket (y por tanto de la conexi\u00f3n TLS) de forma muy similar a como lo hacemos con el enfoque cl\u00e1sico. As\u00ed, para recibir datos: if (wolfSSL_read(ssl, buff, sizeof(buff)-1) == -1) { fprintf(stderr, \"ERROR: failed to read\\n\"); return -1; } Y para enviar datos de vuelta: /* Reply back to the client */ if (wolfSSL_write(ssl, buff, len) != len) { fprintf(stderr, \"ERROR: failed to write\\n\"); return -1; } Por \u00faltimo, finalizaremos la conexi\u00f3n con la invocaci\u00f3n de la funci\u00f3n wolfSSL_free(ssl) . Note El cliente proporcionado sigue una estrategia de implementaci\u00f3n similar. Compara ambos c\u00f3digos (cliente y servidor) y aseg\u00farate de entender las diferencias entre ellos. Tarea entregable Compila y ejecuta el sistema cliente/servidor TLS y obt\u00e9n capturas de tr\u00e1fico tanto de las fases de establecimiento de conexi\u00f3n como de las fases de transferencia de datos. En base a lo aprendido en las clases de teor\u00eda y la documentaci\u00f3n adicional sobre TLS y wolfSSL, redacta un breve informe que resuma el proceso de handshake y transferencia de datos en TLS tomando como base los paquetes reales observados para esta conexi\u00f3n. Cliente/servidor DTLS. Ejemplo b\u00e1sico en host El desarrollo de un sistema b\u00e1sico cliente/servidor con soporte DTLS utilizando WolfSSL es muy similar al visto anteriormente para TLS. Como detalle adicional, la inicializaci\u00f3n de la infraestructura debe realizarse indicando el soporte para DTLS en sus versiones 1.0 o 1.2: wolfDTLSv1_client_method(); // DTLS 1.0 wolfDTLSv1_2_client_method(); // DTLS 1.2 El resto del c\u00f3digo sigue una filosof\u00eda similar a TLS, adaptado, obviamente, a las caracter\u00edsticas de UDP (tipo de socket, ausencia de conexi\u00f3n, etc.), por lo que se deja como ejercicio su an\u00e1lisis y ejecuci\u00f3n. Tarea entregable Analiza, compila y ejecuta los c\u00f3digos correspondientes al sistema cliente/servidor DTLS. Realiza capturas de tr\u00e1fico y comp\u00e1ralas, paquete a paquete, con las generadas para un patr\u00f3n de tr\u00e1fico similar en el caso de TLS. Incide en sus similitudes y diferencias, tanto a nivel de handshake como de transferencia de datos. Observa, en este \u00faltimo caso, la aparici\u00f3n de nuevos campos de encabezado en los env\u00edos de datos DTLS. \u00bfCu\u00e1l/cu\u00e1les son esos campos y por qu\u00e9 aparecen? Realiza una comparativa del tr\u00e1fico total generado en ambos casos para exactamente la misma cantidad de datos transferidos. TLS en el ESP32. El componente ESP-TLS ESP-IDF proporciona un componente (ESP-TLS) que ofrece una interfaz (API) simplificada para acceder a funcionalidad b\u00e1sica TLS. A\u00fan as\u00ed, ofrece una funcionalidad suficientemente amplia como para implementar casos de uso comunes en entornos IoT. La API de ESP-TLS es sencilla, y se basa en el uso de cuatro funciones b\u00e1sicas: Establecimiento de conexi\u00f3n TLS ( esp_tls_conn_new() ) Prototipo: esp_tls_t *esp_tls_conn_new(const char *hostname, int hostlen, int port, constesp_tls_cfg_t *cfg) Descripci\u00f3n: Crea una nueva conexi\u00f3n TLS/SSL bloqueante, estableciendo dicha conexi\u00f3n contra un servidor establecido. Par\u00e1metros: hostname : Identificaci\u00f3n del host. hostlen : Longitud del par\u00e1metro hostname . port : Puerto de conexi\u00f3n con el host. cfg : Configuraci\u00f3n de la conexi\u00f3n TLS. Valor de retorno: Puntero a esp_tls_t (manejador de la conexi\u00f3n). Devuelve NULL si se produce un error en la conexi\u00f3n. Destrucci\u00f3n de conexi\u00f3n TLS ( esp_tls_conn_delete() ) void esp_tls_conn_delete(esp_tls_t *tls) Descripci\u00f3n: Cierra la conexi\u00f3n TLS/SSL. Par\u00e1metros: tls : Manejador de la conexi\u00f3n. Escritura de datos ( esp_tls_conn_read() ) static ssize_t esp_tls_conn_write(esp_tls_t *tls, const void *data, size_t datalen) Descripci\u00f3n: Escribe en la conexi\u00f3n TLS/SSL indicada el contenido del buffer data . Par\u00e1metros: tls : Manejador de la conexi\u00f3n. data : Buffer de env\u00edo. datalen : Longitud del buffer de env\u00edo (o n\u00famero m\u00e1ximo de bytes a escribir). Valor de retorno: >=0 : \u00e9xito en el env\u00edo. N\u00famero de bytes efectivamente enviados. <0 : error en el env\u00edo. Lectura de datos ( esp_tls_conn_read() ) static ssize_t esp_tls_conn_read(esp_tls_t *tls, void *data, size_t datalen) Descripci\u00f3n: Lee desde la conexi\u00f3n TLS/SSL indicada hacia el buffer data . Par\u00e1metros: tls : Manejador de la conexi\u00f3n. data : Buffer de recepci\u00f3n. datalen : Longitud del buffer de recepci\u00f3n (o n\u00famero m\u00e1ximo de bytes a leer). Valor de retorno: >0 : \u00e9xito en la recepci\u00f3n. N\u00famero de bytes efectivamente le\u00eddos. =0 : error en la recepci\u00f3n. La conexi\u00f3n se cerr\u00f3. <0 : error en la recepci\u00f3n. Estructura b\u00e1sica de un cliente TCP usando ESP-IDF Un cliente TCP implementado sobre ESP-IDF para dar soporte TLS, requiere ciertas modificaciones con respecto a la versi\u00f3n sin TLS. De hecho, el uso de ESP-IDF simplifica el c\u00f3digo del cliente. La estructura b\u00e1sica resultar\u00eda: /// Includes anteriores. #include \"esp_tls.h\" // Puede tomarse desde menuconfig. #define HOST_IP_ADDR DIRECCION_DE_HOST #define PORT PUERTO static const char *payload = \"Hola, mundo via TLS\"; // ... static void tls_client_task( void *pvParameters ) { // ... // Configuraci\u00f3n de ESP-TLS (vac\u00edo para opciones defecto). esp_tls_cfg_t cfg = { }; // Creaci\u00f3n de conexi\u00f3n. struct esp_tls *tls = esp_tls_conn_new( HOST_IP_ADDR, longitud, PORT, &cfg); // Chequeo de errores. // ... // Env\u00edo de datos. ret = esp_tls_conn_write(tls, payload, strlen(payload)); // Chequeo de errores. // ... // Lectura de datos ret = esp_tls_conn_read(tls, (char *)rx_buffer, 128); // Chequeo de errores. // ... // Destrucci\u00f3n de la conexi\u00f3n esp_tls_conn_delete( tls ); vTaskDelete( NULL ); } void app_main( void ) { // ... } Tarea entregable Compila y ejecuta el cliente TLS en el ESP32, y consigue que interact\u00fae con el servidor TLS que probaste anteriormente en el host . Comprueba que, efectivamente, los datos se transfieren cifrados entre ambos extremos, y que el intercambio de paquetes es similar al que observaste entre cliente y servidor en el host . Note Puedes valerte para ello de la base del ejemplo examples/protocols/https_request , obviamente adaptando la totalidad de su c\u00f3digo para que se comporte como un simple cliente echo .","title":"Pr\u00e1ctica 5. Seguridad (TLS y DTLS)"},{"location":"RPI-II/P3_old/#practica-5-seguridad-tls-y-dtls","text":"","title":"Pr\u00e1ctica 5. Seguridad (TLS y DTLS)"},{"location":"RPI-II/P3_old/#objetivos","text":"Observar el comportamiento de TLS y DTLS para el intercambio cifrado de mensajes. Conocer las diferencias b\u00e1sicas entre TLS y DTLS. Conocer una API b\u00e1sica de programaci\u00f3n de sistemas cliente/servidor usando TLS y DTLS (WolfSSL). Conocer una API b\u00e1sica de programaci\u00f3n de sistemas cliente/servidor en ESP-IDF (ESP-TLS).","title":"Objetivos"},{"location":"RPI-II/P3_old/#contenido-del-paquete-proporcionado-y-setup-basico","text":"El paquete proporcionado (puedes descargarlo aqu\u00ed ) incluye ejemplos de sistemas cliente/servidor programados utilizando TLS y DTLS mediante el uso de la biblioteca WolfSSL. Estos c\u00f3digos est\u00e1n dise\u00f1ados para ejecutarse exclusivamente en un sistema Linux, y requieren la instalaci\u00f3n de los paquetes de desarrollo WolfSSL. Para realizar la instalaci\u00f3n, ejecuta en tu m\u00e1quina virtual (esta l\u00ednea podr\u00eda cambiar si usas otra distribuci\u00f3n de Linux, en cuyo caso deber\u00e1s buscar los paquetes equivalentes): sudo apt-get install libwolfssl-dev libwolfssl* Una vez hecho esto, prueba a realizar la compilaci\u00f3n tanto del ejemplo TLS como DTLS utilizando la orden make en el directorio correspondiente. Si todo ha ido bien, puedes continuar con el an\u00e1lisis de los c\u00f3digos en la siguiente secci\u00f3n.","title":"Contenido del paquete proporcionado y setup b\u00e1sico"},{"location":"RPI-II/P3_old/#clienteservidor-tls-ejemplo-basico-en-host","text":"","title":"Cliente/servidor TLS. Ejemplo b\u00e1sico en host"},{"location":"RPI-II/P3_old/#servidor-tls","text":"Analizaremos en primer lugar el c\u00f3digo b\u00e1sico del servidor TLS. Para ello, observa el contenido del fchero tls/server-tls.c .","title":"Servidor TLS"},{"location":"RPI-II/P3_old/#cabeceras-y-constantes","text":"El uso de WolfSSL requiere la inclusi\u00f3n de dos cabeceras b\u00e1sicas: #include <wolfssl/options.h> #include <wolfssl/ssl.h> Adem\u00e1s, ya que ser\u00e1n necesarios en el desarrollo, definiremos las rutas al certificado (clave p\u00fablica) del servidor y su clave privada: #define CERT_FILE \"../certs/server-cert.pem\" #define KEY_FILE \"../certs/server-key.pem\" Observa adem\u00e1s que el puerto de escucha del servidor ser\u00e1 el 11111 .","title":"Cabeceras y constantes"},{"location":"RPI-II/P3_old/#objetos-basicos-wolfssl-contexto-y-objeto-ssl","text":"Definiremos dos objetos b\u00e1sicos que se utilizar\u00e1n de forma recurrente en el c\u00f3digo: WOLFSSL_CTX* ctx; WOLFSSL* ssl; El contexto ( ctx ) incluye valores globales para cada conexi\u00f3n SSL, incluyendo informaci\u00f3n sobre certificados. Es posible utilizar un mismo contexto para m\u00faltiples conexiones, siempre que compartan caracter\u00edsticas. Para crear un nuevo contexto, utilizaremos la funci\u00f3n wolfSSL_CTX_new como sigue: /* Create and initialize WOLFSSL_CTX */ if ((ctx = wolfSSL_CTX_new(wolfTLSv1_2_server_method())) == NULL) { fprintf(stderr, \"ERROR: failed to create WOLFSSL_CTX\\n\"); return -1; } El argumento proporcionado incluye informaci\u00f3n sobre la versi\u00f3n de protocolo a utilizar. Actualmente, WolfSSL soporta SSL 3.0, TLS 1.1, TLS 1.2, DTLS 1.0 y DTLS 1.2. En este caso, para la parte cliente, las funciones a utilizar como argumento ser\u00edan: wolfSSLv3_server_method(); // SSLv3 wolfTLSv1_server_method(); // TLSv1 wolfTLSv1_1_server_method(); // TLSv1.1 wolfTLSv1_2_server_method(); // TLSv1.2 wolfDTLSv1_server_method(); // DTLS wolfDTLSv1_2_server_method(); // DTLS 1.2 En segundo lugar, es necesario cargar nuestra CA (Autoridad Certificadora) en el contexto, para que cualquier cliente pueda verificar, en el momento de su conexi\u00f3n, la identidad del sevidor. Para ello, usamos la funci\u00f3n wolfSSL_CTX_use_certificate_file de la siguiente manera: /* Load server certificates into WOLFSSL_CTX */ if (wolfSSL_CTX_use_certificate_file(ctx, CERT_FILE, SSL_FILETYPE_PEM) != SSL_SUCCESS) { fprintf(stderr, \"ERROR: failed to load %s, please check the file.\\n\", CERT_FILE); return -1; } Del mismo modo, el servidor deber\u00e1 incluir su clave privada en formato PEM: /* Load server key into WOLFSSL_CTX */ if (wolfSSL_CTX_use_PrivateKey_file(ctx, KEY_FILE, SSL_FILETYPE_PEM) != SSL_SUCCESS) { fprintf(stderr, \"ERROR: failed to load %s, please check the file.\\n\", KEY_FILE); return -1; } A continuaci\u00f3n, observa como el c\u00f3digo de escucha y aceptaci\u00f3n de conexiones entrantes no difier de cualquier c\u00f3digo que hayas desarrollado previamente para aceptar conexiones entrantes TCP ( bind , + listen + accept ). Justo tras la conexi\u00f3n ( accept ), resulta necesario crear un nuevo objeto SSL, as\u00ed como asociar el descriptor de socket con la nueva sesi\u00f3n (conexi\u00f3n) TLS: /* Create a WOLFSSL object */ if ((ssl = wolfSSL_new(ctx)) == NULL) { fprintf(stderr, \"ERROR: failed to create WOLFSSL object\\n\"); return -1; } /* Attach wolfSSL to the socket */ wolfSSL_set_fd(ssl, connd); /* Establish TLS connection */ ret = wolfSSL_accept(ssl); if (ret != SSL_SUCCESS) { fprintf(stderr, \"wolfSSL_accept error = %d\\n\", wolfSSL_get_error(ssl, ret)); return -1; } A partir de este punto, podemos enviar y recibir datos a trav\u00e9s del socket (y por tanto de la conexi\u00f3n TLS) de forma muy similar a como lo hacemos con el enfoque cl\u00e1sico. As\u00ed, para recibir datos: if (wolfSSL_read(ssl, buff, sizeof(buff)-1) == -1) { fprintf(stderr, \"ERROR: failed to read\\n\"); return -1; } Y para enviar datos de vuelta: /* Reply back to the client */ if (wolfSSL_write(ssl, buff, len) != len) { fprintf(stderr, \"ERROR: failed to write\\n\"); return -1; } Por \u00faltimo, finalizaremos la conexi\u00f3n con la invocaci\u00f3n de la funci\u00f3n wolfSSL_free(ssl) . Note El cliente proporcionado sigue una estrategia de implementaci\u00f3n similar. Compara ambos c\u00f3digos (cliente y servidor) y aseg\u00farate de entender las diferencias entre ellos. Tarea entregable Compila y ejecuta el sistema cliente/servidor TLS y obt\u00e9n capturas de tr\u00e1fico tanto de las fases de establecimiento de conexi\u00f3n como de las fases de transferencia de datos. En base a lo aprendido en las clases de teor\u00eda y la documentaci\u00f3n adicional sobre TLS y wolfSSL, redacta un breve informe que resuma el proceso de handshake y transferencia de datos en TLS tomando como base los paquetes reales observados para esta conexi\u00f3n.","title":"Objetos b\u00e1sicos WolfSSL. Contexto y objeto SSL"},{"location":"RPI-II/P3_old/#clienteservidor-dtls-ejemplo-basico-en-host","text":"El desarrollo de un sistema b\u00e1sico cliente/servidor con soporte DTLS utilizando WolfSSL es muy similar al visto anteriormente para TLS. Como detalle adicional, la inicializaci\u00f3n de la infraestructura debe realizarse indicando el soporte para DTLS en sus versiones 1.0 o 1.2: wolfDTLSv1_client_method(); // DTLS 1.0 wolfDTLSv1_2_client_method(); // DTLS 1.2 El resto del c\u00f3digo sigue una filosof\u00eda similar a TLS, adaptado, obviamente, a las caracter\u00edsticas de UDP (tipo de socket, ausencia de conexi\u00f3n, etc.), por lo que se deja como ejercicio su an\u00e1lisis y ejecuci\u00f3n. Tarea entregable Analiza, compila y ejecuta los c\u00f3digos correspondientes al sistema cliente/servidor DTLS. Realiza capturas de tr\u00e1fico y comp\u00e1ralas, paquete a paquete, con las generadas para un patr\u00f3n de tr\u00e1fico similar en el caso de TLS. Incide en sus similitudes y diferencias, tanto a nivel de handshake como de transferencia de datos. Observa, en este \u00faltimo caso, la aparici\u00f3n de nuevos campos de encabezado en los env\u00edos de datos DTLS. \u00bfCu\u00e1l/cu\u00e1les son esos campos y por qu\u00e9 aparecen? Realiza una comparativa del tr\u00e1fico total generado en ambos casos para exactamente la misma cantidad de datos transferidos.","title":"Cliente/servidor DTLS. Ejemplo b\u00e1sico en host"},{"location":"RPI-II/P3_old/#tls-en-el-esp32-el-componente-esp-tls","text":"ESP-IDF proporciona un componente (ESP-TLS) que ofrece una interfaz (API) simplificada para acceder a funcionalidad b\u00e1sica TLS. A\u00fan as\u00ed, ofrece una funcionalidad suficientemente amplia como para implementar casos de uso comunes en entornos IoT. La API de ESP-TLS es sencilla, y se basa en el uso de cuatro funciones b\u00e1sicas:","title":"TLS en el ESP32. El componente ESP-TLS"},{"location":"RPI-II/P3_old/#establecimiento-de-conexion-tls-esp_tls_conn_new","text":"Prototipo: esp_tls_t *esp_tls_conn_new(const char *hostname, int hostlen, int port, constesp_tls_cfg_t *cfg) Descripci\u00f3n: Crea una nueva conexi\u00f3n TLS/SSL bloqueante, estableciendo dicha conexi\u00f3n contra un servidor establecido. Par\u00e1metros: hostname : Identificaci\u00f3n del host. hostlen : Longitud del par\u00e1metro hostname . port : Puerto de conexi\u00f3n con el host. cfg : Configuraci\u00f3n de la conexi\u00f3n TLS. Valor de retorno: Puntero a esp_tls_t (manejador de la conexi\u00f3n). Devuelve NULL si se produce un error en la conexi\u00f3n.","title":"Establecimiento de conexi\u00f3n TLS (esp_tls_conn_new())"},{"location":"RPI-II/P3_old/#destruccion-de-conexion-tls-esp_tls_conn_delete","text":"void esp_tls_conn_delete(esp_tls_t *tls) Descripci\u00f3n: Cierra la conexi\u00f3n TLS/SSL. Par\u00e1metros: tls : Manejador de la conexi\u00f3n.","title":"Destrucci\u00f3n de conexi\u00f3n TLS (esp_tls_conn_delete())"},{"location":"RPI-II/P3_old/#escritura-de-datos-esp_tls_conn_read","text":"static ssize_t esp_tls_conn_write(esp_tls_t *tls, const void *data, size_t datalen) Descripci\u00f3n: Escribe en la conexi\u00f3n TLS/SSL indicada el contenido del buffer data . Par\u00e1metros: tls : Manejador de la conexi\u00f3n. data : Buffer de env\u00edo. datalen : Longitud del buffer de env\u00edo (o n\u00famero m\u00e1ximo de bytes a escribir). Valor de retorno: >=0 : \u00e9xito en el env\u00edo. N\u00famero de bytes efectivamente enviados. <0 : error en el env\u00edo.","title":"Escritura de datos (esp_tls_conn_read())"},{"location":"RPI-II/P3_old/#lectura-de-datos-esp_tls_conn_read","text":"static ssize_t esp_tls_conn_read(esp_tls_t *tls, void *data, size_t datalen) Descripci\u00f3n: Lee desde la conexi\u00f3n TLS/SSL indicada hacia el buffer data . Par\u00e1metros: tls : Manejador de la conexi\u00f3n. data : Buffer de recepci\u00f3n. datalen : Longitud del buffer de recepci\u00f3n (o n\u00famero m\u00e1ximo de bytes a leer). Valor de retorno: >0 : \u00e9xito en la recepci\u00f3n. N\u00famero de bytes efectivamente le\u00eddos. =0 : error en la recepci\u00f3n. La conexi\u00f3n se cerr\u00f3. <0 : error en la recepci\u00f3n.","title":"Lectura de datos (esp_tls_conn_read())"},{"location":"RPI-II/P3_old/#estructura-basica-de-un-cliente-tcp-usando-esp-idf","text":"Un cliente TCP implementado sobre ESP-IDF para dar soporte TLS, requiere ciertas modificaciones con respecto a la versi\u00f3n sin TLS. De hecho, el uso de ESP-IDF simplifica el c\u00f3digo del cliente. La estructura b\u00e1sica resultar\u00eda: /// Includes anteriores. #include \"esp_tls.h\" // Puede tomarse desde menuconfig. #define HOST_IP_ADDR DIRECCION_DE_HOST #define PORT PUERTO static const char *payload = \"Hola, mundo via TLS\"; // ... static void tls_client_task( void *pvParameters ) { // ... // Configuraci\u00f3n de ESP-TLS (vac\u00edo para opciones defecto). esp_tls_cfg_t cfg = { }; // Creaci\u00f3n de conexi\u00f3n. struct esp_tls *tls = esp_tls_conn_new( HOST_IP_ADDR, longitud, PORT, &cfg); // Chequeo de errores. // ... // Env\u00edo de datos. ret = esp_tls_conn_write(tls, payload, strlen(payload)); // Chequeo de errores. // ... // Lectura de datos ret = esp_tls_conn_read(tls, (char *)rx_buffer, 128); // Chequeo de errores. // ... // Destrucci\u00f3n de la conexi\u00f3n esp_tls_conn_delete( tls ); vTaskDelete( NULL ); } void app_main( void ) { // ... } Tarea entregable Compila y ejecuta el cliente TLS en el ESP32, y consigue que interact\u00fae con el servidor TLS que probaste anteriormente en el host . Comprueba que, efectivamente, los datos se transfieren cifrados entre ambos extremos, y que el intercambio de paquetes es similar al que observaste entre cliente y servidor en el host . Note Puedes valerte para ello de la base del ejemplo examples/protocols/https_request , obviamente adaptando la totalidad de su c\u00f3digo para que se comporte como un simple cliente echo .","title":"Estructura b\u00e1sica de un cliente TCP usando ESP-IDF"},{"location":"RPI-II/P4/","text":"Pr\u00e1ctica 4. Protocolos b\u00e1sicos de capa de aplicaci\u00f3n. Websockets Objetivos Estudiar el intercambio de mensajes entre un cliente y un servidor websockets , tanto en la fase de handshake como de intercambio de datos. Conseguir interactuar con un servidor websockets utilizando un navegador web como cliente. Estudiar el componente websockets client en ESP-IDF. Conocer el m\u00f3dulo Python websockets para desarrollar sistemas b\u00e1sicos cliente/servidor utilizando websockets (opcional). Interactuando con un navegador web Los websockets permiten el env\u00edo as\u00edncrono bidireccional de informaci\u00f3n, entre un cliente y servidor web. La manera m\u00e1s sencilla de usarlos es mediante un navegador web convencional ya que la mayor\u00eda de ellos soportan este tipo de comunicaci\u00f3n a trav\u00e9s de scripts Javascript . Como servidor emplearemos un ejemplo de referencia ( websocket-echo-server ) que devuelve los mensajes recibidos. El an\u00e1lisis del c\u00f3digo de este servidor queda fuera del \u00e1mbito de la presente pr\u00e1ctica. Para instalar el servidor se precisa de los siguientes comandos: git clone https://github.com/websockets/websocket-echo-server.git cd websocket-echo-server npm ci --production node index.js Alternativamente, si no se quiere instalar software adicional en el host, se puede emplear un Docker container siguiendo las instrucciones del mismo repositorio ( enlace ). La configuraci\u00f3n del servidor se lleva a cabo mediante las siguientes variables de entorno: BIND_ADDRESS : direcci\u00f3n en la que escucha el servidor, por defecto :: . BIND_PORT : puerto de escucha, por defecto 1337 . HEARTBEAT_INTERVAL : intervalo (en milisegundos) entre env\u00edos de mensajes de ping a los clientes para comprobar el estado de las conexiones, por defecto es 30000 . HIGH_WATER_MARK : umbral (en bytes) para el buffer de salida de cada conexi\u00f3n, cuando se supera, el env\u00edo de datos se suspende hasta que se drene el buffer, por defeco es 16384 . MAX_MESSAGE_SIZE : m\u00e1ximo tama\u00f1o de mensaje (en bytes), por defecto es 65536 . Como cliente emplearemos la siguiente p\u00e1gina web: <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>WebSocket Test</title> <script> // Create new WebSocket connection var mySocket = new WebSocket(\"ws://[::1]:1337\"); // Associate listeners mySocket.onopen = function(evt) { console.log(\"WebSocket connection established.\"); // Send data when the connection is open mySocket.send(\"WebSocket Rocks!\"); }; mySocket.onmessage = function(evt) { console.log(\"Received message: \" + evt.data); }; mySocket.onclose = function(evt) { console.log(\"WebSocket closed with status: \" + evt.code); }; mySocket.onerror = function(evt) { console.error(\"WebSocket error:\", evt); }; // Optionally close the WebSocket after 5 seconds setTimeout(function() { mySocket.close(); console.log(\"WebSocket connection closed.\"); }, 5000); </script> </head> <body> <h1>Check the Console for WebSocket output</h1> </body> </html> Tarea Ejecuta el servidor en el host y, tras guardar el c\u00f3digo fuente del cliente en un fichero cliente.html , \u00e1brelo con el navegador Chrome y activa las herramientas de desarrollo ( DevTools ) para poder visualizar los mensajes mostrados en consola. Tarea Analiza el flujo TCP, HTTP y WS intercambiado mediante Wireshark . Websockets en el ESP32 El soporte a nivel de cliente para el protocolo websockets est\u00e1 integrado en ESP-IDF a trav\u00e9s del componente ESP websocket client , cuya documentaci\u00f3n puede consultarse a trav\u00e9s de este enlace . El componente ESP websocket client ofrece soporte para el protocolo websocket tanto sobre TCP como sobre TLS. Como todos los componentes en ESP-IDF, el componente websocket emite eventos que pueden ser tratados por parte de la aplicaci\u00f3n, entre los cuales destacan: WEBSOCKET_EVENT_CONNECTED : se emite una vez el cliente se ha conectado al servidor, previo al intercambio de datos. WEBSOCKET_EVENT_ERROR : en caso de error. WEBSOCKET_EVENT_CLOSED : la conexi\u00f3n se ha cerrado limpiamente. WEBSOCKET_EVENT_FINISH : el thread cliente va a cerrarse. WEBSOCKET_EVENT_DATA : se emite al recibir datos desde el servidor. Este \u00faltimo evento es de especial inter\u00e9s para nosotros, ya que acarrea la construcci\u00f3n de una estructura de tipo esp_websocket_event_data_t en la que se almacena el mensaje recibido desde el servidor (tanto en sus campos de control como de datos). Algunos campos de inter\u00e9s dentro de la estructura son: data_ptr : puntero a los datos recibidos ( payload ). data_len : tama\u00f1o (en bytes) de los datos recibidos. op_code : c\u00f3digo de operaci\u00f3n asociado al mensaje recibido. La documentaci\u00f3n del componente ofrece informaci\u00f3n sobre campos adicionales, de menor inter\u00e9s para nosotros. Observemos el c\u00f3digo de una posible funci\u00f3n manejadora de eventos del componente websocket : tatic void websocket_event_handler(void *handler_args, esp_event_base_t base, int32_t event_id, void *event_data) { esp_websocket_event_data_t *data = (esp_websocket_event_data_t *)event_data; switch (event_id) { case WEBSOCKET_EVENT_CONNECTED: ESP_LOGI(TAG, \"WEBSOCKET_EVENT_CONNECTED\"); break; case WEBSOCKET_EVENT_DATA: ESP_LOGI(TAG, \"WEBSOCKET_EVENT_DATA\"); ESP_LOGI(TAG, \"Received opcode=%d\", data->op_code); if (data->op_code == 0x2) { // Opcode 0x2 indicates binary data ESP_LOG_BUFFER_HEX(\"Received binary data\", data->data_ptr, data->data_len); } else if (data->op_code == 0x08 && data->data_len == 2) { ESP_LOGW(TAG, \"Received closed message with code=%d\", 256 * data->data_ptr[0] + data->data_ptr[1]); } else { ESP_LOGW(TAG, \"Received=%.*s\\n\\n\", data->data_len, (char *)data->data_ptr); } ESP_LOGW(TAG, \"Total payload length=%d, data_len=%d, current payload offset=%d\\r\\n\", data->payload_len, data->data_len, data->payload_offset); xTimerReset(shutdown_signal_timer, portMAX_DELAY); break; case WEBSOCKET_EVENT_ERROR: ESP_LOGI(TAG, \"WEBSOCKET_EVENT_ERROR\"); break; case WEBSOCKET_EVENT_FINISH: ESP_LOGI(TAG, \"WEBSOCKET_EVENT_FINISH\"); break; } } Observa el c\u00f3digo. En funci\u00f3n del par\u00e1metro event_id , el manejador toma un camino de ejecuci\u00f3n u otro. Centr\u00e9monos en la recepci\u00f3n de un evento de tipo \u1e80EBSOCKET_EVENT_DATA ; a trav\u00e9s de los distintos campos de la estructura de informaci\u00f3n recibida ( esp_websocket_event_data_t ), es posible: Obtener y mostrar el c\u00f3digo de la operaci\u00f3n ( op_code ). Mostrar el contenido del mensaje recibido ( data_ptr ). Mostrar el tama\u00f1o del mensaje recibido ( data_len y payload_len ). Preguntas \u00bfCu\u00e1l es la diferencia entre los campos data_len y payload_len ? \u00bfPor qu\u00e9 el programa realiza un tratamiento especial cuando op_code == 8 ? Dada la anterior funci\u00f3n manejadora, la inicializaci\u00f3n de un cliente websockets en el ESP32 es sencilla, y se resume en los siguientes pasos: Configuraci\u00f3n de URI (host + puerto) esp_websocket_client_config_t websocket_cfg = {}; websocket_cfg.uri = \"ws://localhost:1337\"; esp_websocket_client_handle_t client = esp_websocket_client_init(&websocket_cfg); Asociaci\u00f3n de manejador a eventos Websocket esp_websocket_register_events(client, WEBSOCKET_EVENT_ANY, websocket_event_handler, (void *)client); Inicializaci\u00f3n del cliente esp_websocket_client_start(client); A partir de este punto, la interacci\u00f3n con el servidor se puede realizar en base a funciones de env\u00edo de texto o binario: int esp_websocket_client_send_text(esp_websocket_client_handle_t client, const char *data, int len, TickType_t timeout) int esp_websocket_client_send_bin(esp_websocket_client_handle_t client, const char *data, int len, TickType_t timeout) No existen funciones de recepci\u00f3n, ya que \u00e9sta es impl\u00edcita y se notifica v\u00eda eventos. Ejemplo b\u00e1sico: cliente echo Estudiaremos a continuaci\u00f3n el ejemplo de cliente proporcionado por el componente espressif/esp_websocket_client para lo cual es preciso descargar el c\u00f3digo del repositorio esp-protocols ya sea mediante git o mediante fichero zip. En este punto, configura, compila, flashea y monitoriza el ejemplo esp-protocols/components/esp_websocket_client/examples/target/ . El ejemplo simplemente conecta con un servidor echo Websockets en la nube (por defecto wss://echo.websocket.events ). Dicho servidor simplemente espera, por parte de cada cliente, el env\u00edo a trav\u00e9s de la conexi\u00f3n de una cadena, respondiendo con la misma cadena en sentido contrario, siempre usando el mismo socket . Tarea Observa el c\u00f3digo del ejemplo y su ejecuci\u00f3n. Determina cu\u00e1l es el funcionamiento del ejemplo, y comprueba que los fragmentos de c\u00f3digo anteriores tienen su funci\u00f3n dentro del c\u00f3digo completo. \u00bfC\u00f3mo implementa el programa la espera limitada en tiempo si no se recibe ning\u00fan paquete tras cierto per\u00edodo? Tarea Analiza las cosas especiales (ej. env\u00edos parciales) mediante Wireshark . Tarea Modifica el ejemplo para que se env\u00eden y se reciban datos en formato JSON. N\u00f3tese que el ejemplo ya dispone parcialmente de c\u00f3digo para ello. Sistema cliente/servidor usando Websockets en Python El m\u00f3dulo websockets proporciona la funcionalidad necesaria tanto a nivel de cliente como de servidor para implementar sistemas basados en dicho protocolo. Concretamente, las funciones de alto nivel que proporciona est\u00e1n basadas en una API de bajo nivel que implementa las dos fases principales del protocolo websockets : Handshake de apertura de comunicaci\u00f3n, en forma de peticiones HTTP upgrade . Transferencia de datos, y finalizaci\u00f3n de la comunicaci\u00f3n con un handshake de cierre de conexi\u00f3n. La primera fase est\u00e1 dise\u00f1ada para integrarse con software HTTP (cliente y servidor) existente, y proporciona una implementaci\u00f3n m\u00ednima para construir, parsear y validar peticiones y respuestas HTTP. La segunda fase implementa el n\u00facleo del protocolo websockets , y proporciona una implementaci\u00f3n completa basada en el m\u00f3dulo asyncio ) de Python. Para utilizar el m\u00f3dulo websockets de Python, primero lo instalaremos v\u00eda pip : pip install websockets Un ejemplo b\u00e1sico se puede basar en un cliente que env\u00eda una cadena a un servidor, y queda a la espera de recibir un mensaje de respuesta por parte de \u00e9ste. Desarrollar la parte servidora para dicha aplicaci\u00f3n resulta sencillo. Observa el siguiente c\u00f3digo: #!/usr/bin/env python import asyncio import websockets async def hello(websocket, path): name = await websocket.recv() print(f\"< {name}\") greeting = f\"Hello {name}!\" await websocket.send(greeting) print(f\"> {greeting}\") start_server = websockets.serve(hello, \"localhost\", 8765) asyncio.get_event_loop().run_until_complete(start_server) asyncio.get_event_loop().run_forever() El paradigma de programaci\u00f3n utilizado en este ejemplo (basado en el m\u00f3dulo asyncio ) queda fuera del prop\u00f3sito de la pr\u00e1ctica (aunque se invita al alumno a estudiarlo, ya que aporta importantes ventajas a nivel de sencillez de desarrollo en aplicaciones de red). En cualquier caso, el anterior servidor ejecuta una (co)rutina manejadora hello para cada conexi\u00f3n websocket establecida; adem\u00e1s, se cierra dicha conexi\u00f3n cuando dicha (co)rutina finaliza. Concretamente, las funciones de inter\u00e9s en este caso son: await websockets.server.serve(ws_handler, host=None, port=None, # ... Crea, incializa y devuelve un objeto servidor Websocket asociado al host y puerto seleccionados. En un contexto de programaci\u00f3n as\u00edncrona (como el del ejemplo, el servidor finaliza autom\u00e1ticamente al salir de dicho contexto). Cuando un cliente conecta al host y puerto espec\u00edficados, se acepta la conexi\u00f3n, que es tratada por la (co)rutina ws_handler (en el ejemplo, hello ). Antes de delegar la conexi\u00f3n a la (co)rutina, se lleva a cabo el handshake de apertura websocket . await recv() Recibe el siguiente mensaje, devolviendo una cadena si el frame recibido es de texto, o un array de bytes si es binario. await send(message) Env\u00eda un mensaje. message puede er una cadena, o un array de bytes. En el primer caso, se env\u00eda un frame de texto; en el segundo caso, un frame binario. A continuaci\u00f3n se muestra un ejemplo de cliente websocket para interactuar con el anterior servidor: #!/usr/bin/env python import asyncio import websockets async def hello(): uri = \"ws://localhost:8765\" async with websockets.connect(uri) as websocket: name = input(\"What's your name? \") await websocket.send(name) print(f\"> {name}\") greeting = await websocket.recv() print(f\"< {greeting}\") asyncio.get_event_loop().run_until_complete(hello()) El c\u00f3digo en este caso es sencillo, ya que \u00fanicamente se basa en la planificaci\u00f3n (ejecuci\u00f3n) de una (co)rutina llamada hello , que establece una conexi\u00f3n con un servidor websocket v\u00eda connect , enviando y recibiendo un par de mensajes. await websockets.client.connect(uri, # ... Conecta con un servidor websocket en la URI determinada. La conexi\u00f3n se cierra al abandonar el contexto as\u00edncrono (es decir, la (co)rutina hello ). Tarea opcional Crea un servidor Python que interactue con una versi\u00f3n derivada del cliente ESP32 anterior.","title":"Pr\u00e1ctica 4"},{"location":"RPI-II/P4/#practica-4-protocolos-basicos-de-capa-de-aplicacion-websockets","text":"","title":"Pr\u00e1ctica 4. Protocolos b\u00e1sicos de capa de aplicaci\u00f3n. Websockets"},{"location":"RPI-II/P4/#objetivos","text":"Estudiar el intercambio de mensajes entre un cliente y un servidor websockets , tanto en la fase de handshake como de intercambio de datos. Conseguir interactuar con un servidor websockets utilizando un navegador web como cliente. Estudiar el componente websockets client en ESP-IDF. Conocer el m\u00f3dulo Python websockets para desarrollar sistemas b\u00e1sicos cliente/servidor utilizando websockets (opcional).","title":"Objetivos"},{"location":"RPI-II/P4/#interactuando-con-un-navegador-web","text":"Los websockets permiten el env\u00edo as\u00edncrono bidireccional de informaci\u00f3n, entre un cliente y servidor web. La manera m\u00e1s sencilla de usarlos es mediante un navegador web convencional ya que la mayor\u00eda de ellos soportan este tipo de comunicaci\u00f3n a trav\u00e9s de scripts Javascript . Como servidor emplearemos un ejemplo de referencia ( websocket-echo-server ) que devuelve los mensajes recibidos. El an\u00e1lisis del c\u00f3digo de este servidor queda fuera del \u00e1mbito de la presente pr\u00e1ctica. Para instalar el servidor se precisa de los siguientes comandos: git clone https://github.com/websockets/websocket-echo-server.git cd websocket-echo-server npm ci --production node index.js Alternativamente, si no se quiere instalar software adicional en el host, se puede emplear un Docker container siguiendo las instrucciones del mismo repositorio ( enlace ). La configuraci\u00f3n del servidor se lleva a cabo mediante las siguientes variables de entorno: BIND_ADDRESS : direcci\u00f3n en la que escucha el servidor, por defecto :: . BIND_PORT : puerto de escucha, por defecto 1337 . HEARTBEAT_INTERVAL : intervalo (en milisegundos) entre env\u00edos de mensajes de ping a los clientes para comprobar el estado de las conexiones, por defecto es 30000 . HIGH_WATER_MARK : umbral (en bytes) para el buffer de salida de cada conexi\u00f3n, cuando se supera, el env\u00edo de datos se suspende hasta que se drene el buffer, por defeco es 16384 . MAX_MESSAGE_SIZE : m\u00e1ximo tama\u00f1o de mensaje (en bytes), por defecto es 65536 . Como cliente emplearemos la siguiente p\u00e1gina web: <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>WebSocket Test</title> <script> // Create new WebSocket connection var mySocket = new WebSocket(\"ws://[::1]:1337\"); // Associate listeners mySocket.onopen = function(evt) { console.log(\"WebSocket connection established.\"); // Send data when the connection is open mySocket.send(\"WebSocket Rocks!\"); }; mySocket.onmessage = function(evt) { console.log(\"Received message: \" + evt.data); }; mySocket.onclose = function(evt) { console.log(\"WebSocket closed with status: \" + evt.code); }; mySocket.onerror = function(evt) { console.error(\"WebSocket error:\", evt); }; // Optionally close the WebSocket after 5 seconds setTimeout(function() { mySocket.close(); console.log(\"WebSocket connection closed.\"); }, 5000); </script> </head> <body> <h1>Check the Console for WebSocket output</h1> </body> </html> Tarea Ejecuta el servidor en el host y, tras guardar el c\u00f3digo fuente del cliente en un fichero cliente.html , \u00e1brelo con el navegador Chrome y activa las herramientas de desarrollo ( DevTools ) para poder visualizar los mensajes mostrados en consola. Tarea Analiza el flujo TCP, HTTP y WS intercambiado mediante Wireshark .","title":"Interactuando con un navegador web"},{"location":"RPI-II/P4/#websockets-en-el-esp32","text":"El soporte a nivel de cliente para el protocolo websockets est\u00e1 integrado en ESP-IDF a trav\u00e9s del componente ESP websocket client , cuya documentaci\u00f3n puede consultarse a trav\u00e9s de este enlace . El componente ESP websocket client ofrece soporte para el protocolo websocket tanto sobre TCP como sobre TLS. Como todos los componentes en ESP-IDF, el componente websocket emite eventos que pueden ser tratados por parte de la aplicaci\u00f3n, entre los cuales destacan: WEBSOCKET_EVENT_CONNECTED : se emite una vez el cliente se ha conectado al servidor, previo al intercambio de datos. WEBSOCKET_EVENT_ERROR : en caso de error. WEBSOCKET_EVENT_CLOSED : la conexi\u00f3n se ha cerrado limpiamente. WEBSOCKET_EVENT_FINISH : el thread cliente va a cerrarse. WEBSOCKET_EVENT_DATA : se emite al recibir datos desde el servidor. Este \u00faltimo evento es de especial inter\u00e9s para nosotros, ya que acarrea la construcci\u00f3n de una estructura de tipo esp_websocket_event_data_t en la que se almacena el mensaje recibido desde el servidor (tanto en sus campos de control como de datos). Algunos campos de inter\u00e9s dentro de la estructura son: data_ptr : puntero a los datos recibidos ( payload ). data_len : tama\u00f1o (en bytes) de los datos recibidos. op_code : c\u00f3digo de operaci\u00f3n asociado al mensaje recibido. La documentaci\u00f3n del componente ofrece informaci\u00f3n sobre campos adicionales, de menor inter\u00e9s para nosotros. Observemos el c\u00f3digo de una posible funci\u00f3n manejadora de eventos del componente websocket : tatic void websocket_event_handler(void *handler_args, esp_event_base_t base, int32_t event_id, void *event_data) { esp_websocket_event_data_t *data = (esp_websocket_event_data_t *)event_data; switch (event_id) { case WEBSOCKET_EVENT_CONNECTED: ESP_LOGI(TAG, \"WEBSOCKET_EVENT_CONNECTED\"); break; case WEBSOCKET_EVENT_DATA: ESP_LOGI(TAG, \"WEBSOCKET_EVENT_DATA\"); ESP_LOGI(TAG, \"Received opcode=%d\", data->op_code); if (data->op_code == 0x2) { // Opcode 0x2 indicates binary data ESP_LOG_BUFFER_HEX(\"Received binary data\", data->data_ptr, data->data_len); } else if (data->op_code == 0x08 && data->data_len == 2) { ESP_LOGW(TAG, \"Received closed message with code=%d\", 256 * data->data_ptr[0] + data->data_ptr[1]); } else { ESP_LOGW(TAG, \"Received=%.*s\\n\\n\", data->data_len, (char *)data->data_ptr); } ESP_LOGW(TAG, \"Total payload length=%d, data_len=%d, current payload offset=%d\\r\\n\", data->payload_len, data->data_len, data->payload_offset); xTimerReset(shutdown_signal_timer, portMAX_DELAY); break; case WEBSOCKET_EVENT_ERROR: ESP_LOGI(TAG, \"WEBSOCKET_EVENT_ERROR\"); break; case WEBSOCKET_EVENT_FINISH: ESP_LOGI(TAG, \"WEBSOCKET_EVENT_FINISH\"); break; } } Observa el c\u00f3digo. En funci\u00f3n del par\u00e1metro event_id , el manejador toma un camino de ejecuci\u00f3n u otro. Centr\u00e9monos en la recepci\u00f3n de un evento de tipo \u1e80EBSOCKET_EVENT_DATA ; a trav\u00e9s de los distintos campos de la estructura de informaci\u00f3n recibida ( esp_websocket_event_data_t ), es posible: Obtener y mostrar el c\u00f3digo de la operaci\u00f3n ( op_code ). Mostrar el contenido del mensaje recibido ( data_ptr ). Mostrar el tama\u00f1o del mensaje recibido ( data_len y payload_len ). Preguntas \u00bfCu\u00e1l es la diferencia entre los campos data_len y payload_len ? \u00bfPor qu\u00e9 el programa realiza un tratamiento especial cuando op_code == 8 ? Dada la anterior funci\u00f3n manejadora, la inicializaci\u00f3n de un cliente websockets en el ESP32 es sencilla, y se resume en los siguientes pasos: Configuraci\u00f3n de URI (host + puerto) esp_websocket_client_config_t websocket_cfg = {}; websocket_cfg.uri = \"ws://localhost:1337\"; esp_websocket_client_handle_t client = esp_websocket_client_init(&websocket_cfg); Asociaci\u00f3n de manejador a eventos Websocket esp_websocket_register_events(client, WEBSOCKET_EVENT_ANY, websocket_event_handler, (void *)client); Inicializaci\u00f3n del cliente esp_websocket_client_start(client); A partir de este punto, la interacci\u00f3n con el servidor se puede realizar en base a funciones de env\u00edo de texto o binario: int esp_websocket_client_send_text(esp_websocket_client_handle_t client, const char *data, int len, TickType_t timeout) int esp_websocket_client_send_bin(esp_websocket_client_handle_t client, const char *data, int len, TickType_t timeout) No existen funciones de recepci\u00f3n, ya que \u00e9sta es impl\u00edcita y se notifica v\u00eda eventos.","title":"Websockets en el ESP32"},{"location":"RPI-II/P4/#ejemplo-basico-cliente-echo","text":"Estudiaremos a continuaci\u00f3n el ejemplo de cliente proporcionado por el componente espressif/esp_websocket_client para lo cual es preciso descargar el c\u00f3digo del repositorio esp-protocols ya sea mediante git o mediante fichero zip. En este punto, configura, compila, flashea y monitoriza el ejemplo esp-protocols/components/esp_websocket_client/examples/target/ . El ejemplo simplemente conecta con un servidor echo Websockets en la nube (por defecto wss://echo.websocket.events ). Dicho servidor simplemente espera, por parte de cada cliente, el env\u00edo a trav\u00e9s de la conexi\u00f3n de una cadena, respondiendo con la misma cadena en sentido contrario, siempre usando el mismo socket . Tarea Observa el c\u00f3digo del ejemplo y su ejecuci\u00f3n. Determina cu\u00e1l es el funcionamiento del ejemplo, y comprueba que los fragmentos de c\u00f3digo anteriores tienen su funci\u00f3n dentro del c\u00f3digo completo. \u00bfC\u00f3mo implementa el programa la espera limitada en tiempo si no se recibe ning\u00fan paquete tras cierto per\u00edodo? Tarea Analiza las cosas especiales (ej. env\u00edos parciales) mediante Wireshark . Tarea Modifica el ejemplo para que se env\u00eden y se reciban datos en formato JSON. N\u00f3tese que el ejemplo ya dispone parcialmente de c\u00f3digo para ello.","title":"Ejemplo b\u00e1sico: cliente echo"},{"location":"RPI-II/P4/#sistema-clienteservidor-usando-websockets-en-python","text":"El m\u00f3dulo websockets proporciona la funcionalidad necesaria tanto a nivel de cliente como de servidor para implementar sistemas basados en dicho protocolo. Concretamente, las funciones de alto nivel que proporciona est\u00e1n basadas en una API de bajo nivel que implementa las dos fases principales del protocolo websockets : Handshake de apertura de comunicaci\u00f3n, en forma de peticiones HTTP upgrade . Transferencia de datos, y finalizaci\u00f3n de la comunicaci\u00f3n con un handshake de cierre de conexi\u00f3n. La primera fase est\u00e1 dise\u00f1ada para integrarse con software HTTP (cliente y servidor) existente, y proporciona una implementaci\u00f3n m\u00ednima para construir, parsear y validar peticiones y respuestas HTTP. La segunda fase implementa el n\u00facleo del protocolo websockets , y proporciona una implementaci\u00f3n completa basada en el m\u00f3dulo asyncio ) de Python. Para utilizar el m\u00f3dulo websockets de Python, primero lo instalaremos v\u00eda pip : pip install websockets Un ejemplo b\u00e1sico se puede basar en un cliente que env\u00eda una cadena a un servidor, y queda a la espera de recibir un mensaje de respuesta por parte de \u00e9ste. Desarrollar la parte servidora para dicha aplicaci\u00f3n resulta sencillo. Observa el siguiente c\u00f3digo: #!/usr/bin/env python import asyncio import websockets async def hello(websocket, path): name = await websocket.recv() print(f\"< {name}\") greeting = f\"Hello {name}!\" await websocket.send(greeting) print(f\"> {greeting}\") start_server = websockets.serve(hello, \"localhost\", 8765) asyncio.get_event_loop().run_until_complete(start_server) asyncio.get_event_loop().run_forever() El paradigma de programaci\u00f3n utilizado en este ejemplo (basado en el m\u00f3dulo asyncio ) queda fuera del prop\u00f3sito de la pr\u00e1ctica (aunque se invita al alumno a estudiarlo, ya que aporta importantes ventajas a nivel de sencillez de desarrollo en aplicaciones de red). En cualquier caso, el anterior servidor ejecuta una (co)rutina manejadora hello para cada conexi\u00f3n websocket establecida; adem\u00e1s, se cierra dicha conexi\u00f3n cuando dicha (co)rutina finaliza. Concretamente, las funciones de inter\u00e9s en este caso son: await websockets.server.serve(ws_handler, host=None, port=None, # ... Crea, incializa y devuelve un objeto servidor Websocket asociado al host y puerto seleccionados. En un contexto de programaci\u00f3n as\u00edncrona (como el del ejemplo, el servidor finaliza autom\u00e1ticamente al salir de dicho contexto). Cuando un cliente conecta al host y puerto espec\u00edficados, se acepta la conexi\u00f3n, que es tratada por la (co)rutina ws_handler (en el ejemplo, hello ). Antes de delegar la conexi\u00f3n a la (co)rutina, se lleva a cabo el handshake de apertura websocket . await recv() Recibe el siguiente mensaje, devolviendo una cadena si el frame recibido es de texto, o un array de bytes si es binario. await send(message) Env\u00eda un mensaje. message puede er una cadena, o un array de bytes. En el primer caso, se env\u00eda un frame de texto; en el segundo caso, un frame binario. A continuaci\u00f3n se muestra un ejemplo de cliente websocket para interactuar con el anterior servidor: #!/usr/bin/env python import asyncio import websockets async def hello(): uri = \"ws://localhost:8765\" async with websockets.connect(uri) as websocket: name = input(\"What's your name? \") await websocket.send(name) print(f\"> {name}\") greeting = await websocket.recv() print(f\"< {greeting}\") asyncio.get_event_loop().run_until_complete(hello()) El c\u00f3digo en este caso es sencillo, ya que \u00fanicamente se basa en la planificaci\u00f3n (ejecuci\u00f3n) de una (co)rutina llamada hello , que establece una conexi\u00f3n con un servidor websocket v\u00eda connect , enviando y recibiendo un par de mensajes. await websockets.client.connect(uri, # ... Conecta con un servidor websocket en la URI determinada. La conexi\u00f3n se cierra al abandonar el contexto as\u00edncrono (es decir, la (co)rutina hello ). Tarea opcional Crea un servidor Python que interactue con una versi\u00f3n derivada del cliente ESP32 anterior.","title":"Sistema cliente/servidor usando Websockets en Python"},{"location":"RPI-II/P4_old/","text":"Pr\u00e1ctica 4. Protocolos b\u00e1sicos de capa de aplicaci\u00f3n. Websockets Objetivos Conocer el m\u00f3dulo Python websockets para desarrollar sistemas b\u00e1sicos cliente/servidor utilizando websockets . Estudar el intercambio de mensajes entre un cliente y un servidor websockets , tanto en la fase de handshake como de intercambio de datos. Conseguir interactuar con un servidor websockets utilizando un navegador web como cliente. Estudiar mecanismos de mantenimiento y publicaci\u00f3n de estado a clientes conectados, t\u00edpicos en un entorno IoT. Estudiar el componente websockets client en ESP-IDF, y desarrollar un firmware b\u00e1sico que interact\u00fae con un servidor Python. Introducir la gesti\u00f3n de objetos JSON en ESP-IDF. Los ficheros necesarios para completar la pr\u00e1ctica pueden descargarse aqu\u00ed . Ejemplo b\u00e1sico: sistema cliente/servidor usando Websockets en Python (\u00b4client1.py, server1.py`) En primer lugar, introducimos el uso del m\u00f3dulo Python websockets , que proporciona toda la funcionalidad necesaria para desarrollar sistemas cliente/servidor utilizando websockets . El m\u00f3dulo websockets proporciona la funcionalidad necesaria tanto a nivel de cliente como de servidor para implementar sistemas basados en dicho protocolo. Concretamente, las funciones de alto nivel que proporciona est\u00e1n basadas en una API de bajo nivel que implementa las dos fases principales del protocolo websockets : Handshake de apertura de comunicaci\u00f3n, en forma de peticiones HTTP upgrade . Transferencia de datos, y finalizaci\u00f3n de la comunicaci\u00f3n con un handshake de cierre de conexi\u00f3n. La primera fase est\u00e1 dise\u00f1ada para integrarse con software HTTP (cliente y servidor) existente, y proporciona una implementaci\u00f3n m\u00ednima para construir, parsear y validar peticiones y respuestas HTTP. La segunda fase implementa el n\u00facleo del protocolo websockets , y proporciona una implementaci\u00f3n completa basada en el m\u00f3dulo asyncio ) de Python. Para utilizar el m\u00f3dulo websockets de Python, primero lo instalaremos v\u00eda pip : pip install websockets Un ejemplo b\u00e1sico se puede basar en un cliente que env\u00eda una cadena a un servidor, y queda a la espera de recibir un mensaje de respuesta por parte de \u00e9ste, tal y como hemos visto en otras pr\u00e1cticas. Desarrollar la parte servidora para dicha aplicaci\u00f3n resulta sencillo. Observa el siguiente c\u00f3digo: #!/usr/bin/env python import asyncio import websockets async def hello(websocket, path): name = await websocket.recv() print(f\"< {name}\") greeting = f\"Hello {name}!\" await websocket.send(greeting) print(f\"> {greeting}\") start_server = websockets.serve(hello, \"localhost\", 8765) asyncio.get_event_loop().run_until_complete(start_server) asyncio.get_event_loop().run_forever() El paradigma de programaci\u00f3n utilizado en este ejemplo (basado en el m\u00f3dulo asyncio ) queda fuera del prop\u00f3sito de la pr\u00e1ctica (aunque se invita al alumno a estudiarlo, ya que aporta importantes ventajas a nivel de sencillez de desarrollo en aplicaciones de red). En cualquier caso, el anterior servidor ejecuta una (co)rutina manejadora hello para cada conexi\u00f3n websocket establecida; adem\u00e1s, se cierra dicha conexi\u00f3n cuando dicha (co)rutina finaliza. Concretamente, las funciones de inter\u00e9s en este caso son: await websockets.server.serve(ws_handler, host=None, port=None, # ... Crea, incializa y devuelve un objeto servidor Websocket asociado al host y puerto seleccionados. En un contexto de programaci\u00f3n as\u00edncrona (como el del ejemplo, el servidor finaliza autom\u00e1ticamente al salir de dicho contexto). Cuando un cliente conecta al host y puerto espec\u00edficados, se acepta la conexi\u00f3n, que es tratada por la (co)rutina ws_handler (en el ejemplo, hello ). Antes de delegar la conexi\u00f3n a la (co)rutina, se lleva a cabo el handshake de apertura websocket . await recv() Recibe el siguiente mensaje, devolviendo una cadena si el frame recibido es de texto, o un array de bytes si es binario. await send(message) Env\u00eda un mensaje. message puede er una cadena, o un array de bytes. En el primer caso, se env\u00eda un frame de texto; en el segundo caso, un frame binario. A continuaci\u00f3n se muestra un ejemplo de cliente websocket para interactuar con el anterior servidor: #!/usr/bin/env python import asyncio import websockets async def hello(): uri = \"ws://localhost:8765\" async with websockets.connect(uri) as websocket: name = input(\"What's your name? \") await websocket.send(name) print(f\"> {name}\") greeting = await websocket.recv() print(f\"< {greeting}\") asyncio.get_event_loop().run_until_complete(hello()) El c\u00f3digo en este caso es sencillo, ya que \u00fanicamente se basa en la planificaci\u00f3n (ejecuci\u00f3n) de una (co)rutina llamada hello , que establece una conexi\u00f3n con un servidor websocket v\u00eda connect , enviando y recibiendo un par de mensajes. await websockets.client.connect(uri, # ... Conecta con un servidor websocket en la URI determinada. La conexi\u00f3n se cierra al abandonar el contexto as\u00edncrono (es decir, la (co)rutina hello ). Tarea entregable Ejecuta el servidor en una terminal de tu m\u00e1quina virtual, y a continuaci\u00f3n el cliente en otra. Analiza el tr\u00e1fico intercambiado y responde a las siguientes preguntas: \u00bfEn qu\u00e9 protocolo de capa de transporte se basa la comunicaci\u00f3n v\u00eda Websockets? En la fase de handshake , \u00bfqu\u00e9 peticiones HTTP se intercambian? Analiza sus emisores y destinatarios, e investiga el cometido principal de cada uno de los campos de sus encabezados (f\u00edjate principalmente en el campo Upgrade y los campos espec\u00edficos para Websockets). En la fase de intercambio de datos, \u00bfqu\u00e9 opcode se especifica en el encabezado de cada paquete? \u00bfPor qu\u00e9? \u00bfSe env\u00edan los datos en claro o cifrados? \u00bfQu\u00e9 opcode se a\u00f1ade en los mensajes de cierre de conexi\u00f3n? Interactuando con un navegador web ( client_for_web.html , server_for_web.py ) Aunque fuera del inter\u00e9s de esta pr\u00e1ctica, es conveniente observar una de las ventajas de websockets : el env\u00edo as\u00edncrono bidireccional de informaci\u00f3n, y observarlo a trav\u00e9s de un navegador web convencional (la mayor\u00eda de navegadores modernos soportan websockets a trav\u00e9s de scripts Javascript ). En este caso, simplemente observa la interacci\u00f3n de un servidor websocket que env\u00eda mensajes que incluyen la hora actual separados un n\u00famero aleatorio de tiempo entre ellos: #!/usr/bin/env python # WS server that sends messages at random intervals import asyncio import datetime import random import websockets async def time(websocket, path): while True: now = datetime.datetime.utcnow().isoformat() + \"Z\" await websocket.send(now) await asyncio.sleep(random.random() * 3) start_server = websockets.serve(time, \"127.0.0.1\", 5678) asyncio.get_event_loop().run_until_complete(start_server) asyncio.get_event_loop().run_forever() Con un cliente (una p\u00e1gina HTML) que establece la conexi\u00f3n v\u00eda websockets , y muestra en la misma un elemento de texto con la marca de tiempo recibida tras la recepci\u00f3n de cada mensaje: <!DOCTYPE html> <html> <head> <title>WebSocket demo</title> </head> <body> <script> var ws = new WebSocket(\"ws://127.0.0.1:5678/\"), messages = document.createElement('ul'); ws.onmessage = function (event) { var messages = document.getElementsByTagName('ul')[0], message = document.createElement('li'), content = document.createTextNode(event.data); message.appendChild(content); messages.appendChild(message); }; document.body.appendChild(messages); </script> </body> </html> Tarea Ejecuta el servidor en tu m\u00e1quina virtual y, tras guardar el c\u00f3digo fuente del cliente en un fichero cliente.html , \u00e1brelo con un navegador. Observa como la p\u00e1gina se actualiza a medida que recibe mensajes a trav\u00e9s del socket. Si quieres, puedes observar el intercambio de mensajes. \u00bfQu\u00e9 ocurre si, en otra pesta\u00f1a, vuelves a abrir la p\u00e1gina cliente? Un ejemplo m\u00e1s complejo: sincronizaci\u00f3n entre m\u00faltiples clientes ( server2.py , client.html ) Un servidor websocket puede recibir eventos desde distintos clientes, procesarlos para, por ejemplo, mantener actualizado un estado a nivel de aplicaci\u00f3n, y sincronizar dicho estado entre todos los clientes conectados, envi\u00e1ndoles mensajes de forma as\u00edncrona a trav\u00e9s del socket bidireccional, a modo de \"notificaciones push \". A continuaci\u00f3n, se muestra el c\u00f3digo de un servidor que mantiene dos tipos de informaci\u00f3n de estado siempre actualizada: el valor de un contador ( STATE ), que puede ser modificado por los clientes conectados sumando o restando uno a su valor a trav\u00e9s de mensajes enviados por el socket ; y el n\u00famero de clientes conectados ( USERS ). #!/usr/bin/env python import asyncio import json import logging import websockets logging.basicConfig() STATE = {\"value\": 0} USERS = set() def state_event(): return json.dumps({\"type\": \"state\", **STATE}) def users_event(): return json.dumps({\"type\": \"users\", \"count\": len(USERS)}) async def notify_state(): if USERS: # asyncio.wait doesn't accept an empty list message = state_event() await asyncio.wait([user.send(message) for user in USERS]) async def notify_users(): if USERS: # asyncio.wait doesn't accept an empty list message = users_event() await asyncio.wait([user.send(message) for user in USERS]) async def register(websocket): USERS.add(websocket) await notify_users() async def unregister(websocket): USERS.remove(websocket) await notify_users() async def counter(websocket, path): # register(websocket) sends user_event() to websocket await register(websocket) try: await websocket.send(state_event()) async for message in websocket: data = json.loads(message) if data[\"action\"] == \"minus\": STATE[\"value\"] -= 1 await notify_state() elif data[\"action\"] == \"plus\": STATE[\"value\"] += 1 await notify_state() else: logging.error(\"unsupported event: {}\", data) finally: await unregister(websocket) start_server = websockets.serve(counter, \"localhost\", 6789) asyncio.get_event_loop().run_until_complete(start_server) asyncio.get_event_loop().run_forever() Observa el c\u00f3digo del servidor. El manejador counter procesa cada conexi\u00f3n entrante, registrando a su entrada a un nuevo cliente en el sistema ( register ) y desregistr\u00e1ndolo antes de finalizar ( unregister ). Ante cada registro o desregistro, se notifica a los usuarios este hecho, enviando a cada cliente un peque\u00f1o texto en formato JSON cuyo contenido es: {\"type\": \"users\", \"count\": usuarios} Es decir, un mensaje con dos campos (veremos JSON en la pr\u00f3xima pr\u00e1ctica): campo type , con valor fijo users , y campo count , con un valor entero que indica el n\u00famero de clientes conectados. A continuaci\u00f3n, para cada mensaje recibido a trav\u00e9s del socket, \u00e9ste se procesa, esperando tambi\u00e9n un fichero JSON con la acci\u00f3n que el cliente solicita (sumar o restar 1 al contador), por ejemplo: {\"action\": \"minus\"} o {\"action\": \"plus\"} En funci\u00f3n de la acci\u00f3n solicitada, el servidor actualiza el valor de STATE , y env\u00eda (rutina notify_state ) dicho valor actualizado a TODOS los clientes conectados mediante un peque\u00f1o mensaje de texto en formato JSON: {\"type\": \"state\", \"value\": VALOR} La parte cliente sigue la misma filosof\u00eda, utilizando de nuevo el navegador como plataforma para visualizar la interacci\u00f3n con el cliente. El c\u00f3digo HTML que puedes abrir en tu navegador es el siguiente: <!DOCTYPE html> <html> <head> <title>WebSocket demo</title> <style type=\"text/css\"> body { font-family: \"Courier New\", sans-serif; text-align: center; } .buttons { font-size: 4em; display: flex; justify-content: center; } .button, .value { line-height: 1; padding: 2rem; margin: 2rem; border: medium solid; min-height: 1em; min-width: 1em; } .button { cursor: pointer; user-select: none; } .minus { color: red; } .plus { color: green; } .value { min-width: 2em; } .state { font-size: 2em; } </style> </head> <body> <div class=\"buttons\"> <div class=\"minus button\">-</div> <div class=\"value\">?</div> <div class=\"plus button\">+</div> </div> <div class=\"state\"> <span class=\"users\">?</span> online </div> <script> var minus = document.querySelector('.minus'), plus = document.querySelector('.plus'), value = document.querySelector('.value'), users = document.querySelector('.users'), websocket = new WebSocket(\"ws://127.0.0.1:6789/\"); minus.onclick = function (event) { websocket.send(JSON.stringify({action: 'minus'})); } plus.onclick = function (event) { websocket.send(JSON.stringify({action: 'plus'})); } websocket.onmessage = function (event) { data = JSON.parse(event.data); switch (data.type) { case 'state': value.textContent = data.value; break; case 'users': users.textContent = ( data.count.toString() + \" user\" + (data.count == 1 ? \"\" : \"s\")); break; default: console.error( \"unsupported event\", data); } }; </script> </body> </html> Observa c\u00f3mo el script env\u00eda mensajes de suma o resta en formato JSON acorde al esperado por el servidor, y procesa los mensajes de entrada actualizando la informaci\u00f3n mostrada en pantalla recibida acerca del valor del contador actualizado y n\u00famero de usuarios. Tarea Ejecuta el servidor en tu m\u00e1quina virtual, y m\u00faltiples clientes en distintas ventanas/pesta\u00f1as del navegador (con ventanas lo ver\u00e1s mejor). Interact\u00faa desde un cliente aumentando o reduciendo el valor del contador, y observa c\u00f3mo dicho valor es actualizado (a trav\u00e9s del servidor) en el resto de clientes abiertos. Conecta y desconecta nuevos clientes y observa tambi\u00e9n como el campo correspondiente en la p\u00e1gina web se actualiza correctamente. Si quieres, puedes analizar el tr\u00e1fico Websockets generado v\u00eda Wireshark. Websockets en el ESP32 El soporte a nivel de cliente para el protocolo websockets est\u00e1 integrado en ESP-IDF a trav\u00e9sd el componente websocket client , cuya documentaci\u00f3n puede consultarse a trav\u00e9s de este enlace . El componente websocket client ofrece soporte para el protocolo websocket sobre TCP y tambi\u00e9n, opcionalmente, sobre TLS. Como todos los componentes en ESP-IDF, el componente websocket emite eventos que pueden ser tratados por parte de la aplicaci\u00f3n, entre los cuales destacan: WEBSOCKET_EVENT_CONNECTED : se emite una vez el cliente se ha conectado al servidor, sin intercambio de datos. WEBSOCKET_EVENT_DISCONNECTED : se emite en el instante de la desconexi\u00f3n entre cliente y servidor. WEBSOCKET_EVENT_DATA : se emite al recibir datos desde el servidor. Este \u00faltimo evento es de especial inter\u00e9s para nosotros, ya que accarrea la construcci\u00f3n de una estructura de tipo esp_websocket_event_data_t en la que se almacena el mensaje recibido desde el servidor (tanto en sus campos de control como de datos). Algunos campos de inter\u00e9s dentro de la estructura son: const char * data_ptr : puntero a los datos recibidos ( payload ). data_len : tama\u00f1o (en bytes) de los datos recibidos. op_code : c\u00f3digo de operaci\u00f3n asociado al mensaje recibido. La documentaci\u00f3n del componente ofrece informaci\u00f3n sobre campos adicionales, de menor inter\u00e9s para nosotros. Observemos el c\u00f3digo de una posible funci\u00f3n manejadora de eventos del componente websocket : static void websocket_event_handler(void *handler_args, esp_event_base_t base, int32_t event_id, void *event_data) { esp_websocket_event_data_t *data = (esp_websocket_event_data_t *)event_data; switch (event_id) { case WEBSOCKET_EVENT_CONNECTED: ESP_LOGI(TAG, \"WEBSOCKET_EVENT_CONNECTED\"); break; case WEBSOCKET_EVENT_DISCONNECTED: ESP_LOGI(TAG, \"WEBSOCKET_EVENT_DISCONNECTED\"); break; case WEBSOCKET_EVENT_DATA: ESP_LOGI(TAG, \"WEBSOCKET_EVENT_DATA\"); ESP_LOGI(TAG, \"Received opcode=%d\", data->op_code); if (data->op_code == 0x08 && data->data_len == 2) { ESP_LOGW(TAG, \"Received closed message with code=%d\", 256*data->data_ptr[0] + data->data_ptr[1]); } else { ESP_LOGW(TAG, \"Received=%.*s\", data->data_len, (char *)data->data_ptr); } ESP_LOGW(TAG, \"Total payload length=%d, data_len=%d, current payload offset=%d\\r\\n\", data->payload_len, data->data_len, data->payload_offset); xTimerReset(shutdown_signal_timer, portMAX_DELAY); break; case WEBSOCKET_EVENT_ERROR: ESP_LOGI(TAG, \"WEBSOCKET_EVENT_ERROR\"); break; } } Observa el c\u00f3digo. En funci\u00f3n del par\u00e1metro event_id , el manejador toma un camino de ejecuci\u00f3n u otro. Centr\u00e9monos en la recepci\u00f3n de un evento de tipo \u1e80EBSOCKET_EVENT_DATA ; a trav\u00e9s de los distintos campos de la estructura de informaci\u00f3n recibida ( event_data ), es posible: Obtener y mostrar el c\u00f3digo de la operaci\u00f3n ( op_code ). Mostrar el contenido del mensaje recibido ( data_ptr ). Mostrar el tama\u00f1o del mensaje recibido ( data_len y payload_len ). Preguntas \u00bfCu\u00e1l es la diferencia entre los campos data_len y payload_len ? \u00bfPor qu\u00e9 el programa realiza un tratamiento especial cuando op_code == 8 ? Dada la anterior funci\u00f3n manejadora, la inicializaci\u00f3n de un cliente websockets en el ESP32 es sencilla, y se resume en los siguientes pasos: Configuraci\u00f3n de URI (host + puerto) esp_websocket_client_config_t websocket_cfg = {}; websocket_cfg.uri = \"ws://localhost:123\"; esp_websocket_client_handle_t client = esp_websocket_client_init(&websocket_cfg); Asociaci\u00f3n de manejador a eventos Websocket esp_websocket_register_events(client, WEBSOCKET_EVENT_ANY, websocket_event_handler, (void *)client); Inicializaci\u00f3n del cliente esp_websocket_client_start(client); A partir de este punto, la interacci\u00f3n con el servidor se puede realizar en base a funciones de env\u00edo de texto o binario: int esp_websocket_client_send(esp_websocket_client_handle_tclient, const char *data, int len, TickType_t timeout) esp_websocket_client_send_bin(esp_websocket_client_handle_tclient, const char *data, int len, TickType_t timeout) No existen funciones de recepci\u00f3n, ya que \u00e9sta es impl\u00edcita y se notifica v\u00eda eventos. Ejemplo b\u00e1sico: cliente echo Veremos en primer lugar un ejemplo completo de cliente ejecutado sobre el ESP32. En este punto, configura, compila, flashea y monitoriza el ejemplo examples/protocols/websockets . El ejemplo simplemente conecta con un servidor echo Websockets en la nube (disponible en ws://websockets.org ). Dicho servidor simplemente espera, por parte de cada cliente, el env\u00edo a trav\u00e9s de la conexi\u00f3n de una cadena, respondiendo con la misma cadena en sentido contrario, siempre usando el mismo socket . Tarea Observa el c\u00f3digo del ejemplo y su ejecuci\u00f3n. Determina cu\u00e1l es el funcionamiento del ejemplo, y comprueba que los fragmentos de c\u00f3digo anteriores tienen su funci\u00f3n dentro del c\u00f3digo completo. \u00bfC\u00f3mo implementa el programa la espera limitada en tiempo si no se recibe ning\u00fan paquete tras cierto per\u00edodo? Ejercicio entregable: Comunicaci\u00f3n as\u00edncrona El objetivo del ejercicio entregable es conseguir que el ESP32 se comunique con el servidor Python que se prob\u00f3 en la secci\u00f3n anterior, y que implementaba comunicaci\u00f3n bidireccional para mantener y difundir el estado interno (contador y n\u00famero de clientes conectados) entre todos los clientes conectados. Para ello, se pide modificar el ejemplo de cliente echo para que: El cliente conecte con el servidor Python especificando su IP y puerto. El cliente sea cien por cien pasivo, es decir, no env\u00ede nunca mensajes al servidor. La funci\u00f3n de manejo de paquetes recibidos trate de forma especial el tipo de mensajes esperado por parte del servidor. Recuerda que se pueden recibir dos tipos de mensajes de texto: Mensajes de estado: {\"type\": \"users\", \"count\": usuarios} Mensajes de usuarios: {\"type\": \"state\", \"value\": VALOR} Observa que ambos mensajes, pese a ser recibidos como texto, corresponden con una representaci\u00f3n JSON de la informaci\u00f3n. Para tratarla desde ESP-IDF, puedes hacer uso del componente cJSON del framework . Por ejemplo, para tratar un mensaje de entrada de tipo \"state\", podr\u00edamos a\u00f1adir la siguiente secuencia de c\u00f3digo en nuestro manejador: #include \"cJSON.h\" // ... if( data->op_code == 1 ) { // Text frame only. cJSON *root = cJSON_Parse((char*)data->data_ptr); char *type = cJSON_GetObjectItem(root,\"type\")->valuestring; ESP_LOGI(TAG, \"type=%s\",type); int field = 0; if( strcmp( type, \"state\" ) == 0) { field = cJSON_GetObjectItem(root,\"value\")->valueint; ESP_LOGI(TAG, \"value=%d\",field); } } Tarea entregable Modifica el firmware de ejemplo websockets para que pueda comunicarse en modo lectura con el servidor Python que mantiene y publicita estado, cuyo c\u00f3digo se te proporciona. El programa ESP-IDF, al menos, mostar\u00e1 por pantalla un mensaje con los datos asociados cada vez que se reciban paquetes de tipo texto ( state o users ). Tambi\u00e9n mostrar\u00e1 un mensaje cada vez que el servidor env\u00ede un mensaje de tipo ping o pong (para ello, consulta el RFC que describe el protocolo para determinar el opcode asociado). Para comprobar el funcionamiento de la soluci\u00f3n, arranca el servidor y al menos dos clientes web. Cuando arranques el ESP32, ambos deber\u00e1n incrementar el n\u00famero de clientes reportado, en respuesta al mensaje enviado por el servidor. Cuando cualquiera de los clientes web incremente el valor del contador, el ESP32 recibir\u00e1 un mensaje con el valor actualizado, del mismo modo que cuando cierres uno de los navegadores web. Tarea opcional Modifica el c\u00f3digo para que el cliente, peri\u00f3dicamente, env\u00ede un mensaje de petici\u00f3n de suma o resta siguiendo las especificaciones y tipos de mensaje que se explicaron anteriormente.","title":"Pr\u00e1ctica 4. Protocolos b\u00e1sicos de capa de aplicaci\u00f3n. Websockets"},{"location":"RPI-II/P4_old/#practica-4-protocolos-basicos-de-capa-de-aplicacion-websockets","text":"","title":"Pr\u00e1ctica 4. Protocolos b\u00e1sicos de capa de aplicaci\u00f3n. Websockets"},{"location":"RPI-II/P4_old/#objetivos","text":"Conocer el m\u00f3dulo Python websockets para desarrollar sistemas b\u00e1sicos cliente/servidor utilizando websockets . Estudar el intercambio de mensajes entre un cliente y un servidor websockets , tanto en la fase de handshake como de intercambio de datos. Conseguir interactuar con un servidor websockets utilizando un navegador web como cliente. Estudiar mecanismos de mantenimiento y publicaci\u00f3n de estado a clientes conectados, t\u00edpicos en un entorno IoT. Estudiar el componente websockets client en ESP-IDF, y desarrollar un firmware b\u00e1sico que interact\u00fae con un servidor Python. Introducir la gesti\u00f3n de objetos JSON en ESP-IDF. Los ficheros necesarios para completar la pr\u00e1ctica pueden descargarse aqu\u00ed .","title":"Objetivos"},{"location":"RPI-II/P4_old/#ejemplo-basico-sistema-clienteservidor-usando-websockets-en-python-client1py-server1py","text":"En primer lugar, introducimos el uso del m\u00f3dulo Python websockets , que proporciona toda la funcionalidad necesaria para desarrollar sistemas cliente/servidor utilizando websockets . El m\u00f3dulo websockets proporciona la funcionalidad necesaria tanto a nivel de cliente como de servidor para implementar sistemas basados en dicho protocolo. Concretamente, las funciones de alto nivel que proporciona est\u00e1n basadas en una API de bajo nivel que implementa las dos fases principales del protocolo websockets : Handshake de apertura de comunicaci\u00f3n, en forma de peticiones HTTP upgrade . Transferencia de datos, y finalizaci\u00f3n de la comunicaci\u00f3n con un handshake de cierre de conexi\u00f3n. La primera fase est\u00e1 dise\u00f1ada para integrarse con software HTTP (cliente y servidor) existente, y proporciona una implementaci\u00f3n m\u00ednima para construir, parsear y validar peticiones y respuestas HTTP. La segunda fase implementa el n\u00facleo del protocolo websockets , y proporciona una implementaci\u00f3n completa basada en el m\u00f3dulo asyncio ) de Python. Para utilizar el m\u00f3dulo websockets de Python, primero lo instalaremos v\u00eda pip : pip install websockets Un ejemplo b\u00e1sico se puede basar en un cliente que env\u00eda una cadena a un servidor, y queda a la espera de recibir un mensaje de respuesta por parte de \u00e9ste, tal y como hemos visto en otras pr\u00e1cticas. Desarrollar la parte servidora para dicha aplicaci\u00f3n resulta sencillo. Observa el siguiente c\u00f3digo: #!/usr/bin/env python import asyncio import websockets async def hello(websocket, path): name = await websocket.recv() print(f\"< {name}\") greeting = f\"Hello {name}!\" await websocket.send(greeting) print(f\"> {greeting}\") start_server = websockets.serve(hello, \"localhost\", 8765) asyncio.get_event_loop().run_until_complete(start_server) asyncio.get_event_loop().run_forever() El paradigma de programaci\u00f3n utilizado en este ejemplo (basado en el m\u00f3dulo asyncio ) queda fuera del prop\u00f3sito de la pr\u00e1ctica (aunque se invita al alumno a estudiarlo, ya que aporta importantes ventajas a nivel de sencillez de desarrollo en aplicaciones de red). En cualquier caso, el anterior servidor ejecuta una (co)rutina manejadora hello para cada conexi\u00f3n websocket establecida; adem\u00e1s, se cierra dicha conexi\u00f3n cuando dicha (co)rutina finaliza. Concretamente, las funciones de inter\u00e9s en este caso son: await websockets.server.serve(ws_handler, host=None, port=None, # ... Crea, incializa y devuelve un objeto servidor Websocket asociado al host y puerto seleccionados. En un contexto de programaci\u00f3n as\u00edncrona (como el del ejemplo, el servidor finaliza autom\u00e1ticamente al salir de dicho contexto). Cuando un cliente conecta al host y puerto espec\u00edficados, se acepta la conexi\u00f3n, que es tratada por la (co)rutina ws_handler (en el ejemplo, hello ). Antes de delegar la conexi\u00f3n a la (co)rutina, se lleva a cabo el handshake de apertura websocket . await recv() Recibe el siguiente mensaje, devolviendo una cadena si el frame recibido es de texto, o un array de bytes si es binario. await send(message) Env\u00eda un mensaje. message puede er una cadena, o un array de bytes. En el primer caso, se env\u00eda un frame de texto; en el segundo caso, un frame binario. A continuaci\u00f3n se muestra un ejemplo de cliente websocket para interactuar con el anterior servidor: #!/usr/bin/env python import asyncio import websockets async def hello(): uri = \"ws://localhost:8765\" async with websockets.connect(uri) as websocket: name = input(\"What's your name? \") await websocket.send(name) print(f\"> {name}\") greeting = await websocket.recv() print(f\"< {greeting}\") asyncio.get_event_loop().run_until_complete(hello()) El c\u00f3digo en este caso es sencillo, ya que \u00fanicamente se basa en la planificaci\u00f3n (ejecuci\u00f3n) de una (co)rutina llamada hello , que establece una conexi\u00f3n con un servidor websocket v\u00eda connect , enviando y recibiendo un par de mensajes. await websockets.client.connect(uri, # ... Conecta con un servidor websocket en la URI determinada. La conexi\u00f3n se cierra al abandonar el contexto as\u00edncrono (es decir, la (co)rutina hello ). Tarea entregable Ejecuta el servidor en una terminal de tu m\u00e1quina virtual, y a continuaci\u00f3n el cliente en otra. Analiza el tr\u00e1fico intercambiado y responde a las siguientes preguntas: \u00bfEn qu\u00e9 protocolo de capa de transporte se basa la comunicaci\u00f3n v\u00eda Websockets? En la fase de handshake , \u00bfqu\u00e9 peticiones HTTP se intercambian? Analiza sus emisores y destinatarios, e investiga el cometido principal de cada uno de los campos de sus encabezados (f\u00edjate principalmente en el campo Upgrade y los campos espec\u00edficos para Websockets). En la fase de intercambio de datos, \u00bfqu\u00e9 opcode se especifica en el encabezado de cada paquete? \u00bfPor qu\u00e9? \u00bfSe env\u00edan los datos en claro o cifrados? \u00bfQu\u00e9 opcode se a\u00f1ade en los mensajes de cierre de conexi\u00f3n?","title":"Ejemplo b\u00e1sico: sistema cliente/servidor usando Websockets en Python (\u00b4client1.py, server1.py`)"},{"location":"RPI-II/P4_old/#interactuando-con-un-navegador-web-client_for_webhtml-server_for_webpy","text":"Aunque fuera del inter\u00e9s de esta pr\u00e1ctica, es conveniente observar una de las ventajas de websockets : el env\u00edo as\u00edncrono bidireccional de informaci\u00f3n, y observarlo a trav\u00e9s de un navegador web convencional (la mayor\u00eda de navegadores modernos soportan websockets a trav\u00e9s de scripts Javascript ). En este caso, simplemente observa la interacci\u00f3n de un servidor websocket que env\u00eda mensajes que incluyen la hora actual separados un n\u00famero aleatorio de tiempo entre ellos: #!/usr/bin/env python # WS server that sends messages at random intervals import asyncio import datetime import random import websockets async def time(websocket, path): while True: now = datetime.datetime.utcnow().isoformat() + \"Z\" await websocket.send(now) await asyncio.sleep(random.random() * 3) start_server = websockets.serve(time, \"127.0.0.1\", 5678) asyncio.get_event_loop().run_until_complete(start_server) asyncio.get_event_loop().run_forever() Con un cliente (una p\u00e1gina HTML) que establece la conexi\u00f3n v\u00eda websockets , y muestra en la misma un elemento de texto con la marca de tiempo recibida tras la recepci\u00f3n de cada mensaje: <!DOCTYPE html> <html> <head> <title>WebSocket demo</title> </head> <body> <script> var ws = new WebSocket(\"ws://127.0.0.1:5678/\"), messages = document.createElement('ul'); ws.onmessage = function (event) { var messages = document.getElementsByTagName('ul')[0], message = document.createElement('li'), content = document.createTextNode(event.data); message.appendChild(content); messages.appendChild(message); }; document.body.appendChild(messages); </script> </body> </html> Tarea Ejecuta el servidor en tu m\u00e1quina virtual y, tras guardar el c\u00f3digo fuente del cliente en un fichero cliente.html , \u00e1brelo con un navegador. Observa como la p\u00e1gina se actualiza a medida que recibe mensajes a trav\u00e9s del socket. Si quieres, puedes observar el intercambio de mensajes. \u00bfQu\u00e9 ocurre si, en otra pesta\u00f1a, vuelves a abrir la p\u00e1gina cliente?","title":"Interactuando con un navegador web (client_for_web.html, server_for_web.py)"},{"location":"RPI-II/P4_old/#un-ejemplo-mas-complejo-sincronizacion-entre-multiples-clientes-server2py-clienthtml","text":"Un servidor websocket puede recibir eventos desde distintos clientes, procesarlos para, por ejemplo, mantener actualizado un estado a nivel de aplicaci\u00f3n, y sincronizar dicho estado entre todos los clientes conectados, envi\u00e1ndoles mensajes de forma as\u00edncrona a trav\u00e9s del socket bidireccional, a modo de \"notificaciones push \". A continuaci\u00f3n, se muestra el c\u00f3digo de un servidor que mantiene dos tipos de informaci\u00f3n de estado siempre actualizada: el valor de un contador ( STATE ), que puede ser modificado por los clientes conectados sumando o restando uno a su valor a trav\u00e9s de mensajes enviados por el socket ; y el n\u00famero de clientes conectados ( USERS ). #!/usr/bin/env python import asyncio import json import logging import websockets logging.basicConfig() STATE = {\"value\": 0} USERS = set() def state_event(): return json.dumps({\"type\": \"state\", **STATE}) def users_event(): return json.dumps({\"type\": \"users\", \"count\": len(USERS)}) async def notify_state(): if USERS: # asyncio.wait doesn't accept an empty list message = state_event() await asyncio.wait([user.send(message) for user in USERS]) async def notify_users(): if USERS: # asyncio.wait doesn't accept an empty list message = users_event() await asyncio.wait([user.send(message) for user in USERS]) async def register(websocket): USERS.add(websocket) await notify_users() async def unregister(websocket): USERS.remove(websocket) await notify_users() async def counter(websocket, path): # register(websocket) sends user_event() to websocket await register(websocket) try: await websocket.send(state_event()) async for message in websocket: data = json.loads(message) if data[\"action\"] == \"minus\": STATE[\"value\"] -= 1 await notify_state() elif data[\"action\"] == \"plus\": STATE[\"value\"] += 1 await notify_state() else: logging.error(\"unsupported event: {}\", data) finally: await unregister(websocket) start_server = websockets.serve(counter, \"localhost\", 6789) asyncio.get_event_loop().run_until_complete(start_server) asyncio.get_event_loop().run_forever() Observa el c\u00f3digo del servidor. El manejador counter procesa cada conexi\u00f3n entrante, registrando a su entrada a un nuevo cliente en el sistema ( register ) y desregistr\u00e1ndolo antes de finalizar ( unregister ). Ante cada registro o desregistro, se notifica a los usuarios este hecho, enviando a cada cliente un peque\u00f1o texto en formato JSON cuyo contenido es: {\"type\": \"users\", \"count\": usuarios} Es decir, un mensaje con dos campos (veremos JSON en la pr\u00f3xima pr\u00e1ctica): campo type , con valor fijo users , y campo count , con un valor entero que indica el n\u00famero de clientes conectados. A continuaci\u00f3n, para cada mensaje recibido a trav\u00e9s del socket, \u00e9ste se procesa, esperando tambi\u00e9n un fichero JSON con la acci\u00f3n que el cliente solicita (sumar o restar 1 al contador), por ejemplo: {\"action\": \"minus\"} o {\"action\": \"plus\"} En funci\u00f3n de la acci\u00f3n solicitada, el servidor actualiza el valor de STATE , y env\u00eda (rutina notify_state ) dicho valor actualizado a TODOS los clientes conectados mediante un peque\u00f1o mensaje de texto en formato JSON: {\"type\": \"state\", \"value\": VALOR} La parte cliente sigue la misma filosof\u00eda, utilizando de nuevo el navegador como plataforma para visualizar la interacci\u00f3n con el cliente. El c\u00f3digo HTML que puedes abrir en tu navegador es el siguiente: <!DOCTYPE html> <html> <head> <title>WebSocket demo</title> <style type=\"text/css\"> body { font-family: \"Courier New\", sans-serif; text-align: center; } .buttons { font-size: 4em; display: flex; justify-content: center; } .button, .value { line-height: 1; padding: 2rem; margin: 2rem; border: medium solid; min-height: 1em; min-width: 1em; } .button { cursor: pointer; user-select: none; } .minus { color: red; } .plus { color: green; } .value { min-width: 2em; } .state { font-size: 2em; } </style> </head> <body> <div class=\"buttons\"> <div class=\"minus button\">-</div> <div class=\"value\">?</div> <div class=\"plus button\">+</div> </div> <div class=\"state\"> <span class=\"users\">?</span> online </div> <script> var minus = document.querySelector('.minus'), plus = document.querySelector('.plus'), value = document.querySelector('.value'), users = document.querySelector('.users'), websocket = new WebSocket(\"ws://127.0.0.1:6789/\"); minus.onclick = function (event) { websocket.send(JSON.stringify({action: 'minus'})); } plus.onclick = function (event) { websocket.send(JSON.stringify({action: 'plus'})); } websocket.onmessage = function (event) { data = JSON.parse(event.data); switch (data.type) { case 'state': value.textContent = data.value; break; case 'users': users.textContent = ( data.count.toString() + \" user\" + (data.count == 1 ? \"\" : \"s\")); break; default: console.error( \"unsupported event\", data); } }; </script> </body> </html> Observa c\u00f3mo el script env\u00eda mensajes de suma o resta en formato JSON acorde al esperado por el servidor, y procesa los mensajes de entrada actualizando la informaci\u00f3n mostrada en pantalla recibida acerca del valor del contador actualizado y n\u00famero de usuarios. Tarea Ejecuta el servidor en tu m\u00e1quina virtual, y m\u00faltiples clientes en distintas ventanas/pesta\u00f1as del navegador (con ventanas lo ver\u00e1s mejor). Interact\u00faa desde un cliente aumentando o reduciendo el valor del contador, y observa c\u00f3mo dicho valor es actualizado (a trav\u00e9s del servidor) en el resto de clientes abiertos. Conecta y desconecta nuevos clientes y observa tambi\u00e9n como el campo correspondiente en la p\u00e1gina web se actualiza correctamente. Si quieres, puedes analizar el tr\u00e1fico Websockets generado v\u00eda Wireshark.","title":"Un ejemplo m\u00e1s complejo: sincronizaci\u00f3n entre m\u00faltiples clientes (server2.py, client.html)"},{"location":"RPI-II/P4_old/#websockets-en-el-esp32","text":"El soporte a nivel de cliente para el protocolo websockets est\u00e1 integrado en ESP-IDF a trav\u00e9sd el componente websocket client , cuya documentaci\u00f3n puede consultarse a trav\u00e9s de este enlace . El componente websocket client ofrece soporte para el protocolo websocket sobre TCP y tambi\u00e9n, opcionalmente, sobre TLS. Como todos los componentes en ESP-IDF, el componente websocket emite eventos que pueden ser tratados por parte de la aplicaci\u00f3n, entre los cuales destacan: WEBSOCKET_EVENT_CONNECTED : se emite una vez el cliente se ha conectado al servidor, sin intercambio de datos. WEBSOCKET_EVENT_DISCONNECTED : se emite en el instante de la desconexi\u00f3n entre cliente y servidor. WEBSOCKET_EVENT_DATA : se emite al recibir datos desde el servidor. Este \u00faltimo evento es de especial inter\u00e9s para nosotros, ya que accarrea la construcci\u00f3n de una estructura de tipo esp_websocket_event_data_t en la que se almacena el mensaje recibido desde el servidor (tanto en sus campos de control como de datos). Algunos campos de inter\u00e9s dentro de la estructura son: const char * data_ptr : puntero a los datos recibidos ( payload ). data_len : tama\u00f1o (en bytes) de los datos recibidos. op_code : c\u00f3digo de operaci\u00f3n asociado al mensaje recibido. La documentaci\u00f3n del componente ofrece informaci\u00f3n sobre campos adicionales, de menor inter\u00e9s para nosotros. Observemos el c\u00f3digo de una posible funci\u00f3n manejadora de eventos del componente websocket : static void websocket_event_handler(void *handler_args, esp_event_base_t base, int32_t event_id, void *event_data) { esp_websocket_event_data_t *data = (esp_websocket_event_data_t *)event_data; switch (event_id) { case WEBSOCKET_EVENT_CONNECTED: ESP_LOGI(TAG, \"WEBSOCKET_EVENT_CONNECTED\"); break; case WEBSOCKET_EVENT_DISCONNECTED: ESP_LOGI(TAG, \"WEBSOCKET_EVENT_DISCONNECTED\"); break; case WEBSOCKET_EVENT_DATA: ESP_LOGI(TAG, \"WEBSOCKET_EVENT_DATA\"); ESP_LOGI(TAG, \"Received opcode=%d\", data->op_code); if (data->op_code == 0x08 && data->data_len == 2) { ESP_LOGW(TAG, \"Received closed message with code=%d\", 256*data->data_ptr[0] + data->data_ptr[1]); } else { ESP_LOGW(TAG, \"Received=%.*s\", data->data_len, (char *)data->data_ptr); } ESP_LOGW(TAG, \"Total payload length=%d, data_len=%d, current payload offset=%d\\r\\n\", data->payload_len, data->data_len, data->payload_offset); xTimerReset(shutdown_signal_timer, portMAX_DELAY); break; case WEBSOCKET_EVENT_ERROR: ESP_LOGI(TAG, \"WEBSOCKET_EVENT_ERROR\"); break; } } Observa el c\u00f3digo. En funci\u00f3n del par\u00e1metro event_id , el manejador toma un camino de ejecuci\u00f3n u otro. Centr\u00e9monos en la recepci\u00f3n de un evento de tipo \u1e80EBSOCKET_EVENT_DATA ; a trav\u00e9s de los distintos campos de la estructura de informaci\u00f3n recibida ( event_data ), es posible: Obtener y mostrar el c\u00f3digo de la operaci\u00f3n ( op_code ). Mostrar el contenido del mensaje recibido ( data_ptr ). Mostrar el tama\u00f1o del mensaje recibido ( data_len y payload_len ). Preguntas \u00bfCu\u00e1l es la diferencia entre los campos data_len y payload_len ? \u00bfPor qu\u00e9 el programa realiza un tratamiento especial cuando op_code == 8 ? Dada la anterior funci\u00f3n manejadora, la inicializaci\u00f3n de un cliente websockets en el ESP32 es sencilla, y se resume en los siguientes pasos: Configuraci\u00f3n de URI (host + puerto) esp_websocket_client_config_t websocket_cfg = {}; websocket_cfg.uri = \"ws://localhost:123\"; esp_websocket_client_handle_t client = esp_websocket_client_init(&websocket_cfg); Asociaci\u00f3n de manejador a eventos Websocket esp_websocket_register_events(client, WEBSOCKET_EVENT_ANY, websocket_event_handler, (void *)client); Inicializaci\u00f3n del cliente esp_websocket_client_start(client); A partir de este punto, la interacci\u00f3n con el servidor se puede realizar en base a funciones de env\u00edo de texto o binario: int esp_websocket_client_send(esp_websocket_client_handle_tclient, const char *data, int len, TickType_t timeout) esp_websocket_client_send_bin(esp_websocket_client_handle_tclient, const char *data, int len, TickType_t timeout) No existen funciones de recepci\u00f3n, ya que \u00e9sta es impl\u00edcita y se notifica v\u00eda eventos.","title":"Websockets en el ESP32"},{"location":"RPI-II/P4_old/#ejemplo-basico-cliente-echo","text":"Veremos en primer lugar un ejemplo completo de cliente ejecutado sobre el ESP32. En este punto, configura, compila, flashea y monitoriza el ejemplo examples/protocols/websockets . El ejemplo simplemente conecta con un servidor echo Websockets en la nube (disponible en ws://websockets.org ). Dicho servidor simplemente espera, por parte de cada cliente, el env\u00edo a trav\u00e9s de la conexi\u00f3n de una cadena, respondiendo con la misma cadena en sentido contrario, siempre usando el mismo socket . Tarea Observa el c\u00f3digo del ejemplo y su ejecuci\u00f3n. Determina cu\u00e1l es el funcionamiento del ejemplo, y comprueba que los fragmentos de c\u00f3digo anteriores tienen su funci\u00f3n dentro del c\u00f3digo completo. \u00bfC\u00f3mo implementa el programa la espera limitada en tiempo si no se recibe ning\u00fan paquete tras cierto per\u00edodo?","title":"Ejemplo b\u00e1sico: cliente echo"},{"location":"RPI-II/P4_old/#ejercicio-entregable-comunicacion-asincrona","text":"El objetivo del ejercicio entregable es conseguir que el ESP32 se comunique con el servidor Python que se prob\u00f3 en la secci\u00f3n anterior, y que implementaba comunicaci\u00f3n bidireccional para mantener y difundir el estado interno (contador y n\u00famero de clientes conectados) entre todos los clientes conectados. Para ello, se pide modificar el ejemplo de cliente echo para que: El cliente conecte con el servidor Python especificando su IP y puerto. El cliente sea cien por cien pasivo, es decir, no env\u00ede nunca mensajes al servidor. La funci\u00f3n de manejo de paquetes recibidos trate de forma especial el tipo de mensajes esperado por parte del servidor. Recuerda que se pueden recibir dos tipos de mensajes de texto: Mensajes de estado: {\"type\": \"users\", \"count\": usuarios} Mensajes de usuarios: {\"type\": \"state\", \"value\": VALOR} Observa que ambos mensajes, pese a ser recibidos como texto, corresponden con una representaci\u00f3n JSON de la informaci\u00f3n. Para tratarla desde ESP-IDF, puedes hacer uso del componente cJSON del framework . Por ejemplo, para tratar un mensaje de entrada de tipo \"state\", podr\u00edamos a\u00f1adir la siguiente secuencia de c\u00f3digo en nuestro manejador: #include \"cJSON.h\" // ... if( data->op_code == 1 ) { // Text frame only. cJSON *root = cJSON_Parse((char*)data->data_ptr); char *type = cJSON_GetObjectItem(root,\"type\")->valuestring; ESP_LOGI(TAG, \"type=%s\",type); int field = 0; if( strcmp( type, \"state\" ) == 0) { field = cJSON_GetObjectItem(root,\"value\")->valueint; ESP_LOGI(TAG, \"value=%d\",field); } } Tarea entregable Modifica el firmware de ejemplo websockets para que pueda comunicarse en modo lectura con el servidor Python que mantiene y publicita estado, cuyo c\u00f3digo se te proporciona. El programa ESP-IDF, al menos, mostar\u00e1 por pantalla un mensaje con los datos asociados cada vez que se reciban paquetes de tipo texto ( state o users ). Tambi\u00e9n mostrar\u00e1 un mensaje cada vez que el servidor env\u00ede un mensaje de tipo ping o pong (para ello, consulta el RFC que describe el protocolo para determinar el opcode asociado). Para comprobar el funcionamiento de la soluci\u00f3n, arranca el servidor y al menos dos clientes web. Cuando arranques el ESP32, ambos deber\u00e1n incrementar el n\u00famero de clientes reportado, en respuesta al mensaje enviado por el servidor. Cuando cualquiera de los clientes web incremente el valor del contador, el ESP32 recibir\u00e1 un mensaje con el valor actualizado, del mismo modo que cuando cierres uno de los navegadores web. Tarea opcional Modifica el c\u00f3digo para que el cliente, peri\u00f3dicamente, env\u00ede un mensaje de petici\u00f3n de suma o resta siguiendo las especificaciones y tipos de mensaje que se explicaron anteriormente.","title":"Ejercicio entregable: Comunicaci\u00f3n as\u00edncrona"},{"location":"RPI-II/P5/","text":"Pr\u00e1ctica 5. El protocolo MQTT (I). Despliegue de clientes y servidores/ brokers . An\u00e1lisis de tr\u00e1fico Objetivos Familiarizarse con el uso de brokers y clientes de suscripci\u00f3n/publicaci\u00f3n utilizando MQTT. Desplegar un sistema basado en MQTT local, incluyendo broker y clientes. Utilizar Eclipse Paho para integrar funcionalidad MQTT en programas Python. Familiarizarse con el uso de wildcards MQTT. Publicaci\u00f3n/suscripci\u00f3n contra un broker en la nube En la primera parte de la pr\u00e1ctica, utilizaremos un servidor/ broker disponible en la nube para su uso libre por parte de los usuarios ( test.mosquitto.org ). Este servidor suele utilizarse con fines de pruebas b\u00e1sicas y depuraci\u00f3n, y hay que ser consciente de que toda la informaci\u00f3n que en \u00e9l se publica puede ser le\u00edda por cualquier suscriptor. Debe tenerse este dato en cuenta a la hora de publicar informaci\u00f3n sensible a trav\u00e9s de MQTT cuando se use el servidor de pruebas. El servidor escucha en los siguientes puertos: 1883 : MQTT, sin encriptaci\u00f3n. 8883 : MQTT, con encriptaci\u00f3n. 8884 : MQTT, con encriptaci\u00f3n, certificado de cliente requerido. 8080 : MQTT sobre WebSockets, sin encriptaci\u00f3n. 8081 : MQTT sobre WebSockets, con encriptaci\u00f3n. Para realizar publicaciones/suscripciones contra el broker utilizaremos la distribuci\u00f3n mosquitto del proyecto Eclipse IoT. Aunque mosquitto es principalmente una implementaci\u00f3n de broker MQTT, nosotros la utilizaremos en este paso a modo de cliente, lo que nos permitir\u00e1 suscribirnos o publicar sobre cualquier topic MQTT. En primer lugar, instala mosquitto : sudo apt-get update sudo apt-get install mosquitto mosquitto-clients mosquitto-dev libmosquitto* Si todo ha ido bien, deber\u00edas disponer de dos binarios listos para ejecuci\u00f3n: mosquitto_sub : permite suscribirse a un determinado topic utilizando un broker . mosquitto_pub : permite publicar un mensaje asociado a un determinado topic utilizando un broker . Tarea 1 Observa la ayuda de ambas ordenes, utilizando el argumento --help . Identifica los par\u00e1metros que te permitir\u00e1n especificar el broker destino, el topic a utilizar y, en el caso de la publicaci\u00f3n, el mensaje a enviar. Suscrib\u00e1monos al topic # en el broker , utilizando para ello la orden: mosquitto_sub -h test.mosquitto.org -t \"#\" Tarea 2 Pausa la salida en cuanto puedas. \u00bfA qu\u00e9 corresponden los mensajes que est\u00e1s obteniendo? A continuaci\u00f3n, vamos a realizar un proceso de publicaci\u00f3n/suscripcion con un topic conocido (por ejemplo, /MIOT/tunombre/ ). Para publicar un mensaje bajo dicho topic : mosquitto_pub -h test.mosquitto.org -t \"/MIOT/tunombre\" -m \"Hola, soy tunombre\" Tarea 3 Suscr\u00edbete al topic /MIOT/tunombre y observa si recibes los resultados tras la publicaci\u00f3n correspondiente. \u00bfC\u00f3mo podr\u00edas suscribirte a todos los mensajes publicados por compa\u00f1eros? Tarea entregable Realiza un an\u00e1lisis del intercambio de mensajes necesario para un proceso de publicaci\u00f3n/suscripci\u00f3n contra el broker de test. Incide en el tipo de protocolo de capa de transporte que utiliza MQTT, mensajes de datos y control, sobrecarga del protocolo de capa de aplicaci\u00f3n, y en general, cualquier aspecto que consideres de inter\u00e9s, incluyendo el uso de opciones relativas a QoS. Despliegue de un broker local usando Eclipse Mosquitto El uso de un servidor remoto presenta ventajas (facilidad de uso), pero una gran cantidad de inconvenientes (seguridad, imposibilidad de configuraci\u00f3n avanzada, ...) En esta secci\u00f3n, configuraremos un broker mosquitto para el despliegue de una infraestructura MQTT local o remota bajo nuestro control. El arranque de un broker (servidor) mosquitto se realiza mediante el propio comando mosquitto : mosquitto [-c config file] [ -d | --daemon ] [-p port number] [-v] Sin embargo, en la mayor\u00eda de distribuciones Linux, el broker arranca por defecto y se ejecuta constantemente en segundo plano. Para comprobar el estado de funcionamiento del broker , basta con ejecutar: sudo service mosquitto status Observar\u00e1s un mensaje que indica que el servicio est\u00e1 activo. Las opciones restart , start o stop te permitir\u00e1n controlar el estado del broker en todo momento. Tarea 4 Comprueba que, con el broker arrancado, puedes realizar un proceso de suscripci\u00f3n/publicaci\u00f3n contra el mismo. El broker mosquitto permite monitorizar sus propias estad\u00edsticas e informaci\u00f3n de estado utilizando el protocolo MQTT. As\u00ed, los topics $SYS retornan, bien peri\u00f3dicamente o bien cuando sucede un evento de inter\u00e9s, la informaci\u00f3n de estado del broker . Puedes consultar m\u00e1s detalles en la p\u00e1gina de manual de mosquitto (comando man mosquitto ), en el ep\u00edgrafe BROKER STATUS . Tarea 5 Comprueba el estado del broker mientras realizas procesos de suscripci\u00f3n/publicaci\u00f3n reportando bytes recibidos/enviados, n\u00famero de conexiones activas e inactivas, y n\u00famero de mensajes enviados/recibidos por el broker . Wildcards Adem\u00e1s de permitir el uso de topics completos para el proceso de suscripci\u00f3n, los topics pueden incluir wildcards o comodines en su estructura. + es la wildcard utilizada para obtener correspondencias con un \u00fanico nivel de la jerarqu\u00eda. As\u00ed, para un topic a/b/c/d , las siguientes suscripciones corresponder\u00e1n con \u00e9xito: a/b/c/d +/b/c/d a/+/c/d a/+/+/d +/+/+/+ Pero no las siguientes: a/b/c b/+/c/d +/+/+ La segunda wildcard soportada es # , y permite corresponencias con cualquier nivel sucesivo de la jerarqu\u00eda. As\u00ed, para un topic a/b/c/d , las siguientes suscripciones corresponder\u00e1n con \u00e9xito: a/b/c/d # a/# a/b/# a/b/c/# +/b/c/# Tarea 6 Experimenta con el uso de wildcards desde m\u00faltiples clientes suscriptores. Resultar\u00e1 de especial inter\u00e9s observar (por ejemplo, con capturas de tr\u00e1fico) el ahorro de mensajes asociado al uso de wildcards que restrinjan qu\u00e9 mensajes son recibidos y por qu\u00e9 clientes. Desarrollo de un clientes locales. Eclipse Paho Los clientes mosquitto_pub y mosquitto_sub son b\u00e1sicamente herramientas de desarrollo y pruebas, pero resulta interesante conocer bibliotecas que permitan la integraci\u00f3n de MQTT en programas existentes. Una de ellas es Eclipse Paho . Paho es una infraestructura desarrollada en el proyecto Eclipse IoT para dar soporte a implementaciones de protocolos de mensajer\u00eda M2M e IoT, aunque, en este momento, su uso principal se centra exclusivamente en MQTT. En nuestro caso, utilizaremos la versi\u00f3n Python de la biblioteca, instalable v\u00eda: pip install paho-mqtt Dispones de la documentaci\u00f3n del m\u00f3dulo a trav\u00e9s de este enlace . El despliegue de un ejemplo sencillo para un cliente que se conecta a un broker y se suscribe al t\u00f3pico $SYS , imprimiendo los mensajes recibidos, resultar\u00eda, utilizando Paho, en el siguiente c\u00f3digo Python: import paho.mqtt.client as mqtt # Funcion callback invocada cuandl el cliente recibe un CONNACK desde el broker. def on_connect(client, userdata, flags, rc): print(\"Connected with result code \"+str(rc)) # Suscribirse en on_connect() asegura que si se pierde la conexi\u00f3n y # se reestablece, las suscripciones se renovar\u00e1n. client.subscribe(\"$SYS/#\") # Funcion callback al recibir un mensaje de publicacion (PUBLISH) desde el # broker. def on_message(client, userdata, msg): print(msg.topic+\" \"+str(msg.payload)) client = mqtt.Client() client.on_connect = on_connect client.on_message = on_message client.connect(\"mqtt.eclipse.org\", 1883, 60) # Llamada bloqueante que procesa el tr\u00e1fico de red, invoca callbacks # y maneja la reconexi\u00f3n al broker. client.loop_forever() La clase cliente puede utilizarse para: Crear una instancia de cliente MQTT. Conectar a un broker usando las funciones de la familia connect*() . Invocar a funciones de la familia loop*() para mantener el tr\u00e1fico de datos con el servidor. Utilizar subscribe() para suscribirse a un topic y recibir mensajes. Utilizar publish() publicar mensajes en el broker . Utilizar disconnect() para desconectar del broker . Los callbacks se invocar\u00e1n autom\u00e1ticamente para permitir el procesamiento de eventos. De entre los m\u00e1s utilizados, destacan: ON_CONNECT : invocado cuando el broker responde a nuestra petici\u00f3n de conexi\u00f3n. Ejemplo: def on_connect(client, userdata, flags, rc): print(\"Connection returned result: \"+connack_string(rc)) ON_DISCONNECT : invocado cuando el cliente se desconecta del broker . Ejemplo: def on_disconnect(client, userdata, rc): if rc != 0: print(\"Unexpected disconnection.\") ON_MESSAGE : invocado cuando se recibe un mensaje en un topic al que el cliente est\u00e1 suscrito. Ejemplo: def on_message(client, userdata, message): print(\"Received message '\" + str(message.payload) + \"' on topic '\" + message.topic + \"' with QoS \" + str(message.qos)) Para publicar de forma puntual sobre un broker (sin mantener una conexi\u00f3n establecida), es posible utilizar la siguiente secuencia de ordenes: import paho.mqtt.publish as publish publish.single(\"paho/test/single\", \"payload\", hostname=\"mqtt.eclipse.org\") Del mismo modo, podemos suscribirnos de forma puntual mediante una llamada bloqueante a: import paho.mqtt.subscribe as subscribe msg = subscribe.simple(\"paho/test/simple\", hostname=\"mqtt.eclipse.org\") print(\"%s %s\" % (msg.topic, msg.payload)) Toda la informaci\u00f3n y documentaci\u00f3n asociada al m\u00f3dulo puede consultarse aqu\u00ed . Tarea entregable Cada alumno propondr\u00e1 una soluci\u00f3n para monitorizar un edificio inteligente a trav\u00e9s de un sistema de mensajer\u00eda MQTT. Para ello, cabe destacar que el edificio constar\u00e1 de: Un identificador del tipo EDIFICIO_TUPUESTODELABORATORIO. Un conjunto de plantas, identificadas por la cadena \"P_NUMPLANTA\". En cada planta, cuatro alas (norte -N-, sur -S-, este -E-, oeste -O-) En cada ala, un conjunto de salas, identificadas por un valor num\u00e9rico. En cada sala, cuatro sensores: TEMP (temperatura), HUM (humedad), LUX (luminosidad), VIBR (vibraci\u00f3n). Se pide, en primer lugar, dise\u00f1ar la jerarqu\u00eda de topics que permita una correcta monitorizaci\u00f3n de los edificios. En segundo lugar, se desarrollar\u00e1 un programa Python cliente que publique, peri\u00f3dicamente y de forma aleatoria, objetos JSON (opcionalmente puedes utilizar CBOR, usando los m\u00f3dulos correspondientes) que incluyan el valor de temperatura, humedad, luminosidad o vibraci\u00f3n para una determinada sala del edificio, elegida tambi\u00e9n aleatoriamente, a trav\u00e9s del topic correspondiente. Estos mensajes estar\u00e1n espaciados en el tiempo un n\u00famero aleatorio de segundos. En tercer lugar, se piden las wildcards que permitan consultar distintos tipos de informaci\u00f3n jer\u00e1rquica. Por ejemplo: Todos los mensajes de temperatura para el edificio. Todos los mensajes de vibraci\u00f3n del ala oeste de la planta 2 del edificio. Todos los mensajes de sensorizaci\u00f3n de la sala 4 del ala Sur de la planta 7 del edificio. ... En \u00faltimo lugar, se pide desarrollar un programa Python que act\u00fae a modo de alarma, y que muestre mensajes s\u00f3lo si alg\u00fan valor recibido para los datos sensorizados supera un umbral preestablecido. En dicho caso, el programa mostrar\u00e1 el edificio, planta, ala, sala y sensor que ha producido la alarma, junto con su valor num\u00e9rico. Puedes utilizar el m\u00f3dulo JSON para parsear los objetos recibidos en Python.","title":"Pr\u00e1ctica 5 (I)"},{"location":"RPI-II/P5/#practica-5-el-protocolo-mqtt-i-despliegue-de-clientes-y-servidoresbrokers-analisis-de-trafico","text":"","title":"Pr\u00e1ctica 5. El protocolo MQTT (I). Despliegue de clientes y servidores/brokers. An\u00e1lisis de tr\u00e1fico"},{"location":"RPI-II/P5/#objetivos","text":"Familiarizarse con el uso de brokers y clientes de suscripci\u00f3n/publicaci\u00f3n utilizando MQTT. Desplegar un sistema basado en MQTT local, incluyendo broker y clientes. Utilizar Eclipse Paho para integrar funcionalidad MQTT en programas Python. Familiarizarse con el uso de wildcards MQTT.","title":"Objetivos"},{"location":"RPI-II/P5/#publicacionsuscripcion-contra-un-broker-en-la-nube","text":"En la primera parte de la pr\u00e1ctica, utilizaremos un servidor/ broker disponible en la nube para su uso libre por parte de los usuarios ( test.mosquitto.org ). Este servidor suele utilizarse con fines de pruebas b\u00e1sicas y depuraci\u00f3n, y hay que ser consciente de que toda la informaci\u00f3n que en \u00e9l se publica puede ser le\u00edda por cualquier suscriptor. Debe tenerse este dato en cuenta a la hora de publicar informaci\u00f3n sensible a trav\u00e9s de MQTT cuando se use el servidor de pruebas. El servidor escucha en los siguientes puertos: 1883 : MQTT, sin encriptaci\u00f3n. 8883 : MQTT, con encriptaci\u00f3n. 8884 : MQTT, con encriptaci\u00f3n, certificado de cliente requerido. 8080 : MQTT sobre WebSockets, sin encriptaci\u00f3n. 8081 : MQTT sobre WebSockets, con encriptaci\u00f3n. Para realizar publicaciones/suscripciones contra el broker utilizaremos la distribuci\u00f3n mosquitto del proyecto Eclipse IoT. Aunque mosquitto es principalmente una implementaci\u00f3n de broker MQTT, nosotros la utilizaremos en este paso a modo de cliente, lo que nos permitir\u00e1 suscribirnos o publicar sobre cualquier topic MQTT. En primer lugar, instala mosquitto : sudo apt-get update sudo apt-get install mosquitto mosquitto-clients mosquitto-dev libmosquitto* Si todo ha ido bien, deber\u00edas disponer de dos binarios listos para ejecuci\u00f3n: mosquitto_sub : permite suscribirse a un determinado topic utilizando un broker . mosquitto_pub : permite publicar un mensaje asociado a un determinado topic utilizando un broker . Tarea 1 Observa la ayuda de ambas ordenes, utilizando el argumento --help . Identifica los par\u00e1metros que te permitir\u00e1n especificar el broker destino, el topic a utilizar y, en el caso de la publicaci\u00f3n, el mensaje a enviar. Suscrib\u00e1monos al topic # en el broker , utilizando para ello la orden: mosquitto_sub -h test.mosquitto.org -t \"#\" Tarea 2 Pausa la salida en cuanto puedas. \u00bfA qu\u00e9 corresponden los mensajes que est\u00e1s obteniendo? A continuaci\u00f3n, vamos a realizar un proceso de publicaci\u00f3n/suscripcion con un topic conocido (por ejemplo, /MIOT/tunombre/ ). Para publicar un mensaje bajo dicho topic : mosquitto_pub -h test.mosquitto.org -t \"/MIOT/tunombre\" -m \"Hola, soy tunombre\" Tarea 3 Suscr\u00edbete al topic /MIOT/tunombre y observa si recibes los resultados tras la publicaci\u00f3n correspondiente. \u00bfC\u00f3mo podr\u00edas suscribirte a todos los mensajes publicados por compa\u00f1eros? Tarea entregable Realiza un an\u00e1lisis del intercambio de mensajes necesario para un proceso de publicaci\u00f3n/suscripci\u00f3n contra el broker de test. Incide en el tipo de protocolo de capa de transporte que utiliza MQTT, mensajes de datos y control, sobrecarga del protocolo de capa de aplicaci\u00f3n, y en general, cualquier aspecto que consideres de inter\u00e9s, incluyendo el uso de opciones relativas a QoS.","title":"Publicaci\u00f3n/suscripci\u00f3n contra un broker en la nube"},{"location":"RPI-II/P5/#despliegue-de-un-broker-local-usando-eclipse-mosquitto","text":"El uso de un servidor remoto presenta ventajas (facilidad de uso), pero una gran cantidad de inconvenientes (seguridad, imposibilidad de configuraci\u00f3n avanzada, ...) En esta secci\u00f3n, configuraremos un broker mosquitto para el despliegue de una infraestructura MQTT local o remota bajo nuestro control. El arranque de un broker (servidor) mosquitto se realiza mediante el propio comando mosquitto : mosquitto [-c config file] [ -d | --daemon ] [-p port number] [-v] Sin embargo, en la mayor\u00eda de distribuciones Linux, el broker arranca por defecto y se ejecuta constantemente en segundo plano. Para comprobar el estado de funcionamiento del broker , basta con ejecutar: sudo service mosquitto status Observar\u00e1s un mensaje que indica que el servicio est\u00e1 activo. Las opciones restart , start o stop te permitir\u00e1n controlar el estado del broker en todo momento. Tarea 4 Comprueba que, con el broker arrancado, puedes realizar un proceso de suscripci\u00f3n/publicaci\u00f3n contra el mismo. El broker mosquitto permite monitorizar sus propias estad\u00edsticas e informaci\u00f3n de estado utilizando el protocolo MQTT. As\u00ed, los topics $SYS retornan, bien peri\u00f3dicamente o bien cuando sucede un evento de inter\u00e9s, la informaci\u00f3n de estado del broker . Puedes consultar m\u00e1s detalles en la p\u00e1gina de manual de mosquitto (comando man mosquitto ), en el ep\u00edgrafe BROKER STATUS . Tarea 5 Comprueba el estado del broker mientras realizas procesos de suscripci\u00f3n/publicaci\u00f3n reportando bytes recibidos/enviados, n\u00famero de conexiones activas e inactivas, y n\u00famero de mensajes enviados/recibidos por el broker .","title":"Despliegue de un broker local usando Eclipse Mosquitto"},{"location":"RPI-II/P5/#wildcards","text":"Adem\u00e1s de permitir el uso de topics completos para el proceso de suscripci\u00f3n, los topics pueden incluir wildcards o comodines en su estructura. + es la wildcard utilizada para obtener correspondencias con un \u00fanico nivel de la jerarqu\u00eda. As\u00ed, para un topic a/b/c/d , las siguientes suscripciones corresponder\u00e1n con \u00e9xito: a/b/c/d +/b/c/d a/+/c/d a/+/+/d +/+/+/+ Pero no las siguientes: a/b/c b/+/c/d +/+/+ La segunda wildcard soportada es # , y permite corresponencias con cualquier nivel sucesivo de la jerarqu\u00eda. As\u00ed, para un topic a/b/c/d , las siguientes suscripciones corresponder\u00e1n con \u00e9xito: a/b/c/d # a/# a/b/# a/b/c/# +/b/c/# Tarea 6 Experimenta con el uso de wildcards desde m\u00faltiples clientes suscriptores. Resultar\u00e1 de especial inter\u00e9s observar (por ejemplo, con capturas de tr\u00e1fico) el ahorro de mensajes asociado al uso de wildcards que restrinjan qu\u00e9 mensajes son recibidos y por qu\u00e9 clientes.","title":"Wildcards"},{"location":"RPI-II/P5/#desarrollo-de-un-clientes-locales-eclipse-paho","text":"Los clientes mosquitto_pub y mosquitto_sub son b\u00e1sicamente herramientas de desarrollo y pruebas, pero resulta interesante conocer bibliotecas que permitan la integraci\u00f3n de MQTT en programas existentes. Una de ellas es Eclipse Paho . Paho es una infraestructura desarrollada en el proyecto Eclipse IoT para dar soporte a implementaciones de protocolos de mensajer\u00eda M2M e IoT, aunque, en este momento, su uso principal se centra exclusivamente en MQTT. En nuestro caso, utilizaremos la versi\u00f3n Python de la biblioteca, instalable v\u00eda: pip install paho-mqtt Dispones de la documentaci\u00f3n del m\u00f3dulo a trav\u00e9s de este enlace . El despliegue de un ejemplo sencillo para un cliente que se conecta a un broker y se suscribe al t\u00f3pico $SYS , imprimiendo los mensajes recibidos, resultar\u00eda, utilizando Paho, en el siguiente c\u00f3digo Python: import paho.mqtt.client as mqtt # Funcion callback invocada cuandl el cliente recibe un CONNACK desde el broker. def on_connect(client, userdata, flags, rc): print(\"Connected with result code \"+str(rc)) # Suscribirse en on_connect() asegura que si se pierde la conexi\u00f3n y # se reestablece, las suscripciones se renovar\u00e1n. client.subscribe(\"$SYS/#\") # Funcion callback al recibir un mensaje de publicacion (PUBLISH) desde el # broker. def on_message(client, userdata, msg): print(msg.topic+\" \"+str(msg.payload)) client = mqtt.Client() client.on_connect = on_connect client.on_message = on_message client.connect(\"mqtt.eclipse.org\", 1883, 60) # Llamada bloqueante que procesa el tr\u00e1fico de red, invoca callbacks # y maneja la reconexi\u00f3n al broker. client.loop_forever() La clase cliente puede utilizarse para: Crear una instancia de cliente MQTT. Conectar a un broker usando las funciones de la familia connect*() . Invocar a funciones de la familia loop*() para mantener el tr\u00e1fico de datos con el servidor. Utilizar subscribe() para suscribirse a un topic y recibir mensajes. Utilizar publish() publicar mensajes en el broker . Utilizar disconnect() para desconectar del broker . Los callbacks se invocar\u00e1n autom\u00e1ticamente para permitir el procesamiento de eventos. De entre los m\u00e1s utilizados, destacan: ON_CONNECT : invocado cuando el broker responde a nuestra petici\u00f3n de conexi\u00f3n. Ejemplo: def on_connect(client, userdata, flags, rc): print(\"Connection returned result: \"+connack_string(rc)) ON_DISCONNECT : invocado cuando el cliente se desconecta del broker . Ejemplo: def on_disconnect(client, userdata, rc): if rc != 0: print(\"Unexpected disconnection.\") ON_MESSAGE : invocado cuando se recibe un mensaje en un topic al que el cliente est\u00e1 suscrito. Ejemplo: def on_message(client, userdata, message): print(\"Received message '\" + str(message.payload) + \"' on topic '\" + message.topic + \"' with QoS \" + str(message.qos)) Para publicar de forma puntual sobre un broker (sin mantener una conexi\u00f3n establecida), es posible utilizar la siguiente secuencia de ordenes: import paho.mqtt.publish as publish publish.single(\"paho/test/single\", \"payload\", hostname=\"mqtt.eclipse.org\") Del mismo modo, podemos suscribirnos de forma puntual mediante una llamada bloqueante a: import paho.mqtt.subscribe as subscribe msg = subscribe.simple(\"paho/test/simple\", hostname=\"mqtt.eclipse.org\") print(\"%s %s\" % (msg.topic, msg.payload)) Toda la informaci\u00f3n y documentaci\u00f3n asociada al m\u00f3dulo puede consultarse aqu\u00ed . Tarea entregable Cada alumno propondr\u00e1 una soluci\u00f3n para monitorizar un edificio inteligente a trav\u00e9s de un sistema de mensajer\u00eda MQTT. Para ello, cabe destacar que el edificio constar\u00e1 de: Un identificador del tipo EDIFICIO_TUPUESTODELABORATORIO. Un conjunto de plantas, identificadas por la cadena \"P_NUMPLANTA\". En cada planta, cuatro alas (norte -N-, sur -S-, este -E-, oeste -O-) En cada ala, un conjunto de salas, identificadas por un valor num\u00e9rico. En cada sala, cuatro sensores: TEMP (temperatura), HUM (humedad), LUX (luminosidad), VIBR (vibraci\u00f3n). Se pide, en primer lugar, dise\u00f1ar la jerarqu\u00eda de topics que permita una correcta monitorizaci\u00f3n de los edificios. En segundo lugar, se desarrollar\u00e1 un programa Python cliente que publique, peri\u00f3dicamente y de forma aleatoria, objetos JSON (opcionalmente puedes utilizar CBOR, usando los m\u00f3dulos correspondientes) que incluyan el valor de temperatura, humedad, luminosidad o vibraci\u00f3n para una determinada sala del edificio, elegida tambi\u00e9n aleatoriamente, a trav\u00e9s del topic correspondiente. Estos mensajes estar\u00e1n espaciados en el tiempo un n\u00famero aleatorio de segundos. En tercer lugar, se piden las wildcards que permitan consultar distintos tipos de informaci\u00f3n jer\u00e1rquica. Por ejemplo: Todos los mensajes de temperatura para el edificio. Todos los mensajes de vibraci\u00f3n del ala oeste de la planta 2 del edificio. Todos los mensajes de sensorizaci\u00f3n de la sala 4 del ala Sur de la planta 7 del edificio. ... En \u00faltimo lugar, se pide desarrollar un programa Python que act\u00fae a modo de alarma, y que muestre mensajes s\u00f3lo si alg\u00fan valor recibido para los datos sensorizados supera un umbral preestablecido. En dicho caso, el programa mostrar\u00e1 el edificio, planta, ala, sala y sensor que ha producido la alarma, junto con su valor num\u00e9rico. Puedes utilizar el m\u00f3dulo JSON para parsear los objetos recibidos en Python.","title":"Desarrollo de un clientes locales. Eclipse Paho"},{"location":"RPI-II/P5_II/","text":"Pr\u00e1ctica 5. El protocolo MQTT (II). Despliegue de clientes en el ESP32 Objetivos Familiarizarse con el componente MQTT en ESP-IDF. Desplegar un cliente completo MQTT en el ESP32, incluyendo rutinas de publicaci\u00f3n y suscripci\u00f3n. Implementar QoS y LWT en el ESP32. El componente MQTT en ESP-IDF El componente ESP-MQTT es una implementaci\u00f3n del protocolo MQTT en su parte cliente, que permite la implementaci\u00f3n completa de clientes MQTT en el ESP32, incluyendo rutinas de publicaci\u00f3n y suscripci\u00f3n a brokers existentes. El componente soporte MQTT sobre TCP por defecto, as\u00ed como funcionalidades avanzadas como SSL/TLS o MQTT sobre Websockets. Adem\u00e1s, permite el despliegue de m\u00faltiples instancias de cliente MQTT sobre la misma placa; el componente implementa tambi\u00e9n par\u00e1metros avanzados soportados por el protocolo MQTT, como autenticaci\u00f3n (mediante nombre de usuario y contrase\u00f1a), mensajes last will y tres niveles de calidad de servicio (QoS). Eventos Como otros componentes, la interacci\u00f3n entre el cliente MQTT y la aplicaci\u00f3n se basa en la recepci\u00f3n de eventos, entre los que destacan: MQTT_EVENT_BEFORE_CONNECT : El cliente se ha inicializado y va a comenzar el proceso de conexi\u00f3n con el broker . MQTT_EVENT_CONNECTED : El cliente ha establecido de forma exitosa una conexi\u00f3n con el broker y est\u00e1 listo para enviar y recibir datos. MQTT_EVENT_DISCONNECTED : El cliente ha abortado la conexi\u00f3n. MQTT_EVENT_SUBSCRIBED : El broker ha confirmado la petici\u00f3n de suscripci\u00f3n del cliente. Los datos contendr\u00e1n el ID del mensaje de suscripci\u00f3n. MQTT_EVENT_UNSUBSCRIBED : El broker confirma la petici\u00f3n de desuscripci\u00f3n del cliente. Los datos contendr\u00e1n el ID del mensaje de desuscripci\u00f3n . MQTT_EVENT_PUBLISHED : El broker ha acusado la recepci\u00f3n de un mensaje previamente publicado por el cliente. Este evento s\u00f3lo se producir\u00e1 cuando QoS sea 1 o 2, ya que el nivel 0 de QoS no utiliza acuses de recibo. Los datos asociados al evento contendr\u00e1n el ID del mensaje publicado. MQTT_EVENT_DATA : El cliente ha recibido un mensaje publicado en el broker . Los datos asociados al evento contienen el ID del mensaje, nombre del topic , datos recibidos y su longitud. API esp_mqtt_client_handle_t esp_mqtt_client_init(const esp_mqtt_client_config_t *config) Rutina de inicializaci\u00f3n del cliente MQTT. Devuelve un manejador de la conexi\u00f3n, o NULL en caso de error. El par\u00e1metro config es una estructura con los par\u00e1metros que regir\u00e1n la conexi\u00f3n, entre los que destacan (v\u00e9ase la documentaci\u00f3n del componente para par\u00e1metros adicionales): esp_event_loop_handle_t event_loop_handle : manejador para eventos MQTT. const char *uri : URI del broker MQTT. uint32_t port : puerto del broker MQTT. const char *username : nombre de usuario, en caso de estar soportado por el broker . const char *password : contrase\u00f1a, en caso de estar soportada por el broker . const char *lwt_topic : topic del mensaje LWT ( Last Will and Testament ). const char *lwt_msg : contenido del mensaje LWT. int lwt_qos : QoS del mensaje LWT. int lwt_retain : flag retain para el mensaje LWT. int lwt_msg_len : longitud del mensaje LWT. int keepalive : valor del temporizador de keepalive (por defecto 120 segundos). esp_err_t esp_mqtt_client_start(esp_mqtt_client_handle_t client) Rutina de arranque del cliente MQTT. Su \u00fanico par\u00e1metro es el manejador devuelto por la anterior rutina. int esp_mqtt_client_subscribe(esp_mqtt_client_handle_t client, const char *topic, int qos) Realiza la suscripci\u00f3n del cliente a un topic con el QoS determinado a trav\u00e9s de su tercer par\u00e1metro. El cliente debe estar conectado al broker para enviar el mensaje de suscripci\u00f3n. int esp_mqtt_client_unsubscribe(esp_mqtt_client_handle_t client, const char *topic) Desuscribe al cliente de un determinado topic. El ciente debe estar conectado al broker para poder enviar el mensaje correspondiente. int esp_mqtt_client_publish(esp_mqtt_client_handle_t client, const char *topic, const char *data, int len, int qos, int retain) El cliente publica un mensaje en el broker . El cliente no tiene que estar conectado al broker para enviar el mensaje de publicaci\u00f3n. En dicho caso, si qos=0 , los mensajes se descartar\u00e1n, y si qos>=1 , los mensajes se encolar\u00e1n a la espera de ser enviados. Devuelve el identificador del mensaje publicado (si qos=0 , el valor de retorno siempre ser\u00e1 0), o -1 en caso de error. Par\u00e1metros de inter\u00e9s: client : manejador del cliente MQTT. topic : topic (en forma de cadena) bajo el cual se publicar\u00e1 el mensaje. data : contenido del mensaje a publicar (es posible publicar un mensaje sin contenido, en cuyo caso se proporcionar\u00e1 un valor NULL en este par\u00e1metro). len : longitud de los datos a enviar. Si se proporciona el valor 0 , se calcula su longitud a partir de la cadena data . qos : nivel de QoS deseado. retain : flag Retain . Tarea 7 Analiza el ejemplo examples/protocols/mqtt/tcp , y configuralo para que utilice como broker el que desplegaste en la m\u00e1quina virtual (aseg\u00farate de que tanto m\u00e1quina virtual como ESP32 pertenecen a la misma red). Realiza procesos de publicaci\u00f3n y suscripci\u00f3n en la m\u00e1quina virtual que permitan visualizar los mensajes publicados por el ESP32 en tu terminal Linux, y los mensajes publicados desde el terminal Linux en la salida de monitorizaci\u00f3n del ESP32. Modifica el ejemplo y analiza el tr\u00e1fico generado (a trav\u00e9s de Wireshark) para los siguientes casos: Publicaci\u00f3n de mensajes con niveles de QoS 0, 1 y 2. Activaci\u00f3n o desactivaci\u00f3n del flag retain en la publicaci\u00f3n desde el ESP32. Configuraci\u00f3n de un mensaje LWT con el topic /disconnected . Para ello, reduce el valor de keepalive a 10 segundos, para que la detecci\u00f3n de desconexi\u00f3n sea m\u00e1s r\u00e1pida. Deber\u00e1s observar el env\u00edo del mensaje con dicho topic transcurrido dicho tiempo desde una desconexi\u00f3n forzada del ESP32 si est\u00e1s suscrito al mismo desde tu terminal Linux. Tarea entregable Modifica el ejemplo proporcionado para que se integre en tu entorno de monitorizaci\u00f3n de un edificio. As\u00ed, el firmware proceder\u00e1 creando una tarea que, peri\u00f3dicamente (cada interval segundos), publique un valor aleatorio para los cuatro par\u00e1metros monitorizados. Adem\u00e1s, deber\u00e1s dise\u00f1a un sistema basado en MQTT mediante el cual puedas controlar, externamente, el comportamiento del sensor, atendiendo a los siguientes criterios: El tiempo ( interval ) mediante que transcurrir\u00e1 entre publicaciones ser\u00e1 configurable a trav\u00e9s de un proceso de publicaci\u00f3n desde tu terminal Linux y suscripci\u00f3n del ESP32 a un topic determinado. La sensorizaci\u00f3n (y publicaci\u00f3n de datos) podr\u00e1 activarse o desactivarse bajo demanda a trav\u00e9s de la publicaci\u00f3n desde tu terminal Linux y suscripci\u00f3n del ESP32 a un topic determinado. Por ejemplo, imagina que tu sensor publica mensajes de sensorizaci\u00f3n en el topic /EDIFICIO_3/P_4/N/12/(TEMP|HUM|LUX|VIBR) . Para controlar el intervalo de publicaci\u00f3n de datos desde dicho ESP32 y fijarlo a 1 segundo, podr\u00edamos publicar un mensaje utilizando la orden: mosquitto_pub -t /EDIFICIO_3/P_4/N/12/interval -m \"1000\" -h IP_BROKER Para desactivar el sensor, podr\u00edamos utilizar: mosquitto_pub -t /EDIFICIO_3/P_4/N/12/disable -m \"\" -h IP_BROKER Para activar el sensor, podr\u00edamos utilizar: mosquitto_pub -t /EDIFICIO_3/P_4/N/12/enable -m \"\" -h IP_BROKER Opcionalmente, puedes ampliar tu soluci\u00f3n para que cada sensor se active o desactive individualmente bajo demanda. En este caso, elige y documenta el topic utilizado.","title":"Pr\u00e1ctica 5 (II)"},{"location":"RPI-II/P5_II/#practica-5-el-protocolo-mqtt-ii-despliegue-de-clientes-en-el-esp32","text":"","title":"Pr\u00e1ctica 5. El protocolo MQTT (II). Despliegue de clientes en el ESP32"},{"location":"RPI-II/P5_II/#objetivos","text":"Familiarizarse con el componente MQTT en ESP-IDF. Desplegar un cliente completo MQTT en el ESP32, incluyendo rutinas de publicaci\u00f3n y suscripci\u00f3n. Implementar QoS y LWT en el ESP32.","title":"Objetivos"},{"location":"RPI-II/P5_II/#el-componente-mqtt-en-esp-idf","text":"El componente ESP-MQTT es una implementaci\u00f3n del protocolo MQTT en su parte cliente, que permite la implementaci\u00f3n completa de clientes MQTT en el ESP32, incluyendo rutinas de publicaci\u00f3n y suscripci\u00f3n a brokers existentes. El componente soporte MQTT sobre TCP por defecto, as\u00ed como funcionalidades avanzadas como SSL/TLS o MQTT sobre Websockets. Adem\u00e1s, permite el despliegue de m\u00faltiples instancias de cliente MQTT sobre la misma placa; el componente implementa tambi\u00e9n par\u00e1metros avanzados soportados por el protocolo MQTT, como autenticaci\u00f3n (mediante nombre de usuario y contrase\u00f1a), mensajes last will y tres niveles de calidad de servicio (QoS).","title":"El componente MQTT en ESP-IDF"},{"location":"RPI-II/P5_II/#eventos","text":"Como otros componentes, la interacci\u00f3n entre el cliente MQTT y la aplicaci\u00f3n se basa en la recepci\u00f3n de eventos, entre los que destacan: MQTT_EVENT_BEFORE_CONNECT : El cliente se ha inicializado y va a comenzar el proceso de conexi\u00f3n con el broker . MQTT_EVENT_CONNECTED : El cliente ha establecido de forma exitosa una conexi\u00f3n con el broker y est\u00e1 listo para enviar y recibir datos. MQTT_EVENT_DISCONNECTED : El cliente ha abortado la conexi\u00f3n. MQTT_EVENT_SUBSCRIBED : El broker ha confirmado la petici\u00f3n de suscripci\u00f3n del cliente. Los datos contendr\u00e1n el ID del mensaje de suscripci\u00f3n. MQTT_EVENT_UNSUBSCRIBED : El broker confirma la petici\u00f3n de desuscripci\u00f3n del cliente. Los datos contendr\u00e1n el ID del mensaje de desuscripci\u00f3n . MQTT_EVENT_PUBLISHED : El broker ha acusado la recepci\u00f3n de un mensaje previamente publicado por el cliente. Este evento s\u00f3lo se producir\u00e1 cuando QoS sea 1 o 2, ya que el nivel 0 de QoS no utiliza acuses de recibo. Los datos asociados al evento contendr\u00e1n el ID del mensaje publicado. MQTT_EVENT_DATA : El cliente ha recibido un mensaje publicado en el broker . Los datos asociados al evento contienen el ID del mensaje, nombre del topic , datos recibidos y su longitud.","title":"Eventos"},{"location":"RPI-II/P5_II/#api","text":"esp_mqtt_client_handle_t esp_mqtt_client_init(const esp_mqtt_client_config_t *config) Rutina de inicializaci\u00f3n del cliente MQTT. Devuelve un manejador de la conexi\u00f3n, o NULL en caso de error. El par\u00e1metro config es una estructura con los par\u00e1metros que regir\u00e1n la conexi\u00f3n, entre los que destacan (v\u00e9ase la documentaci\u00f3n del componente para par\u00e1metros adicionales): esp_event_loop_handle_t event_loop_handle : manejador para eventos MQTT. const char *uri : URI del broker MQTT. uint32_t port : puerto del broker MQTT. const char *username : nombre de usuario, en caso de estar soportado por el broker . const char *password : contrase\u00f1a, en caso de estar soportada por el broker . const char *lwt_topic : topic del mensaje LWT ( Last Will and Testament ). const char *lwt_msg : contenido del mensaje LWT. int lwt_qos : QoS del mensaje LWT. int lwt_retain : flag retain para el mensaje LWT. int lwt_msg_len : longitud del mensaje LWT. int keepalive : valor del temporizador de keepalive (por defecto 120 segundos). esp_err_t esp_mqtt_client_start(esp_mqtt_client_handle_t client) Rutina de arranque del cliente MQTT. Su \u00fanico par\u00e1metro es el manejador devuelto por la anterior rutina. int esp_mqtt_client_subscribe(esp_mqtt_client_handle_t client, const char *topic, int qos) Realiza la suscripci\u00f3n del cliente a un topic con el QoS determinado a trav\u00e9s de su tercer par\u00e1metro. El cliente debe estar conectado al broker para enviar el mensaje de suscripci\u00f3n. int esp_mqtt_client_unsubscribe(esp_mqtt_client_handle_t client, const char *topic) Desuscribe al cliente de un determinado topic. El ciente debe estar conectado al broker para poder enviar el mensaje correspondiente. int esp_mqtt_client_publish(esp_mqtt_client_handle_t client, const char *topic, const char *data, int len, int qos, int retain) El cliente publica un mensaje en el broker . El cliente no tiene que estar conectado al broker para enviar el mensaje de publicaci\u00f3n. En dicho caso, si qos=0 , los mensajes se descartar\u00e1n, y si qos>=1 , los mensajes se encolar\u00e1n a la espera de ser enviados. Devuelve el identificador del mensaje publicado (si qos=0 , el valor de retorno siempre ser\u00e1 0), o -1 en caso de error. Par\u00e1metros de inter\u00e9s: client : manejador del cliente MQTT. topic : topic (en forma de cadena) bajo el cual se publicar\u00e1 el mensaje. data : contenido del mensaje a publicar (es posible publicar un mensaje sin contenido, en cuyo caso se proporcionar\u00e1 un valor NULL en este par\u00e1metro). len : longitud de los datos a enviar. Si se proporciona el valor 0 , se calcula su longitud a partir de la cadena data . qos : nivel de QoS deseado. retain : flag Retain . Tarea 7 Analiza el ejemplo examples/protocols/mqtt/tcp , y configuralo para que utilice como broker el que desplegaste en la m\u00e1quina virtual (aseg\u00farate de que tanto m\u00e1quina virtual como ESP32 pertenecen a la misma red). Realiza procesos de publicaci\u00f3n y suscripci\u00f3n en la m\u00e1quina virtual que permitan visualizar los mensajes publicados por el ESP32 en tu terminal Linux, y los mensajes publicados desde el terminal Linux en la salida de monitorizaci\u00f3n del ESP32. Modifica el ejemplo y analiza el tr\u00e1fico generado (a trav\u00e9s de Wireshark) para los siguientes casos: Publicaci\u00f3n de mensajes con niveles de QoS 0, 1 y 2. Activaci\u00f3n o desactivaci\u00f3n del flag retain en la publicaci\u00f3n desde el ESP32. Configuraci\u00f3n de un mensaje LWT con el topic /disconnected . Para ello, reduce el valor de keepalive a 10 segundos, para que la detecci\u00f3n de desconexi\u00f3n sea m\u00e1s r\u00e1pida. Deber\u00e1s observar el env\u00edo del mensaje con dicho topic transcurrido dicho tiempo desde una desconexi\u00f3n forzada del ESP32 si est\u00e1s suscrito al mismo desde tu terminal Linux. Tarea entregable Modifica el ejemplo proporcionado para que se integre en tu entorno de monitorizaci\u00f3n de un edificio. As\u00ed, el firmware proceder\u00e1 creando una tarea que, peri\u00f3dicamente (cada interval segundos), publique un valor aleatorio para los cuatro par\u00e1metros monitorizados. Adem\u00e1s, deber\u00e1s dise\u00f1a un sistema basado en MQTT mediante el cual puedas controlar, externamente, el comportamiento del sensor, atendiendo a los siguientes criterios: El tiempo ( interval ) mediante que transcurrir\u00e1 entre publicaciones ser\u00e1 configurable a trav\u00e9s de un proceso de publicaci\u00f3n desde tu terminal Linux y suscripci\u00f3n del ESP32 a un topic determinado. La sensorizaci\u00f3n (y publicaci\u00f3n de datos) podr\u00e1 activarse o desactivarse bajo demanda a trav\u00e9s de la publicaci\u00f3n desde tu terminal Linux y suscripci\u00f3n del ESP32 a un topic determinado. Por ejemplo, imagina que tu sensor publica mensajes de sensorizaci\u00f3n en el topic /EDIFICIO_3/P_4/N/12/(TEMP|HUM|LUX|VIBR) . Para controlar el intervalo de publicaci\u00f3n de datos desde dicho ESP32 y fijarlo a 1 segundo, podr\u00edamos publicar un mensaje utilizando la orden: mosquitto_pub -t /EDIFICIO_3/P_4/N/12/interval -m \"1000\" -h IP_BROKER Para desactivar el sensor, podr\u00edamos utilizar: mosquitto_pub -t /EDIFICIO_3/P_4/N/12/disable -m \"\" -h IP_BROKER Para activar el sensor, podr\u00edamos utilizar: mosquitto_pub -t /EDIFICIO_3/P_4/N/12/enable -m \"\" -h IP_BROKER Opcionalmente, puedes ampliar tu soluci\u00f3n para que cada sensor se active o desactive individualmente bajo demanda. En este caso, elige y documenta el topic utilizado.","title":"API"},{"location":"RPI-II/P5_old/","text":"Pr\u00e1ctica 3. Servidores REST y representaci\u00f3n de la informaci\u00f3n. JSON y CBOR Objetivos Entender los mecanismos ofrecidos por ESP-IDF para la creaci\u00f3n de un servidor REST HTTP. Implementar, a trav\u00e9s de los mecanismos ofrecidos por ESP-IDF, una API REST extendida en el ESP32. Entender los conceptos b\u00e1sicos de representaci\u00f3n de datos a trav\u00e9s de JSON. Implementar, a trav\u00e9s de la biblioteca cJSON , un tipo de mensaje personalizado para los intercambios de datos entre cliente y servidor. Entender los conceptos b\u00e1sicos de representaci\u00f3n de datos a trav\u00e9s de CBOR, y evaluar sus ventajas con respecto a JSON. Implementar, a trav\u00e9s de la biblioteca tinycbor , un tipo de mensaje personalizado para los intercambios de datos entre cliente y servidor, comparando los tama\u00f1os de payload con respecto al intercambio JSON. Desarrollo de un servidor REST en ESP-IDF En la primera parte de la pr\u00e1ctica, veremos c\u00f3mo desarrollar, utilizando las funcionalidades ofrecidas por ESP-IDF, un servidor HTTP que exponga una API REST mediante la cual ser\u00e1 posible interactuar, en modos lectura y escritura, con un servidor (en nuestro caso, un dispositivo ESP32). Concretamente, trabajaremos con el ejemplo example/protocols/http_server/restful_server de la distribuci\u00f3n de IDF. Descripci\u00f3n de la API El ejemplo que estudiaremos construye una sencilla interfaz (API) con tres endpoints que permiten interactuar con distintas funcionalidades del ESP32. N\u00f3tese que tanto las URLs como la funcionalidad asociada a ellas es totalmente personalizable, y puede ser ampliada de acuerdo a las necesidades de nuestra aplicaci\u00f3n. La siguiente tabla resume la funcionalidad de cada endpoint , as\u00ed como posibles ejemplos de valores enviados o devueltos a/por el servidor: API M\u00e9todo Ejemplo de recurso le\u00eddo/escrito Descripci\u00f3n URL /api/v1/system/info GET { version:\"v4.0-dev\", cores:2 } Utilizado por los clientes para obtener informaci\u00f3n de la placa (versi\u00f3n, n\u00famero de cores, ...) / /api/v1/temp/raw GET { raw:22 } Utilizado por los clientes para obtener datos de temperatura desde un sensor (no disponible en el ESP32) /chart /api/v1/light/brightness POST { red:160, green:160, blue:160 } Utilizado por los clientes para escribir en la placa valores de control para controlar la luminosidad de LEDs /light Configuraci\u00f3n y compilaci\u00f3n del ejemplo En primer lugar, configura, compila y flashea el ejemplo mencionado. En este caso, las instrucciones se dividen en dos partes: compilaci\u00f3n del firmware para el ESP32, y preparaci\u00f3n de un cliente web sencillo que nos permitir\u00e1 observar la interacci\u00f3n con el mismo. Esta \u00faltima parte no es estrictamente necesaria, pero nos ayudar\u00e1 en la interacci\u00f3n con el dispositivo de forma visual hasta que veamos c\u00f3mo hacerlo a trav\u00e9s de l\u00ednea de comandos. A trav\u00e9s del men\u00fa de configuraci\u00f3n, configura un nombre para el dispositivo (por ejemplo, 'esp_home_tunombre'), e indica que el modo de despliegue ( Website deploy mode ) sea Deploy website to SPI Nor Flash . Por \u00faltimo, configura las credenciales del punto de acceso WiFi al que conectar\u00e1, siguiendo la metodolog\u00eda habitual. En segundo lugar, necesitamos instalar los componentes necesarios para desplegar el cliente web. Para ello, navega al subdirectorio front/web-demo , donde reside el c\u00f3digo fuente del cliente. Ejecuta los siguientes comandos para instalar las dependencias necesarias: sudo apt-get install npm node-vue* npm install npm run build Dependiendo del sistema, en este punto se puede producir un error de openssl (\"digital envelope routines::unsupported\"). Si fuese el caso, es preciso establecer la variable de entorno adecudada y volver a ejecutar el comando npm run build . En Linux/MacOS: export NODE_OPTIONS=--openssl-legacy-provider En Windows: set NODE_OPTIONS=--openssl-legacy-provider Una vez construido el front-end, ya podr\u00e1s ejecutar, desde el directorio base del ejemplo, la orden de compilaci\u00f3n y flasheado: idf.py build idf.py flash idf.py monitor Interacci\u00f3n con el dispositivo v\u00eda interfaz web Si todo ha ido bien, podr\u00e1s observar en la salida de monitorizaci\u00f3n la IP proporcionada al ESP32. Abre un navegador en la m\u00e1quina virtual o en tu PC (estando conectada a la misma red que tu ESP32), navega hacia la direcci\u00f3n IP del ESP32, y deber\u00edas observar una p\u00e1gina como la siguiente: Esta es una p\u00e1gina web servida por el propio ESP32, que te permitir\u00e1 interactuar con \u00e9l. Concretamente, la p\u00e1gina dispone de dos funcionalidades: Chart : consulta peri\u00f3dicamente el valor de temperatura devuelto por el ESP32 a trav\u00e9s del endpoint /api/v1/temp/raw . Light : permite enviar al ESP32 nuevos valores para las tres componentes de luminosidad que hipot\u00e9ticamente podr\u00eda equipar el ESP32. Tarea 3.1 Interact\u00faa con el sensor de luminosidad del ESP32 enviando distintos valores. Observa c\u00f3mo la salida de monitorizaci\u00f3n del ESP32 responde mostrando los valores recibidos. Analiza el tr\u00e1fico generado para una de dichas peticiones utilizando Wireshark. \u00bfC\u00f3mo se codifican los datos en el env\u00edo? \u00bfC\u00f3mo se codifican los datos peri\u00f3dicos de temperatura recibidos? Interacci\u00f3n con el dispositivo v\u00eda l\u00ednea de comandos ( curl ) curl es una herramienta orientada a la transferencia de archivos por red. Entre otras (muchas) funcionalidades, curl soporta los m\u00e9todos GET y PUT del protocolo HTTP, justo las necesarias para realizar peticiones de lectura y escritura sobre nuestro servidor HTTP REST. Nota La versi\u00f3n de curl de PowerShell en Windows hace uso de Invoke-WebRequest y es mejor evitarla. Es preferible usar la versi\u00f3n de curl de CMD que es m\u00e1s compatible con las versiones UNIX (Linux/MacOS). Concretamente, para realizar una petici\u00f3n HTTP GET sobre nuestro servidor, podemos ejecutar: curl http://IP/URI Por ejemplo, la petici\u00f3n: curl http://192.168.1.26/api/v1/temp/raw (siendo 192.168.1.26 la IP del ESP32) nos responder\u00e1 con el valor de temperatura instant\u00e1nea. Del mismo modo, para escribir (m\u00e9todo POST ) sobre el servidor, utilizaremos el par\u00e1metro -d , seguido del recurso que queramos enviar. Ten en cuenta que es responsabilidad del cliente enviar un recurso bien formado e interpretable por el dispositivo: curl -d '{\"red\":70,\"green\":80,\"blue\":99}' -H \"Content-Type: application/json\" -X POST http://192.168.1.26/api/v1/light/brightness Observa que hemos incluido el tipo de recurso enviado ( JSON ) y la operacion solicitada ( POST ). Volveremos a esto en breve. Tarea 3.2 Comprueba que, efectivamente, el tr\u00e1fico generado por las anteriores \u00f3rdenes es el mismo que el que observaste en el caso del cliente web. Observa qu\u00e9 ocurre si consultas un endpoint inexistente, o si env\u00edas un JSON mal formado o con informaci\u00f3n incorrecta. Interacci\u00f3n con el dispositivo v\u00eda Node-RED Para interactuar con el dispositivo v\u00eda Node-RED, simplemente despliega un flujo que contenga un nodo de tipo HTTP Request . En su cuadro de di\u00e1logo de configuraci\u00f3n, podr\u00e1s incliur tanto el m\u00e9todo a utilizar (e.g. GET o POST ) como el endpoint (URL) destino y, opcionalmente, los datos a enviar si esto es necesario. Tarea 3.3 Comprueba que, efectivamente, el tr\u00e1fico generado por un flujo que utilice un nodo de interacci\u00f3n HTTP es el esperado, y el comportamiento del ESP32 tambi\u00e9n. En el caso de necesitar enviar un objeto JSON, puedes investigar c\u00f3mo formarlo con los nodos correspondientes, aunque esto lo veremos en las siguientes secciones. Implementaci\u00f3n de un servidor HTTP con API REST La implementaci\u00f3n de un servidor HTTP en ESP-IDF se delega al componente HTTP Server , que implementa toda la funcionalida necesaria para tal fin de forma eficiente y ligera. La construcci\u00f3n de un servidor puede resumirse en tres funciones principales (observa la implementaci\u00f3n de la funcion start_rest_server en el fichero rest_server.c ) del ejemplo: httpd_start : crea una instancia de servidor HTTP, y aloja recursos para ella seg\u00fan la configuraci\u00f3n proporcionada. En funci\u00f3n del tr\u00e1fico generado (URIs solicitadas), se utilizar\u00e1n manejadores espec\u00edficos definidos por el usuario para analizarlo y, en caso necesario, enviar respuestas al cliente correspondiente. httpd_stop : finaliza el servidor HTTP, cerrando cualquier conexi\u00f3n previamente establecida con clientes. httpd_register_uri_handler : registra un manejador (una funci\u00f3n definida por el usuario) para tratar una petici\u00f3n sobre una URI determinada. La estructura proporcionada dispone de campos para indicar la URI destino ( uri ), el m\u00e9todo que se espera recibir ( method , por ejemplo HTTPD_GET o HTTPD_POST ) y un puntero a una funci\u00f3n que procesar\u00e1 la petici\u00f3n recibida a trav\u00e9s de la URI indicada. Dicha funci\u00f3n s\u00f3lo se ejecutar\u00e1 si el m\u00e9todo coincide con el indicado. La funci\u00f3n start_rest_server del ejemplo proporciona los mecanismos b\u00e1sicos para la creaci\u00f3n de la API anteriormente descrita. As\u00ed, para crear el endpoint /api/v1/system/info , procederemos, en primer lugar, registr\u00e1ndolo en el servidor, preparando previamente la estructura de tipo httpd_uri_t : httpd_uri_t system_info_get_uri = { .uri = \"/api/v1/system/info\", .method = HTTP_GET, .handler = system_info_get_handler, .user_ctx = rest_context }; httpd_register_uri_handler(server, &system_info_get_uri); En este caso, la operaci\u00f3n asociada a la invocaci\u00f3n del handler ser\u00e1, exclusivamente GET ; de hecho, si invocamos a un m\u00e9todo POST sobre este endpoint , el servidor nos responder\u00e1 autom\u00e1ticamente con un aviso que indicar\u00e1 que dicho m\u00e9todo no est\u00e1 soportado. El procesamiento de la petici\u00f3n GET se realiza en la funci\u00f3n system_info_get_handler , y el esquema que se sigue es, en cualquier caso, sencillo: static esp_err_t system_info_get_handler(httpd_req_t *req) { // Preparaci\u00f3n del tipo de respuesta. httpd_resp_set_type(req, \"application/json\"); // Preparaci\u00f3n del buffer de respuesta. char * buffer = // En el ejemplo preparamos un buffer JSON. // Env\u00edo de respuesta. https_resp_sendstr( req, buffer ); return ESP_OK; Alternativamente, si la respuesta es binaria, podr\u00edamos utilizar la funci\u00f3n https_resp_send( req, buffer, buffer_len ) para procesarla y enviarla (lo necesitar\u00e1s para enviar un buffer binario CBOR). La creaci\u00f3n de un endpoint con soporte para m\u00e9todo POST resulta algo m\u00e1s larga, aunque el registro del mismo no difiere del ejemplo anterior: /* URI handler for light brightness control */ httpd_uri_t light_brightness_post_uri = { .uri = \"/api/v1/light/brightness\", .method = HTTP_POST, .handler = light_brightness_post_handler, .user_ctx = rest_context }; httpd_register_uri_handler(server, &light_brightness_post_uri); Observa el cuerpo de la funci\u00f3n light_brightness_post_handler . La recepci\u00f3n del objeto enviado por parte del cliente se realiza en base a m\u00faltiples invocaciones a la rutina httpd_req_recv : /* Simple handler for light brightness control */ static esp_err_t light_brightness_post_handler(httpd_req_t *req) { int total_len = req->content_len; int cur_len = 0; char *buf = ((rest_server_context_t *)(req->user_ctx))->scratch; int received = 0; if (total_len >= SCRATCH_BUFSIZE) { /* Respond with 500 Internal Server Error */ httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, \"content too long\"); return ESP_FAIL; } while (cur_len < total_len) { received = httpd_req_recv(req, buf + cur_len, total_len); if (received <= 0) { /* Respond with 500 Internal Server Error */ httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, \"Failed to post control value\"); return ESP_FAIL; } cur_len += received; } buf[total_len] = '\\0'; /// A partir de este punto, disponemos en buf del objeto recibido v\u00eda HTTP. /// ... Tarea entregable Observa y estudia los c\u00f3digos de los manejadores implementados en el ejemplo. Extiende la API proporcionada para crear un nuevo endpoint que permita obtener la temperatura (n\u00famero aleatorio), pero transform\u00e1ndola a grados Fahrenheit. En este caso, el valor devuelto en el fichero JSON ser\u00e1 un n\u00famero en punto flotante (en la siguiente secci\u00f3n te se explicar\u00e1 c\u00f3mo hacerlo, por lo que de momento puedes enviar \u00fanicamente la parte entera del mismo). Representaci\u00f3n de la informaci\u00f3n. JSON JSON es un formato de representaci\u00f3n de datos en modo texto para el intercambio de datos entre sistemas inform\u00e1ticos. Se cre\u00f3 inicialmente como una notaci\u00f3n literal de los objetos Javascript, pero dada su amplia aceptaci\u00f3n (realmente como alternativa a XML), se considera a d\u00eda de hoy un componente totalmente independiente al lenguaje. Los tipos de datos soportados por JSON incluyen: Valores num\u00e9ricos: permitiendo n\u00fameros con y sin signo, y con parte decimla en notaci\u00f3n separada por puntos. Cadenas: secuencias de cero o m\u00e1s caracteres. Booleanos: true y false . Arrays: listas ordenadas de cero o m\u00e1s valores de cualquier tipo, separados por comas y encerrados entre corchetes. Objetos: colecciones no ordenadas de pares <nombre>:<valor> , separados por comas y encerrados entre llaves. ESP-IDF incluye el componente cJSON para parsear y construir objetos de tipo JSON de forma sencilla y consistente. La biblioteca cJSON representa datos JSON utilizando una estructura sencilla, v\u00e9ase: /* The cJSON structure: */ typedef struct cJSON { struct cJSON *next; struct cJSON *prev; struct cJSON *child; int type; char *valuestring; /* writing to valueint is DEPRECATED, use cJSON_SetNumberValue instead */ int valueint; double valuedouble; char *string; } cJSON; El campo type informa sobre el tipo de dato contenido en el objeto, v\u00e9ase: cJSON_False ( cJSON_IsFalse() ): representa un valor booleano falso. cJSON_True ( cJSON_IsTrue() ): representa un valor booleano verdadero. cJSON_NULL ( cJSON_IsNULL() ): representa un valor nulo. cJSON_Number ( cJSON_IsNumber() ): representa un valor num\u00e9rico. Dicho valor se almacena en el campo valuedouble como flotante y en valueint como entero. cJSON_String ( cJSON_IsString() ): representa un valor cadena, y se almacena en el campo valuestring como un array de bytes terminado por el car\u00e1cter nulo ('\\0'). cJSON_Array ( cJSON_IsArray() ): representa un array de valores. En el campo child se almacena una lista enlazada con los elementos del array, terminada en NULL. cJSON_Object ( cJSON_IsObject() ): representa un valor objeto. Sus valores se almacenan de la misma manera que el array anterior, pero en el campo string se almacenan adem\u00e1s las claves del objeto a modo de lista. Creaci\u00f3n y parseado de una estructura JSON Para cada tipo de datos, existe una rutina asociada con nombre cJSON_Create... que permite crear un item del tipo correspondiente. Todas estas funciones alojan memoria suficiente como para albergar el dato creado. Dado un objeto JSON en forma de cadena, es posible analizarlo (parsearlo) utilizando la funci\u00f3n cJSON_Parse : cJSON * json = cJSON_Parse( string ); Para imprimir el contenido de una estructura JSON en modo texto, podemos hacer uso de la funci\u00f3n cJSON_Print(json) : char * string = cJSON_Print( json ); Ejemplos Observa de nuevo el contenido de las funciones manejadoras en nuestro servidor REST. Concretamente, c\u00e9ntrate en la funci\u00f3n system_info_get_handler , que construye un objeto JSON con dos campos, de tipo cadena (\"version\") y num\u00e9rico (\"cores\"): /* Simple handler for getting system handler */ static esp_err_t system_info_get_handler(httpd_req_t *req) { // Preparaci\u00f3n del tipo de datos de la respuesta. httpd_resp_set_type(req, \"application/json\"); // Creaci\u00f3n del objeto JSON. cJSON *root = cJSON_CreateObject(); // Obtenci\u00f3n del dato. esp_chip_info_t chip_info; esp_chip_info(&chip_info); // Anyadimos un campo de tipo cadena. cJSON_AddStringToObject(root, \"version\", IDF_VER); // Anyadimos un campo de tipo num\u00e9rico. cJSON_AddNumberToObject(root, \"cores\", chip_info.cores); // Imprimimos a cadena previo al env\u00edo. const char *sys_info = cJSON_Print(root); // Enviamos cabecera + objeto JSON en modo texto v\u00eda HTTP. httpd_resp_sendstr(req, sys_info); // Liberamos recursos. free((void *)sys_info); // Liberamos recursos del objeto JSON. cJSON_Delete(root); return ESP_OK; } La funci\u00f3n light_brightness_post_handler realiza un parseado del objeto JSON recibido. Observa su cuerpo: // buf contiene la cadena recibida a trav\u00e9s de HTTP (m\u00e9todo POST). // ... // Parseamos el objeto JSON. cJSON *root = cJSON_Parse(buf); // Obtenemos tres valores num\u00e9ricos (RGB). int red = cJSON_GetObjectItem(root, \"red\")->valueint; int green = cJSON_GetObjectItem(root, \"green\")->valueint; int blue = cJSON_GetObjectItem(root, \"blue\")->valueint; // Mostramos por pantalla los valores parseados. ESP_LOGI(REST_TAG, \"Light control: red = %d, green = %d, blue = %d\", red, green, blue); // Liberamos recursos JSON. cJSON_Delete(root); // Enviamos una respuesta generica en modo texto. httpd_resp_sendstr(req, \"Post control value successfully\"); return ESP_OK; Tarea entregable Extiende la tarea anterior para a\u00f1adir el dato en formato punto flotante de la temperatura en grados Fahrenheit. Tarea entregable Crea un nuevo endpoint que utilice un formato m\u00e1s complejo de objetos JSON, incluyendo distintos tipos de datos que puedan dar respuesta a un hipot\u00e9tico entorno IoT. Documenta la API generada y el formato de los objetos que has dise\u00f1ado. Puedes, si as\u00ed lo deseas, incluir capturas Wireshark para ilustrar el intercambio de mensajes producido. Nos interesar\u00e1, especialmente, el n\u00famero de bytes transportados para enviar/recibir tus mensajes JSON. Representaci\u00f3n de la informaci\u00f3n. CBOR CBOR ( Concise Binary Object Representation ) es el formato de serializaci\u00f3n de datos recomendado en muchos de los stacks IoT, espec\u00edficamente en aquellos basados en CoAP. Pese a ser un formato binario, CBOR guarda similitudes con JSON, ya que sigue su mismo modelo de datos: valores num\u00e9ricos, strings , arrays, mapas (objetos en JSON) y valores booleanos y nulos. Sin embargo, a diferencia de JSON, un objeto CBOR es autodescriptivo, y en este punto radica una de sus ventajas: es posible intercambiar datos entre un cliente y un servidor sin ce\u00f1irse a un esquema de datos concreto conocido por ambas partes. El hecho de ser un formato binario implica mejoras sustanciales con respecto a JSON, por ejemplo al transportar datos binarios (claves de cifrado, datos gr\u00e1ficos, o valores flotantes sensorizados, entre otros muchos); estos datos sol\u00edan codificarse en JSON utilizando, por ejemplo, formato base64 , a\u00f1adiendo complejidad al proceso de codificaci\u00f3n/decodificaci\u00f3n. En general, el uso de un formato binario implica menor complejidad a la hora de ser integrado en aplicaciones, y es por esta raz\u00f3n por la que se considera \u00f3ptimo para nodos de bajas prestaciones, t\u00edpicos en IoT. El formato CBOR est\u00e1 documentado en el RFC 7049 , y por tanto se considera un est\u00e1ndar bien documentado y estable de cara al futuro. CBOR en el ESP32 ESP-IDF incluye la biblioteca tinyCBOR como implementaci\u00f3n ligera del est\u00e1ndar, que permite tanto codificar distintos tipos de datos a formato CBOR, parsear estructuras CBOR y convertir dichas estructuras tanto a formato texto visualizable como a JSON. TinyCBOR est\u00e1 mantenido como proyecto de software libre por parte de Intel, y su documentaci\u00f3n detallada (se sugiere consultarla) se encuentra disponible en el siguiente enlace . Estudiaremos el funcionamiento de tinyCBOR a trav\u00e9s de un ejemplo funcional (lo puedes encontrar en examples/protocols/cbor ). El ejemplo muestra los mecanismos necesarios para, en primer lugar, crear un objeto CBOR completo utilizando la biblioteca, y en segundo lugar, el mecanismo para convertir dicho objeto a representaci\u00f3n JSON, as\u00ed como para parsearlo manualmente. En primer lugar, compila, flashea y ejecuta el ejemplo. Ver\u00e1s que la salida deber\u00eda ser similar a la siguiente: I (320) example: encoded buffer size 67 I (320) example: convert CBOR to JSON [{\"chip\":\"esp32\",\"unicore\":false,\"ip\":[192,168,1,100]},3.1400001049041748,\"simple(99)\",\"2019-07-10 09:00:00+0000\",\"undefined\"] I (340) example: decode CBOR manually Array[ Map{ chip esp32 unicore false ip Array[ 192 168 1 100 ] } 3.14 simple(99) 2019-07-10 09:00:00+0000 undefined ] Observa que la estructura del objeto CBOR ser\u00e1 medianamente compleja: constar\u00e1 de un array formado por cinco elementos: Un mapa (conjunto no ordenado de pares clave-valor ), combinando cadenas, booleanos y un segundo array para especificar una direcci\u00f3n IP. Un valor flotante (3.14). Un valor num\u00e9rico \"simple\" (99). Una fecha (en forma de cadena). Un valor indefinido. El firmware procede en tres etapas: Etapa 1: creaci\u00f3n (codificaci\u00f3n) del objeto CBOR Observa el cuerpo de la tarea principal ( app_main ). El codificador CBOR se basa en dos variables: CborEncoder Root_encoder; // Codificador CBOR. uint8_t buf[100]; // Buffer para alojar el objeto CBOR (array de bytes). En segundo lugar, y ya que utilizaremos un array y un mapa, necesitaremos constructores especiales para dichos objetos: // Creaci\u00f3n de Array. CborEncoder array_encoder; CborEncoder map_encoder; cbor_encoder_create_array(&root_encoder, &array_encoder, 5); // [ // 1. Creaci\u00f3n del Mapa. cbor_encoder_create_map(&array_encoder, &map_encoder, 3); // { A partir de este punto, podemos proceder con la construcci\u00f3n de los objetos siguiendo el esquema deseado: // chip: esp32 (cadena:cadena) cbor_encode_text_stringz(&map_encoder, \"chip\"); cbor_encode_text_stringz(&map_encoder, \"esp32\"); // unicore: false (cadena:booleano) cbor_encode_text_stringz(&map_encoder, \"unicore\"); cbor_encode_boolean(&map_encoder, false); // IP:[192,168,1,100] (cadena:array) cbor_encode_text_stringz(&map_encoder, \"ip\"); CborEncoder array2; cbor_encoder_create_array(&map_encoder, &array2, 4); // [ // Valores num\u00e9ricos. cbor_encode_uint(&array2, 192); cbor_encode_uint(&array2, 168); cbor_encode_uint(&array2, 1); cbor_encode_uint(&array2, 100); cbor_encoder_close_container(&map_encoder, &array2); // ] cbor_encoder_close_container(&array_encoder, &map_encoder); // } // 2. Flotante cbor_encode_float(&array_encoder, 3.14); // 3. Valor simple cbor_encode_simple_value(&array_encoder, 99); // 4. Cadena cbor_encode_text_stringz(&array_encoder, \"2019-07-10 09:00:00+0000\"); // 5. Undefined value. cbor_encode_undefined(&array_encoder); cbor_encoder_close_container(&root_encoder, &array_encoder); // ] // Mostramos el tama\u00f1o del buffer creado. ESP_LOGI(TAG, \"encoded buffer size %d\", cbor_encoder_get_buffer_size(&root_encoder, buf)); Etapa 2: conversi\u00f3n a JSON La conversi\u00f3n a JSON (t\u00edpicamente por motivos de visualizaci\u00f3n o depuraci\u00f3n), puede realizarse del siguiente modo: // Initialize the cbor parser and the value iterator cbor_parser_init(buf, sizeof(buf), 0, &root_parser, &it); ESP_LOGI(TAG, \"convert CBOR to JSON\"); // Dump the values in JSON format cbor_value_to_json(stdout, &it, 0); Etapa 3: parseado manual de un objeto CBOR Por \u00faltimo, el parseado manual del objeto CBOR se deja como ejercicio de estudio para el alumno, y est\u00e1 implementado en la funci\u00f3n example_dump_cbor_buffer del ejemplo. B\u00e1sicamente, la funci\u00f3n itera por cada uno de los elementos del objeto CBOR, consultando el tipo de cada elemento y actuando en consecuencia. Para aquellos tipos complejos (e.g. arrays o mapas), la funci\u00f3n se invoca recursivamente hasta encontrar un elemento de tipo b\u00e1sico. En este caso, simplemente imprime por pantalla su valor (e.g. en el caso de un entero, caso CborIntegerType ). Tarea entregable Se pide extender la API REST con un nuevo endpoint que permita obtener la misma informaci\u00f3n que el endpoint JSON desarrollado en la anterior tarea, pero en esta ocasi\u00f3n, utilizando formato CBOR. El objetivo del ejercicio es comparar la cantidad de tr\u00e1fico generado en cada representaci\u00f3n, por lo que se sugiere que el objeto intercambiado sea relativamente complejo (es decir, incluya disintos tipos de datos num\u00e9ricos, arrays, o mapas). A continuaci\u00f3n se incluyen notas adicionales que te permitir\u00e1n depurar tu desarrollo, observando los valores devueltos por el servidor HTTP. Notas adicionales: creaci\u00f3n y consulta de un endpoint CBOR en la API REST Las modificaciones a realizar en la funci\u00f3n manejadora del endpoint para responder con un objeto CBOR son m\u00ednimas. De hecho, se centran simplemente en el tipo de respuesta y el mecanismo a usar para enviarla, v\u00e9ase: static esp_err_t system_info_get_handler(httpd_req_t *req) { // Tipo de respuesta. httpd_resp_set_type(req, \"application/cbor\"); CborEncoder root_encoder; uint8_t buf[100]; // Codificador CBOR. cbor_encoder_init(&root_encoder, buf, sizeof(buf), 0); // Codificamos CBOR. // ... // Enviamos respuesta, consultando previamente el tama\u00f1o del buffer codificado. httpd_resp_send(req, (char*)buf, cbor_encoder_get_buffer_size( &root_encoder, buf)); return ESP_OK; Para consultar desde l\u00ednea de comandos sobre este endpoint , podemos utilizar directamente curl , volcando la salida recibida a un fichero (por ejemplo, output.cbor ): curl http://192.168.1.26/api/v1/system/info > output.cbor Si visualizas el contenido del fichero, ver\u00e1s que contiene datos binarios dif\u00edcilmente interpretables. A continuaci\u00f3n veremos distintos mecanismos de visualizaci\u00f3n. Notas adicionales: visualizaci\u00f3n de datos CBOR Una opci\u00f3n de visualizaci\u00f3n consiste en utilizar la web cbor.me . En el panel derecho, podr\u00e1s pegar el contenido binario le\u00eddo. Si necesitas realizar la conversi\u00f3n antes de pegarlo en la web, puedes hacerlo con la orden: xxd -ps output.cbor Un ejemplo de salida (a pegar en el panel derecho de la web), podr\u00eda ser: $ xxd -ps output.cbor 85a3646368697065657370333267756e69636f7265f46269708418c018a8 011864fa4048f5c3f8637818323031392d30372d31302030393a30303a30 302b30303030f7 Deber\u00edas observar una salida similar a la siguiente (ten en cuenta que la herramiente autom\u00e1ticamente indenta el contenido del panel derecho; recuerda que simplemente debes pegar la salida generada por xxd ): Otra opci\u00f3n de visualizaci\u00f3n puede ser un programa Python (podr\u00edas integrarlo en tu servidor TCP/UDP, por ejemplo), que haga uso del m\u00f3dulo cbor2 ( documentaci\u00f3n ). Para comprobar su funcionamiento, primero inst\u00e1lalo: pip install cbor2 Y comprueba si efectivamente funciona utilizando el siguiente programa Python: from cbor2 import dumps, loads, dump, load with open('output.cbor', 'rb') as fp: obj = load(fp) print(obj) Al ejecutarlo, observar\u00e1s el contenido del objeto: python cbor.py [{'chip': 'esp32', 'unicore': False, 'ip': [192, 168, 1, 100]}, 3.140000104904175, CBORSimpleValue(value=99), '2019-07-10 09:00:00+0000', undefined]","title":"Pr\u00e1ctica 3. Servidores REST y representaci\u00f3n de la informaci\u00f3n. JSON y CBOR"},{"location":"RPI-II/P5_old/#practica-3-servidores-rest-y-representacion-de-la-informacion-json-y-cbor","text":"","title":"Pr\u00e1ctica 3. Servidores REST y representaci\u00f3n de la informaci\u00f3n. JSON y CBOR"},{"location":"RPI-II/P5_old/#objetivos","text":"Entender los mecanismos ofrecidos por ESP-IDF para la creaci\u00f3n de un servidor REST HTTP. Implementar, a trav\u00e9s de los mecanismos ofrecidos por ESP-IDF, una API REST extendida en el ESP32. Entender los conceptos b\u00e1sicos de representaci\u00f3n de datos a trav\u00e9s de JSON. Implementar, a trav\u00e9s de la biblioteca cJSON , un tipo de mensaje personalizado para los intercambios de datos entre cliente y servidor. Entender los conceptos b\u00e1sicos de representaci\u00f3n de datos a trav\u00e9s de CBOR, y evaluar sus ventajas con respecto a JSON. Implementar, a trav\u00e9s de la biblioteca tinycbor , un tipo de mensaje personalizado para los intercambios de datos entre cliente y servidor, comparando los tama\u00f1os de payload con respecto al intercambio JSON.","title":"Objetivos"},{"location":"RPI-II/P5_old/#desarrollo-de-un-servidor-rest-en-esp-idf","text":"En la primera parte de la pr\u00e1ctica, veremos c\u00f3mo desarrollar, utilizando las funcionalidades ofrecidas por ESP-IDF, un servidor HTTP que exponga una API REST mediante la cual ser\u00e1 posible interactuar, en modos lectura y escritura, con un servidor (en nuestro caso, un dispositivo ESP32). Concretamente, trabajaremos con el ejemplo example/protocols/http_server/restful_server de la distribuci\u00f3n de IDF.","title":"Desarrollo de un servidor REST en ESP-IDF"},{"location":"RPI-II/P5_old/#descripcion-de-la-api","text":"El ejemplo que estudiaremos construye una sencilla interfaz (API) con tres endpoints que permiten interactuar con distintas funcionalidades del ESP32. N\u00f3tese que tanto las URLs como la funcionalidad asociada a ellas es totalmente personalizable, y puede ser ampliada de acuerdo a las necesidades de nuestra aplicaci\u00f3n. La siguiente tabla resume la funcionalidad de cada endpoint , as\u00ed como posibles ejemplos de valores enviados o devueltos a/por el servidor: API M\u00e9todo Ejemplo de recurso le\u00eddo/escrito Descripci\u00f3n URL /api/v1/system/info GET { version:\"v4.0-dev\", cores:2 } Utilizado por los clientes para obtener informaci\u00f3n de la placa (versi\u00f3n, n\u00famero de cores, ...) / /api/v1/temp/raw GET { raw:22 } Utilizado por los clientes para obtener datos de temperatura desde un sensor (no disponible en el ESP32) /chart /api/v1/light/brightness POST { red:160, green:160, blue:160 } Utilizado por los clientes para escribir en la placa valores de control para controlar la luminosidad de LEDs /light","title":"Descripci\u00f3n de la API"},{"location":"RPI-II/P5_old/#configuracion-y-compilacion-del-ejemplo","text":"En primer lugar, configura, compila y flashea el ejemplo mencionado. En este caso, las instrucciones se dividen en dos partes: compilaci\u00f3n del firmware para el ESP32, y preparaci\u00f3n de un cliente web sencillo que nos permitir\u00e1 observar la interacci\u00f3n con el mismo. Esta \u00faltima parte no es estrictamente necesaria, pero nos ayudar\u00e1 en la interacci\u00f3n con el dispositivo de forma visual hasta que veamos c\u00f3mo hacerlo a trav\u00e9s de l\u00ednea de comandos. A trav\u00e9s del men\u00fa de configuraci\u00f3n, configura un nombre para el dispositivo (por ejemplo, 'esp_home_tunombre'), e indica que el modo de despliegue ( Website deploy mode ) sea Deploy website to SPI Nor Flash . Por \u00faltimo, configura las credenciales del punto de acceso WiFi al que conectar\u00e1, siguiendo la metodolog\u00eda habitual. En segundo lugar, necesitamos instalar los componentes necesarios para desplegar el cliente web. Para ello, navega al subdirectorio front/web-demo , donde reside el c\u00f3digo fuente del cliente. Ejecuta los siguientes comandos para instalar las dependencias necesarias: sudo apt-get install npm node-vue* npm install npm run build Dependiendo del sistema, en este punto se puede producir un error de openssl (\"digital envelope routines::unsupported\"). Si fuese el caso, es preciso establecer la variable de entorno adecudada y volver a ejecutar el comando npm run build . En Linux/MacOS: export NODE_OPTIONS=--openssl-legacy-provider En Windows: set NODE_OPTIONS=--openssl-legacy-provider Una vez construido el front-end, ya podr\u00e1s ejecutar, desde el directorio base del ejemplo, la orden de compilaci\u00f3n y flasheado: idf.py build idf.py flash idf.py monitor","title":"Configuraci\u00f3n y compilaci\u00f3n del ejemplo"},{"location":"RPI-II/P5_old/#interaccion-con-el-dispositivo-via-interfaz-web","text":"Si todo ha ido bien, podr\u00e1s observar en la salida de monitorizaci\u00f3n la IP proporcionada al ESP32. Abre un navegador en la m\u00e1quina virtual o en tu PC (estando conectada a la misma red que tu ESP32), navega hacia la direcci\u00f3n IP del ESP32, y deber\u00edas observar una p\u00e1gina como la siguiente: Esta es una p\u00e1gina web servida por el propio ESP32, que te permitir\u00e1 interactuar con \u00e9l. Concretamente, la p\u00e1gina dispone de dos funcionalidades: Chart : consulta peri\u00f3dicamente el valor de temperatura devuelto por el ESP32 a trav\u00e9s del endpoint /api/v1/temp/raw . Light : permite enviar al ESP32 nuevos valores para las tres componentes de luminosidad que hipot\u00e9ticamente podr\u00eda equipar el ESP32. Tarea 3.1 Interact\u00faa con el sensor de luminosidad del ESP32 enviando distintos valores. Observa c\u00f3mo la salida de monitorizaci\u00f3n del ESP32 responde mostrando los valores recibidos. Analiza el tr\u00e1fico generado para una de dichas peticiones utilizando Wireshark. \u00bfC\u00f3mo se codifican los datos en el env\u00edo? \u00bfC\u00f3mo se codifican los datos peri\u00f3dicos de temperatura recibidos?","title":"Interacci\u00f3n con el dispositivo v\u00eda interfaz web"},{"location":"RPI-II/P5_old/#interaccion-con-el-dispositivo-via-linea-de-comandos-curl","text":"curl es una herramienta orientada a la transferencia de archivos por red. Entre otras (muchas) funcionalidades, curl soporta los m\u00e9todos GET y PUT del protocolo HTTP, justo las necesarias para realizar peticiones de lectura y escritura sobre nuestro servidor HTTP REST. Nota La versi\u00f3n de curl de PowerShell en Windows hace uso de Invoke-WebRequest y es mejor evitarla. Es preferible usar la versi\u00f3n de curl de CMD que es m\u00e1s compatible con las versiones UNIX (Linux/MacOS). Concretamente, para realizar una petici\u00f3n HTTP GET sobre nuestro servidor, podemos ejecutar: curl http://IP/URI Por ejemplo, la petici\u00f3n: curl http://192.168.1.26/api/v1/temp/raw (siendo 192.168.1.26 la IP del ESP32) nos responder\u00e1 con el valor de temperatura instant\u00e1nea. Del mismo modo, para escribir (m\u00e9todo POST ) sobre el servidor, utilizaremos el par\u00e1metro -d , seguido del recurso que queramos enviar. Ten en cuenta que es responsabilidad del cliente enviar un recurso bien formado e interpretable por el dispositivo: curl -d '{\"red\":70,\"green\":80,\"blue\":99}' -H \"Content-Type: application/json\" -X POST http://192.168.1.26/api/v1/light/brightness Observa que hemos incluido el tipo de recurso enviado ( JSON ) y la operacion solicitada ( POST ). Volveremos a esto en breve. Tarea 3.2 Comprueba que, efectivamente, el tr\u00e1fico generado por las anteriores \u00f3rdenes es el mismo que el que observaste en el caso del cliente web. Observa qu\u00e9 ocurre si consultas un endpoint inexistente, o si env\u00edas un JSON mal formado o con informaci\u00f3n incorrecta.","title":"Interacci\u00f3n con el dispositivo v\u00eda l\u00ednea de comandos (curl)"},{"location":"RPI-II/P5_old/#interaccion-con-el-dispositivo-via-node-red","text":"Para interactuar con el dispositivo v\u00eda Node-RED, simplemente despliega un flujo que contenga un nodo de tipo HTTP Request . En su cuadro de di\u00e1logo de configuraci\u00f3n, podr\u00e1s incliur tanto el m\u00e9todo a utilizar (e.g. GET o POST ) como el endpoint (URL) destino y, opcionalmente, los datos a enviar si esto es necesario. Tarea 3.3 Comprueba que, efectivamente, el tr\u00e1fico generado por un flujo que utilice un nodo de interacci\u00f3n HTTP es el esperado, y el comportamiento del ESP32 tambi\u00e9n. En el caso de necesitar enviar un objeto JSON, puedes investigar c\u00f3mo formarlo con los nodos correspondientes, aunque esto lo veremos en las siguientes secciones.","title":"Interacci\u00f3n con el dispositivo v\u00eda Node-RED"},{"location":"RPI-II/P5_old/#implementacion-de-un-servidor-http-con-api-rest","text":"La implementaci\u00f3n de un servidor HTTP en ESP-IDF se delega al componente HTTP Server , que implementa toda la funcionalida necesaria para tal fin de forma eficiente y ligera. La construcci\u00f3n de un servidor puede resumirse en tres funciones principales (observa la implementaci\u00f3n de la funcion start_rest_server en el fichero rest_server.c ) del ejemplo: httpd_start : crea una instancia de servidor HTTP, y aloja recursos para ella seg\u00fan la configuraci\u00f3n proporcionada. En funci\u00f3n del tr\u00e1fico generado (URIs solicitadas), se utilizar\u00e1n manejadores espec\u00edficos definidos por el usuario para analizarlo y, en caso necesario, enviar respuestas al cliente correspondiente. httpd_stop : finaliza el servidor HTTP, cerrando cualquier conexi\u00f3n previamente establecida con clientes. httpd_register_uri_handler : registra un manejador (una funci\u00f3n definida por el usuario) para tratar una petici\u00f3n sobre una URI determinada. La estructura proporcionada dispone de campos para indicar la URI destino ( uri ), el m\u00e9todo que se espera recibir ( method , por ejemplo HTTPD_GET o HTTPD_POST ) y un puntero a una funci\u00f3n que procesar\u00e1 la petici\u00f3n recibida a trav\u00e9s de la URI indicada. Dicha funci\u00f3n s\u00f3lo se ejecutar\u00e1 si el m\u00e9todo coincide con el indicado. La funci\u00f3n start_rest_server del ejemplo proporciona los mecanismos b\u00e1sicos para la creaci\u00f3n de la API anteriormente descrita. As\u00ed, para crear el endpoint /api/v1/system/info , procederemos, en primer lugar, registr\u00e1ndolo en el servidor, preparando previamente la estructura de tipo httpd_uri_t : httpd_uri_t system_info_get_uri = { .uri = \"/api/v1/system/info\", .method = HTTP_GET, .handler = system_info_get_handler, .user_ctx = rest_context }; httpd_register_uri_handler(server, &system_info_get_uri); En este caso, la operaci\u00f3n asociada a la invocaci\u00f3n del handler ser\u00e1, exclusivamente GET ; de hecho, si invocamos a un m\u00e9todo POST sobre este endpoint , el servidor nos responder\u00e1 autom\u00e1ticamente con un aviso que indicar\u00e1 que dicho m\u00e9todo no est\u00e1 soportado. El procesamiento de la petici\u00f3n GET se realiza en la funci\u00f3n system_info_get_handler , y el esquema que se sigue es, en cualquier caso, sencillo: static esp_err_t system_info_get_handler(httpd_req_t *req) { // Preparaci\u00f3n del tipo de respuesta. httpd_resp_set_type(req, \"application/json\"); // Preparaci\u00f3n del buffer de respuesta. char * buffer = // En el ejemplo preparamos un buffer JSON. // Env\u00edo de respuesta. https_resp_sendstr( req, buffer ); return ESP_OK; Alternativamente, si la respuesta es binaria, podr\u00edamos utilizar la funci\u00f3n https_resp_send( req, buffer, buffer_len ) para procesarla y enviarla (lo necesitar\u00e1s para enviar un buffer binario CBOR). La creaci\u00f3n de un endpoint con soporte para m\u00e9todo POST resulta algo m\u00e1s larga, aunque el registro del mismo no difiere del ejemplo anterior: /* URI handler for light brightness control */ httpd_uri_t light_brightness_post_uri = { .uri = \"/api/v1/light/brightness\", .method = HTTP_POST, .handler = light_brightness_post_handler, .user_ctx = rest_context }; httpd_register_uri_handler(server, &light_brightness_post_uri); Observa el cuerpo de la funci\u00f3n light_brightness_post_handler . La recepci\u00f3n del objeto enviado por parte del cliente se realiza en base a m\u00faltiples invocaciones a la rutina httpd_req_recv : /* Simple handler for light brightness control */ static esp_err_t light_brightness_post_handler(httpd_req_t *req) { int total_len = req->content_len; int cur_len = 0; char *buf = ((rest_server_context_t *)(req->user_ctx))->scratch; int received = 0; if (total_len >= SCRATCH_BUFSIZE) { /* Respond with 500 Internal Server Error */ httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, \"content too long\"); return ESP_FAIL; } while (cur_len < total_len) { received = httpd_req_recv(req, buf + cur_len, total_len); if (received <= 0) { /* Respond with 500 Internal Server Error */ httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, \"Failed to post control value\"); return ESP_FAIL; } cur_len += received; } buf[total_len] = '\\0'; /// A partir de este punto, disponemos en buf del objeto recibido v\u00eda HTTP. /// ... Tarea entregable Observa y estudia los c\u00f3digos de los manejadores implementados en el ejemplo. Extiende la API proporcionada para crear un nuevo endpoint que permita obtener la temperatura (n\u00famero aleatorio), pero transform\u00e1ndola a grados Fahrenheit. En este caso, el valor devuelto en el fichero JSON ser\u00e1 un n\u00famero en punto flotante (en la siguiente secci\u00f3n te se explicar\u00e1 c\u00f3mo hacerlo, por lo que de momento puedes enviar \u00fanicamente la parte entera del mismo).","title":"Implementaci\u00f3n de un servidor HTTP con API REST"},{"location":"RPI-II/P5_old/#representacion-de-la-informacion-json","text":"JSON es un formato de representaci\u00f3n de datos en modo texto para el intercambio de datos entre sistemas inform\u00e1ticos. Se cre\u00f3 inicialmente como una notaci\u00f3n literal de los objetos Javascript, pero dada su amplia aceptaci\u00f3n (realmente como alternativa a XML), se considera a d\u00eda de hoy un componente totalmente independiente al lenguaje. Los tipos de datos soportados por JSON incluyen: Valores num\u00e9ricos: permitiendo n\u00fameros con y sin signo, y con parte decimla en notaci\u00f3n separada por puntos. Cadenas: secuencias de cero o m\u00e1s caracteres. Booleanos: true y false . Arrays: listas ordenadas de cero o m\u00e1s valores de cualquier tipo, separados por comas y encerrados entre corchetes. Objetos: colecciones no ordenadas de pares <nombre>:<valor> , separados por comas y encerrados entre llaves. ESP-IDF incluye el componente cJSON para parsear y construir objetos de tipo JSON de forma sencilla y consistente. La biblioteca cJSON representa datos JSON utilizando una estructura sencilla, v\u00e9ase: /* The cJSON structure: */ typedef struct cJSON { struct cJSON *next; struct cJSON *prev; struct cJSON *child; int type; char *valuestring; /* writing to valueint is DEPRECATED, use cJSON_SetNumberValue instead */ int valueint; double valuedouble; char *string; } cJSON; El campo type informa sobre el tipo de dato contenido en el objeto, v\u00e9ase: cJSON_False ( cJSON_IsFalse() ): representa un valor booleano falso. cJSON_True ( cJSON_IsTrue() ): representa un valor booleano verdadero. cJSON_NULL ( cJSON_IsNULL() ): representa un valor nulo. cJSON_Number ( cJSON_IsNumber() ): representa un valor num\u00e9rico. Dicho valor se almacena en el campo valuedouble como flotante y en valueint como entero. cJSON_String ( cJSON_IsString() ): representa un valor cadena, y se almacena en el campo valuestring como un array de bytes terminado por el car\u00e1cter nulo ('\\0'). cJSON_Array ( cJSON_IsArray() ): representa un array de valores. En el campo child se almacena una lista enlazada con los elementos del array, terminada en NULL. cJSON_Object ( cJSON_IsObject() ): representa un valor objeto. Sus valores se almacenan de la misma manera que el array anterior, pero en el campo string se almacenan adem\u00e1s las claves del objeto a modo de lista.","title":"Representaci\u00f3n de la informaci\u00f3n. JSON"},{"location":"RPI-II/P5_old/#creacion-y-parseado-de-una-estructura-json","text":"Para cada tipo de datos, existe una rutina asociada con nombre cJSON_Create... que permite crear un item del tipo correspondiente. Todas estas funciones alojan memoria suficiente como para albergar el dato creado. Dado un objeto JSON en forma de cadena, es posible analizarlo (parsearlo) utilizando la funci\u00f3n cJSON_Parse : cJSON * json = cJSON_Parse( string ); Para imprimir el contenido de una estructura JSON en modo texto, podemos hacer uso de la funci\u00f3n cJSON_Print(json) : char * string = cJSON_Print( json );","title":"Creaci\u00f3n y parseado de una estructura JSON"},{"location":"RPI-II/P5_old/#ejemplos","text":"Observa de nuevo el contenido de las funciones manejadoras en nuestro servidor REST. Concretamente, c\u00e9ntrate en la funci\u00f3n system_info_get_handler , que construye un objeto JSON con dos campos, de tipo cadena (\"version\") y num\u00e9rico (\"cores\"): /* Simple handler for getting system handler */ static esp_err_t system_info_get_handler(httpd_req_t *req) { // Preparaci\u00f3n del tipo de datos de la respuesta. httpd_resp_set_type(req, \"application/json\"); // Creaci\u00f3n del objeto JSON. cJSON *root = cJSON_CreateObject(); // Obtenci\u00f3n del dato. esp_chip_info_t chip_info; esp_chip_info(&chip_info); // Anyadimos un campo de tipo cadena. cJSON_AddStringToObject(root, \"version\", IDF_VER); // Anyadimos un campo de tipo num\u00e9rico. cJSON_AddNumberToObject(root, \"cores\", chip_info.cores); // Imprimimos a cadena previo al env\u00edo. const char *sys_info = cJSON_Print(root); // Enviamos cabecera + objeto JSON en modo texto v\u00eda HTTP. httpd_resp_sendstr(req, sys_info); // Liberamos recursos. free((void *)sys_info); // Liberamos recursos del objeto JSON. cJSON_Delete(root); return ESP_OK; } La funci\u00f3n light_brightness_post_handler realiza un parseado del objeto JSON recibido. Observa su cuerpo: // buf contiene la cadena recibida a trav\u00e9s de HTTP (m\u00e9todo POST). // ... // Parseamos el objeto JSON. cJSON *root = cJSON_Parse(buf); // Obtenemos tres valores num\u00e9ricos (RGB). int red = cJSON_GetObjectItem(root, \"red\")->valueint; int green = cJSON_GetObjectItem(root, \"green\")->valueint; int blue = cJSON_GetObjectItem(root, \"blue\")->valueint; // Mostramos por pantalla los valores parseados. ESP_LOGI(REST_TAG, \"Light control: red = %d, green = %d, blue = %d\", red, green, blue); // Liberamos recursos JSON. cJSON_Delete(root); // Enviamos una respuesta generica en modo texto. httpd_resp_sendstr(req, \"Post control value successfully\"); return ESP_OK; Tarea entregable Extiende la tarea anterior para a\u00f1adir el dato en formato punto flotante de la temperatura en grados Fahrenheit. Tarea entregable Crea un nuevo endpoint que utilice un formato m\u00e1s complejo de objetos JSON, incluyendo distintos tipos de datos que puedan dar respuesta a un hipot\u00e9tico entorno IoT. Documenta la API generada y el formato de los objetos que has dise\u00f1ado. Puedes, si as\u00ed lo deseas, incluir capturas Wireshark para ilustrar el intercambio de mensajes producido. Nos interesar\u00e1, especialmente, el n\u00famero de bytes transportados para enviar/recibir tus mensajes JSON.","title":"Ejemplos"},{"location":"RPI-II/P5_old/#representacion-de-la-informacion-cbor","text":"CBOR ( Concise Binary Object Representation ) es el formato de serializaci\u00f3n de datos recomendado en muchos de los stacks IoT, espec\u00edficamente en aquellos basados en CoAP. Pese a ser un formato binario, CBOR guarda similitudes con JSON, ya que sigue su mismo modelo de datos: valores num\u00e9ricos, strings , arrays, mapas (objetos en JSON) y valores booleanos y nulos. Sin embargo, a diferencia de JSON, un objeto CBOR es autodescriptivo, y en este punto radica una de sus ventajas: es posible intercambiar datos entre un cliente y un servidor sin ce\u00f1irse a un esquema de datos concreto conocido por ambas partes. El hecho de ser un formato binario implica mejoras sustanciales con respecto a JSON, por ejemplo al transportar datos binarios (claves de cifrado, datos gr\u00e1ficos, o valores flotantes sensorizados, entre otros muchos); estos datos sol\u00edan codificarse en JSON utilizando, por ejemplo, formato base64 , a\u00f1adiendo complejidad al proceso de codificaci\u00f3n/decodificaci\u00f3n. En general, el uso de un formato binario implica menor complejidad a la hora de ser integrado en aplicaciones, y es por esta raz\u00f3n por la que se considera \u00f3ptimo para nodos de bajas prestaciones, t\u00edpicos en IoT. El formato CBOR est\u00e1 documentado en el RFC 7049 , y por tanto se considera un est\u00e1ndar bien documentado y estable de cara al futuro.","title":"Representaci\u00f3n de la informaci\u00f3n. CBOR"},{"location":"RPI-II/P5_old/#cbor-en-el-esp32","text":"ESP-IDF incluye la biblioteca tinyCBOR como implementaci\u00f3n ligera del est\u00e1ndar, que permite tanto codificar distintos tipos de datos a formato CBOR, parsear estructuras CBOR y convertir dichas estructuras tanto a formato texto visualizable como a JSON. TinyCBOR est\u00e1 mantenido como proyecto de software libre por parte de Intel, y su documentaci\u00f3n detallada (se sugiere consultarla) se encuentra disponible en el siguiente enlace . Estudiaremos el funcionamiento de tinyCBOR a trav\u00e9s de un ejemplo funcional (lo puedes encontrar en examples/protocols/cbor ). El ejemplo muestra los mecanismos necesarios para, en primer lugar, crear un objeto CBOR completo utilizando la biblioteca, y en segundo lugar, el mecanismo para convertir dicho objeto a representaci\u00f3n JSON, as\u00ed como para parsearlo manualmente. En primer lugar, compila, flashea y ejecuta el ejemplo. Ver\u00e1s que la salida deber\u00eda ser similar a la siguiente: I (320) example: encoded buffer size 67 I (320) example: convert CBOR to JSON [{\"chip\":\"esp32\",\"unicore\":false,\"ip\":[192,168,1,100]},3.1400001049041748,\"simple(99)\",\"2019-07-10 09:00:00+0000\",\"undefined\"] I (340) example: decode CBOR manually Array[ Map{ chip esp32 unicore false ip Array[ 192 168 1 100 ] } 3.14 simple(99) 2019-07-10 09:00:00+0000 undefined ] Observa que la estructura del objeto CBOR ser\u00e1 medianamente compleja: constar\u00e1 de un array formado por cinco elementos: Un mapa (conjunto no ordenado de pares clave-valor ), combinando cadenas, booleanos y un segundo array para especificar una direcci\u00f3n IP. Un valor flotante (3.14). Un valor num\u00e9rico \"simple\" (99). Una fecha (en forma de cadena). Un valor indefinido. El firmware procede en tres etapas:","title":"CBOR en el ESP32"},{"location":"RPI-II/P5_old/#etapa-1-creacion-codificacion-del-objeto-cbor","text":"Observa el cuerpo de la tarea principal ( app_main ). El codificador CBOR se basa en dos variables: CborEncoder Root_encoder; // Codificador CBOR. uint8_t buf[100]; // Buffer para alojar el objeto CBOR (array de bytes). En segundo lugar, y ya que utilizaremos un array y un mapa, necesitaremos constructores especiales para dichos objetos: // Creaci\u00f3n de Array. CborEncoder array_encoder; CborEncoder map_encoder; cbor_encoder_create_array(&root_encoder, &array_encoder, 5); // [ // 1. Creaci\u00f3n del Mapa. cbor_encoder_create_map(&array_encoder, &map_encoder, 3); // { A partir de este punto, podemos proceder con la construcci\u00f3n de los objetos siguiendo el esquema deseado: // chip: esp32 (cadena:cadena) cbor_encode_text_stringz(&map_encoder, \"chip\"); cbor_encode_text_stringz(&map_encoder, \"esp32\"); // unicore: false (cadena:booleano) cbor_encode_text_stringz(&map_encoder, \"unicore\"); cbor_encode_boolean(&map_encoder, false); // IP:[192,168,1,100] (cadena:array) cbor_encode_text_stringz(&map_encoder, \"ip\"); CborEncoder array2; cbor_encoder_create_array(&map_encoder, &array2, 4); // [ // Valores num\u00e9ricos. cbor_encode_uint(&array2, 192); cbor_encode_uint(&array2, 168); cbor_encode_uint(&array2, 1); cbor_encode_uint(&array2, 100); cbor_encoder_close_container(&map_encoder, &array2); // ] cbor_encoder_close_container(&array_encoder, &map_encoder); // } // 2. Flotante cbor_encode_float(&array_encoder, 3.14); // 3. Valor simple cbor_encode_simple_value(&array_encoder, 99); // 4. Cadena cbor_encode_text_stringz(&array_encoder, \"2019-07-10 09:00:00+0000\"); // 5. Undefined value. cbor_encode_undefined(&array_encoder); cbor_encoder_close_container(&root_encoder, &array_encoder); // ] // Mostramos el tama\u00f1o del buffer creado. ESP_LOGI(TAG, \"encoded buffer size %d\", cbor_encoder_get_buffer_size(&root_encoder, buf));","title":"Etapa 1: creaci\u00f3n (codificaci\u00f3n) del objeto CBOR"},{"location":"RPI-II/P5_old/#etapa-2-conversion-a-json","text":"La conversi\u00f3n a JSON (t\u00edpicamente por motivos de visualizaci\u00f3n o depuraci\u00f3n), puede realizarse del siguiente modo: // Initialize the cbor parser and the value iterator cbor_parser_init(buf, sizeof(buf), 0, &root_parser, &it); ESP_LOGI(TAG, \"convert CBOR to JSON\"); // Dump the values in JSON format cbor_value_to_json(stdout, &it, 0);","title":"Etapa 2: conversi\u00f3n a JSON"},{"location":"RPI-II/P5_old/#etapa-3-parseado-manual-de-un-objeto-cbor","text":"Por \u00faltimo, el parseado manual del objeto CBOR se deja como ejercicio de estudio para el alumno, y est\u00e1 implementado en la funci\u00f3n example_dump_cbor_buffer del ejemplo. B\u00e1sicamente, la funci\u00f3n itera por cada uno de los elementos del objeto CBOR, consultando el tipo de cada elemento y actuando en consecuencia. Para aquellos tipos complejos (e.g. arrays o mapas), la funci\u00f3n se invoca recursivamente hasta encontrar un elemento de tipo b\u00e1sico. En este caso, simplemente imprime por pantalla su valor (e.g. en el caso de un entero, caso CborIntegerType ). Tarea entregable Se pide extender la API REST con un nuevo endpoint que permita obtener la misma informaci\u00f3n que el endpoint JSON desarrollado en la anterior tarea, pero en esta ocasi\u00f3n, utilizando formato CBOR. El objetivo del ejercicio es comparar la cantidad de tr\u00e1fico generado en cada representaci\u00f3n, por lo que se sugiere que el objeto intercambiado sea relativamente complejo (es decir, incluya disintos tipos de datos num\u00e9ricos, arrays, o mapas). A continuaci\u00f3n se incluyen notas adicionales que te permitir\u00e1n depurar tu desarrollo, observando los valores devueltos por el servidor HTTP.","title":"Etapa 3: parseado manual de un objeto CBOR"},{"location":"RPI-II/P5_old/#notas-adicionales-creacion-y-consulta-de-un-endpoint-cbor-en-la-api-rest","text":"Las modificaciones a realizar en la funci\u00f3n manejadora del endpoint para responder con un objeto CBOR son m\u00ednimas. De hecho, se centran simplemente en el tipo de respuesta y el mecanismo a usar para enviarla, v\u00e9ase: static esp_err_t system_info_get_handler(httpd_req_t *req) { // Tipo de respuesta. httpd_resp_set_type(req, \"application/cbor\"); CborEncoder root_encoder; uint8_t buf[100]; // Codificador CBOR. cbor_encoder_init(&root_encoder, buf, sizeof(buf), 0); // Codificamos CBOR. // ... // Enviamos respuesta, consultando previamente el tama\u00f1o del buffer codificado. httpd_resp_send(req, (char*)buf, cbor_encoder_get_buffer_size( &root_encoder, buf)); return ESP_OK; Para consultar desde l\u00ednea de comandos sobre este endpoint , podemos utilizar directamente curl , volcando la salida recibida a un fichero (por ejemplo, output.cbor ): curl http://192.168.1.26/api/v1/system/info > output.cbor Si visualizas el contenido del fichero, ver\u00e1s que contiene datos binarios dif\u00edcilmente interpretables. A continuaci\u00f3n veremos distintos mecanismos de visualizaci\u00f3n.","title":"Notas adicionales: creaci\u00f3n y consulta de un endpoint CBOR en la API REST"},{"location":"RPI-II/P5_old/#notas-adicionales-visualizacion-de-datos-cbor","text":"Una opci\u00f3n de visualizaci\u00f3n consiste en utilizar la web cbor.me . En el panel derecho, podr\u00e1s pegar el contenido binario le\u00eddo. Si necesitas realizar la conversi\u00f3n antes de pegarlo en la web, puedes hacerlo con la orden: xxd -ps output.cbor Un ejemplo de salida (a pegar en el panel derecho de la web), podr\u00eda ser: $ xxd -ps output.cbor 85a3646368697065657370333267756e69636f7265f46269708418c018a8 011864fa4048f5c3f8637818323031392d30372d31302030393a30303a30 302b30303030f7 Deber\u00edas observar una salida similar a la siguiente (ten en cuenta que la herramiente autom\u00e1ticamente indenta el contenido del panel derecho; recuerda que simplemente debes pegar la salida generada por xxd ): Otra opci\u00f3n de visualizaci\u00f3n puede ser un programa Python (podr\u00edas integrarlo en tu servidor TCP/UDP, por ejemplo), que haga uso del m\u00f3dulo cbor2 ( documentaci\u00f3n ). Para comprobar su funcionamiento, primero inst\u00e1lalo: pip install cbor2 Y comprueba si efectivamente funciona utilizando el siguiente programa Python: from cbor2 import dumps, loads, dump, load with open('output.cbor', 'rb') as fp: obj = load(fp) print(obj) Al ejecutarlo, observar\u00e1s el contenido del objeto: python cbor.py [{'chip': 'esp32', 'unicore': False, 'ip': [192, 168, 1, 100]}, 3.140000104904175, CBORSimpleValue(value=99), '2019-07-10 09:00:00+0000', undefined]","title":"Notas adicionales: visualizaci\u00f3n de datos CBOR"},{"location":"RPI-II/P5_old/notas/","text":"Implementaci\u00f3n de una interfaz REST v\u00eda HTTP Ejemplo Ejemplo: restful_server navegar a front/webdemo apt-get install npm node-vue* npm install y npm run build en direcrorio front/web-demo idf.py build","title":"Notas"},{"location":"RPI-II/P5_old/notas/#implementacion-de-una-interfaz-rest-via-http","text":"","title":"Implementaci\u00f3n de una interfaz REST v\u00eda HTTP"},{"location":"RPI-II/P5_old/notas/#ejemplo","text":"Ejemplo: restful_server navegar a front/webdemo apt-get install npm node-vue* npm install y npm run build en direcrorio front/web-demo idf.py build","title":"Ejemplo"},{"location":"RPI-II/P6/","text":"Pr\u00e1ctica 6. Introducci\u00f3n a ThingsBoard Objetivos Entender los conceptos b\u00e1sicos detr\u00e1s de la plataforma IoT Thingsboard. Dominar el proceso de provisionamiento autom\u00e1tico de dispositivos. Aprender a gestionar datos de telemetr\u00eda enviados a la plataforma desde el dispositivo. Aprender a gestionar atributos de dispositivos y diferenciar entre los tres tipos que ofrece Thingsboard. Realizar representaciones sencillas en forma de dashboard y gestionar alarmas. Introducci\u00f3n a ThingsBoard \u00bfQu\u00e9 es ThingsBoard? ThingsBoard es una plataforma de c\u00f3digo abierto para la gesti\u00f3n de dispositivos IoT (Internet de las Cosas) que permite a los usuarios conectar, administrar y analizar datos de dispositivos de forma sencilla y eficiente. Algunas de sus caracter\u00edsticas clave incluyen: Gesti\u00f3n de Dispositivos : ThingsBoard permite a los usuarios registrar y administrar dispositivos IoT, as\u00ed como definir atributos y telemetr\u00eda que pueden ser enviados desde los dispositivos a la plataforma. Visualizaci\u00f3n de Datos : La plataforma proporciona herramientas para crear dashboards personalizables, donde los usuarios pueden visualizar datos en tiempo real mediante gr\u00e1ficos, mapas y otros widgets. Integraci\u00f3n de Protocolos : ThingsBoard admite m\u00faltiples protocolos de comunicaci\u00f3n, como MQTT, HTTP y CoAP, lo que facilita la conexi\u00f3n de dispositivos IoT de diferentes fabricantes. Reglas y Alarmas : Los usuarios pueden configurar reglas y alertas para gestionar eventos en tiempo real, lo que permite automatizar acciones basadas en condiciones espec\u00edficas. Escalabilidad : Es adecuada para aplicaciones desde peque\u00f1as hasta grandes, lo que la hace vers\u00e1til para diferentes tipos de proyectos IoT. API y Extensibilidad : ThingsBoard ofrece API REST y MQTT que permiten a los desarrolladores integrar la plataforma con otros sistemas y servicios. En resumen, ThingsBoard es una soluci\u00f3n robusta para la gesti\u00f3n y an\u00e1lisis de datos IoT que proporciona a los usuarios las herramientas necesarias para construir y escalar aplicaciones IoT de manera efectiva. Instalaci\u00f3n y acceso En esta pr\u00e1ctica, puedes optar por utilizar la versi\u00f3n de demostraci\u00f3n en cloud de Thingsboard, o bien instalar tu propia versi\u00f3n de la plataforma en una m\u00e1quina con acceso local o remoto. Dispones de toda la informaci\u00f3n sobre instalaci\u00f3n en distintas plataformas en la p\u00e1gina de ThingsBoard . En un entorno Docker ya preparado, la forma m\u00e1s sencilla de proceder es mediante la instalaci\u00f3n de la imagen tb-postgres (instrucciones aqu\u00ed . Tarea (opcional) Instala en tu m\u00e1quina local Thingsboard siguiendo el m\u00e9todo de instalaci\u00f3n m\u00e1s apropiado a tu caso. Prueba b\u00e1sica de conectividad de un dispositivo Los dispositivos son el tipo de entidad b\u00e1sico en Thingsboard. Un dispositivo en la plataforma no es m\u00e1s que una representaci\u00f3n digital de un dispositivo f\u00edsico, incluyendo sus propiedades, atributos, modos de acceso y datos de telemetr\u00eda. Aunque en esta pr\u00e1ctica veremos que los dispositivos pueden crearse en la plataforma de forma autom\u00e1tica mediante un proceso de provisionamiento, es conveniente realizar una primera prueba de conectividad creando manualmente un dispositivo, e interactuando con \u00e9l v\u00eda una API preestablecida (en nuestro caso, MQTT). En primer lugar, dir\u00edgete al men\u00fa \"Entidades\", \"Dispositivos\". Crea (usando el s\u00edmbolo + ) un nuevo dispositivo. A\u00f1ade el nombre que desees (no debe existir) y deja vac\u00edos el resto de campos. Aparecer\u00e1 una ventana en la que se sugieren distintas formas de comprobar la conectividad externa al nuevo dispositivo. Entre ellas, escogeremos en este paso MQTT. Selecciona la pesta\u00f1a correspondiente al protocolo, y a continuaci\u00f3n el sistema operativo que est\u00e1s utilizando. En respuesta, la plataforma sugerir\u00e1 un comando que te permitir\u00e1 testear la conectividad. Por ejemplo, en el caso de MQTT y Linux, ejecuta: mosquitto_pub -d -q 1 -h URL_THINGSBOARD -p 1883 -t v1/devices/me/telemetry -u \"TOKEN\" -m \"{temperature:25}\" Observa que el nombre de usuario que se utiliza para establecer la conexi\u00f3n con el broker es el token asociado al nuevo dispositivo. En este mensaje, se utiliza el topic v1/devices/me/telemetry , a trav\u00e9s del cual se pueden enviar datos de telemetr\u00eda al dispositivo virtual usando un formato JSON. Tarea Crea un nuevo dispositivo y comprueba la conectividad hacia el mismo desde l\u00ednea de comandos (o cualquier herramienta de publicaci\u00f3n MQTT). Provisionamiento Conceptos generales El proceso de provisionamiento en ThingsBoard puede ser automatizado para as\u00ed partir de un firmware com\u00fan que no deba personalizarse para cada dispositivo. Durante el provisionamiento autom\u00e1tico, el dispositivo puede o bien generar credenciales \u00fanicas, o bien solicitar al servidor que le proporcione dichas credenciales. El funcionamiento es sencillo. El dispositivo env\u00eda una petici\u00f3n de provisonamiento ( request ) a ThingsBoard. Esta petici\u00f3n debe contener una clave de provisonamiento ( provision key ) y un secreto ( secret ). La petici\u00f3n puede incluir, opcionalmente, el nombre del dispositivo y las credenciales generadas por el dispositivo. Si dichas credenciales no se proporcionan, el servidor generar\u00e1 un access token para que sea utilizado en el futuro por el dispositivo provisionado. El esquema podr\u00eda resumirse como: Siendo un ejemplo de petici\u00f3n de provisionamiento: { \"deviceName\": \"DEVICE_NAME\", \"provisionDeviceKey\": \"YOUR_PROVISION_KEY_HERE\", \"provisionDeviceSecret\": \"YOUR_PROVISION_SECRET_HERE\" } ThingsBoard validar\u00e1 la petici\u00f3n y responder\u00e1 con la respuesta ( response ) de provisionamiento correspondiente. Una respuesta exitosa contendr\u00e1 el identificador del dispositivo, tipo de credenciales, y el cuerpo de la respuesta (habitualmente, un token ). Si la respuesta no fue exitosa, t\u00edpicamente \u00fanicamente contendr\u00e1 el estado. Ejemplo de respuesta de provisionamiento: { \"provisionDeviceStatus\":\"SUCCESS\", \"credentialsType\":\"ACCESS_TOKEN\", \"accessToken\":\"sLzc0gDAZPkGMzFVTyUY\" } Durante la validaci\u00f3n de la petici\u00f3n, ThingsBoard comprobar\u00e1 la informaci\u00f3n proporcionada ( provisionDeviceKey y provisionDeviceSecret ) para encontrar el Perfil de Dispositivo correspondiente. Cuando se encuentre, la plataforma utilizar\u00e1 la correspondiente estrategia de provisionamiento para validar el nombre del dispositivo. Existen dos tipos de estrategias de provisionamiento: Permitir crear nuevos dispositivos . Se comprueba que ning\u00fan dispositivo con el mismo nombre est\u00e1 ya provisonado en ThingsBoard. Esta estrategia es \u00fatil si no se dispone de una lista de nombres de dispositivo \u00fanica (e.g. direcciones MAC) durante la fabricaci\u00f3n de los dispositivos pero el dispositivo s\u00ed dispone de acceso a dicha informaci\u00f3n en el firmware . Es m\u00e1s sencilla de implementar, pero menos segura que la segunda estrategia. Comprobar dispositivos pre-provisionados . Comprueba que el dispositivo con el mismo nombre ya ha sido creado en ThingsBoard, pero todav\u00eda no ha sido provisionado. Esta estrategia es \u00fatil cuando se desea provisionar s\u00f3lo una lista preconfeccionada de dispositivos. Asumamos que se ha obtenido una lista de identificadores (e.g. MACs) durante la fabricaci\u00f3n. Ser\u00eda posible utilizar bulk provisioning para subir dicha lista a ThingsBoard; as\u00ed, los dispositivos de la lista pueden solicitar peticiones de provisionamiento, y ning\u00fan otro dispositivo podr\u00eda hacerlo. Cuando el provisionamiento ha finalizado, ThingsBoard actualizar\u00e1 el atributo del servidor provisionState asociado al dispositivo (m\u00e1s sobre atributos m\u00e1s adelante en esta misma pr\u00e1ctica), asign\u00e1ndole el valor provisioned . Configuraci\u00f3n del perfil de dispositivo Es necesario configurar un perfil de dispositivo para habilitar la funcionalidad de provisionamiento. Concretamente, es necesario seguir los siguientes pasos: Crear un nuevo perfil de dispositivo, o editar uno existente. Asignarle un nombre, un tipo de transporte (e.g. MQTT), reglas de alarma para los dispositivos que se adhieran al perfil, y por \u00faltimo una estrategia de provisionamiento. En el paso 4 (Estrategia de Provisionamiento), seleccionar Permitir crear nuevos dispositivos , y anotar (o recordar clave y secreto de provisonamiento. Dispones de toda la informaci\u00f3n en la documentaci\u00f3n de ThingsBoard. Tarea Crea dos perfiles de dispositivo con capacidades de provisionamiento. Investiga la definici\u00f3n de alarmas para un campo de telemetr\u00eda llamado \"temperature\", que active una alarma siempre que un dispositivo bajo dicho perfil emita un valor superior al umbral fijado. Fija el transporte en MQTT y recuerda los datos de credenciales para los nuevos perfiles. APIs para provisonamiento En esta pr\u00e1ctica, utilizaremos MQTT como API para forzar un proceso de provisionamiento autom\u00e1tico desde el dispositivo. Existen alternativas utilizando HTTP y CoAP, que puedes consultar en la documentaci\u00f3n de ThingsBoard. La API MQTT es sencilla. En esta pr\u00e1ctica usaremos credenciales generadas por el servidor ThingsBoard, pero puedes encontrar f\u00e1cilmente la correspondiente API para credenciales generadas por el dispositivo en la documentaci\u00f3n de la plataforma. Mediante MQTT, el firmware de dispositivo puede solicitar un proceso de provisionamiento de forma sencilla. Sin embargo, veremos un ejemplo Python que nos servir\u00e1 de inspiraci\u00f3n para la tarea entregable, que se basar\u00e1 en un proceso equivalente utilizando ESP-IDF. Si no lo hiciste en la anterior pr\u00e1ctica, instala paho en un entorno virtual: python -m venv .venv source .venv/bin/activate pip install paho-mqtt Observa el siguiente c\u00f3digo; ejec\u00fatalo desde cualquier m\u00e1quina con una instalaci\u00f3n de paho-mqtt python3 test.py : from paho.mqtt.client import Client from json import dumps, loads RESULT_CODES = { 1: \"incorrect protocol version\", 2: \"invalid client identifier\", 3: \"server unavailable\", 4: \"bad username or password\", 5: \"not authorised\", } def collect_required_data(): config = {} print(\"\\n\\n\", \"=\"*80, sep=\"\") print(\" \"*10, \"\\033[1m\\033[94mThingsBoard device provisioning with basic authorization example script.\\033[0m\", sep=\"\") print(\"=\"*80, \"\\n\\n\", sep=\"\") host = input(\"Please write your ThingsBoard \\033[93mhost\\033[0m or leave it blank to use default (thingsboard.cloud): \") config[\"host\"] = host if host else \"demo.thingsboard.io\" port = input(\"Please write your ThingsBoard \\033[93mport\\033[0m or leave it blank to use default (1883): \") config[\"port\"] = int(port) if port else 1883 config[\"provision_device_key\"] = input(\"Please write \\033[93mprovision device key\\033[0m: \") config[\"provision_device_secret\"] = input(\"Please write \\033[93mprovision device secret\\033[0m: \") device_name = input(\"Please write \\033[93mdevice name\\033[0m or leave it blank to generate: \") if device_name: config[\"device_name\"] = device_name print(\"\\n\", \"=\"*80, \"\\n\", sep=\"\") return config class ProvisionClient(Client): PROVISION_REQUEST_TOPIC = \"/provision/request\" PROVISION_RESPONSE_TOPIC = \"/provision/response\" def __init__(self, host, port, provision_request): super().__init__() self._host = host self._port = port self._username = \"provision\" self.on_connect = self.__on_connect self.on_message = self.__on_message self.__provision_request = provision_request def __on_connect(self, client, userdata, flags, rc): # Callback for connect if rc == 0: print(\"[Provisioning client] Connected to ThingsBoard \") client.subscribe(self.PROVISION_RESPONSE_TOPIC) # Subscribe to provisioning response topic provision_request = dumps(self.__provision_request) print(\"[Provisioning client] Sending provisioning request %s\" % provision_request) client.publish(self.PROVISION_REQUEST_TOPIC, provision_request) # Publishing provisioning request topic else: print(\"[Provisioning client] Cannot connect to ThingsBoard!, result: %s\" % RESULT_CODES[rc]) def __on_message(self, client, userdata, msg): decoded_payload = msg.payload.decode(\"UTF-8\") print(\"[Provisioning client] Received data from ThingsBoard: %s\" % decoded_payload) decoded_message = loads(decoded_payload) provision_device_status = decoded_message.get(\"status\") if provision_device_status == \"SUCCESS\": self.__save_credentials(decoded_message[\"credentialsValue\"]) else: print(\"[Provisioning client] Provisioning was unsuccessful with status %s and message: %s\" % (provision_device_status, decoded_message[\"errorMsg\"])) self.disconnect() def provision(self): print(\"[Provisioning client] Connecting to ThingsBoard (provisioning client)\") self.__clean_credentials() self.connect(self._host, self._port, 60) self.loop_forever() def get_new_client(self): client_credentials = self.__get_credentials() new_client = None if client_credentials: new_client = Client() new_client.username_pw_set(client_credentials) print(\"[Provisioning client] Read credentials from file.\") else: print(\"[Provisioning client] Cannot read credentials from file!\") return new_client @staticmethod def __get_credentials(): new_credentials = None try: with open(\"credentials\", \"r\") as credentials_file: new_credentials = credentials_file.read() except Exception as e: print(e) return new_credentials @staticmethod def __save_credentials(credentials): with open(\"credentials\", \"w\") as credentials_file: credentials_file.write(credentials) @staticmethod def __clean_credentials(): open(\"credentials\", \"w\").close() def on_tb_connected(client, userdata, flags, rc): # Callback for connect with received credentials if rc == 0: print(\"[ThingsBoard client] Connected to ThingsBoard with credentials: %s\" % client._username.decode()) else: print(\"[ThingsBoard client] Cannot connect to ThingsBoard!, result: %s\" % RESULT_CODES[rc]) if __name__ == '__main__': config = collect_required_data() THINGSBOARD_HOST = config[\"host\"] # ThingsBoard instance host THINGSBOARD_PORT = config[\"port\"] # ThingsBoard instance MQTT port PROVISION_REQUEST = {\"provisionDeviceKey\": config[\"provision_device_key\"], # Provision device key, replace this value with your value from device profile. \"provisionDeviceSecret\": config[\"provision_device_secret\"], # Provision device secret, replace this value with your value from device profile. } if config.get(\"device_name\") is not None: PROVISION_REQUEST[\"deviceName\"] = config[\"device_name\"] provision_client = ProvisionClient(THINGSBOARD_HOST, THINGSBOARD_PORT, PROVISION_REQUEST) provision_client.provision() # Request provisioned data tb_client = provision_client.get_new_client() # Getting client with provisioned data if tb_client: tb_client.on_connect = on_tb_connected # Setting callback for connect tb_client.connect(THINGSBOARD_HOST, THINGSBOARD_PORT, 60) tb_client.loop_forever() # Starting infinity loop else: print(\"Client was not created!\") Tarea Contesta a las siguientes cuestiones: - \u00bfQu\u00e9 nombre de usuario es necesario usar para la autenticaci\u00f3n en el broker MQTT? - \u00bfQu\u00e9 topics se utilizan para publicar la informaci\u00f3n de petici\u00f3n de provisionamiento y recibir la respuesta correspondiente? Tarea entregable Crea un firmware con ESP-IDF que proceda de forma similar al anterior ejemplo, de modo que provisione autom\u00e1ticamente (con nombre generado por el servidor) a un dispositivo ESP32 en ThingsBoard. Gesti\u00f3n de telemetr\u00eda y visualizaci\u00f3n ThingsBoard proporciona un conjunto de caracter\u00edsticas que permite trabajar con datos en forma de series temporales, permitiendo: Recolectar datos de dispositivos usando distintos protocolos e integracioens . Almacenar series temporales en forma de base de datos SQL (PostgreSQL) o NoSQL (Cassandra o Timescale). Consultar los \u00faltimos valores de telemetr\u00eda obtenidos o todos los datos en rango de tiempo determinado. Suscribirse a actualizaciones de datos usando Websockets para visualizaci\u00f3n en tiempo real y anal\u00edtica. Visualizar las series temporales usando dashboards configurables . Filtrar y analizar datos usando cadenas de reglas . Generar alarmas basadas en datos recolectados. Reenviar datos a servicios externos usando reglas (por ejemplo, a Kafka o RabbitMQ). Puntos de datos ThingsBoard trata internamente los datos de series temporales como pares clave-valor con marca de tiempo. Llamamos punto de datos a un \u00fanico par clave-valor con marca de tiempo. La flexibilidad y simplicidad del formato clave-valor permite una integraci\u00f3n f\u00e1cil y sin problemas con casi cualquier dispositivo IoT del mercado. La clave siempre es una cadena de texto y, b\u00e1sicamente, es el nombre de la clave del punto de datos, mientras que el valor puede ser una cadena, un valor booleano, un doble, un entero o un JSON. Los ejemplos a continuaci\u00f3n usan el formato de datos interno. El propio dispositivo puede cargar datos utilizando varios protocolos y formatos de datos. Consulta la API de carga de datos para m\u00e1s informaci\u00f3n. El siguiente JSON contiene 5 puntos de datos: temperatura (double), humedad (integer), hvacEnabled (boolean), hvacState (string) y configuraci\u00f3n (JSON): { \"temperature\": 42.2, \"humidity\": 70, \"hvacEnabled\": true, \"hvacState\": \"IDLE\", \"configuration\": { \"someNumber\": 42, \"someArray\": [1, 2, 3], \"someNestedObject\": {\"key\": \"value\"} } } Observa que el JSON listado arriba no contiene informaci\u00f3n de marca de tiempo. En tal caso, ThingsBoard utiliza la marca de tiempo actual del servidor. Sin embargo, puedes incluir informaci\u00f3n de marca de tiempo en el mensaje. Consulta el ejemplo a continuaci\u00f3n: { \"ts\": 1527863043000, \"values\": { \"temperature\": 42.2, \"humidity\": 70 } } API MQTT Para publicar datos de telemetr\u00eda al servidor ThingsBoard desde cualquier dispositivo, es suficiente con publicar un mensaje MQTT bajo el siguiente topic: v1/devices/me/telemetry` El formato de datos m\u00e1s simple soportado es: {\"key1\":\"value1\", \"key2\":\"value2\"} o [{\"key1\":\"value1\"}, {\"key2\":\"value2\"}] (en este caso, la marca de tiempo ser\u00e1 asignada por el servidor). Si se desea que el cliente fije la marca de tiempo, es posible usar el formato: {\"ts\":1451649600512, \"values\":{\"key1\":\"value1\", \"key2\":\"value2\"}} Donde 1451649600512 es una marca de tiempo Unix con precisi\u00f3n de milisegundos. Usando las herramientas de la suite mosquitto , podr\u00edamos enviar un dato como: mosquitto_pub -d -q 1 -h \"demo.thingsboard.io\" -t \"v1/devices/me/telemetry\" -u \"$ACCESS_TOKEN\" -m \"{\"temperature\":42}\" Para enviar un objeto JSON sin datos de marca de tiempo: mosquitto_pub -d -q 1 -h \"demo.thingsboard.io\" -t \"v1/devices/me/telemetry\" -u \"$ACCESS_TOKEN\" -f \"telemetry-data-as-object.json\" Siendo el contenido del fichero JSON: { \"stringKey\": \"value1\", \"booleanKey\": true, \"doubleKey\": 42.0, \"longKey\": 73, \"jsonKey\": { \"someNumber\": 42, \"someArray\": [1,2,3], \"someNestedObject\": {\"key\": \"value\"} } } Para publicar, por ejemplo, un objeto con marca de tiempo, usando datos m\u00e1s complejos, podr\u00edamos construir el siguiente JSON: { \"ts\": 1451649600512, \"values\": { \"stringKey\": \"value1\", \"booleanKey\": true, \"doubleKey\": 42.0, \"longKey\": 73, \"jsonKey\": { \"someNumber\": 42, \"someArray\": [1, 2, 3], \"someNestedObject\": { \"key\": \"value\" } } } } Tarea entregable Modifica el anterior firmware para que, desde una tarea y peri\u00f3dicamente, se env\u00ede a Thingsboard datos de telemetr\u00eda. Estos datos pueden tener un valor aleatorio, pero ser\u00eda muy conveniente (aunque no evaluable para la pr\u00e1ctica) que se tomasen desde sensores reales. El formato del mensaje es libre, pero intenta obtener uno que aune realismo y cierta complejidad en el uso de tipos de datos. Gesti\u00f3n de atributos ThingsBoard proporciona la capacidad de asignar atributos personalizados a las entidades (por ejemplo, a los dispositivos) y gestionar estos atributos. Estos atributos se almacenan en la base de datos y pueden ser utilizados para la visualizaci\u00f3n y el procesamiento de datos. Los atributos se tratan como pares clave-valor. La flexibilidad y simplicidad del formato clave-valor permiten una integraci\u00f3n f\u00e1cil y sin problemas con casi cualquier dispositivo IoT del mercado. La clave siempre es una cadena de texto y, b\u00e1sicamente, es el nombre del atributo, mientras que el valor del atributo puede ser una cadena, un valor booleano, un doble, un entero o un JSON. Por ejemplo: { \"firmwareVersion\":\"v2.3.1\", \"booleanParameter\":true, \"doubleParameter\":42.0, \"longParameter\":73, \"configuration\": { \"someNumber\": 42, \"someArray\": [1,2,3], \"someNestedObject\": {\"key\": \"value\"} } } El desarrollador es libre para seleccionar cualquier nombre de atributo. Tipos de atributos Atributos de servidor Este tipo de atributo es compatible con casi cualquier entidad de la plataforma, incluyendo dispositivos, bienes, u otras entidades. Los atributos del lado del servidor son aquellos que pueden ser configurados a trav\u00e9s de la interfaz de administraci\u00f3n o la API REST. El firmware del dispositivo no puede acceder al atributo del lado del servidor. Supongamos que deseas construir una soluci\u00f3n de monitorizaci\u00f3n de edificios y revisemos algunos ejemplos: La latitud, longitud y direcci\u00f3n son buenos ejemplos de atributos del lado del servidor que puedes asignar a activos que representen edificios u otros bienes inmuebles. Puedes utilizar estos atributos en el widget de mapa en tu panel para visualizar la ubicaci\u00f3n de los edificios. El atributo floorPlanImage puede contener una URL de la imagen. Puedes usar este atributo para visualizar el plano de planta en el widget de mapa de imagen. Los atributos maxTemperatureThreshold y temperatureAlarmEnabled pueden ser utilizados para configurar y habilitar/deshabilitar alarmas para un dispositivo o activo en particular. Tarea Ve a Dispositivos . Haz clic en la fila del dispositivo en particular para abrir los detalles del dispositivo. Selecciona la pesta\u00f1a Atributos . Elige el alcance de Atributos del servidor . Haz clic en el icono \"+\". Introduce el nombre del nuevo atributo. Selecciona el tipo de valor del atributo e introduce el valor del atributo. Ordena usando Hora de la \u00faltima actualizaci\u00f3n para ubicar r\u00e1pidamente el atributo reci\u00e9n creado. En la documentaci\u00f3n de ThingsBoard encontrar\u00e1s la API para gestionar este tipo de atributos program\u00e1ticamente. Atributos compartidos Este tipo de atributos est\u00e1 disponible solo para Dispositivos. Es similar a los atributos del lado del servidor, pero tiene una diferencia importante. El firmware/aplicaci\u00f3n del dispositivo puede solicitar el valor de los atributos compartidos o suscribirse a las actualizaciones de estos atributos. Los dispositivos que se comunican mediante MQTT u otros protocolos de comunicaci\u00f3n bidireccional pueden suscribirse a las actualizaciones de atributos y recibir notificaciones en tiempo real. Los dispositivos que se comunican a trav\u00e9s de HTTP u otros protocolos de comunicaci\u00f3n de solicitud-respuesta pueden solicitar peri\u00f3dicamente el valor de los atributos compartidos. El caso de uso m\u00e1s com\u00fan de los atributos compartidos es almacenar configuraciones de dispositivos. Supongamos la misma soluci\u00f3n de monitoreo de edificios y revisemos algunos ejemplos: El atributo targetFirmwareVersion puede ser utilizado para almacenar la versi\u00f3n de firmware para un dispositivo en particular. El atributo maxTemperature puede ser utilizado para activar autom\u00e1ticamente el sistema HVAC si hace demasiado calor en la habitaci\u00f3n. El usuario puede cambiar el atributo a trav\u00e9s de la interfaz de usuario. Un script u otra aplicaci\u00f3n del lado del servidor puede cambiar el valor del atributo a trav\u00e9s de la API REST. Tarea Ve a Dispositivos . Haz clic en la fila del dispositivo en particular para abrir los detalles del dispositivo. Selecciona la pesta\u00f1a Atributos . Elige el alcance de Atributos compartidos . Haz clic en el icono \"+\". Introduce el nombre del nuevo atributo. Selecciona el tipo de valor del atributo e introduce el valor del atributo. Observa el nuevo atributo. La funci\u00f3n de bulk provisioning te permite crear r\u00e1pidamente m\u00faltiples dispositivos y activos y sus atributos desde un archivo CSV. Atributos de cliente Este tipo de atributos est\u00e1 disponible solo para Dispositivos. Se utiliza para reportar varios datos semiest\u00e1ticos desde el Dispositivo (Cliente) a ThingsBoard (Servidor). Es similar a los atributos compartidos, pero tiene una diferencia importante. El firmware/aplicaci\u00f3n del dispositivo puede enviar el valor de los atributos desde el dispositivo a la plataforma. El caso de uso m\u00e1s com\u00fan de los atributos del cliente es reportar el estado del dispositivo. Supongamos la misma soluci\u00f3n de monitoreo de edificios y revisemos algunos ejemplos: El atributo currentFirmwareVersion puede ser utilizado para reportar la versi\u00f3n del firmware/aplicaci\u00f3n instalada para el dispositivo a la plataforma. El atributo currentConfiguration puede ser utilizado para reportar la configuraci\u00f3n actual del firmware/aplicaci\u00f3n a la plataforma. El atributo currentState puede ser utilizado para persistir y restaurar el estado actual del firmware/aplicaci\u00f3n a trav\u00e9s de la red, si el dispositivo no tiene almacenamiento persistente. Los usuarios y las aplicaciones del lado del servidor pueden explorar los atributos del lado del cliente a trav\u00e9s de la interfaz de usuario/API REST, pero no pueden cambiarlos. B\u00e1sicamente, el valor del atributo del lado del cliente es de solo lectura para la UI/API REST. API para gesti\u00f3n de atributos La API de atributos de ThingsBoard permite a los dispositivos: Subir atributos del dispositivo del lado del cliente al servidor. Solicitar atributos del dispositivo del lado del cliente y compartidos desde el servidor. Suscribirse a atributos compartidos del dispositivo desde el servidor. Publicar actualizaci\u00f3n de atributos en el servidor Para publicar atributos del dispositivo del lado del cliente en el nodo del servidor de ThingsBoard, env\u00eda un mensaje PUBLISH al siguiente topic: v1/devices/me/attributes A continuaci\u00f3n, se muestran ejemplos de c\u00f3mo publicar atributos de dispositivo del lado del cliente. No olvides reemplazar demo.thingsboard.io con tu host y $ACCESS_TOKEN con el token de acceso de tu dispositivo. En este ejemplo, el nombre de host hace referencia al servidor de demostraci\u00f3n en vivo. Ejemplo 1. Publicar actualizaci\u00f3n de atributos del lado del cliente. Datos de telemetr\u00eda: {\"attribute1\": \"value1\", \"attribute2\": true} Ejecuta el comando: mosquitto_pub -d -h \"demo.thingsboard.io\" -t \"v1/devices/me/attributes\" -u \"$ACCESS_TOKEN\" -m \"{\"attribute1\": \"value1\", \"attribute2\": true}\" Ejemplo 2. Publicar actualizaci\u00f3n de atributos del lado del cliente utilizando datos del archivo new-attributes-values.json . Contenido del archivo new-attributes-values.json: { \"attribute1\": \"value1\", \"attribute2\": true, \"attribute3\": 42.0, \"attribute4\": 73, \"attribute5\": { \"someNumber\": 42, \"someArray\": [1, 2, 3], \"someNestedObject\": {\"key\": \"value\"} } } Solicitar valores de atributos del servidor Para solicitar atributos del dispositivo del lado del cliente o compartidos en el nodo del servidor de ThingsBoard, env\u00eda un mensaje PUBLISH al siguiente topic: v1/devices/me/attributes/request/$request_id donde $request_id es tu identificador de solicitud entero. Antes de enviar el mensaje PUBLISH con la solicitud, el cliente necesita suscribirse a: v1/devices/me/attributes/response/+ El siguiente ejemplo est\u00e1 escrito en JavaScript. No hay ejemplos en l\u00ednea de comandos puros disponibles porque la suscripci\u00f3n y publicaci\u00f3n deben ocurrir en la misma sesi\u00f3n de MQTT. Guarda el archivo mqtt-js-attributes-request.js en tu PC. No olvides reemplazar el nombre de host demo.thingsboard.io con tu host. var mqtt = require('mqtt') var client = mqtt.connect('mqtt://demo.thingsboard.io',{ username: process.env.TOKEN }) client.on('connect', function () { console.log('connected') client.subscribe('v1/devices/me/attributes/response/+') client.publish('v1/devices/me/attributes/request/1', '{\"clientKeys\":\"attribute1,attribute2\", \"sharedKeys\":\"shared1,shared2\"}') }) client.on('message', function (topic, message) { console.log('response.topic: ' + topic) console.log('response.body: ' + message.toString()) client.end() }) Puedes ejecutar el comando desde cualquier m\u00e1quina con node instalado: export TOKEN=$ACCESS_TOKEN node mqtt-js-attributes-request.js Suscribirse a las actualizaciones de atributos desde el servidor Para suscribirse a los cambios de atributos compartidos del dispositivo, env\u00eda un mensaje SUBSCRIBE al siguiente topic: v1/devices/me/attributes Cuando un atributo compartido es modificado por uno de los componentes del servidor (como la API REST o la Cadena de Reglas), el cliente recibir\u00e1 la siguiente actualizaci\u00f3n: {\"key1\":\"value1\"} En el siguiente ejemplo, no olvides reemplazar demo.thingsboard.io con tu host y $ACCESS_TOKEN con el token de acceso de tu dispositivo. Ejecuta el comando: mosquitto_sub -d -h \"demo.thingsboard.io\" -t \"v1/devices/me/attributes\" -u \"$ACCESS_TOKEN\" Tarea entregable En un escenario de monitorizaci\u00f3n de edificios en la UCM, aprovecha el concepto de atributo para reemplazar la jerarqu\u00eda de topics que dise\u00f1aste en una pr\u00e1ctica anterior. Busca en tu dise\u00f1o utilizar atributos de los tres tipos mencionados anteriormente, descr\u00edbelos en la memoria e interact\u00faa con ellos desde el firmware y usando APIs externas (para ello, deber\u00e1s consultar la documentaci\u00f3n de Thingsboard). Tarea entregable Mediante el uso de atributos, gestiona la activaci\u00f3n/desactivaci\u00f3n del env\u00edo de cada sensor, as\u00ed como el intervalo entre env\u00edos para un dispositivo. Deber\u00edas poder gestionar dichos valores desde la interfaz de Thingsboard. Tarea entregable Investiga en la documentaci\u00f3n de Thingsboard sobre el desarrollo de dashboard y la gesti\u00f3n de alarmas. Desarrolla un dashboard de visualizaci\u00f3n para tus dispositivos, incluyendo informaci\u00f3n sobre alarmas recibidas.","title":"Pr\u00e1ctica 6"},{"location":"RPI-II/P6/#practica-6-introduccion-a-thingsboard","text":"","title":"Pr\u00e1ctica 6. Introducci\u00f3n a ThingsBoard"},{"location":"RPI-II/P6/#objetivos","text":"Entender los conceptos b\u00e1sicos detr\u00e1s de la plataforma IoT Thingsboard. Dominar el proceso de provisionamiento autom\u00e1tico de dispositivos. Aprender a gestionar datos de telemetr\u00eda enviados a la plataforma desde el dispositivo. Aprender a gestionar atributos de dispositivos y diferenciar entre los tres tipos que ofrece Thingsboard. Realizar representaciones sencillas en forma de dashboard y gestionar alarmas.","title":"Objetivos"},{"location":"RPI-II/P6/#introduccion-a-thingsboard","text":"","title":"Introducci\u00f3n a ThingsBoard"},{"location":"RPI-II/P6/#que-es-thingsboard","text":"ThingsBoard es una plataforma de c\u00f3digo abierto para la gesti\u00f3n de dispositivos IoT (Internet de las Cosas) que permite a los usuarios conectar, administrar y analizar datos de dispositivos de forma sencilla y eficiente. Algunas de sus caracter\u00edsticas clave incluyen: Gesti\u00f3n de Dispositivos : ThingsBoard permite a los usuarios registrar y administrar dispositivos IoT, as\u00ed como definir atributos y telemetr\u00eda que pueden ser enviados desde los dispositivos a la plataforma. Visualizaci\u00f3n de Datos : La plataforma proporciona herramientas para crear dashboards personalizables, donde los usuarios pueden visualizar datos en tiempo real mediante gr\u00e1ficos, mapas y otros widgets. Integraci\u00f3n de Protocolos : ThingsBoard admite m\u00faltiples protocolos de comunicaci\u00f3n, como MQTT, HTTP y CoAP, lo que facilita la conexi\u00f3n de dispositivos IoT de diferentes fabricantes. Reglas y Alarmas : Los usuarios pueden configurar reglas y alertas para gestionar eventos en tiempo real, lo que permite automatizar acciones basadas en condiciones espec\u00edficas. Escalabilidad : Es adecuada para aplicaciones desde peque\u00f1as hasta grandes, lo que la hace vers\u00e1til para diferentes tipos de proyectos IoT. API y Extensibilidad : ThingsBoard ofrece API REST y MQTT que permiten a los desarrolladores integrar la plataforma con otros sistemas y servicios. En resumen, ThingsBoard es una soluci\u00f3n robusta para la gesti\u00f3n y an\u00e1lisis de datos IoT que proporciona a los usuarios las herramientas necesarias para construir y escalar aplicaciones IoT de manera efectiva.","title":"\u00bfQu\u00e9 es ThingsBoard?"},{"location":"RPI-II/P6/#instalacion-y-acceso","text":"En esta pr\u00e1ctica, puedes optar por utilizar la versi\u00f3n de demostraci\u00f3n en cloud de Thingsboard, o bien instalar tu propia versi\u00f3n de la plataforma en una m\u00e1quina con acceso local o remoto. Dispones de toda la informaci\u00f3n sobre instalaci\u00f3n en distintas plataformas en la p\u00e1gina de ThingsBoard . En un entorno Docker ya preparado, la forma m\u00e1s sencilla de proceder es mediante la instalaci\u00f3n de la imagen tb-postgres (instrucciones aqu\u00ed . Tarea (opcional) Instala en tu m\u00e1quina local Thingsboard siguiendo el m\u00e9todo de instalaci\u00f3n m\u00e1s apropiado a tu caso.","title":"Instalaci\u00f3n y acceso"},{"location":"RPI-II/P6/#prueba-basica-de-conectividad-de-un-dispositivo","text":"Los dispositivos son el tipo de entidad b\u00e1sico en Thingsboard. Un dispositivo en la plataforma no es m\u00e1s que una representaci\u00f3n digital de un dispositivo f\u00edsico, incluyendo sus propiedades, atributos, modos de acceso y datos de telemetr\u00eda. Aunque en esta pr\u00e1ctica veremos que los dispositivos pueden crearse en la plataforma de forma autom\u00e1tica mediante un proceso de provisionamiento, es conveniente realizar una primera prueba de conectividad creando manualmente un dispositivo, e interactuando con \u00e9l v\u00eda una API preestablecida (en nuestro caso, MQTT). En primer lugar, dir\u00edgete al men\u00fa \"Entidades\", \"Dispositivos\". Crea (usando el s\u00edmbolo + ) un nuevo dispositivo. A\u00f1ade el nombre que desees (no debe existir) y deja vac\u00edos el resto de campos. Aparecer\u00e1 una ventana en la que se sugieren distintas formas de comprobar la conectividad externa al nuevo dispositivo. Entre ellas, escogeremos en este paso MQTT. Selecciona la pesta\u00f1a correspondiente al protocolo, y a continuaci\u00f3n el sistema operativo que est\u00e1s utilizando. En respuesta, la plataforma sugerir\u00e1 un comando que te permitir\u00e1 testear la conectividad. Por ejemplo, en el caso de MQTT y Linux, ejecuta: mosquitto_pub -d -q 1 -h URL_THINGSBOARD -p 1883 -t v1/devices/me/telemetry -u \"TOKEN\" -m \"{temperature:25}\" Observa que el nombre de usuario que se utiliza para establecer la conexi\u00f3n con el broker es el token asociado al nuevo dispositivo. En este mensaje, se utiliza el topic v1/devices/me/telemetry , a trav\u00e9s del cual se pueden enviar datos de telemetr\u00eda al dispositivo virtual usando un formato JSON. Tarea Crea un nuevo dispositivo y comprueba la conectividad hacia el mismo desde l\u00ednea de comandos (o cualquier herramienta de publicaci\u00f3n MQTT).","title":"Prueba b\u00e1sica de conectividad de un dispositivo"},{"location":"RPI-II/P6/#provisionamiento","text":"","title":"Provisionamiento"},{"location":"RPI-II/P6/#conceptos-generales","text":"El proceso de provisionamiento en ThingsBoard puede ser automatizado para as\u00ed partir de un firmware com\u00fan que no deba personalizarse para cada dispositivo. Durante el provisionamiento autom\u00e1tico, el dispositivo puede o bien generar credenciales \u00fanicas, o bien solicitar al servidor que le proporcione dichas credenciales. El funcionamiento es sencillo. El dispositivo env\u00eda una petici\u00f3n de provisonamiento ( request ) a ThingsBoard. Esta petici\u00f3n debe contener una clave de provisonamiento ( provision key ) y un secreto ( secret ). La petici\u00f3n puede incluir, opcionalmente, el nombre del dispositivo y las credenciales generadas por el dispositivo. Si dichas credenciales no se proporcionan, el servidor generar\u00e1 un access token para que sea utilizado en el futuro por el dispositivo provisionado. El esquema podr\u00eda resumirse como: Siendo un ejemplo de petici\u00f3n de provisionamiento: { \"deviceName\": \"DEVICE_NAME\", \"provisionDeviceKey\": \"YOUR_PROVISION_KEY_HERE\", \"provisionDeviceSecret\": \"YOUR_PROVISION_SECRET_HERE\" } ThingsBoard validar\u00e1 la petici\u00f3n y responder\u00e1 con la respuesta ( response ) de provisionamiento correspondiente. Una respuesta exitosa contendr\u00e1 el identificador del dispositivo, tipo de credenciales, y el cuerpo de la respuesta (habitualmente, un token ). Si la respuesta no fue exitosa, t\u00edpicamente \u00fanicamente contendr\u00e1 el estado. Ejemplo de respuesta de provisionamiento: { \"provisionDeviceStatus\":\"SUCCESS\", \"credentialsType\":\"ACCESS_TOKEN\", \"accessToken\":\"sLzc0gDAZPkGMzFVTyUY\" } Durante la validaci\u00f3n de la petici\u00f3n, ThingsBoard comprobar\u00e1 la informaci\u00f3n proporcionada ( provisionDeviceKey y provisionDeviceSecret ) para encontrar el Perfil de Dispositivo correspondiente. Cuando se encuentre, la plataforma utilizar\u00e1 la correspondiente estrategia de provisionamiento para validar el nombre del dispositivo. Existen dos tipos de estrategias de provisionamiento: Permitir crear nuevos dispositivos . Se comprueba que ning\u00fan dispositivo con el mismo nombre est\u00e1 ya provisonado en ThingsBoard. Esta estrategia es \u00fatil si no se dispone de una lista de nombres de dispositivo \u00fanica (e.g. direcciones MAC) durante la fabricaci\u00f3n de los dispositivos pero el dispositivo s\u00ed dispone de acceso a dicha informaci\u00f3n en el firmware . Es m\u00e1s sencilla de implementar, pero menos segura que la segunda estrategia. Comprobar dispositivos pre-provisionados . Comprueba que el dispositivo con el mismo nombre ya ha sido creado en ThingsBoard, pero todav\u00eda no ha sido provisionado. Esta estrategia es \u00fatil cuando se desea provisionar s\u00f3lo una lista preconfeccionada de dispositivos. Asumamos que se ha obtenido una lista de identificadores (e.g. MACs) durante la fabricaci\u00f3n. Ser\u00eda posible utilizar bulk provisioning para subir dicha lista a ThingsBoard; as\u00ed, los dispositivos de la lista pueden solicitar peticiones de provisionamiento, y ning\u00fan otro dispositivo podr\u00eda hacerlo. Cuando el provisionamiento ha finalizado, ThingsBoard actualizar\u00e1 el atributo del servidor provisionState asociado al dispositivo (m\u00e1s sobre atributos m\u00e1s adelante en esta misma pr\u00e1ctica), asign\u00e1ndole el valor provisioned .","title":"Conceptos generales"},{"location":"RPI-II/P6/#configuracion-del-perfil-de-dispositivo","text":"Es necesario configurar un perfil de dispositivo para habilitar la funcionalidad de provisionamiento. Concretamente, es necesario seguir los siguientes pasos: Crear un nuevo perfil de dispositivo, o editar uno existente. Asignarle un nombre, un tipo de transporte (e.g. MQTT), reglas de alarma para los dispositivos que se adhieran al perfil, y por \u00faltimo una estrategia de provisionamiento. En el paso 4 (Estrategia de Provisionamiento), seleccionar Permitir crear nuevos dispositivos , y anotar (o recordar clave y secreto de provisonamiento. Dispones de toda la informaci\u00f3n en la documentaci\u00f3n de ThingsBoard. Tarea Crea dos perfiles de dispositivo con capacidades de provisionamiento. Investiga la definici\u00f3n de alarmas para un campo de telemetr\u00eda llamado \"temperature\", que active una alarma siempre que un dispositivo bajo dicho perfil emita un valor superior al umbral fijado. Fija el transporte en MQTT y recuerda los datos de credenciales para los nuevos perfiles.","title":"Configuraci\u00f3n del perfil de dispositivo"},{"location":"RPI-II/P6/#apis-para-provisonamiento","text":"En esta pr\u00e1ctica, utilizaremos MQTT como API para forzar un proceso de provisionamiento autom\u00e1tico desde el dispositivo. Existen alternativas utilizando HTTP y CoAP, que puedes consultar en la documentaci\u00f3n de ThingsBoard. La API MQTT es sencilla. En esta pr\u00e1ctica usaremos credenciales generadas por el servidor ThingsBoard, pero puedes encontrar f\u00e1cilmente la correspondiente API para credenciales generadas por el dispositivo en la documentaci\u00f3n de la plataforma. Mediante MQTT, el firmware de dispositivo puede solicitar un proceso de provisionamiento de forma sencilla. Sin embargo, veremos un ejemplo Python que nos servir\u00e1 de inspiraci\u00f3n para la tarea entregable, que se basar\u00e1 en un proceso equivalente utilizando ESP-IDF. Si no lo hiciste en la anterior pr\u00e1ctica, instala paho en un entorno virtual: python -m venv .venv source .venv/bin/activate pip install paho-mqtt Observa el siguiente c\u00f3digo; ejec\u00fatalo desde cualquier m\u00e1quina con una instalaci\u00f3n de paho-mqtt python3 test.py : from paho.mqtt.client import Client from json import dumps, loads RESULT_CODES = { 1: \"incorrect protocol version\", 2: \"invalid client identifier\", 3: \"server unavailable\", 4: \"bad username or password\", 5: \"not authorised\", } def collect_required_data(): config = {} print(\"\\n\\n\", \"=\"*80, sep=\"\") print(\" \"*10, \"\\033[1m\\033[94mThingsBoard device provisioning with basic authorization example script.\\033[0m\", sep=\"\") print(\"=\"*80, \"\\n\\n\", sep=\"\") host = input(\"Please write your ThingsBoard \\033[93mhost\\033[0m or leave it blank to use default (thingsboard.cloud): \") config[\"host\"] = host if host else \"demo.thingsboard.io\" port = input(\"Please write your ThingsBoard \\033[93mport\\033[0m or leave it blank to use default (1883): \") config[\"port\"] = int(port) if port else 1883 config[\"provision_device_key\"] = input(\"Please write \\033[93mprovision device key\\033[0m: \") config[\"provision_device_secret\"] = input(\"Please write \\033[93mprovision device secret\\033[0m: \") device_name = input(\"Please write \\033[93mdevice name\\033[0m or leave it blank to generate: \") if device_name: config[\"device_name\"] = device_name print(\"\\n\", \"=\"*80, \"\\n\", sep=\"\") return config class ProvisionClient(Client): PROVISION_REQUEST_TOPIC = \"/provision/request\" PROVISION_RESPONSE_TOPIC = \"/provision/response\" def __init__(self, host, port, provision_request): super().__init__() self._host = host self._port = port self._username = \"provision\" self.on_connect = self.__on_connect self.on_message = self.__on_message self.__provision_request = provision_request def __on_connect(self, client, userdata, flags, rc): # Callback for connect if rc == 0: print(\"[Provisioning client] Connected to ThingsBoard \") client.subscribe(self.PROVISION_RESPONSE_TOPIC) # Subscribe to provisioning response topic provision_request = dumps(self.__provision_request) print(\"[Provisioning client] Sending provisioning request %s\" % provision_request) client.publish(self.PROVISION_REQUEST_TOPIC, provision_request) # Publishing provisioning request topic else: print(\"[Provisioning client] Cannot connect to ThingsBoard!, result: %s\" % RESULT_CODES[rc]) def __on_message(self, client, userdata, msg): decoded_payload = msg.payload.decode(\"UTF-8\") print(\"[Provisioning client] Received data from ThingsBoard: %s\" % decoded_payload) decoded_message = loads(decoded_payload) provision_device_status = decoded_message.get(\"status\") if provision_device_status == \"SUCCESS\": self.__save_credentials(decoded_message[\"credentialsValue\"]) else: print(\"[Provisioning client] Provisioning was unsuccessful with status %s and message: %s\" % (provision_device_status, decoded_message[\"errorMsg\"])) self.disconnect() def provision(self): print(\"[Provisioning client] Connecting to ThingsBoard (provisioning client)\") self.__clean_credentials() self.connect(self._host, self._port, 60) self.loop_forever() def get_new_client(self): client_credentials = self.__get_credentials() new_client = None if client_credentials: new_client = Client() new_client.username_pw_set(client_credentials) print(\"[Provisioning client] Read credentials from file.\") else: print(\"[Provisioning client] Cannot read credentials from file!\") return new_client @staticmethod def __get_credentials(): new_credentials = None try: with open(\"credentials\", \"r\") as credentials_file: new_credentials = credentials_file.read() except Exception as e: print(e) return new_credentials @staticmethod def __save_credentials(credentials): with open(\"credentials\", \"w\") as credentials_file: credentials_file.write(credentials) @staticmethod def __clean_credentials(): open(\"credentials\", \"w\").close() def on_tb_connected(client, userdata, flags, rc): # Callback for connect with received credentials if rc == 0: print(\"[ThingsBoard client] Connected to ThingsBoard with credentials: %s\" % client._username.decode()) else: print(\"[ThingsBoard client] Cannot connect to ThingsBoard!, result: %s\" % RESULT_CODES[rc]) if __name__ == '__main__': config = collect_required_data() THINGSBOARD_HOST = config[\"host\"] # ThingsBoard instance host THINGSBOARD_PORT = config[\"port\"] # ThingsBoard instance MQTT port PROVISION_REQUEST = {\"provisionDeviceKey\": config[\"provision_device_key\"], # Provision device key, replace this value with your value from device profile. \"provisionDeviceSecret\": config[\"provision_device_secret\"], # Provision device secret, replace this value with your value from device profile. } if config.get(\"device_name\") is not None: PROVISION_REQUEST[\"deviceName\"] = config[\"device_name\"] provision_client = ProvisionClient(THINGSBOARD_HOST, THINGSBOARD_PORT, PROVISION_REQUEST) provision_client.provision() # Request provisioned data tb_client = provision_client.get_new_client() # Getting client with provisioned data if tb_client: tb_client.on_connect = on_tb_connected # Setting callback for connect tb_client.connect(THINGSBOARD_HOST, THINGSBOARD_PORT, 60) tb_client.loop_forever() # Starting infinity loop else: print(\"Client was not created!\") Tarea Contesta a las siguientes cuestiones: - \u00bfQu\u00e9 nombre de usuario es necesario usar para la autenticaci\u00f3n en el broker MQTT? - \u00bfQu\u00e9 topics se utilizan para publicar la informaci\u00f3n de petici\u00f3n de provisionamiento y recibir la respuesta correspondiente? Tarea entregable Crea un firmware con ESP-IDF que proceda de forma similar al anterior ejemplo, de modo que provisione autom\u00e1ticamente (con nombre generado por el servidor) a un dispositivo ESP32 en ThingsBoard.","title":"APIs para provisonamiento"},{"location":"RPI-II/P6/#gestion-de-telemetria-y-visualizacion","text":"ThingsBoard proporciona un conjunto de caracter\u00edsticas que permite trabajar con datos en forma de series temporales, permitiendo: Recolectar datos de dispositivos usando distintos protocolos e integracioens . Almacenar series temporales en forma de base de datos SQL (PostgreSQL) o NoSQL (Cassandra o Timescale). Consultar los \u00faltimos valores de telemetr\u00eda obtenidos o todos los datos en rango de tiempo determinado. Suscribirse a actualizaciones de datos usando Websockets para visualizaci\u00f3n en tiempo real y anal\u00edtica. Visualizar las series temporales usando dashboards configurables . Filtrar y analizar datos usando cadenas de reglas . Generar alarmas basadas en datos recolectados. Reenviar datos a servicios externos usando reglas (por ejemplo, a Kafka o RabbitMQ).","title":"Gesti\u00f3n de telemetr\u00eda y visualizaci\u00f3n"},{"location":"RPI-II/P6/#puntos-de-datos","text":"ThingsBoard trata internamente los datos de series temporales como pares clave-valor con marca de tiempo. Llamamos punto de datos a un \u00fanico par clave-valor con marca de tiempo. La flexibilidad y simplicidad del formato clave-valor permite una integraci\u00f3n f\u00e1cil y sin problemas con casi cualquier dispositivo IoT del mercado. La clave siempre es una cadena de texto y, b\u00e1sicamente, es el nombre de la clave del punto de datos, mientras que el valor puede ser una cadena, un valor booleano, un doble, un entero o un JSON. Los ejemplos a continuaci\u00f3n usan el formato de datos interno. El propio dispositivo puede cargar datos utilizando varios protocolos y formatos de datos. Consulta la API de carga de datos para m\u00e1s informaci\u00f3n. El siguiente JSON contiene 5 puntos de datos: temperatura (double), humedad (integer), hvacEnabled (boolean), hvacState (string) y configuraci\u00f3n (JSON): { \"temperature\": 42.2, \"humidity\": 70, \"hvacEnabled\": true, \"hvacState\": \"IDLE\", \"configuration\": { \"someNumber\": 42, \"someArray\": [1, 2, 3], \"someNestedObject\": {\"key\": \"value\"} } } Observa que el JSON listado arriba no contiene informaci\u00f3n de marca de tiempo. En tal caso, ThingsBoard utiliza la marca de tiempo actual del servidor. Sin embargo, puedes incluir informaci\u00f3n de marca de tiempo en el mensaje. Consulta el ejemplo a continuaci\u00f3n: { \"ts\": 1527863043000, \"values\": { \"temperature\": 42.2, \"humidity\": 70 } }","title":"Puntos de datos"},{"location":"RPI-II/P6/#api-mqtt","text":"Para publicar datos de telemetr\u00eda al servidor ThingsBoard desde cualquier dispositivo, es suficiente con publicar un mensaje MQTT bajo el siguiente topic: v1/devices/me/telemetry` El formato de datos m\u00e1s simple soportado es: {\"key1\":\"value1\", \"key2\":\"value2\"} o [{\"key1\":\"value1\"}, {\"key2\":\"value2\"}] (en este caso, la marca de tiempo ser\u00e1 asignada por el servidor). Si se desea que el cliente fije la marca de tiempo, es posible usar el formato: {\"ts\":1451649600512, \"values\":{\"key1\":\"value1\", \"key2\":\"value2\"}} Donde 1451649600512 es una marca de tiempo Unix con precisi\u00f3n de milisegundos. Usando las herramientas de la suite mosquitto , podr\u00edamos enviar un dato como: mosquitto_pub -d -q 1 -h \"demo.thingsboard.io\" -t \"v1/devices/me/telemetry\" -u \"$ACCESS_TOKEN\" -m \"{\"temperature\":42}\" Para enviar un objeto JSON sin datos de marca de tiempo: mosquitto_pub -d -q 1 -h \"demo.thingsboard.io\" -t \"v1/devices/me/telemetry\" -u \"$ACCESS_TOKEN\" -f \"telemetry-data-as-object.json\" Siendo el contenido del fichero JSON: { \"stringKey\": \"value1\", \"booleanKey\": true, \"doubleKey\": 42.0, \"longKey\": 73, \"jsonKey\": { \"someNumber\": 42, \"someArray\": [1,2,3], \"someNestedObject\": {\"key\": \"value\"} } } Para publicar, por ejemplo, un objeto con marca de tiempo, usando datos m\u00e1s complejos, podr\u00edamos construir el siguiente JSON: { \"ts\": 1451649600512, \"values\": { \"stringKey\": \"value1\", \"booleanKey\": true, \"doubleKey\": 42.0, \"longKey\": 73, \"jsonKey\": { \"someNumber\": 42, \"someArray\": [1, 2, 3], \"someNestedObject\": { \"key\": \"value\" } } } } Tarea entregable Modifica el anterior firmware para que, desde una tarea y peri\u00f3dicamente, se env\u00ede a Thingsboard datos de telemetr\u00eda. Estos datos pueden tener un valor aleatorio, pero ser\u00eda muy conveniente (aunque no evaluable para la pr\u00e1ctica) que se tomasen desde sensores reales. El formato del mensaje es libre, pero intenta obtener uno que aune realismo y cierta complejidad en el uso de tipos de datos.","title":"API MQTT"},{"location":"RPI-II/P6/#gestion-de-atributos","text":"ThingsBoard proporciona la capacidad de asignar atributos personalizados a las entidades (por ejemplo, a los dispositivos) y gestionar estos atributos. Estos atributos se almacenan en la base de datos y pueden ser utilizados para la visualizaci\u00f3n y el procesamiento de datos. Los atributos se tratan como pares clave-valor. La flexibilidad y simplicidad del formato clave-valor permiten una integraci\u00f3n f\u00e1cil y sin problemas con casi cualquier dispositivo IoT del mercado. La clave siempre es una cadena de texto y, b\u00e1sicamente, es el nombre del atributo, mientras que el valor del atributo puede ser una cadena, un valor booleano, un doble, un entero o un JSON. Por ejemplo: { \"firmwareVersion\":\"v2.3.1\", \"booleanParameter\":true, \"doubleParameter\":42.0, \"longParameter\":73, \"configuration\": { \"someNumber\": 42, \"someArray\": [1,2,3], \"someNestedObject\": {\"key\": \"value\"} } } El desarrollador es libre para seleccionar cualquier nombre de atributo.","title":"Gesti\u00f3n de atributos"},{"location":"RPI-II/P6/#tipos-de-atributos","text":"","title":"Tipos de atributos"},{"location":"RPI-II/P6/#atributos-de-servidor","text":"Este tipo de atributo es compatible con casi cualquier entidad de la plataforma, incluyendo dispositivos, bienes, u otras entidades. Los atributos del lado del servidor son aquellos que pueden ser configurados a trav\u00e9s de la interfaz de administraci\u00f3n o la API REST. El firmware del dispositivo no puede acceder al atributo del lado del servidor. Supongamos que deseas construir una soluci\u00f3n de monitorizaci\u00f3n de edificios y revisemos algunos ejemplos: La latitud, longitud y direcci\u00f3n son buenos ejemplos de atributos del lado del servidor que puedes asignar a activos que representen edificios u otros bienes inmuebles. Puedes utilizar estos atributos en el widget de mapa en tu panel para visualizar la ubicaci\u00f3n de los edificios. El atributo floorPlanImage puede contener una URL de la imagen. Puedes usar este atributo para visualizar el plano de planta en el widget de mapa de imagen. Los atributos maxTemperatureThreshold y temperatureAlarmEnabled pueden ser utilizados para configurar y habilitar/deshabilitar alarmas para un dispositivo o activo en particular. Tarea Ve a Dispositivos . Haz clic en la fila del dispositivo en particular para abrir los detalles del dispositivo. Selecciona la pesta\u00f1a Atributos . Elige el alcance de Atributos del servidor . Haz clic en el icono \"+\". Introduce el nombre del nuevo atributo. Selecciona el tipo de valor del atributo e introduce el valor del atributo. Ordena usando Hora de la \u00faltima actualizaci\u00f3n para ubicar r\u00e1pidamente el atributo reci\u00e9n creado. En la documentaci\u00f3n de ThingsBoard encontrar\u00e1s la API para gestionar este tipo de atributos program\u00e1ticamente.","title":"Atributos de servidor"},{"location":"RPI-II/P6/#atributos-compartidos","text":"Este tipo de atributos est\u00e1 disponible solo para Dispositivos. Es similar a los atributos del lado del servidor, pero tiene una diferencia importante. El firmware/aplicaci\u00f3n del dispositivo puede solicitar el valor de los atributos compartidos o suscribirse a las actualizaciones de estos atributos. Los dispositivos que se comunican mediante MQTT u otros protocolos de comunicaci\u00f3n bidireccional pueden suscribirse a las actualizaciones de atributos y recibir notificaciones en tiempo real. Los dispositivos que se comunican a trav\u00e9s de HTTP u otros protocolos de comunicaci\u00f3n de solicitud-respuesta pueden solicitar peri\u00f3dicamente el valor de los atributos compartidos. El caso de uso m\u00e1s com\u00fan de los atributos compartidos es almacenar configuraciones de dispositivos. Supongamos la misma soluci\u00f3n de monitoreo de edificios y revisemos algunos ejemplos: El atributo targetFirmwareVersion puede ser utilizado para almacenar la versi\u00f3n de firmware para un dispositivo en particular. El atributo maxTemperature puede ser utilizado para activar autom\u00e1ticamente el sistema HVAC si hace demasiado calor en la habitaci\u00f3n. El usuario puede cambiar el atributo a trav\u00e9s de la interfaz de usuario. Un script u otra aplicaci\u00f3n del lado del servidor puede cambiar el valor del atributo a trav\u00e9s de la API REST. Tarea Ve a Dispositivos . Haz clic en la fila del dispositivo en particular para abrir los detalles del dispositivo. Selecciona la pesta\u00f1a Atributos . Elige el alcance de Atributos compartidos . Haz clic en el icono \"+\". Introduce el nombre del nuevo atributo. Selecciona el tipo de valor del atributo e introduce el valor del atributo. Observa el nuevo atributo. La funci\u00f3n de bulk provisioning te permite crear r\u00e1pidamente m\u00faltiples dispositivos y activos y sus atributos desde un archivo CSV.","title":"Atributos compartidos"},{"location":"RPI-II/P6/#atributos-de-cliente","text":"Este tipo de atributos est\u00e1 disponible solo para Dispositivos. Se utiliza para reportar varios datos semiest\u00e1ticos desde el Dispositivo (Cliente) a ThingsBoard (Servidor). Es similar a los atributos compartidos, pero tiene una diferencia importante. El firmware/aplicaci\u00f3n del dispositivo puede enviar el valor de los atributos desde el dispositivo a la plataforma. El caso de uso m\u00e1s com\u00fan de los atributos del cliente es reportar el estado del dispositivo. Supongamos la misma soluci\u00f3n de monitoreo de edificios y revisemos algunos ejemplos: El atributo currentFirmwareVersion puede ser utilizado para reportar la versi\u00f3n del firmware/aplicaci\u00f3n instalada para el dispositivo a la plataforma. El atributo currentConfiguration puede ser utilizado para reportar la configuraci\u00f3n actual del firmware/aplicaci\u00f3n a la plataforma. El atributo currentState puede ser utilizado para persistir y restaurar el estado actual del firmware/aplicaci\u00f3n a trav\u00e9s de la red, si el dispositivo no tiene almacenamiento persistente. Los usuarios y las aplicaciones del lado del servidor pueden explorar los atributos del lado del cliente a trav\u00e9s de la interfaz de usuario/API REST, pero no pueden cambiarlos. B\u00e1sicamente, el valor del atributo del lado del cliente es de solo lectura para la UI/API REST.","title":"Atributos de cliente"},{"location":"RPI-II/P6/#api-para-gestion-de-atributos","text":"La API de atributos de ThingsBoard permite a los dispositivos: Subir atributos del dispositivo del lado del cliente al servidor. Solicitar atributos del dispositivo del lado del cliente y compartidos desde el servidor. Suscribirse a atributos compartidos del dispositivo desde el servidor.","title":"API para gesti\u00f3n de atributos"},{"location":"RPI-II/P6/#publicar-actualizacion-de-atributos-en-el-servidor","text":"Para publicar atributos del dispositivo del lado del cliente en el nodo del servidor de ThingsBoard, env\u00eda un mensaje PUBLISH al siguiente topic: v1/devices/me/attributes A continuaci\u00f3n, se muestran ejemplos de c\u00f3mo publicar atributos de dispositivo del lado del cliente. No olvides reemplazar demo.thingsboard.io con tu host y $ACCESS_TOKEN con el token de acceso de tu dispositivo. En este ejemplo, el nombre de host hace referencia al servidor de demostraci\u00f3n en vivo. Ejemplo 1. Publicar actualizaci\u00f3n de atributos del lado del cliente. Datos de telemetr\u00eda: {\"attribute1\": \"value1\", \"attribute2\": true} Ejecuta el comando: mosquitto_pub -d -h \"demo.thingsboard.io\" -t \"v1/devices/me/attributes\" -u \"$ACCESS_TOKEN\" -m \"{\"attribute1\": \"value1\", \"attribute2\": true}\" Ejemplo 2. Publicar actualizaci\u00f3n de atributos del lado del cliente utilizando datos del archivo new-attributes-values.json . Contenido del archivo new-attributes-values.json: { \"attribute1\": \"value1\", \"attribute2\": true, \"attribute3\": 42.0, \"attribute4\": 73, \"attribute5\": { \"someNumber\": 42, \"someArray\": [1, 2, 3], \"someNestedObject\": {\"key\": \"value\"} } }","title":"Publicar actualizaci\u00f3n de atributos en el servidor"},{"location":"RPI-II/P6/#solicitar-valores-de-atributos-del-servidor","text":"Para solicitar atributos del dispositivo del lado del cliente o compartidos en el nodo del servidor de ThingsBoard, env\u00eda un mensaje PUBLISH al siguiente topic: v1/devices/me/attributes/request/$request_id donde $request_id es tu identificador de solicitud entero. Antes de enviar el mensaje PUBLISH con la solicitud, el cliente necesita suscribirse a: v1/devices/me/attributes/response/+ El siguiente ejemplo est\u00e1 escrito en JavaScript. No hay ejemplos en l\u00ednea de comandos puros disponibles porque la suscripci\u00f3n y publicaci\u00f3n deben ocurrir en la misma sesi\u00f3n de MQTT. Guarda el archivo mqtt-js-attributes-request.js en tu PC. No olvides reemplazar el nombre de host demo.thingsboard.io con tu host. var mqtt = require('mqtt') var client = mqtt.connect('mqtt://demo.thingsboard.io',{ username: process.env.TOKEN }) client.on('connect', function () { console.log('connected') client.subscribe('v1/devices/me/attributes/response/+') client.publish('v1/devices/me/attributes/request/1', '{\"clientKeys\":\"attribute1,attribute2\", \"sharedKeys\":\"shared1,shared2\"}') }) client.on('message', function (topic, message) { console.log('response.topic: ' + topic) console.log('response.body: ' + message.toString()) client.end() }) Puedes ejecutar el comando desde cualquier m\u00e1quina con node instalado: export TOKEN=$ACCESS_TOKEN node mqtt-js-attributes-request.js","title":"Solicitar valores de atributos del servidor"},{"location":"RPI-II/P6/#suscribirse-a-las-actualizaciones-de-atributos-desde-el-servidor","text":"Para suscribirse a los cambios de atributos compartidos del dispositivo, env\u00eda un mensaje SUBSCRIBE al siguiente topic: v1/devices/me/attributes Cuando un atributo compartido es modificado por uno de los componentes del servidor (como la API REST o la Cadena de Reglas), el cliente recibir\u00e1 la siguiente actualizaci\u00f3n: {\"key1\":\"value1\"} En el siguiente ejemplo, no olvides reemplazar demo.thingsboard.io con tu host y $ACCESS_TOKEN con el token de acceso de tu dispositivo. Ejecuta el comando: mosquitto_sub -d -h \"demo.thingsboard.io\" -t \"v1/devices/me/attributes\" -u \"$ACCESS_TOKEN\" Tarea entregable En un escenario de monitorizaci\u00f3n de edificios en la UCM, aprovecha el concepto de atributo para reemplazar la jerarqu\u00eda de topics que dise\u00f1aste en una pr\u00e1ctica anterior. Busca en tu dise\u00f1o utilizar atributos de los tres tipos mencionados anteriormente, descr\u00edbelos en la memoria e interact\u00faa con ellos desde el firmware y usando APIs externas (para ello, deber\u00e1s consultar la documentaci\u00f3n de Thingsboard). Tarea entregable Mediante el uso de atributos, gestiona la activaci\u00f3n/desactivaci\u00f3n del env\u00edo de cada sensor, as\u00ed como el intervalo entre env\u00edos para un dispositivo. Deber\u00edas poder gestionar dichos valores desde la interfaz de Thingsboard. Tarea entregable Investiga en la documentaci\u00f3n de Thingsboard sobre el desarrollo de dashboard y la gesti\u00f3n de alarmas. Desarrolla un dashboard de visualizaci\u00f3n para tus dispositivos, incluyendo informaci\u00f3n sobre alarmas recibidas.","title":"Suscribirse a las actualizaciones de atributos desde el servidor"},{"location":"RPI-II/P6-II_old/","text":"Pr\u00e1ctica 2. El protocolo MQTT (II). Despliegue de clientes en el ESP32 Objetivos Familiarizarse con el componente MQTT en ESP-IDF. Desplegar un cliente completo MQTT en el ESP32, incluyendo rutinas de publicaci\u00f3n y suscripci\u00f3n. Implementar QoS y LWT en el ESP32. El componente MQTT en ESP-IDF El componente ESP-MQTT es una implementaci\u00f3n del protocolo MQTT en su parte cliente, que permite la implementaci\u00f3n completa de clientes MQTT en el ESP32, incluyendo rutinas de publicaci\u00f3n y suscripci\u00f3n a brokers existentes. El componente soporte MQTT sobre TCP por defecto, as\u00ed como funcionalidades avanzadas como SSL/TLS o MQTT sobre Websockets. Adem\u00e1s, permite el despliegue de m\u00faltiples instancias de cliente MQTT sobre la misma placa; el componente implementa tambi\u00e9n par\u00e1metros avanzados soportados por el protocolo MQTT, como autenticaci\u00f3n (mediante nombre de usuario y contrase\u00f1a), mensajes last will y tres niveles de calidad de servicio (QoS). Eventos Como otros componentes, la interacci\u00f3n entre el cliente MQTT y la aplicaci\u00f3n se basa en la recepci\u00f3n de eventos, entre los que destacan: MQTT_EVENT_BEFORE_CONNECT : El cliente se ha inicializado y va a comenzar el proceso de conexi\u00f3n con el broker . MQTT_EVENT_CONNECTED : El cliente ha establecido de forma exitosa una conexi\u00f3n con el broker y est\u00e1 listo para enviar y recibir datos. MQTT_EVENT_DISCONNECTED : El cliente ha abortado la conexi\u00f3n. MQTT_EVENT_SUBSCRIBED : El broker ha confirmado la petici\u00f3n de suscripci\u00f3n del cliente. Los datos contendr\u00e1n el ID del mensaje de suscripci\u00f3n. MQTT_EVENT_UNSUBSCRIBED : El broker confirma la petici\u00f3n de desuscripci\u00f3n del cliente. Los datos contendr\u00e1n el ID del mensaje de desuscripci\u00f3n . MQTT_EVENT_PUBLISHED : El broker ha acusado la recepci\u00f3n de un mensaje previamente publicado por el cliente. Este evento s\u00f3lo se producir\u00e1 cuando QoS sea 1 o 2, ya que el nivel 0 de QoS no utiliza acuses de recibo. Los datos asociados al evento contendr\u00e1n el ID del mensaje publicado. MQTT_EVENT_DATA : El cliente ha recibido un mensaje publicado en el broker . Los datos asociados al evento contienen el ID del mensaje, nombre del topic , datos recibidos y su longitud. API esp_mqtt_client_handle_t esp_mqtt_client_init(const esp_mqtt_client_config_t *config) Rutina de inicializaci\u00f3n del cliente MQTT. Devuelve un manejador de la conexi\u00f3n, o NULL en caso de error. El par\u00e1metro config es una estructura con los par\u00e1metros que regir\u00e1n la conexi\u00f3n, entre los que destacan (v\u00e9ase la documentaci\u00f3n del componente para par\u00e1metros adicionales): esp_event_loop_handle_t event_loop_handle : manejador para eventos MQTT. const char *uri : URI del broker MQTT. uint32_t port : puerto del broker MQTT. const char *username : nombre de usuario, en caso de estar soportado por el broker . const char *password : contrase\u00f1a, en caso de estar soportada por el broker . const char *lwt_topic : topic del mensaje LWT ( Last Will and Testament ). const char *lwt_msg : contenido del mensaje LWT. int lwt_qos : QoS del mensaje LWT. int lwt_retain : flag retain para el mensaje LWT. int lwt_msg_len : longitud del mensaje LWT. int keepalive : valor del temporizador de keepalive (por defecto 120 segundos). esp_err_t esp_mqtt_client_start(esp_mqtt_client_handle_t client) Rutina de arranque del cliente MQTT. Su \u00fanico par\u00e1metro es el manejador devuelto por la anterior rutina. int esp_mqtt_client_subscribe(esp_mqtt_client_handle_t client, const char *topic, int qos) Realiza la suscripci\u00f3n del cliente a un topic con el QoS determinado a trav\u00e9s de su tercer par\u00e1metro. El cliente debe estar conectado al broker para enviar el mensaje de suscripci\u00f3n. int esp_mqtt_client_unsubscribe(esp_mqtt_client_handle_t client, const char *topic) Desuscribe al cliente de un determinado topic. El ciente debe estar conectado al broker para poder enviar el mensaje correspondiente. int esp_mqtt_client_publish(esp_mqtt_client_handle_t client, const char *topic, const char *data, int len, int qos, int retain) El cliente publica un mensaje en el broker . El cliente no tiene que estar conectado al broker para enviar el mensaje de publicaci\u00f3n. En dicho caso, si qos=0 , los mensajes se descartar\u00e1n, y si qos>=1 , los mensajes se encolar\u00e1n a la espera de ser enviados. Devuelve el identificador del mensaje publicado (si qos=0 , el valor de retorno siempre ser\u00e1 0), o -1 en caso de error. Par\u00e1metros de inter\u00e9s: client : manejador del cliente MQTT. topic : topic (en forma de cadena) bajo el cual se publicar\u00e1 el mensaje. data : contenido del mensaje a publicar (es posible publicar un mensaje sin contenido, en cuyo caso se proporcionar\u00e1 un valor NULL en este par\u00e1metro). len : longitud de los datos a enviar. Si se proporciona el valor 0 , se calcula su longitud a partir de la cadena data . qos : nivel de QoS deseado. retain : flag Retain . Tarea 2.8 (tambi\u00e9n para evaluaci\u00f3n por proyecto) Analiza el ejemplo examples/protocols/mqtt/tcp , y configuralo para que utilice como broker el que desplegaste en la m\u00e1quina virtual (aseg\u00farate de que tanto m\u00e1quina virtual como ESP32 pertenecen a la misma red). Realiza procesos de publicaci\u00f3n y suscripci\u00f3n en la m\u00e1quina virtual que permitan visualizar los mensajes publicados por el ESP32 en tu terminal Linux, y los mensajes publicados desde el terminal Linux en la salida de monitorizaci\u00f3n del ESP32. Modifica el ejemplo y analiza el tr\u00e1fico generado (a trav\u00e9s de Wireshark) para los siguientes casos: Publicaci\u00f3n de mensajes con niveles de QoS 0, 1 y 2. Activaci\u00f3n o desactivaci\u00f3n del flag retain en la publicaci\u00f3n desde el ESP32. Configuraci\u00f3n de un mensaje LWT con el topic /disconnected . Para ello, reduce el valor de keepalive a 10 segundos, para que la detecci\u00f3n de desconexi\u00f3n sea m\u00e1s r\u00e1pida. Deber\u00e1s observar el env\u00edo del mensaje con dicho topic transcurrido dicho tiempo desde una desconexi\u00f3n forzada del ESP32 si est\u00e1s suscrito al mismo desde tu terminal Linux. Tarea 2.9 Modifica el ejemplo proporcionado para que se integre en tu entorno de monitorizaci\u00f3n de un edificio. As\u00ed, el firmware proceder\u00e1 creando una tarea que, peri\u00f3dicamente (cada interval segundos), publique un valor aleatorio para los cuatro par\u00e1metros monitorizados. Adem\u00e1s, deber\u00e1s dise\u00f1a un sistema basado en MQTT mediante el cual puedas controlar, externamente, el comportamiento del sensor, atendiendo a los siguientes criterios: El tiempo ( interval ) mediante que transcurrir\u00e1 entre publicaciones ser\u00e1 configurable a trav\u00e9s de un proceso de publicaci\u00f3n desde tu terminal Linux y suscripci\u00f3n del ESP32 a un topic determinado. La sensorizaci\u00f3n (y publicaci\u00f3n de datos) podr\u00e1 activarse o desactivarse bajo demanda a trav\u00e9s de la publicaci\u00f3n desde tu terminal Linux y suscripci\u00f3n del ESP32 a un topic determinado. Por ejemplo, imagina que tu sensor publica mensajes de sensorizaci\u00f3n en el topic /EDIFICIO_3/P_4/N/12/(TEMP|HUM|LUX|VIBR) . Para controlar el intervalo de publicaci\u00f3n de datos desde dicho ESP32 y fijarlo a 1 segundo, podr\u00edamos publicar un mensaje utilizando la orden: mosquitto_pub -t /EDIFICIO_3/P_4/N/12/interval -m \"1000\" -h IP_BROKER Para desactivar el sensor, podr\u00edamos utilizar: mosquitto_pub -t /EDIFICIO_3/P_4/N/12/disable -m \"\" -h IP_BROKER Para activar el sensor, podr\u00edamos utilizar: mosquitto_pub -t /EDIFICIO_3/P_4/N/12/enable -m \"\" -h IP_BROKER Opcionalmente, puedes ampliar tu soluci\u00f3n para que cada sensor se active o desactive individualmente bajo demanda. En este caso, elige y documenta el topic utilizado.","title":"Pr\u00e1ctica 2. El protocolo MQTT (II). Despliegue de clientes en el ESP32"},{"location":"RPI-II/P6-II_old/#practica-2-el-protocolo-mqtt-ii-despliegue-de-clientes-en-el-esp32","text":"","title":"Pr\u00e1ctica 2. El protocolo MQTT (II). Despliegue de clientes en el ESP32"},{"location":"RPI-II/P6-II_old/#objetivos","text":"Familiarizarse con el componente MQTT en ESP-IDF. Desplegar un cliente completo MQTT en el ESP32, incluyendo rutinas de publicaci\u00f3n y suscripci\u00f3n. Implementar QoS y LWT en el ESP32.","title":"Objetivos"},{"location":"RPI-II/P6-II_old/#el-componente-mqtt-en-esp-idf","text":"El componente ESP-MQTT es una implementaci\u00f3n del protocolo MQTT en su parte cliente, que permite la implementaci\u00f3n completa de clientes MQTT en el ESP32, incluyendo rutinas de publicaci\u00f3n y suscripci\u00f3n a brokers existentes. El componente soporte MQTT sobre TCP por defecto, as\u00ed como funcionalidades avanzadas como SSL/TLS o MQTT sobre Websockets. Adem\u00e1s, permite el despliegue de m\u00faltiples instancias de cliente MQTT sobre la misma placa; el componente implementa tambi\u00e9n par\u00e1metros avanzados soportados por el protocolo MQTT, como autenticaci\u00f3n (mediante nombre de usuario y contrase\u00f1a), mensajes last will y tres niveles de calidad de servicio (QoS).","title":"El componente MQTT en ESP-IDF"},{"location":"RPI-II/P6-II_old/#eventos","text":"Como otros componentes, la interacci\u00f3n entre el cliente MQTT y la aplicaci\u00f3n se basa en la recepci\u00f3n de eventos, entre los que destacan: MQTT_EVENT_BEFORE_CONNECT : El cliente se ha inicializado y va a comenzar el proceso de conexi\u00f3n con el broker . MQTT_EVENT_CONNECTED : El cliente ha establecido de forma exitosa una conexi\u00f3n con el broker y est\u00e1 listo para enviar y recibir datos. MQTT_EVENT_DISCONNECTED : El cliente ha abortado la conexi\u00f3n. MQTT_EVENT_SUBSCRIBED : El broker ha confirmado la petici\u00f3n de suscripci\u00f3n del cliente. Los datos contendr\u00e1n el ID del mensaje de suscripci\u00f3n. MQTT_EVENT_UNSUBSCRIBED : El broker confirma la petici\u00f3n de desuscripci\u00f3n del cliente. Los datos contendr\u00e1n el ID del mensaje de desuscripci\u00f3n . MQTT_EVENT_PUBLISHED : El broker ha acusado la recepci\u00f3n de un mensaje previamente publicado por el cliente. Este evento s\u00f3lo se producir\u00e1 cuando QoS sea 1 o 2, ya que el nivel 0 de QoS no utiliza acuses de recibo. Los datos asociados al evento contendr\u00e1n el ID del mensaje publicado. MQTT_EVENT_DATA : El cliente ha recibido un mensaje publicado en el broker . Los datos asociados al evento contienen el ID del mensaje, nombre del topic , datos recibidos y su longitud.","title":"Eventos"},{"location":"RPI-II/P6-II_old/#api","text":"esp_mqtt_client_handle_t esp_mqtt_client_init(const esp_mqtt_client_config_t *config) Rutina de inicializaci\u00f3n del cliente MQTT. Devuelve un manejador de la conexi\u00f3n, o NULL en caso de error. El par\u00e1metro config es una estructura con los par\u00e1metros que regir\u00e1n la conexi\u00f3n, entre los que destacan (v\u00e9ase la documentaci\u00f3n del componente para par\u00e1metros adicionales): esp_event_loop_handle_t event_loop_handle : manejador para eventos MQTT. const char *uri : URI del broker MQTT. uint32_t port : puerto del broker MQTT. const char *username : nombre de usuario, en caso de estar soportado por el broker . const char *password : contrase\u00f1a, en caso de estar soportada por el broker . const char *lwt_topic : topic del mensaje LWT ( Last Will and Testament ). const char *lwt_msg : contenido del mensaje LWT. int lwt_qos : QoS del mensaje LWT. int lwt_retain : flag retain para el mensaje LWT. int lwt_msg_len : longitud del mensaje LWT. int keepalive : valor del temporizador de keepalive (por defecto 120 segundos). esp_err_t esp_mqtt_client_start(esp_mqtt_client_handle_t client) Rutina de arranque del cliente MQTT. Su \u00fanico par\u00e1metro es el manejador devuelto por la anterior rutina. int esp_mqtt_client_subscribe(esp_mqtt_client_handle_t client, const char *topic, int qos) Realiza la suscripci\u00f3n del cliente a un topic con el QoS determinado a trav\u00e9s de su tercer par\u00e1metro. El cliente debe estar conectado al broker para enviar el mensaje de suscripci\u00f3n. int esp_mqtt_client_unsubscribe(esp_mqtt_client_handle_t client, const char *topic) Desuscribe al cliente de un determinado topic. El ciente debe estar conectado al broker para poder enviar el mensaje correspondiente. int esp_mqtt_client_publish(esp_mqtt_client_handle_t client, const char *topic, const char *data, int len, int qos, int retain) El cliente publica un mensaje en el broker . El cliente no tiene que estar conectado al broker para enviar el mensaje de publicaci\u00f3n. En dicho caso, si qos=0 , los mensajes se descartar\u00e1n, y si qos>=1 , los mensajes se encolar\u00e1n a la espera de ser enviados. Devuelve el identificador del mensaje publicado (si qos=0 , el valor de retorno siempre ser\u00e1 0), o -1 en caso de error. Par\u00e1metros de inter\u00e9s: client : manejador del cliente MQTT. topic : topic (en forma de cadena) bajo el cual se publicar\u00e1 el mensaje. data : contenido del mensaje a publicar (es posible publicar un mensaje sin contenido, en cuyo caso se proporcionar\u00e1 un valor NULL en este par\u00e1metro). len : longitud de los datos a enviar. Si se proporciona el valor 0 , se calcula su longitud a partir de la cadena data . qos : nivel de QoS deseado. retain : flag Retain . Tarea 2.8 (tambi\u00e9n para evaluaci\u00f3n por proyecto) Analiza el ejemplo examples/protocols/mqtt/tcp , y configuralo para que utilice como broker el que desplegaste en la m\u00e1quina virtual (aseg\u00farate de que tanto m\u00e1quina virtual como ESP32 pertenecen a la misma red). Realiza procesos de publicaci\u00f3n y suscripci\u00f3n en la m\u00e1quina virtual que permitan visualizar los mensajes publicados por el ESP32 en tu terminal Linux, y los mensajes publicados desde el terminal Linux en la salida de monitorizaci\u00f3n del ESP32. Modifica el ejemplo y analiza el tr\u00e1fico generado (a trav\u00e9s de Wireshark) para los siguientes casos: Publicaci\u00f3n de mensajes con niveles de QoS 0, 1 y 2. Activaci\u00f3n o desactivaci\u00f3n del flag retain en la publicaci\u00f3n desde el ESP32. Configuraci\u00f3n de un mensaje LWT con el topic /disconnected . Para ello, reduce el valor de keepalive a 10 segundos, para que la detecci\u00f3n de desconexi\u00f3n sea m\u00e1s r\u00e1pida. Deber\u00e1s observar el env\u00edo del mensaje con dicho topic transcurrido dicho tiempo desde una desconexi\u00f3n forzada del ESP32 si est\u00e1s suscrito al mismo desde tu terminal Linux. Tarea 2.9 Modifica el ejemplo proporcionado para que se integre en tu entorno de monitorizaci\u00f3n de un edificio. As\u00ed, el firmware proceder\u00e1 creando una tarea que, peri\u00f3dicamente (cada interval segundos), publique un valor aleatorio para los cuatro par\u00e1metros monitorizados. Adem\u00e1s, deber\u00e1s dise\u00f1a un sistema basado en MQTT mediante el cual puedas controlar, externamente, el comportamiento del sensor, atendiendo a los siguientes criterios: El tiempo ( interval ) mediante que transcurrir\u00e1 entre publicaciones ser\u00e1 configurable a trav\u00e9s de un proceso de publicaci\u00f3n desde tu terminal Linux y suscripci\u00f3n del ESP32 a un topic determinado. La sensorizaci\u00f3n (y publicaci\u00f3n de datos) podr\u00e1 activarse o desactivarse bajo demanda a trav\u00e9s de la publicaci\u00f3n desde tu terminal Linux y suscripci\u00f3n del ESP32 a un topic determinado. Por ejemplo, imagina que tu sensor publica mensajes de sensorizaci\u00f3n en el topic /EDIFICIO_3/P_4/N/12/(TEMP|HUM|LUX|VIBR) . Para controlar el intervalo de publicaci\u00f3n de datos desde dicho ESP32 y fijarlo a 1 segundo, podr\u00edamos publicar un mensaje utilizando la orden: mosquitto_pub -t /EDIFICIO_3/P_4/N/12/interval -m \"1000\" -h IP_BROKER Para desactivar el sensor, podr\u00edamos utilizar: mosquitto_pub -t /EDIFICIO_3/P_4/N/12/disable -m \"\" -h IP_BROKER Para activar el sensor, podr\u00edamos utilizar: mosquitto_pub -t /EDIFICIO_3/P_4/N/12/enable -m \"\" -h IP_BROKER Opcionalmente, puedes ampliar tu soluci\u00f3n para que cada sensor se active o desactive individualmente bajo demanda. En este caso, elige y documenta el topic utilizado.","title":"API"},{"location":"RPI-II/P6_old/","text":"Pr\u00e1ctica 2. El protocolo MQTT (I). Despliegue de clientes y servidores/ brokers . An\u00e1lisis de tr\u00e1fico Objetivos Familiarizarse con el uso de brokers y clientes de suscripci\u00f3n/publicaci\u00f3n utilizando MQTT. Desplegar un sistema basado en MQTT local, incluyendo broker y clientes. Utilizar Eclipse Paho para integrar funcionalidad MQTT en programas Python. Familiarizarse con el uso de wildcards MQTT. Publicaci\u00f3n/suscripci\u00f3n contra un broker en la nube En la primera parte de la pr\u00e1ctica, utilizaremos un servidor/ broker disponible en la nube para su uso libre por parte de los usuarios ( test.mosquitto.org ). Este servidor suele utilizarse con fines de pruebas b\u00e1sicas y depuraci\u00f3n, y hay que ser consciente de que toda la informaci\u00f3n que en \u00e9l se publica puede ser le\u00edda por cualquier suscriptor. Debe tenerse este dato en cuenta a la hora de publicar informaci\u00f3n sensible a trav\u00e9s de MQTT cuando se use el servidor de pruebas. El servidor escucha en los siguientes puertos: 1883 : MQTT, sin encriptaci\u00f3n. 8883 : MQTT, con encriptaci\u00f3n. 8884 : MQTT, con encriptaci\u00f3n, certificado de cliente requerido. 8080 : MQTT sobre WebSockets, sin encriptaci\u00f3n. 8081 : MQTT sobre WebSockets, con encriptaci\u00f3n. Para realizar publicaciones/suscripciones contra el broker utilizaremos la distribuci\u00f3n mosquitto del proyecto Eclipse IoT. Aunque mosquitto es principalmente una implementaci\u00f3n de broker MQTT, nosotros la utilizaremos en este paso a modo de cliente, lo que nos permitir\u00e1 suscribirnos o publicar sobre cualquier topic MQTT. En primer lugar, instala mosquitto : sudo apt-get update sudo apt-get install mosquitto mosquitto-clients mosquitto-dev libmosquitto* Si todo ha ido bien, deber\u00edas disponer de dos binarios listos para ejecuci\u00f3n: mosquitto_sub : permite suscribirse a un determinado topic utilizando un broker . mosquitto_pub : permite publicar un mensaje asociado a un determinado topic utilizando un broker . Tarea 2.1 Observa la ayuda de ambas ordenes, utilizando el argumento --help . Identifica los par\u00e1metros que te permitir\u00e1n especificar el broker destino, el topic a utilizar y, en el caso de la publicaci\u00f3n, el mensaje a enviar. Suscrib\u00e1monos al topic # en el broker , utilizando para ello la orden: mosquitto_sub -h test.mosquitto.org -t \"#\" Tarea 2.2 Pausa la salida en cuanto puedas. \u00bfA qu\u00e9 corresponden los mensajes que est\u00e1s obteniendo? A continuaci\u00f3n, vamos a realizar un proceso de publicaci\u00f3n/suscripcion con un topic conocido (por ejemplo, /MIOT/tunombre/ ). Para publicar un mensaje bajo dicho topic : mosquitto_pub -h test.mosquitto.org -t \"/MIOT/tunombre\" -m \"Hola, soy tunombre\" Tarea 2.3 Suscr\u00edbete al topic /MIOT/tunombre y observa si recibes los resultados tras la publicaci\u00f3n correspondiente. \u00bfC\u00f3mo podr\u00edas suscribirte a todos los mensajes publicados por compa\u00f1eros? Tarea entregable Realiza un an\u00e1lisis del intercambio de mensajes necesario para un proceso de publicaci\u00f3n/suscripci\u00f3n contra el broker de test. Incide en el tipo de protocolo de capa de transporte que utiliza MQTT, mensajes de datos y control, sobrecarga del protocolo de capa de aplicaci\u00f3n, y en general, cualquier aspecto que consideres de inter\u00e9s, incluyendo el uso de opciones relativas a QoS. Despliegue de un broker local usando Eclipse Mosquitto El uso de un servidor remoto presenta ventajas (facilidad de uso), pero una gran cantidad de inconvenientes (seguridad, imposibilidad de configuraci\u00f3n avanzada, ...) En esta secci\u00f3n, configuraremos un broker mosquitto para el despliegue de una infraestructura MQTT local o remota bajo nuestro control. El arranque de un broker (servidor) mosquitto se realiza mediante el propio comando mosquitto : mosquitto [-c config file] [ -d | --daemon ] [-p port number] [-v] Sin embargo, en la mayor\u00eda de distribuciones Linux, el broker arranca por defecto y se ejecuta constantemente en segundo plano. Para comprobar el estado de funcionamiento del broker , basta con ejecutar: sudo service mosquitto status Observar\u00e1s un mensaje que indica que el servicio est\u00e1 activo. Las opciones restart , start o stop te permitir\u00e1n controlar el estado del broker en todo momento. Tarea 2.4 Comprueba que, con el broker arrancado, puedes realizar un proceso de suscripci\u00f3n/publicaci\u00f3n contra el mismo. El broker mosquitto permite monitorizar sus propias estad\u00edsticas e informaci\u00f3n de estado utilizando el protocolo MQTT. As\u00ed, los topics $SYS retornan, bien peri\u00f3dicamente o bien cuando sucede un evento de inter\u00e9s, la informaci\u00f3n de estado del broker . Puedes consultar m\u00e1s detalles en la p\u00e1gina de manual de mosquitto (comando man mosquitto ), en el ep\u00edgrafe BROKER STATUS . Tarea 2.5 Comprueba el estado del broker mientras realizas procesos de suscripci\u00f3n/publicaci\u00f3n reportando bytes recibidos/enviados, n\u00famero de conexiones activas e inactivas, y n\u00famero de mensajes enviados/recibidos por el broker . Wildcards Adem\u00e1s de permitir el uso de topics completos para el proceso de suscripci\u00f3n, los topics pueden incluir wildcards o comodines en su estructura. + es la wildcard utilizada para obtener correspondencias con un \u00fanico nivel de la jerarqu\u00eda. As\u00ed, para un topic a/b/c/d , las siguientes suscripciones corresponder\u00e1n con \u00e9xito: a/b/c/d +/b/c/d a/+/c/d a/+/+/d +/+/+/+ Pero no las siguientes: a/b/c b/+/c/d +/+/+ La segunda wildcard soportada es # , y permite corresponencias con cualquier nivel sucesivo de la jerarqu\u00eda. As\u00ed, para un topic a/b/c/d , las siguientes suscripciones corresponder\u00e1n con \u00e9xito: a/b/c/d # a/# a/b/# a/b/c/# +/b/c/# Tarea 2.6 Experimenta con el uso de wildcards desde m\u00faltiples clientes suscriptores. Resultar\u00e1 de especial inter\u00e9s observar (por ejemplo, con capturas de tr\u00e1fico) el ahorro de mensajes asociado al uso de wildcards que restrinjan qu\u00e9 mensajes son recibidos y por qu\u00e9 clientes. Desarrollo de un clientes locales. Opci\u00f3n 1: Node-RED El despliegue de un cliente MQTT (ya sea suscriptor o publicador) utilizando Node-RED resulta muy sencillo. Por defecto, Node-RED incorpora dos tipos de nodos que nos ser\u00e1n de utilidad para nuestros despliegues: Nodo MQTT-in . Recibe datos desde un broker MQTT, y es por tanto el mecanismo recomendado para suscribirse a un determinado topic . El topic al que se suscribe uno de estos nodos es por defecto fijo, aunque puede ser configurado, en versiones modernas del nodo, como din\u00e1mico (campo Action -> Dynamic subscription ) del men\u00fa de configuraci\u00f3n. Nodo MQTT-out . Env\u00eda datos hacia un broker MQTT, y es por tanto el mecanismo recomendado para publicar un mensaje sobre un determinado topic . El topic bajo el que se publica un determinado dato puede ser fijo (configurado v\u00eda cuadro de di\u00e1logo de configuraci\u00f3n) o variable (configurado como el contenido del campo msg.topic del mensaje recibido por el nodo MQTT-out ). Ambos requerir\u00e1n, desde su men\u00fa de configuraci\u00f3n (accesible v\u00eda doble click en el nodo), de la configuraci\u00f3n previa de un broker MQTT (llamado server en el cuadro de di\u00e1logo de configuraci\u00f3n del nodo). En el caso de una instalaci\u00f3n local, bastar\u00e1 con indicar localhost como localizaci\u00f3n de dicho servidor. Tarea 2.7 Experimenta con el uso de los nodos MQTT-in y MQTT-out enviando y recibiendo mensajes desde un broker local o remoto. Espec\u00edficamente, aseg\u00farate de saber c\u00f3mo personalizar tanto el topic como el mensaje a publicar en un nodo de publicaci\u00f3n, o el topic al que se suscribir\u00e1 un nodo de suscripci\u00f3n. Desarrollo de un clientes locales. Opci\u00f3n 2: Eclipse Paho Los clientes mosquitto_pub y mosquitto_sub son b\u00e1sicamente herramientas de desarrollo y pruebas, pero resulta interesante conocer bibliotecas que permitan la integraci\u00f3n de MQTT en programas existentes. Una de ellas es Eclipse Paho . Paho es una infraestructura desarrollada en el proyecto Eclipse IoT para dar soporte a implementaciones de protocolos de mensajer\u00eda M2M e IoT, aunque, en este momento, su uso principal se centra exclusivamente en MQTT. En nuestro caso, utilizaremos la versi\u00f3n Python de la biblioteca, instalable v\u00eda: pip install paho-mqtt Dispones de la documentaci\u00f3n del m\u00f3dulo a trav\u00e9s de este enlace . El despliegue de un ejemplo sencillo para un cliente que se conecta a un broker y se suscribe al t\u00f3pico $SYS , imprimiendo los mensajes recibidos, resultar\u00eda, utilizando Paho, en el siguiente c\u00f3digo Python: import paho.mqtt.client as mqtt # Funcion callback invocada cuandl el cliente recibe un CONNACK desde el broker. def on_connect(client, userdata, flags, rc): print(\"Connected with result code \"+str(rc)) # Suscribirse en on_connect() asegura que si se pierde la conexi\u00f3n y # se reestablece, las suscripciones se renovar\u00e1n. client.subscribe(\"$SYS/#\") # Funcion callback al recibir un mensaje de publicacion (PUBLISH) desde el # broker. def on_message(client, userdata, msg): print(msg.topic+\" \"+str(msg.payload)) client = mqtt.Client() client.on_connect = on_connect client.on_message = on_message client.connect(\"mqtt.eclipse.org\", 1883, 60) # Llamada bloqueante que procesa el tr\u00e1fico de red, invoca callbacks # y maneja la reconexi\u00f3n al broker. client.loop_forever() La clase cliente puede utilizarse para: Crear una instancia de cliente MQTT. Conectar a un broker usando las funciones de la familia connect*() . Invocar a funciones de la familia loop*() para mantener el tr\u00e1fico de datos con el servidor. Utilizar subscribe() para suscribirse a un topic y recibir mensajes. Utilizar publish() publicar mensajes en el broker . Utilizar disconnect() para desconectar del broker . Los callbacks se invocar\u00e1n autom\u00e1ticamente para permitir el procesamiento de eventos. De entre los m\u00e1s utilizados, destacan: ON_CONNECT : invocado cuando el broker responde a nuestra petici\u00f3n de conexi\u00f3n. Ejemplo: def on_connect(client, userdata, flags, rc): print(\"Connection returned result: \"+connack_string(rc)) ON_DISCONNECT : invocado cuando el cliente se desconecta del broker . Ejemplo: def on_disconnect(client, userdata, rc): if rc != 0: print(\"Unexpected disconnection.\") ON_MESSAGE : invocado cuando se recibe un mensaje en un topic al que el cliente est\u00e1 suscrito. Ejemplo: def on_message(client, userdata, message): print(\"Received message '\" + str(message.payload) + \"' on topic '\" + message.topic + \"' with QoS \" + str(message.qos)) Para publicar de forma puntual sobre un broker (sin mantener una conexi\u00f3n establecida), es posible utilizar la siguiente secuencia de ordenes: import paho.mqtt.publish as publish publish.single(\"paho/test/single\", \"payload\", hostname=\"mqtt.eclipse.org\") Del mismo modo, podemos suscribirnos de forma puntual mediante una llamada bloqueante a: import paho.mqtt.subscribe as subscribe msg = subscribe.simple(\"paho/test/simple\", hostname=\"mqtt.eclipse.org\") print(\"%s %s\" % (msg.topic, msg.payload)) Toda la informaci\u00f3n y documentaci\u00f3n asociada al m\u00f3dulo puede consultarse aqu\u00ed . Tarea entregable Cada alumno propondr\u00e1 una soluci\u00f3n para monitorizar un edificio inteligente a trav\u00e9s de un sistema de mensajer\u00eda MQTT. Para ello, cabe destacar que el edificio constar\u00e1 de: Un identificador del tipo EDIFICIO_TUPUESTODELABORATORIO. Un conjunto de plantas, identificadas por la cadena \"P_NUMPLANTA\". En cada planta, cuatro alas (norte -N-, sur -S-, este -E-, oeste -O-) En cada ala, un conjunto de salas, identificadas por un valor num\u00e9rico. En cada sala, cuatro sensores: TEMP (temperatura), HUM (humedad), LUX (luminosidad), VIBR (vibraci\u00f3n). Se pide, en primer lugar, dise\u00f1ar la jerarqu\u00eda de topics que permita una correcta monitorizaci\u00f3n de los edificios. En segundo lugar, se desarrollar\u00e1 un programa Python cliente o un flujo Node-RED que publique, peri\u00f3dicamente y de forma aleatoria, objetos JSON (opcionalmente puedes utilizar CBOR) que incluyan el valor de temperatura, humedad, luminosidad o vibraci\u00f3n para una determinada sala del edificio, elegida tambi\u00e9n aleatoriamente, a trav\u00e9s del topic correspondiente. Estos mensajes estar\u00e1n espaciados en el tiempo un n\u00famero aleatorio de segundos (en el caso de Node-RED, se sugiere buscar nodos que permitan generar n\u00fameros aleatorios para dar soporte a la tarea). En tercer lugar, se piden las wildcards que permitan consultar distintos tipos de informaci\u00f3n jer\u00e1rquica. Por ejemplo: Todos los mensajes de temperatura para el edificio. Todos los mensajes de vibraci\u00f3n del ala oeste de la planta 2 del edificio. Todos los mensajes de sensorizaci\u00f3n de la sala 4 del ala Sur de la planta 7 del edificio. ... En \u00faltimo lugar, se pide desarrollar un programa Python o un flujo Node-RED que act\u00fae a modo de alarma, y que muestre mensajes s\u00f3lo si alg\u00fan valor recibido para los datos sensorizados supera un umbral preestablecido. En dicho caso, el programa mostrar\u00e1 el edificio, planta, ala, sala y sensor que ha producido la alarma, junto con su valor num\u00e9rico. Puedes utilizar el m\u00f3dulo JSON para parsear los objetos recibidos en Python, o los nodos correspondientes en Node-RED.","title":"Pr\u00e1ctica 2. El protocolo MQTT (I). Despliegue de clientes y servidores/brokers. An\u00e1lisis de tr\u00e1fico"},{"location":"RPI-II/P6_old/#practica-2-el-protocolo-mqtt-i-despliegue-de-clientes-y-servidoresbrokers-analisis-de-trafico","text":"","title":"Pr\u00e1ctica 2. El protocolo MQTT (I). Despliegue de clientes y servidores/brokers. An\u00e1lisis de tr\u00e1fico"},{"location":"RPI-II/P6_old/#objetivos","text":"Familiarizarse con el uso de brokers y clientes de suscripci\u00f3n/publicaci\u00f3n utilizando MQTT. Desplegar un sistema basado en MQTT local, incluyendo broker y clientes. Utilizar Eclipse Paho para integrar funcionalidad MQTT en programas Python. Familiarizarse con el uso de wildcards MQTT.","title":"Objetivos"},{"location":"RPI-II/P6_old/#publicacionsuscripcion-contra-un-broker-en-la-nube","text":"En la primera parte de la pr\u00e1ctica, utilizaremos un servidor/ broker disponible en la nube para su uso libre por parte de los usuarios ( test.mosquitto.org ). Este servidor suele utilizarse con fines de pruebas b\u00e1sicas y depuraci\u00f3n, y hay que ser consciente de que toda la informaci\u00f3n que en \u00e9l se publica puede ser le\u00edda por cualquier suscriptor. Debe tenerse este dato en cuenta a la hora de publicar informaci\u00f3n sensible a trav\u00e9s de MQTT cuando se use el servidor de pruebas. El servidor escucha en los siguientes puertos: 1883 : MQTT, sin encriptaci\u00f3n. 8883 : MQTT, con encriptaci\u00f3n. 8884 : MQTT, con encriptaci\u00f3n, certificado de cliente requerido. 8080 : MQTT sobre WebSockets, sin encriptaci\u00f3n. 8081 : MQTT sobre WebSockets, con encriptaci\u00f3n. Para realizar publicaciones/suscripciones contra el broker utilizaremos la distribuci\u00f3n mosquitto del proyecto Eclipse IoT. Aunque mosquitto es principalmente una implementaci\u00f3n de broker MQTT, nosotros la utilizaremos en este paso a modo de cliente, lo que nos permitir\u00e1 suscribirnos o publicar sobre cualquier topic MQTT. En primer lugar, instala mosquitto : sudo apt-get update sudo apt-get install mosquitto mosquitto-clients mosquitto-dev libmosquitto* Si todo ha ido bien, deber\u00edas disponer de dos binarios listos para ejecuci\u00f3n: mosquitto_sub : permite suscribirse a un determinado topic utilizando un broker . mosquitto_pub : permite publicar un mensaje asociado a un determinado topic utilizando un broker . Tarea 2.1 Observa la ayuda de ambas ordenes, utilizando el argumento --help . Identifica los par\u00e1metros que te permitir\u00e1n especificar el broker destino, el topic a utilizar y, en el caso de la publicaci\u00f3n, el mensaje a enviar. Suscrib\u00e1monos al topic # en el broker , utilizando para ello la orden: mosquitto_sub -h test.mosquitto.org -t \"#\" Tarea 2.2 Pausa la salida en cuanto puedas. \u00bfA qu\u00e9 corresponden los mensajes que est\u00e1s obteniendo? A continuaci\u00f3n, vamos a realizar un proceso de publicaci\u00f3n/suscripcion con un topic conocido (por ejemplo, /MIOT/tunombre/ ). Para publicar un mensaje bajo dicho topic : mosquitto_pub -h test.mosquitto.org -t \"/MIOT/tunombre\" -m \"Hola, soy tunombre\" Tarea 2.3 Suscr\u00edbete al topic /MIOT/tunombre y observa si recibes los resultados tras la publicaci\u00f3n correspondiente. \u00bfC\u00f3mo podr\u00edas suscribirte a todos los mensajes publicados por compa\u00f1eros? Tarea entregable Realiza un an\u00e1lisis del intercambio de mensajes necesario para un proceso de publicaci\u00f3n/suscripci\u00f3n contra el broker de test. Incide en el tipo de protocolo de capa de transporte que utiliza MQTT, mensajes de datos y control, sobrecarga del protocolo de capa de aplicaci\u00f3n, y en general, cualquier aspecto que consideres de inter\u00e9s, incluyendo el uso de opciones relativas a QoS.","title":"Publicaci\u00f3n/suscripci\u00f3n contra un broker en la nube"},{"location":"RPI-II/P6_old/#despliegue-de-un-broker-local-usando-eclipse-mosquitto","text":"El uso de un servidor remoto presenta ventajas (facilidad de uso), pero una gran cantidad de inconvenientes (seguridad, imposibilidad de configuraci\u00f3n avanzada, ...) En esta secci\u00f3n, configuraremos un broker mosquitto para el despliegue de una infraestructura MQTT local o remota bajo nuestro control. El arranque de un broker (servidor) mosquitto se realiza mediante el propio comando mosquitto : mosquitto [-c config file] [ -d | --daemon ] [-p port number] [-v] Sin embargo, en la mayor\u00eda de distribuciones Linux, el broker arranca por defecto y se ejecuta constantemente en segundo plano. Para comprobar el estado de funcionamiento del broker , basta con ejecutar: sudo service mosquitto status Observar\u00e1s un mensaje que indica que el servicio est\u00e1 activo. Las opciones restart , start o stop te permitir\u00e1n controlar el estado del broker en todo momento. Tarea 2.4 Comprueba que, con el broker arrancado, puedes realizar un proceso de suscripci\u00f3n/publicaci\u00f3n contra el mismo. El broker mosquitto permite monitorizar sus propias estad\u00edsticas e informaci\u00f3n de estado utilizando el protocolo MQTT. As\u00ed, los topics $SYS retornan, bien peri\u00f3dicamente o bien cuando sucede un evento de inter\u00e9s, la informaci\u00f3n de estado del broker . Puedes consultar m\u00e1s detalles en la p\u00e1gina de manual de mosquitto (comando man mosquitto ), en el ep\u00edgrafe BROKER STATUS . Tarea 2.5 Comprueba el estado del broker mientras realizas procesos de suscripci\u00f3n/publicaci\u00f3n reportando bytes recibidos/enviados, n\u00famero de conexiones activas e inactivas, y n\u00famero de mensajes enviados/recibidos por el broker .","title":"Despliegue de un broker local usando Eclipse Mosquitto"},{"location":"RPI-II/P6_old/#wildcards","text":"Adem\u00e1s de permitir el uso de topics completos para el proceso de suscripci\u00f3n, los topics pueden incluir wildcards o comodines en su estructura. + es la wildcard utilizada para obtener correspondencias con un \u00fanico nivel de la jerarqu\u00eda. As\u00ed, para un topic a/b/c/d , las siguientes suscripciones corresponder\u00e1n con \u00e9xito: a/b/c/d +/b/c/d a/+/c/d a/+/+/d +/+/+/+ Pero no las siguientes: a/b/c b/+/c/d +/+/+ La segunda wildcard soportada es # , y permite corresponencias con cualquier nivel sucesivo de la jerarqu\u00eda. As\u00ed, para un topic a/b/c/d , las siguientes suscripciones corresponder\u00e1n con \u00e9xito: a/b/c/d # a/# a/b/# a/b/c/# +/b/c/# Tarea 2.6 Experimenta con el uso de wildcards desde m\u00faltiples clientes suscriptores. Resultar\u00e1 de especial inter\u00e9s observar (por ejemplo, con capturas de tr\u00e1fico) el ahorro de mensajes asociado al uso de wildcards que restrinjan qu\u00e9 mensajes son recibidos y por qu\u00e9 clientes.","title":"Wildcards"},{"location":"RPI-II/P6_old/#desarrollo-de-un-clientes-locales-opcion-1-node-red","text":"El despliegue de un cliente MQTT (ya sea suscriptor o publicador) utilizando Node-RED resulta muy sencillo. Por defecto, Node-RED incorpora dos tipos de nodos que nos ser\u00e1n de utilidad para nuestros despliegues: Nodo MQTT-in . Recibe datos desde un broker MQTT, y es por tanto el mecanismo recomendado para suscribirse a un determinado topic . El topic al que se suscribe uno de estos nodos es por defecto fijo, aunque puede ser configurado, en versiones modernas del nodo, como din\u00e1mico (campo Action -> Dynamic subscription ) del men\u00fa de configuraci\u00f3n. Nodo MQTT-out . Env\u00eda datos hacia un broker MQTT, y es por tanto el mecanismo recomendado para publicar un mensaje sobre un determinado topic . El topic bajo el que se publica un determinado dato puede ser fijo (configurado v\u00eda cuadro de di\u00e1logo de configuraci\u00f3n) o variable (configurado como el contenido del campo msg.topic del mensaje recibido por el nodo MQTT-out ). Ambos requerir\u00e1n, desde su men\u00fa de configuraci\u00f3n (accesible v\u00eda doble click en el nodo), de la configuraci\u00f3n previa de un broker MQTT (llamado server en el cuadro de di\u00e1logo de configuraci\u00f3n del nodo). En el caso de una instalaci\u00f3n local, bastar\u00e1 con indicar localhost como localizaci\u00f3n de dicho servidor. Tarea 2.7 Experimenta con el uso de los nodos MQTT-in y MQTT-out enviando y recibiendo mensajes desde un broker local o remoto. Espec\u00edficamente, aseg\u00farate de saber c\u00f3mo personalizar tanto el topic como el mensaje a publicar en un nodo de publicaci\u00f3n, o el topic al que se suscribir\u00e1 un nodo de suscripci\u00f3n.","title":"Desarrollo de un clientes locales. Opci\u00f3n 1: Node-RED"},{"location":"RPI-II/P6_old/#desarrollo-de-un-clientes-locales-opcion-2-eclipse-paho","text":"Los clientes mosquitto_pub y mosquitto_sub son b\u00e1sicamente herramientas de desarrollo y pruebas, pero resulta interesante conocer bibliotecas que permitan la integraci\u00f3n de MQTT en programas existentes. Una de ellas es Eclipse Paho . Paho es una infraestructura desarrollada en el proyecto Eclipse IoT para dar soporte a implementaciones de protocolos de mensajer\u00eda M2M e IoT, aunque, en este momento, su uso principal se centra exclusivamente en MQTT. En nuestro caso, utilizaremos la versi\u00f3n Python de la biblioteca, instalable v\u00eda: pip install paho-mqtt Dispones de la documentaci\u00f3n del m\u00f3dulo a trav\u00e9s de este enlace . El despliegue de un ejemplo sencillo para un cliente que se conecta a un broker y se suscribe al t\u00f3pico $SYS , imprimiendo los mensajes recibidos, resultar\u00eda, utilizando Paho, en el siguiente c\u00f3digo Python: import paho.mqtt.client as mqtt # Funcion callback invocada cuandl el cliente recibe un CONNACK desde el broker. def on_connect(client, userdata, flags, rc): print(\"Connected with result code \"+str(rc)) # Suscribirse en on_connect() asegura que si se pierde la conexi\u00f3n y # se reestablece, las suscripciones se renovar\u00e1n. client.subscribe(\"$SYS/#\") # Funcion callback al recibir un mensaje de publicacion (PUBLISH) desde el # broker. def on_message(client, userdata, msg): print(msg.topic+\" \"+str(msg.payload)) client = mqtt.Client() client.on_connect = on_connect client.on_message = on_message client.connect(\"mqtt.eclipse.org\", 1883, 60) # Llamada bloqueante que procesa el tr\u00e1fico de red, invoca callbacks # y maneja la reconexi\u00f3n al broker. client.loop_forever() La clase cliente puede utilizarse para: Crear una instancia de cliente MQTT. Conectar a un broker usando las funciones de la familia connect*() . Invocar a funciones de la familia loop*() para mantener el tr\u00e1fico de datos con el servidor. Utilizar subscribe() para suscribirse a un topic y recibir mensajes. Utilizar publish() publicar mensajes en el broker . Utilizar disconnect() para desconectar del broker . Los callbacks se invocar\u00e1n autom\u00e1ticamente para permitir el procesamiento de eventos. De entre los m\u00e1s utilizados, destacan: ON_CONNECT : invocado cuando el broker responde a nuestra petici\u00f3n de conexi\u00f3n. Ejemplo: def on_connect(client, userdata, flags, rc): print(\"Connection returned result: \"+connack_string(rc)) ON_DISCONNECT : invocado cuando el cliente se desconecta del broker . Ejemplo: def on_disconnect(client, userdata, rc): if rc != 0: print(\"Unexpected disconnection.\") ON_MESSAGE : invocado cuando se recibe un mensaje en un topic al que el cliente est\u00e1 suscrito. Ejemplo: def on_message(client, userdata, message): print(\"Received message '\" + str(message.payload) + \"' on topic '\" + message.topic + \"' with QoS \" + str(message.qos)) Para publicar de forma puntual sobre un broker (sin mantener una conexi\u00f3n establecida), es posible utilizar la siguiente secuencia de ordenes: import paho.mqtt.publish as publish publish.single(\"paho/test/single\", \"payload\", hostname=\"mqtt.eclipse.org\") Del mismo modo, podemos suscribirnos de forma puntual mediante una llamada bloqueante a: import paho.mqtt.subscribe as subscribe msg = subscribe.simple(\"paho/test/simple\", hostname=\"mqtt.eclipse.org\") print(\"%s %s\" % (msg.topic, msg.payload)) Toda la informaci\u00f3n y documentaci\u00f3n asociada al m\u00f3dulo puede consultarse aqu\u00ed . Tarea entregable Cada alumno propondr\u00e1 una soluci\u00f3n para monitorizar un edificio inteligente a trav\u00e9s de un sistema de mensajer\u00eda MQTT. Para ello, cabe destacar que el edificio constar\u00e1 de: Un identificador del tipo EDIFICIO_TUPUESTODELABORATORIO. Un conjunto de plantas, identificadas por la cadena \"P_NUMPLANTA\". En cada planta, cuatro alas (norte -N-, sur -S-, este -E-, oeste -O-) En cada ala, un conjunto de salas, identificadas por un valor num\u00e9rico. En cada sala, cuatro sensores: TEMP (temperatura), HUM (humedad), LUX (luminosidad), VIBR (vibraci\u00f3n). Se pide, en primer lugar, dise\u00f1ar la jerarqu\u00eda de topics que permita una correcta monitorizaci\u00f3n de los edificios. En segundo lugar, se desarrollar\u00e1 un programa Python cliente o un flujo Node-RED que publique, peri\u00f3dicamente y de forma aleatoria, objetos JSON (opcionalmente puedes utilizar CBOR) que incluyan el valor de temperatura, humedad, luminosidad o vibraci\u00f3n para una determinada sala del edificio, elegida tambi\u00e9n aleatoriamente, a trav\u00e9s del topic correspondiente. Estos mensajes estar\u00e1n espaciados en el tiempo un n\u00famero aleatorio de segundos (en el caso de Node-RED, se sugiere buscar nodos que permitan generar n\u00fameros aleatorios para dar soporte a la tarea). En tercer lugar, se piden las wildcards que permitan consultar distintos tipos de informaci\u00f3n jer\u00e1rquica. Por ejemplo: Todos los mensajes de temperatura para el edificio. Todos los mensajes de vibraci\u00f3n del ala oeste de la planta 2 del edificio. Todos los mensajes de sensorizaci\u00f3n de la sala 4 del ala Sur de la planta 7 del edificio. ... En \u00faltimo lugar, se pide desarrollar un programa Python o un flujo Node-RED que act\u00fae a modo de alarma, y que muestre mensajes s\u00f3lo si alg\u00fan valor recibido para los datos sensorizados supera un umbral preestablecido. En dicho caso, el programa mostrar\u00e1 el edificio, planta, ala, sala y sensor que ha producido la alarma, junto con su valor num\u00e9rico. Puedes utilizar el m\u00f3dulo JSON para parsear los objetos recibidos en Python, o los nodos correspondientes en Node-RED.","title":"Desarrollo de un clientes locales. Opci\u00f3n 2: Eclipse Paho"},{"location":"RPI-II/P7/","text":"Pr\u00e1ctica 7. El protocolo CoAP Objetivos El objetivo de esta pr\u00e1ctica es realizar una introducci\u00f3n al protocolo CoAP, uno de los m\u00e1s extendidos a d\u00eda de hoy para llevar a cabo comunicaciones M2M. Los objetivos did\u00e1cticos de la pr\u00e1ctica son: Entender la estructura cliente-servidor del protocolo CoAP. Comprender los mensajes utilizados para establecer una comunicaci\u00f3n CoAP, tanto a nivel de sintaxis como de sem\u00e1ntica. Modificar una aplicaci\u00f3n cliente/servidor ejemplo basada en libcoap que realice una comunicaci\u00f3n sencilla a trav\u00e9s del protocolo CoAP en un entorno Linux. Estudiar el componente libcoap en ESP-IDF para reproducir el comportamiento del servidor CoAP para ofrecer su fucionalidad desde un ESP32. Instalaci\u00f3n y requisitos previos En esta pr\u00e1ctica realizaremos un estudio del protocolo CoAP utilizando una implementaci\u00f3n ya desarrollada para un sistema cliente/servidor que hace uso del protocolo CoAP, distribuida a trav\u00e9s de la biblioteca libcoap . N\u00f3tese que se trata de una pr\u00e1ctica introductoria, ya que el protocolo CoAP se utilizar\u00e1, en sucesivas pr\u00e1cticas, para dar soporte a protocolos de m\u00e1s alto nivel (principalmente LWM2M). El objetivo principal de la pr\u00e1ctica es, pues, introducir a alto nivel las caracter\u00edsticas de CoAP como protocolo de capa de aplicaci\u00f3n, as\u00ed como ser capaces de interactuar con un servidor existente a trav\u00e9s de herramientas ya desarrolladas. De forma adicional, se estudiar\u00e1 la posibilidad de implementar un servidor CoAP en el ESP32. Instalaci\u00f3n de requisitos adicionales y libcoap En primer lugar, instalemos los prerequisitos necesarios para hacer funcionar libcoap . Para ello, en la m\u00e1quina virtual, ejecutaremos las siguientes \u00f3rdenes: sudo apt update sudo apt install pkg-config libssl-dev libtool Procedemos ahora con la instalaci\u00f3n de `libcoap. Para ello, descarga la \u00faltima versi\u00f3n de la biblioteca desde la p\u00e1gina web del proyecto, descompr\u00edmelo y pasa a la fase de compilaci\u00f3n e instalaci\u00f3n: sh autogen.sh ./configure --enable-examples --enable-dtls --with-openssl --disable-documentation make make install Si no hay ning\u00fan error, libcoap se habr\u00e1 instalado con \u00e9xito. Ser\u00e1 de especial inter\u00e9s para nosotros la instalaci\u00f3n de programas servidor ( coap-server ) y cliente ( coap-client ) de ejemplo en el directorio examples . Tarea 7.1 Ejecuta los programas servidor y cliente CoAP del directorio examples . Estudia sus opciones y par\u00e1metros de configuraci\u00f3n. \u00bfEn qu\u00e9 puertos y bajo qu\u00e9 protocolos escucha el servidor CoAP tras su arranque? Intercambio de mensajes CoAP Tarea entregable En la presente secci\u00f3n se proponen distintos intercambios de mensajes CoAP entre el cliente y el servidor de ejemplo proporcionados como parte de la instalaci\u00f3n de libcoap . Para cada uno de ellos, se pide un estudio b\u00e1sico de los paquetes intercambiados, haciendo especial hincapi\u00e9 en la pila de protocolos utilizados, contenido de los paquetes y n\u00famero de paquetes intercambiados. Este estudio, incluyendo capturas y comentarios adicionales, conformar\u00e1 el entregable asociado a la pr\u00e1ctica. Arranque del servidor CoAP En primer lugar, realizaremos un intercambio b\u00e1sico de mensajes CoAP entre el cliente y el servidor. Para ello, abriremos dos terminales desde las que ejecutaremos, respectivamente, el servidor y el cliente. Tarea 7.2 Investiga las opciones disponibles en el cliente y servidor con respecto a la cantidad de mensajes de depuraci\u00f3n a mostrar. Ejecuta el servidor CoAP con suficiente nivel de detalle en los mensajes de depuraci\u00f3n. Una vez arrancado el servidor, ejecuta la orden correspondiente desde l\u00ednea de \u00f3rdenes para averiguar qu\u00e9 puertos ha abierto, y por tanto c\u00f3mo nos podemos comunicar con \u00e9l. Averigua si estos puertos son bien conocidos well-known (valor menor a 1024) y, en su caso, c\u00f3mo pueden modificarse. Obtenci\u00f3n de informaci\u00f3n del servidor ( Resource Discovery ) En primer lugar, obtendremos la informaci\u00f3n sobre los recursos disponibles en el servidor CoAP. Para ello, realizaremos una petici\u00f3n GET sobre el recurso /.well-known/core del servidor. Esta transacci\u00f3n nos devolver\u00e1 los recursos disponibles en el mismo, as\u00ed como algunas caracter\u00edsticas adicionales. Tarea 7.3 \u00bfQu\u00e9 recursos est\u00e1n disponibles en el servidor? Estudia el c\u00f3digo fuente del mismo para observar la correlaci\u00f3n entre los recursos descubiertos y los programados en el c\u00f3digo. Averigua el significado de los atributos rt , ct , if y *title. Obtenci\u00f3n de informaci\u00f3n desde recursos Utilizando el cliente CoAP proporcionado, resulta sencillo realizar consultas para obtener datos desde el servidor. Para ello, utilizaremos el m\u00e9todo GET , seguido del recurso a consultar y, opcionalmente, de una consulta concreta. Tarea 7.4 Consulta la marca de tiempo proporcionada por el servidor en modo legible (por ejemplo, Dec 13 14:20:43 ), y tambi\u00e9n en forma de ticks de reloj, utilizando la consulta adecuada. \u00bfQu\u00e9 valor de retorno (c\u00f3digo) incluye la respuesta CoAP si el proceso ha tenido \u00e9xito? Modificaci\u00f3n de recursos Al igual que con el m\u00e9todo GET, es posible realizar modificaciones en el servidor utilizando el m\u00e9todo PUT. Consulta la ayuda del cliente proporcionado para observar alg\u00fan ejemplo que d\u00e9 soporte a esta funcionalidad. Tarea 7.5 Modifica la marca de tiempo que proporciona el servidor CoAP. \u00bfQu\u00e9 valor de retorno (c\u00f3digo) incluye la respuesta CoAP si el proceso ha tenido \u00e9xito? Eliminaci\u00f3n y creaci\u00f3n de recursos Es posible eliminar un determinado recurso (en el ejemplo, el temporizador), utilizando el m\u00e9todo DELETE . Investiga c\u00f3mo hacerlo desde el cliente proporcionado. Tarea 7.6 Elimina el recurso time del servidor y, a continuaci\u00f3n, modifica la marca de tiempo mediante una orden PUT }. \u00bfQu\u00e9 valores de retorno (c\u00f3digo) se devuelven en ambos casos?} Suscripci\u00f3n (observaci\u00f3n) de recursos Es posible suscribirse a los cambios en el valor de un recurso utilizando la opci\u00f3n -s del cliente. Tarea 7.7 Activa la observaci\u00f3n sobre el recurso time del servidor y analiza tanto la frecuencia de respuesta como el intercambio de mensajes producido (a trav\u00e9s de Wireshark ). \u00bfSe producen peticiones peri\u00f3dicas usando GET ? CoAP sobre TCP Alternativamente, CoAP puede funcionar utilizando el protocolo de capa de transporte TCP. En este caso, como es l\u00f3gico, se establecer\u00e1 una conexi\u00f3n entre cliente y servidor previa a cualquier intercambio de datos. Tarea 7.8 Fuerza el uso de TCP en el cliente mediante la opci\u00f3n correspondiente y estudia las principales diferencias entre los mensajes intercambiados con respecto al uso de UDP. \u00bfCu\u00e1l es la eficiencia al utilizar UDP y TCP como protocolos de transporte para CoAP? Tarea 7.9 Fuerza el uso de TCP en el cliente mediante la opci\u00f3n correspondiente y estudia las principales diferencias entre los mensajes intercambiados con respecto al uso de UDP. \u00bfCu\u00e1l es la eficiencia al utilizar UDP y TCP como protocolos de transporte para CoAP? CoAP con Thingsboard Como se mencion\u00f3 en la pr\u00e1ctica anterior, Thingsboard permite por defecto la comunicaci\u00f3n mediante CoAP con los dispositivos. Suponiendo una instancia local de Thingsboard es f\u00e1cil comprobar la conectividad mediante CoAP empleando el siguiente comando, d\u00f3nde , como es obvio, se debe sustituir por el del dispositivo: coap-client -v 6 -m POST -t json -e \"{temperature:15}\" coap://127.0.0.1:5683/api/v1/<TOKEN>/telemetry Tarea 7.10 (opcional) Crea un nuevo dispositvo en la instancia local de Thingsboad y comprueba su conectividad. Analiza mediante Wireshark la comunicaci\u00f3n. Tareas entregables Tarea entregable Deber\u00e1s entregar una memoria en la que se incida en detalles observados y aprendidos acerca del protocolo CoAP, con especial atenci\u00f3n a las capturas obtenidas a trav\u00e9s de Wireshark. Tarea entregable Estudia el c\u00f3digo del servidor proporcionado, especialmente de la funci\u00f3n init_resources , y a\u00f1ade un nuevo recurso llamado temperature . Este recurso aceptar\u00e1 dos consultas distintas: ?celsius (consulta por defecto) devolver\u00e1 el valor de temperatura expresado en grados cent\u00edgrados, mientras que ?fahrenheit devolver\u00e1 la temperatura en grados Fahrenheit. En este caso, el valor de temperatura se obtendr\u00e1 directamente a trav\u00e9s de un n\u00famero aleatorio, pero se valorar\u00e1 su obtenci\u00f3n a partir de un sensor real. Tarea entregable ESP-IDF incluye un port de libcoap como componente del ESP Registry ( espressif/coap ). El ejemplo coap_server implementa un servidor CoAP b\u00e1sico, con un s\u00f3lo recurso (puedes consultarlo t\u00fa mismo/a obteniendo la informaci\u00f3n del recurso /well-known/core ). Analiza el c\u00f3digo y observa que la biblioteca libcoap se utiliza de forma exacta a como has estudiado en el c\u00f3digo del servidor de ejemplo. Se pide modificar el firmware para dar soporte al recurso time de forma id\u00e9ntica (con la misma sem\u00e1ntica) que la utilizada en el host .","title":"Pr\u00e1ctica 7"},{"location":"RPI-II/P7/#practica-7-el-protocolo-coap","text":"","title":"Pr\u00e1ctica 7. El protocolo CoAP"},{"location":"RPI-II/P7/#objetivos","text":"El objetivo de esta pr\u00e1ctica es realizar una introducci\u00f3n al protocolo CoAP, uno de los m\u00e1s extendidos a d\u00eda de hoy para llevar a cabo comunicaciones M2M. Los objetivos did\u00e1cticos de la pr\u00e1ctica son: Entender la estructura cliente-servidor del protocolo CoAP. Comprender los mensajes utilizados para establecer una comunicaci\u00f3n CoAP, tanto a nivel de sintaxis como de sem\u00e1ntica. Modificar una aplicaci\u00f3n cliente/servidor ejemplo basada en libcoap que realice una comunicaci\u00f3n sencilla a trav\u00e9s del protocolo CoAP en un entorno Linux. Estudiar el componente libcoap en ESP-IDF para reproducir el comportamiento del servidor CoAP para ofrecer su fucionalidad desde un ESP32.","title":"Objetivos"},{"location":"RPI-II/P7/#instalacion-y-requisitos-previos","text":"En esta pr\u00e1ctica realizaremos un estudio del protocolo CoAP utilizando una implementaci\u00f3n ya desarrollada para un sistema cliente/servidor que hace uso del protocolo CoAP, distribuida a trav\u00e9s de la biblioteca libcoap . N\u00f3tese que se trata de una pr\u00e1ctica introductoria, ya que el protocolo CoAP se utilizar\u00e1, en sucesivas pr\u00e1cticas, para dar soporte a protocolos de m\u00e1s alto nivel (principalmente LWM2M). El objetivo principal de la pr\u00e1ctica es, pues, introducir a alto nivel las caracter\u00edsticas de CoAP como protocolo de capa de aplicaci\u00f3n, as\u00ed como ser capaces de interactuar con un servidor existente a trav\u00e9s de herramientas ya desarrolladas. De forma adicional, se estudiar\u00e1 la posibilidad de implementar un servidor CoAP en el ESP32.","title":"Instalaci\u00f3n y requisitos previos"},{"location":"RPI-II/P7/#instalacion-de-requisitos-adicionales-y-libcoap","text":"En primer lugar, instalemos los prerequisitos necesarios para hacer funcionar libcoap . Para ello, en la m\u00e1quina virtual, ejecutaremos las siguientes \u00f3rdenes: sudo apt update sudo apt install pkg-config libssl-dev libtool Procedemos ahora con la instalaci\u00f3n de `libcoap. Para ello, descarga la \u00faltima versi\u00f3n de la biblioteca desde la p\u00e1gina web del proyecto, descompr\u00edmelo y pasa a la fase de compilaci\u00f3n e instalaci\u00f3n: sh autogen.sh ./configure --enable-examples --enable-dtls --with-openssl --disable-documentation make make install Si no hay ning\u00fan error, libcoap se habr\u00e1 instalado con \u00e9xito. Ser\u00e1 de especial inter\u00e9s para nosotros la instalaci\u00f3n de programas servidor ( coap-server ) y cliente ( coap-client ) de ejemplo en el directorio examples . Tarea 7.1 Ejecuta los programas servidor y cliente CoAP del directorio examples . Estudia sus opciones y par\u00e1metros de configuraci\u00f3n. \u00bfEn qu\u00e9 puertos y bajo qu\u00e9 protocolos escucha el servidor CoAP tras su arranque?","title":"Instalaci\u00f3n de requisitos adicionales y libcoap"},{"location":"RPI-II/P7/#intercambio-de-mensajes-coap","text":"Tarea entregable En la presente secci\u00f3n se proponen distintos intercambios de mensajes CoAP entre el cliente y el servidor de ejemplo proporcionados como parte de la instalaci\u00f3n de libcoap . Para cada uno de ellos, se pide un estudio b\u00e1sico de los paquetes intercambiados, haciendo especial hincapi\u00e9 en la pila de protocolos utilizados, contenido de los paquetes y n\u00famero de paquetes intercambiados. Este estudio, incluyendo capturas y comentarios adicionales, conformar\u00e1 el entregable asociado a la pr\u00e1ctica.","title":"Intercambio de mensajes CoAP"},{"location":"RPI-II/P7/#arranque-del-servidor-coap","text":"En primer lugar, realizaremos un intercambio b\u00e1sico de mensajes CoAP entre el cliente y el servidor. Para ello, abriremos dos terminales desde las que ejecutaremos, respectivamente, el servidor y el cliente. Tarea 7.2 Investiga las opciones disponibles en el cliente y servidor con respecto a la cantidad de mensajes de depuraci\u00f3n a mostrar. Ejecuta el servidor CoAP con suficiente nivel de detalle en los mensajes de depuraci\u00f3n. Una vez arrancado el servidor, ejecuta la orden correspondiente desde l\u00ednea de \u00f3rdenes para averiguar qu\u00e9 puertos ha abierto, y por tanto c\u00f3mo nos podemos comunicar con \u00e9l. Averigua si estos puertos son bien conocidos well-known (valor menor a 1024) y, en su caso, c\u00f3mo pueden modificarse.","title":"Arranque del servidor CoAP"},{"location":"RPI-II/P7/#obtencion-de-informacion-del-servidor-resource-discovery","text":"En primer lugar, obtendremos la informaci\u00f3n sobre los recursos disponibles en el servidor CoAP. Para ello, realizaremos una petici\u00f3n GET sobre el recurso /.well-known/core del servidor. Esta transacci\u00f3n nos devolver\u00e1 los recursos disponibles en el mismo, as\u00ed como algunas caracter\u00edsticas adicionales. Tarea 7.3 \u00bfQu\u00e9 recursos est\u00e1n disponibles en el servidor? Estudia el c\u00f3digo fuente del mismo para observar la correlaci\u00f3n entre los recursos descubiertos y los programados en el c\u00f3digo. Averigua el significado de los atributos rt , ct , if y *title.","title":"Obtenci\u00f3n de informaci\u00f3n del servidor (Resource Discovery)"},{"location":"RPI-II/P7/#obtencion-de-informacion-desde-recursos","text":"Utilizando el cliente CoAP proporcionado, resulta sencillo realizar consultas para obtener datos desde el servidor. Para ello, utilizaremos el m\u00e9todo GET , seguido del recurso a consultar y, opcionalmente, de una consulta concreta. Tarea 7.4 Consulta la marca de tiempo proporcionada por el servidor en modo legible (por ejemplo, Dec 13 14:20:43 ), y tambi\u00e9n en forma de ticks de reloj, utilizando la consulta adecuada. \u00bfQu\u00e9 valor de retorno (c\u00f3digo) incluye la respuesta CoAP si el proceso ha tenido \u00e9xito?","title":"Obtenci\u00f3n de informaci\u00f3n desde recursos"},{"location":"RPI-II/P7/#modificacion-de-recursos","text":"Al igual que con el m\u00e9todo GET, es posible realizar modificaciones en el servidor utilizando el m\u00e9todo PUT. Consulta la ayuda del cliente proporcionado para observar alg\u00fan ejemplo que d\u00e9 soporte a esta funcionalidad. Tarea 7.5 Modifica la marca de tiempo que proporciona el servidor CoAP. \u00bfQu\u00e9 valor de retorno (c\u00f3digo) incluye la respuesta CoAP si el proceso ha tenido \u00e9xito?","title":"Modificaci\u00f3n de recursos"},{"location":"RPI-II/P7/#eliminacion-y-creacion-de-recursos","text":"Es posible eliminar un determinado recurso (en el ejemplo, el temporizador), utilizando el m\u00e9todo DELETE . Investiga c\u00f3mo hacerlo desde el cliente proporcionado. Tarea 7.6 Elimina el recurso time del servidor y, a continuaci\u00f3n, modifica la marca de tiempo mediante una orden PUT }. \u00bfQu\u00e9 valores de retorno (c\u00f3digo) se devuelven en ambos casos?}","title":"Eliminaci\u00f3n y creaci\u00f3n de recursos"},{"location":"RPI-II/P7/#suscripcion-observacion-de-recursos","text":"Es posible suscribirse a los cambios en el valor de un recurso utilizando la opci\u00f3n -s del cliente. Tarea 7.7 Activa la observaci\u00f3n sobre el recurso time del servidor y analiza tanto la frecuencia de respuesta como el intercambio de mensajes producido (a trav\u00e9s de Wireshark ). \u00bfSe producen peticiones peri\u00f3dicas usando GET ?","title":"Suscripci\u00f3n (observaci\u00f3n) de recursos"},{"location":"RPI-II/P7/#coap-sobre-tcp","text":"Alternativamente, CoAP puede funcionar utilizando el protocolo de capa de transporte TCP. En este caso, como es l\u00f3gico, se establecer\u00e1 una conexi\u00f3n entre cliente y servidor previa a cualquier intercambio de datos. Tarea 7.8 Fuerza el uso de TCP en el cliente mediante la opci\u00f3n correspondiente y estudia las principales diferencias entre los mensajes intercambiados con respecto al uso de UDP. \u00bfCu\u00e1l es la eficiencia al utilizar UDP y TCP como protocolos de transporte para CoAP? Tarea 7.9 Fuerza el uso de TCP en el cliente mediante la opci\u00f3n correspondiente y estudia las principales diferencias entre los mensajes intercambiados con respecto al uso de UDP. \u00bfCu\u00e1l es la eficiencia al utilizar UDP y TCP como protocolos de transporte para CoAP?","title":"CoAP sobre TCP"},{"location":"RPI-II/P7/#coap-con-thingsboard","text":"Como se mencion\u00f3 en la pr\u00e1ctica anterior, Thingsboard permite por defecto la comunicaci\u00f3n mediante CoAP con los dispositivos. Suponiendo una instancia local de Thingsboard es f\u00e1cil comprobar la conectividad mediante CoAP empleando el siguiente comando, d\u00f3nde , como es obvio, se debe sustituir por el del dispositivo: coap-client -v 6 -m POST -t json -e \"{temperature:15}\" coap://127.0.0.1:5683/api/v1/<TOKEN>/telemetry Tarea 7.10 (opcional) Crea un nuevo dispositvo en la instancia local de Thingsboad y comprueba su conectividad. Analiza mediante Wireshark la comunicaci\u00f3n.","title":"CoAP con Thingsboard"},{"location":"RPI-II/P7/#tareas-entregables","text":"Tarea entregable Deber\u00e1s entregar una memoria en la que se incida en detalles observados y aprendidos acerca del protocolo CoAP, con especial atenci\u00f3n a las capturas obtenidas a trav\u00e9s de Wireshark. Tarea entregable Estudia el c\u00f3digo del servidor proporcionado, especialmente de la funci\u00f3n init_resources , y a\u00f1ade un nuevo recurso llamado temperature . Este recurso aceptar\u00e1 dos consultas distintas: ?celsius (consulta por defecto) devolver\u00e1 el valor de temperatura expresado en grados cent\u00edgrados, mientras que ?fahrenheit devolver\u00e1 la temperatura en grados Fahrenheit. En este caso, el valor de temperatura se obtendr\u00e1 directamente a trav\u00e9s de un n\u00famero aleatorio, pero se valorar\u00e1 su obtenci\u00f3n a partir de un sensor real. Tarea entregable ESP-IDF incluye un port de libcoap como componente del ESP Registry ( espressif/coap ). El ejemplo coap_server implementa un servidor CoAP b\u00e1sico, con un s\u00f3lo recurso (puedes consultarlo t\u00fa mismo/a obteniendo la informaci\u00f3n del recurso /well-known/core ). Analiza el c\u00f3digo y observa que la biblioteca libcoap se utiliza de forma exacta a como has estudiado en el c\u00f3digo del servidor de ejemplo. Se pide modificar el firmware para dar soporte al recurso time de forma id\u00e9ntica (con la misma sem\u00e1ntica) que la utilizada en el host .","title":"Tareas entregables"},{"location":"RPI-II/P7_old/","text":"Pr\u00e1ctica 4. El protocolo CoAP Objetivos El objetivo de esta pr\u00e1ctica es realizar una introducci\u00f3n al protocolo CoAP, uno de los m\u00e1s extendidos a d\u00eda de hoy para llevar a cabo comunicaciones M2M. Los objetivos did\u00e1cticos de la pr\u00e1ctica son: Entender la estructura cliente-servidor del protocolo CoAP. Comprender los mensajes utilizados para establecer una comunicaci\u00f3n CoAP, tanto a nivel de sintaxis como de sem\u00e1ntica. Modificar una aplicaci\u00f3n cliente/servidor ejemplo basada en libcoap que realice una comunicaci\u00f3n sencilla a trav\u00e9s del protocolo CoAP en un entorno Linux. Estudiar el componente libcoap en ESP-IDF para reproducir el comportamiento del servidor CoAP para ofrecer su fucionalidad desde un ESP32. Instalaci\u00f3n y requisitos previos En esta pr\u00e1ctica realizaremos un estudio del protocolo CoAP utilizando una implementaci\u00f3n ya desarrollada para un sistema cliente/servidor que hace uso del protocolo CoAP, distribuida a trav\u00e9s de la biblioteca libcoap . N\u00f3tese que se trata de una pr\u00e1ctica introductoria, ya que el protocolo CoAP se utilizar\u00e1, en sucesivas pr\u00e1cticas, para dar soporte a protocolos de m\u00e1s alto nivel (principalmente LWM2M). El objetivo principal de la pr\u00e1ctica es, pues, introducir a alto nivel las caracter\u00edsticas de CoAP como protocolo de capa de aplicaci\u00f3n, as\u00ed como ser capaces de interactuar con un servidor existente a trav\u00e9s de herramientas ya desarrolladas. De forma adicional, se estudiar\u00e1 la posibilidad de implementar un servidor CoAP en el ESP32. Instalaci\u00f3n de requisitos adicionales y libcoap En primer lugar, instalemos los prerequisitos necesarios para hacer funcionar libcoap . Para ello, en la m\u00e1quina virtual, ejecutaremos las siguientes \u00f3rdenes: sudo apt-get update sudo apt-get install libtool Procedemos ahora con la instalaci\u00f3n de `libcoap. Para ello, descarga la \u00faltima versi\u00f3n de la biblioteca desde la p\u00e1gina web del proyecto, descompr\u00edmelo y pasa a la fase de compilaci\u00f3n e instalaci\u00f3n: sh autogen.sh ./configure --enable-examples --enable-dtls --with-openssl --disable-documentation make make install Si no hay ning\u00fan error, libcoap se habr\u00e1 instalado con \u00e9xito. Ser\u00e1 de especial inter\u00e9s para nosotros la instalaci\u00f3n de programas servidor ( coap-server ) y cliente ( coap-client ) de ejemplo en el directorio examples . Tarea 4.1 Ejecuta los programas servidor y cliente CoAP del directorio examples . Estudia sus opciones y par\u00e1metros de configuraci\u00f3n. \u00bfEn qu\u00e9 puertos y bajo qu\u00e9 protocolos escucha el servidor CoAP tras su arranque? Intercambio de mensajes CoAP Tarea entregable En la presente secci\u00f3n se proponen distintos intercambios de mensajes CoAP entre el cliente y el servidor de ejemplo proporcionados como parte de la instalaci\u00f3n de libcoap . Para cada uno de ellos, se pide un estudio b\u00e1sico de los paquetes intercambiados, haciendo especial hincapi\u00e9 en la pila de protocolos utilizados, contenido de los paquetes y n\u00famero de paquetes intercambiados. Este estudio, incluyendo capturas y comentarios adicionales, conformar\u00e1 el entregable asociado a la pr\u00e1ctica. Arranque del servidor CoAP En primer lugar, realizaremos un intercambio b\u00e1sico de mensajes CoAP entre el cliente y el servidor. Para ello, abriremos dos terminales desde las que ejecutaremos, respectivamente, el servidor y el cliente. Tarea 4.2 Investiga las opciones disponibles en el cliente y servidor con respecto a la cantidad de mensajes de depuraci\u00f3n a mostrar. Ejecuta el servidor CoAP con suficiente nivel de detalle en los mensajes de depuraci\u00f3n. Una vez arrancado el servidor, ejecuta la orden correspondiente desde l\u00ednea de \u00f3rdenes para averiguar qu\u00e9 puertos ha abierto, y por tanto c\u00f3mo nos podemos comunicar con \u00e9l. Averigua si estos puertos son bien conocidos well-known , valor menor a 1024) y, en su caso, c\u00f3mo pueden modificarse. Obtenci\u00f3n de informaci\u00f3n del servidor ( Resource Discovery ) En primer lugar, obtendremos la informaci\u00f3n sobre los recursos disponibles en el servidor CoAP. Para ello, realizaremos una petici\u00f3n GET sobre el recurso /.well-known/core del servidor. Esta transacci\u00f3n nos devolver\u00e1 los recursos disponibles en el mismo, as\u00ed como algunas caracter\u00edsticas adicionales. Tarea 4.3 \u00bfQu\u00e9 recursos est\u00e1n disponibles en el servidor? Estudia el c\u00f3digo fuente del mismo para observar la correlaci\u00f3n entre los recursos descubiertos y los programados en el c\u00f3digo. Averigua el significado de los atributos rt , ct , if y *title. Obtenci\u00f3n de informaci\u00f3n desde recursos Utilizando el cliente CoAP proporcionado, resulta sencillo realizar consultas para obtener datos desde el servidor. Para ello, utilizaremos la acci\u00f3n (verbo) GET , seguido del recurso a consultar y, opcionalmente, de una consulta concreta. Tarea 4.4 Consulta la marca de tiempo proporcionada por el servidor en modo legible (por ejemplo, Dec 13 14:20:43 ), y tambi\u00e9n en forma de ticks de reloj, utilizando la consulta adecuada. \u00bfQu\u00e9 valor de retorno (c\u00f3digo) incluye la respuesta CoAP si el proceso ha tenido \u00e9xito? Modificaci\u00f3n de recursos Al igual que con el verbo GET, es posible realizar modificaciones en el servidor utilizando el verbo PUT. Consulta la ayuda del cliente proporcionado para observar alg\u00fan ejemplo que d\u00e9 soporte a esta funcionalidad. Tarea 4.5 Modifica la marca de tiempo que proporciona el servidor CoAP. \u00bfQu\u00e9 valor de retorno (c\u00f3digo) incluye la respuesta CoAP si el proceso ha tenido \u00e9xito? Eliminaci\u00f3n y creaci\u00f3n de recursos Es posible eliminar un determinado recurso (en el ejemplo, el temporizador), utilizando el verbo DELETE . Investiga c\u00f3mo hacerlo desde el cliente proporcionado. Tarea 4.6 Elimina el recurso time del servidor y, a continuaci\u00f3n, modifica la marca de tiempo mediante una orden PUT }. \u00bfQu\u00e9 valores de retorno (c\u00f3digo) se devuelven en ambos casos?} Suscripci\u00f3n (observaci\u00f3n) de recursos Es posible suscribirse a los cambios en el valor de un recurso utilizando la opci\u00f3n -s del cliente. Tarea 4.7 Activa la observaci\u00f3n sobre el recurso time del servidor y analiza tanto la frecuencia de respuesta como el intercambio de mensajes producido (a trav\u00e9s de Wireshark ). \u00bfSe producen peticiones peri\u00f3dicas usando GET ? CoAP sobre TCP Alternativamente, CoAP puede funcionar utilizando el protocolo de capa de transporte TCP. En este caso, como es l\u00f3gico, se establecer\u00e1 una conexi\u00f3n entre cliente y servidor previa a cualquier intercambio de datos. Tarea 4.8 Fuerza el uso de TCP en el cliente mediante la opci\u00f3n correspondiente y estudia las principales diferencias entre los mensajes intercambiados con respecto al uso de UDP. \u00bfCu\u00e1l es la eficiencia al utilizar UDP y TCP como protocolos de transporte para CoAP? Tareas entregables Tarea entregable Deber\u00e1s entregar una memoria en la que se incida en detalles observados y aprendidos acerca del protocolo CoAP, con especial atenci\u00f3n a las capturas obtenidas a trav\u00e9s de Wireshark. Tarea entregable Estudia el c\u00f3digo del servidor proporcionado, especialmente de la funci\u00f3n init_resources , y a\u00f1ade un nuevo recurso llamado temperature . Este recurso aceptar\u00e1 dos consultas distintas: ?celsius (consulta por defecto) devolver\u00e1 el valor de temperatura expresado en grados cent\u00edgrados, mientras que ?fahrenheit devolver\u00e1 la temperatura en grados Fahrenheit. En este caso, el valor de temperatura se obtendr\u00e1 directamente a trav\u00e9s de un n\u00famero aleatorio, pero se valorar\u00e1 su obtenci\u00f3n a partir de un sensor real. Tarea entregable ESP-IDF incluye un port de libcoap . El ejemplo examples/protocols/coap_server implementa un servidor CoAP b\u00e1sico, con un s\u00f3lo recurso (puedes consultarlo t\u00fa mismo/a obteniendo la informaci\u00f3n del recurso /well-known/core ). Analiza el c\u00f3digo y observa que la biblioteca libcoap se utiliza de forma exacta a como has estudiado en el c\u00f3digo del servidor de ejemplo. Se pide modificar el firmware para dar soporte al recurso time de forma id\u00e9ntica (con la misma sem\u00e1ntica) que la utilizada en el host .","title":"Pr\u00e1ctica 4. El protocolo CoAP"},{"location":"RPI-II/P7_old/#practica-4-el-protocolo-coap","text":"","title":"Pr\u00e1ctica 4. El protocolo CoAP"},{"location":"RPI-II/P7_old/#objetivos","text":"El objetivo de esta pr\u00e1ctica es realizar una introducci\u00f3n al protocolo CoAP, uno de los m\u00e1s extendidos a d\u00eda de hoy para llevar a cabo comunicaciones M2M. Los objetivos did\u00e1cticos de la pr\u00e1ctica son: Entender la estructura cliente-servidor del protocolo CoAP. Comprender los mensajes utilizados para establecer una comunicaci\u00f3n CoAP, tanto a nivel de sintaxis como de sem\u00e1ntica. Modificar una aplicaci\u00f3n cliente/servidor ejemplo basada en libcoap que realice una comunicaci\u00f3n sencilla a trav\u00e9s del protocolo CoAP en un entorno Linux. Estudiar el componente libcoap en ESP-IDF para reproducir el comportamiento del servidor CoAP para ofrecer su fucionalidad desde un ESP32.","title":"Objetivos"},{"location":"RPI-II/P7_old/#instalacion-y-requisitos-previos","text":"En esta pr\u00e1ctica realizaremos un estudio del protocolo CoAP utilizando una implementaci\u00f3n ya desarrollada para un sistema cliente/servidor que hace uso del protocolo CoAP, distribuida a trav\u00e9s de la biblioteca libcoap . N\u00f3tese que se trata de una pr\u00e1ctica introductoria, ya que el protocolo CoAP se utilizar\u00e1, en sucesivas pr\u00e1cticas, para dar soporte a protocolos de m\u00e1s alto nivel (principalmente LWM2M). El objetivo principal de la pr\u00e1ctica es, pues, introducir a alto nivel las caracter\u00edsticas de CoAP como protocolo de capa de aplicaci\u00f3n, as\u00ed como ser capaces de interactuar con un servidor existente a trav\u00e9s de herramientas ya desarrolladas. De forma adicional, se estudiar\u00e1 la posibilidad de implementar un servidor CoAP en el ESP32.","title":"Instalaci\u00f3n y requisitos previos"},{"location":"RPI-II/P7_old/#instalacion-de-requisitos-adicionales-y-libcoap","text":"En primer lugar, instalemos los prerequisitos necesarios para hacer funcionar libcoap . Para ello, en la m\u00e1quina virtual, ejecutaremos las siguientes \u00f3rdenes: sudo apt-get update sudo apt-get install libtool Procedemos ahora con la instalaci\u00f3n de `libcoap. Para ello, descarga la \u00faltima versi\u00f3n de la biblioteca desde la p\u00e1gina web del proyecto, descompr\u00edmelo y pasa a la fase de compilaci\u00f3n e instalaci\u00f3n: sh autogen.sh ./configure --enable-examples --enable-dtls --with-openssl --disable-documentation make make install Si no hay ning\u00fan error, libcoap se habr\u00e1 instalado con \u00e9xito. Ser\u00e1 de especial inter\u00e9s para nosotros la instalaci\u00f3n de programas servidor ( coap-server ) y cliente ( coap-client ) de ejemplo en el directorio examples . Tarea 4.1 Ejecuta los programas servidor y cliente CoAP del directorio examples . Estudia sus opciones y par\u00e1metros de configuraci\u00f3n. \u00bfEn qu\u00e9 puertos y bajo qu\u00e9 protocolos escucha el servidor CoAP tras su arranque?","title":"Instalaci\u00f3n de requisitos adicionales y libcoap"},{"location":"RPI-II/P7_old/#intercambio-de-mensajes-coap","text":"Tarea entregable En la presente secci\u00f3n se proponen distintos intercambios de mensajes CoAP entre el cliente y el servidor de ejemplo proporcionados como parte de la instalaci\u00f3n de libcoap . Para cada uno de ellos, se pide un estudio b\u00e1sico de los paquetes intercambiados, haciendo especial hincapi\u00e9 en la pila de protocolos utilizados, contenido de los paquetes y n\u00famero de paquetes intercambiados. Este estudio, incluyendo capturas y comentarios adicionales, conformar\u00e1 el entregable asociado a la pr\u00e1ctica.","title":"Intercambio de mensajes CoAP"},{"location":"RPI-II/P7_old/#arranque-del-servidor-coap","text":"En primer lugar, realizaremos un intercambio b\u00e1sico de mensajes CoAP entre el cliente y el servidor. Para ello, abriremos dos terminales desde las que ejecutaremos, respectivamente, el servidor y el cliente. Tarea 4.2 Investiga las opciones disponibles en el cliente y servidor con respecto a la cantidad de mensajes de depuraci\u00f3n a mostrar. Ejecuta el servidor CoAP con suficiente nivel de detalle en los mensajes de depuraci\u00f3n. Una vez arrancado el servidor, ejecuta la orden correspondiente desde l\u00ednea de \u00f3rdenes para averiguar qu\u00e9 puertos ha abierto, y por tanto c\u00f3mo nos podemos comunicar con \u00e9l. Averigua si estos puertos son bien conocidos well-known , valor menor a 1024) y, en su caso, c\u00f3mo pueden modificarse.","title":"Arranque del servidor CoAP"},{"location":"RPI-II/P7_old/#obtencion-de-informacion-del-servidor-resource-discovery","text":"En primer lugar, obtendremos la informaci\u00f3n sobre los recursos disponibles en el servidor CoAP. Para ello, realizaremos una petici\u00f3n GET sobre el recurso /.well-known/core del servidor. Esta transacci\u00f3n nos devolver\u00e1 los recursos disponibles en el mismo, as\u00ed como algunas caracter\u00edsticas adicionales. Tarea 4.3 \u00bfQu\u00e9 recursos est\u00e1n disponibles en el servidor? Estudia el c\u00f3digo fuente del mismo para observar la correlaci\u00f3n entre los recursos descubiertos y los programados en el c\u00f3digo. Averigua el significado de los atributos rt , ct , if y *title.","title":"Obtenci\u00f3n de informaci\u00f3n del servidor (Resource Discovery)"},{"location":"RPI-II/P7_old/#obtencion-de-informacion-desde-recursos","text":"Utilizando el cliente CoAP proporcionado, resulta sencillo realizar consultas para obtener datos desde el servidor. Para ello, utilizaremos la acci\u00f3n (verbo) GET , seguido del recurso a consultar y, opcionalmente, de una consulta concreta. Tarea 4.4 Consulta la marca de tiempo proporcionada por el servidor en modo legible (por ejemplo, Dec 13 14:20:43 ), y tambi\u00e9n en forma de ticks de reloj, utilizando la consulta adecuada. \u00bfQu\u00e9 valor de retorno (c\u00f3digo) incluye la respuesta CoAP si el proceso ha tenido \u00e9xito?","title":"Obtenci\u00f3n de informaci\u00f3n desde recursos"},{"location":"RPI-II/P7_old/#modificacion-de-recursos","text":"Al igual que con el verbo GET, es posible realizar modificaciones en el servidor utilizando el verbo PUT. Consulta la ayuda del cliente proporcionado para observar alg\u00fan ejemplo que d\u00e9 soporte a esta funcionalidad. Tarea 4.5 Modifica la marca de tiempo que proporciona el servidor CoAP. \u00bfQu\u00e9 valor de retorno (c\u00f3digo) incluye la respuesta CoAP si el proceso ha tenido \u00e9xito?","title":"Modificaci\u00f3n de recursos"},{"location":"RPI-II/P7_old/#eliminacion-y-creacion-de-recursos","text":"Es posible eliminar un determinado recurso (en el ejemplo, el temporizador), utilizando el verbo DELETE . Investiga c\u00f3mo hacerlo desde el cliente proporcionado. Tarea 4.6 Elimina el recurso time del servidor y, a continuaci\u00f3n, modifica la marca de tiempo mediante una orden PUT }. \u00bfQu\u00e9 valores de retorno (c\u00f3digo) se devuelven en ambos casos?}","title":"Eliminaci\u00f3n y creaci\u00f3n de recursos"},{"location":"RPI-II/P7_old/#suscripcion-observacion-de-recursos","text":"Es posible suscribirse a los cambios en el valor de un recurso utilizando la opci\u00f3n -s del cliente. Tarea 4.7 Activa la observaci\u00f3n sobre el recurso time del servidor y analiza tanto la frecuencia de respuesta como el intercambio de mensajes producido (a trav\u00e9s de Wireshark ). \u00bfSe producen peticiones peri\u00f3dicas usando GET ?","title":"Suscripci\u00f3n (observaci\u00f3n) de recursos"},{"location":"RPI-II/P7_old/#coap-sobre-tcp","text":"Alternativamente, CoAP puede funcionar utilizando el protocolo de capa de transporte TCP. En este caso, como es l\u00f3gico, se establecer\u00e1 una conexi\u00f3n entre cliente y servidor previa a cualquier intercambio de datos. Tarea 4.8 Fuerza el uso de TCP en el cliente mediante la opci\u00f3n correspondiente y estudia las principales diferencias entre los mensajes intercambiados con respecto al uso de UDP. \u00bfCu\u00e1l es la eficiencia al utilizar UDP y TCP como protocolos de transporte para CoAP?","title":"CoAP sobre TCP"},{"location":"RPI-II/P7_old/#tareas-entregables","text":"Tarea entregable Deber\u00e1s entregar una memoria en la que se incida en detalles observados y aprendidos acerca del protocolo CoAP, con especial atenci\u00f3n a las capturas obtenidas a trav\u00e9s de Wireshark. Tarea entregable Estudia el c\u00f3digo del servidor proporcionado, especialmente de la funci\u00f3n init_resources , y a\u00f1ade un nuevo recurso llamado temperature . Este recurso aceptar\u00e1 dos consultas distintas: ?celsius (consulta por defecto) devolver\u00e1 el valor de temperatura expresado en grados cent\u00edgrados, mientras que ?fahrenheit devolver\u00e1 la temperatura en grados Fahrenheit. En este caso, el valor de temperatura se obtendr\u00e1 directamente a trav\u00e9s de un n\u00famero aleatorio, pero se valorar\u00e1 su obtenci\u00f3n a partir de un sensor real. Tarea entregable ESP-IDF incluye un port de libcoap . El ejemplo examples/protocols/coap_server implementa un servidor CoAP b\u00e1sico, con un s\u00f3lo recurso (puedes consultarlo t\u00fa mismo/a obteniendo la informaci\u00f3n del recurso /well-known/core ). Analiza el c\u00f3digo y observa que la biblioteca libcoap se utiliza de forma exacta a como has estudiado en el c\u00f3digo del servidor de ejemplo. Se pide modificar el firmware para dar soporte al recurso time de forma id\u00e9ntica (con la misma sem\u00e1ntica) que la utilizada en el host .","title":"Tareas entregables"},{"location":"RPI-II/P8/","text":"Pr\u00e1ctica 8. El protocolo LWM2M Objetivos Familiarizarse con el protocolo LWM2M, tanto en la interacci\u00f3n con servidores como en la generaci\u00f3n y definici\u00f3n de objetos y recursos. Familiarizarse con el protocolo de bootstrapping LWM2M y entender su importancia en entornos reales. Conocer dos herramientas para el desarrollo de sistemas basados en LWM2M: Wakaama y Leshan. Experimentar con el proceso de definici\u00f3n de objetos en Wakaama. Observar y poner en marcha un proceso de provisionamiento ( bootstrapping ) usando Wakaama. Desplegar servidores locales LWM2M usando tanto Wakaama como Leshan. El protocolo LWM2M OMA Lightweight M2M (LWM2M) es un protocolo impulsado por la Open Mobile Alliance para la comunicaci\u00f3n M2M entre dispositivos y su gesti\u00f3n en entornos IoT. LWM2M se construye por defecto sobre el protocolo CoAP, y soporta, a nivel de transporte, el protocolo UDP (en versiones recientes soporta tambi\u00e9n otros protocolos de transporte). Entre las funcionalidades b\u00e1sicas de LWM2M destacan la existencia de servidores LWM2M, bootstrapping , control de acceso, gesti\u00f3n de dispositivos, actualizaciones de firmware , localizaci\u00f3n o estad\u00edsticas de conectividad. Adem\u00e1s, soporta seguridad a trav\u00e9s de DTLS. Concretamente, la primera especificaci\u00f3n de LWM2M (versi\u00f3n 1.0) introdujo las siguientes caracter\u00edsticas b\u00e1sicas: Definici\u00f3n de un modelo simple para la definici\u00f3n de recursos, basado en objetos. Definici\u00f3n de operaciones de creaci\u00f3n, consulta, modificaci\u00f3n, borrado y configuraci\u00f3n de recursos. Observaci\u00f3n/notificaci\u00f3n sobre recursos. Soporte para formato de datos JSON, texto plano y TLV. Colas de mensajes para soportar modos de bajo consumo en dispositivos. Soporte para m\u00faltiples servidores LWM2M. Objetos b\u00e1sicos LWM2M: Seguridad, Servidor, Control de Acceso, Dispositivo, Conectividad, Actualizaci\u00f3n de Firmware, Localizaci\u00f3n, Estad\u00edsticas de Conectividad. Para m\u00e1s informaci\u00f3n sobre los objetos predefinidos, consulta el siguiente enlace . Versiones subsiguientes del protocolo (1.1 y 1.2) introdujeron caracter\u00edsticas adicionales, como por ejemplo: Mejora del proceso de bootstrapping . Mejora del soporte para PKI. Soporte para TCP/TLS. Soporte para CBOR. Soporte para MQTT y HTTP como protocolos subyacentes. Implementaciones LWM2M En la presente pr\u00e1ctica, utilizaremos dos paquetes de software pertenecientes al proyecto Eclipse IoT, ambos con soporte completo para LWM2M. Cada uno de ellos presenta ventajas e inconvenientes que es necesario conocer. Eclipse Wakaama Eclipse Wakaama es un conjunto de ficheros fuente escritos en C que permiten ser integrados en cualquier proyecto para proporcionar funcionalidad de cliente , servidor y servidor de bootstrap LWM2M hasta su versi\u00f3n 1.1. En el lado cliente, Wakaama permite la definici\u00f3n de objetos conforme al est\u00e1ndar, as\u00ed como la recepci\u00f3n de comandos desde servidores y su enrutado hacia el objeto u objetos correspondientes. Desde el punto de vista servidor, Wakaama proporciona APIs para enviar comandos a clientes LWM2M registrados. Todo el proyecto es compatible con POSIX, y en esta pr\u00e1ctica experimentaremos con su funcionalidad trabajando desde Linux (modo cliente, servidor y servidor de bootstrap ) y desde el ESP32 (modo cliente). Instalaci\u00f3n Utilizaremos una versi\u00f3n espec\u00edfica que permitir\u00e1 ser ejecutada tanto en Linux como en el ESP32. Para ello, clonamos en primer lugar la versi\u00f3n correspondiente del proyecto (es importante que utilices este commit espec\u00edfico): git clone https://github.com/eclipse/wakaama.git cd wakaama git reset --hard 31d64c0c41fae9653c1fa53ef58d1a44e49017fa El proyecto Wakaama proporciona cuatro componentes que utilizaremos durante la pr\u00e1ctica, todos dentro del directorio examples : bootstrap_server : implementa un servidor de bootstrap con l\u00ednea de comandos propia. client : implementa un cliente complejo, con definici\u00f3n de nueve objetos que siguen las especificaciones de la OMA m\u00e1s uno propio, y soporte para bootstrapping . lightclient : implementa un cliente sencillo, con definici\u00f3n de tres objetos seg\u00fan especificaciones OMA y un cuarto objeto propio. server : implementa un servidor LWM2M que ofrece l\u00ednea de comandos para la interacci\u00f3n con clientes registrados. El modo de compilar cada uno de los ejemplos es exactamente el mismo: Dir\u00edgete al directorio del ejemplo. Crea un directorio build y accede a \u00e9l. Configura el proyecto con la orden cmake .. . Compila el ejemplo con la orden make . Si todo ha ido bien, deber\u00edas tener un binario distinto en el directorio build correspondiente, con los que trabajar\u00e1s el resto de la pr\u00e1ctica. Tarea Compila cada uno de los ejemplos anteriormente mencionados en tu m\u00e1quina virtual, utilizando los par\u00e1metros por defecto para cada uno de ellos. Eclipse Leshan Eclipse Leshan es un proyecto alternativo que proporciona implementaciones en Java de clientes, servidores y servidores de bootstrap LWM2M, y est\u00e1 especialmente dise\u00f1ado para ser adaptable y extensible, permitiendo a los desarrolladores implementar sus propias versiones de cada uno de los tres anteriores elmentos adaptados a sus necesidades espec\u00edficas. Al igual que Wakaama, Leshan proporciona la definici\u00f3n e interacci\u00f3n con objetos IPSO, construcci\u00f3n sobre DTLS y utilizaci\u00f3n de CoAP como protocolo subyacente. Adem\u00e1s, el proyecto proporciona dos servidores de test que resultan muy \u00fatiles a la hora de desarrollar, v\u00e9ase: Servidor LWM2M en leshan.eclipseprojects.io , disponible en coap://leshan.eclipseprojects.io:5683 y coaps://leshan.eclipseprojects.io:5684 . Servidor de bootstrap en leshan.eclipseprojects.io/bs , disponible en coap://leshan.eclipseprojects.io:5783 y coaps://leshan.eclipseprojects.io:5784 . Instalaci\u00f3n Instala en primer lugar los prerequisitos necesarios para la correcta instalaci\u00f3n de Leshan (pueden variar en funci\u00f3n de tu distribuci\u00f3n Linux): sudo apt-get update sudo apt-get install openjdk-17-jdk maven git-core Clona el repositorio oficial de Leshan desde la siguiente direcci\u00f3n: git clone https://github.com/eclipse/leshan.git Por \u00faltimo, compila el proyecto: cd leshan mvn clean install Tras la fase de instalaci\u00f3n, podr\u00e1s lanzar tanto el servidor LWM2M: java -jar leshan-demo-server/target/leshan-demo-server-*-SNAPSHOT-jar-with-dependencies.jar La opci\u00f3n -h te permitir\u00e1 observar la ayuda del servidor. Como el servidor de bootstrapping : java -jar leshan-demo-bsserver/target/leshan-demo-bsserver-*-SNAPSHOT-jar-with-dependencies.jar La opci\u00f3n -h te permitir\u00e1 observar la ayuda del servidor. En ambos casos, la salida asociada a la ejecuci\u00f3n de los servidores nos indicar\u00e1n la URL que podremos consultar desde cualquier navegador para obtener informaci\u00f3n del mismo, as\u00ed como la URL y puerto de escucha de cada uno, que deberemos indicar en los clientes correspondientes. Tarea Instala Eclipse Leshan y arranca el servidor LWM2M. Accede a la p\u00e1gina web de gesti\u00f3n y comprueba que efectivamente funciona. A continucaci\u00f3n, detenlo y haz lo propio con el servidor de bootstrapping . Eclipse Wakaama. Cliente y servidor LWM2M El objetivo principal de esta parte de la pr\u00e1ctica ser\u00e1 disponer de un sistema completo LWM2M basado en un cliente y dos servidores (uno LWM2M, otro de bootstrapping ), todos funcionando bajo Eclipse Wakaama. Para ello, en primer lugar, arrancaremos el servidor Wakaama en una de las terminales. Observa que el servidor, tras arrancar, expone una sencilla l\u00ednea de comandos que podemos aprovechar para interactuar con \u00e9l: ./lwm2mserver > help help Type 'help [COMMAND]' for more details on a command. list List registered clients. read Read from a client. disc Discover resources of a client. write Write to a client. time Write time-related attributes to a client. attr Write value-related attributes to a client. clear Clear attributes of a client. exec Execute a client resource. del Delete a client Object instance. create Create an Object instance. observe Observe from a client. cancel Cancel an observe. q Quit the server. La orden help muestra la ayuda global, pudi\u00e9ndose especializar para cada comando concreto: > help read read CLIENT# URI CLIENT#: client number as returned by command 'list' URI: uri to read such as /3, /3/0/2, /1024/11, /1024/0/1 Result will be displayed asynchronously. Si en este instante listamos un los clientes registrados, veremos que no hay ninguno: > list No client. En segundo lugar, vamos a arrancar el cliente Wakaama. Por defecto, este cliente intentar\u00e1 conectar con un servidor LWM2M existente en localhost , puerto 5683. En cualquier caso, estos valores pueden modificarse en la propia invocaci\u00f3n (consulta la opci\u00f3n -h para m\u00e1s informaci\u00f3n sobre par\u00e1metros disponibles): ./lwm2mclient Trying to bind LWM2M Client to port 56830 LWM2M Client \"testlwm2mclient\" started on port 56830 > Opening connection to server at ::1:5683 -> State: STATE_REGISTERING 13 bytes received from [::1]:5683 64 41 69 06 06 69 E8 86 82 72 64 01 30 dAi..i...rd.0 -> State: STATE_READY > help help Type 'help [COMMAND]' for more details on a command. list List known servers. change Change the value of resource. update Trigger a registration update bootstrap Initiate a DI bootstrap process dispb Display current backup of objects/instances/resources (only security and server objects are backupped) ls List Objects and Instances disp Display current objects/instances/resources dump Dump an Object add Add support of object 31024 rm Remove support of object 31024 quit Quit the client gracefully. ^C Quit the client abruptly (without sending a de-register message). > -> State: STATE_READY Al igual que el servidor, el cliente soporta la introducci\u00f3n de comandos por parte del usuario. Observa que hemos ejecutado el comando help para mostrar los comandos disponibles. Adem\u00e1s, el cliente ha pasado desde un estado STATE_REGISTERING a un estado STATE_READY , lo que significa que se ha registrado correctamente en el servidor con el nombre testlwm2mclient . Observa ahora la salida del servidor, y ver\u00e1s que \u00e9ste ha realizado un proceso de descubrimiento de recursos en el cliente conectado. Concretamente, el servidor reporta la informaci\u00f3n relativa al nuevo cliente conectado: New client #0 registered. Client #0: name: \"testlwm2mclient\" version: \"1.1\" binding: \"UDP\" lifetime: 300 sec objects: /1/0, /2/0, /3/0, /4/0, /5/0, /6/0, /7/0, /31024/10, /31024/11, /31024/12, Concretamente, el n\u00famero asociado al cliente es el 0 . Podemos recuperar esta informaci\u00f3n en todo momento con el comando list en el servidor. En el cliente, puedes seleccionar el nombre que se utilizar\u00e1 en el proceso de registro con la opci\u00f3n -n . Tarea entregable Observa, utilizando Wireshark, el proceso de registro de un cliente en un servidor, y analiza el contenido del mensaje o mensajes intercambiados entre ambos. \u00bfQu\u00e9 protocolos se utilizan? El cliente con el que estamos trabajando es suficientemente complejo en su funcionamiento, y permite observar c\u00f3mo se implementa el soporte tanto para objetos predefinidos por la OMA como para objetos propios. Concretamente, el cliente implementa nueve objetos distintos: Security Object ( id=0 ). Server Object ( id=1 ). Access Control Object ( id=2 ), como un simple esqueleto, sin funcionalidad asociada. Device Object ( id=3 ), que contiene (y devuelve) valores espec\u00edficos codificados en base al ap\u00e9ndice E de la especificaci\u00f3n t\u00e9cnica de LWM2M. Connectivity Monitoring Object ( id=4 ), como un simple esqueleto, sin funcionalidad. Firmware Update Object ( id=5 ), como un simple esqueleto, sin funcionalidad. Location Object ( id=6 ), como un simple esqueleto, sin funcionalidad. Connectivity Statistics Object ( id=7 ), como un simple esqueleto, sin funcionalidad. Test Object ( id=31024 ), con la siguiente descripci\u00f3n: Objetos: Objeto ID Multiples Instancias Obligatorio Test 31024 S\u00ed No Recurso: Nombre ID Operaciones M\u00faltiples Instancias Obligatorio Tipo Rango test 1 R/W No Yes Integer 0-255 exec 2 E No Yes dec 3 R/W No Yes Float En el cliente, el comando dump nos permitir\u00e1 observar el contenido de una instancia determinada de un objeto, o de todas ellas. En el servidor, el comando read nos permitir\u00e1 hacer lo propio. Tarea entregable Analiza el valor actual de los objetos /3 y el objeto de test, tanto desde el cliente (comando dump ) como desde el servidor (comando read ). En \u00faltimo caso, realiza una captura de tr\u00e1fico v\u00eda Wireshark y analiza los mensajes intercambiados entre ambos extremos. Para escribir en un determinado recurso desde el servidor, podemos hacer uso del comando write de la siguiente forma: write 0 /31024/10/1 91 As\u00ed, estar\u00edamos escribiendo en el recurso 1 de la instancia 10 del objeto 31024 el valor entero 91. Tarea entregable Realiza escrituras en objetos del cliente y analiza el nuevo valor, comprobando que efectivamente se han llevado a cabo. Realiza una captura de tr\u00e1fico v\u00eda Wireshark y analiza los mensajes intercambiados entre ambos extremos en el caso de una escritura. Observa tambi\u00e9n que el servidor permite la observaci\u00f3n de recursos espec\u00edficos (comando observe ). Experimenta con esta opci\u00f3n y observa el tr\u00e1fico generado (puedes modificar el valor de un recurso desde el propio cliente y ver qu\u00e9 ocurre en el servidor). Por \u00faltimo, con la orden quit desconectamos del servidor. Observa tambi\u00e9n los mensajes CoAP que se generan en este caso. Definici\u00f3n de un objeto en Eclipse Wakaama Como has podido observar, el ejemplo de cliente define una serie de objetos, algunos especificados por la OMA, y otros personalizados. En este \u00faltimo caso, al que nos referiremos como test_object , se utilizan e ilustran algunas de las funcionalidades b\u00e1sicas de Wakaama como infraestructura para el desarrollo de Smart Objects v\u00eda LWM2M. Observa tanto el c\u00f3digo del cliente LWM2M (fichero fuente lwm2mclient.c del ejemplo client ) como la definici\u00f3n del objeto de test (fichero fuente test_object.c ). El primer fichero implementa la l\u00f3gica principal del cliente, incluyendo gesti\u00f3n de la conexi\u00f3n, l\u00f3gica de an\u00e1lisis de comandos introducidos por el usuario, gesti\u00f3n de bootstrapping , etc. Concretamente, nos interesa analizar las l\u00edneas relativas a la invocaci\u00f3n de la funci\u00f3n get_test_object , en cuyo interior se definen tanto los recursos como el comportamiento de nuestro cliente ante distintos tipos de operaciones sobre ellos. Observa que, al igual que para nuestro objeto de test, existen funciones similares para el resto de objetos definidos (obviamente podr\u00edan existir m\u00e1s), con un fichero fuente donde se define el comportamiento de cada uno de ellos. Uno de estos objetos es test_object.c . La principal funci\u00f3n de entrada a este m\u00f3dulo es precisamente get_test_object() . Observa que, en ella, se define el identificador del objeto, as\u00ed como cada uno de los recursos que expone (en este caso, tres), sus valores iniciales, y las funciones que se utilizar\u00e1n como callbacks asociados a cada posible operaci\u00f3n: lwm2m_object_t * testObj; testObj = (lwm2m_object_t *)lwm2m_malloc(sizeof(lwm2m_object_t)); if (NULL != testObj) { int i; prv_instance_t * targetP; memset(testObj, 0, sizeof(lwm2m_object_t)); testObj->objID = TEST_OBJECT_ID; for (i=0 ; i < 3 ; i++) { targetP = (prv_instance_t *)lwm2m_malloc(sizeof(prv_instance_t)); if (NULL == targetP) return NULL; memset(targetP, 0, sizeof(prv_instance_t)); targetP->shortID = 10 + i; targetP->test = 20 + i; targetP->dec = -30 + i + (double)i/100.0; testObj->instanceList = LWM2M_LIST_ADD(testObj->instanceList, targetP); } /* * From a single instance object, two more functions are available. * - The first one (createFunc) create a new instance and filled it with the provided informations. If an ID is * provided a check is done for verifying his disponibility, or a new one is generated. * - The other one (deleteFunc) delete an instance by removing it from the instance list (and freeing the memory * allocated to it) */ testObj->readFunc = prv_read; testObj->discoverFunc = prv_discover; testObj->writeFunc = prv_write; testObj->executeFunc = prv_exec; testObj->createFunc = prv_create; testObj->deleteFunc = prv_delete; } return testObj; Estas funciones de callback est\u00e1n definidas en el propio fichero, y su contenido es personalizable en funci\u00f3n del dise\u00f1o del objeto. Observemos, por ejemplo, el contenido de la funci\u00f3n asociada a la lectura, prv_read : static uint8_t prv_read(uint16_t instanceId, int * numDataP, lwm2m_data_t ** dataArrayP, lwm2m_object_t * objectP) { prv_instance_t * targetP; int i; targetP = (prv_instance_t *)lwm2m_list_find(objectP->instanceList, instanceId); if (NULL == targetP) return COAP_404_NOT_FOUND; if (*numDataP == 0) { *dataArrayP = lwm2m_data_new(2); if (*dataArrayP == NULL) return COAP_500_INTERNAL_SERVER_ERROR; *numDataP = 2; (*dataArrayP)[0].id = 1; (*dataArrayP)[1].id = 3; } for (i = 0 ; i < *numDataP ; i++) { switch ((*dataArrayP)[i].id) { case 1: lwm2m_data_encode_int(targetP->test, *dataArrayP + i); break; case 2: return COAP_405_METHOD_NOT_ALLOWED; case 3: lwm2m_data_encode_float(targetP->dec, *dataArrayP + i); break; default: return COAP_404_NOT_FOUND; } } return COAP_205_CONTENT; } Observa que en primer lugar se busca la instancia del objeto solicitada, devolvi\u00e9ndose el error correspondiente en caso de no existir (puedes comprobar esta funcionalidad solicitando desde el servidor la lectura de una instancia inexistente). El par\u00e1metro numDataP nos indica el recurso concreto que se desea leer, o todos si dicho valor es 0. Tras tomar el valor actual a servir, \u00e9ste se codifica en funci\u00f3n del tipo de datos predefinido para el recurso espec\u00edfico solicitado. En caso de no estar soportado el m\u00e9todo para un recurso espec\u00edfico, se devuelve el error correspondiente (en este caso 405 ). En caso de solicitar un recurso inexistente, se devuelve el error 404 . Tarea Comprueba que el comportamiento del objeto de test es el esperado, interactuando con \u00e9l desde el servidor utilizando todos los m\u00e9todos disponibles. Puedes modificar su comportamiento, a\u00f1adir invocaciones a rutinas de log , o lo que consideres de utilidad. Eclipse Wakaama. Bootstrapping En este punto, el cliente Wakaama se conecta directamente con el servidor que hemos lanzado, y cuya direcci\u00f3n IP y puerto son los proporcionados por defecto en el c\u00f3digo. Llevado el cliente a un sensor, esto har\u00eda que nunca pudiese variar, durante el ciclo de vida del mismo, el servidor (o servidores) a los que conecta. Esto hace tambi\u00e9n que un cliente pueda \u00fanicamente conectar con un servidor LWM2M, cuando en algunas ocasiones es deseable replicar los mensajes enviados a m\u00faltiples servidores, bien por razones de tolerancia a fallos, o bien por necesidades de la aplicaci\u00f3n. Para solucionar este problema, los firmwares de f\u00e1brica suelen conocer \u00fanicamente la direcci\u00f3n o direcciones fijas de uno o varios servidores de bootstrap que, ante peticiones de provisionamiento, proporcionan al cliente las credenciales de seguridad y las direcciones de los servidores LWM2M en los que deben registrarse. As\u00ed, resulta sencillo manejar din\u00e1micamente ambos aspectos sin necesitar reflashear el firmware del sensor. En nuestro caso, utilizaremos un sencillo servidor de bootstrap proporcionado por Wakaama, aunque Leshan ofrece mecanismos mucho m\u00e1s sofisticados para realizar este mismo proceso, con su propio esqueleto de servidor bootstrap e interfaces REST (con monitores web) para gestionar el proceso. En primer lugar, dir\u00edgete al directorio que contiene el servidor bootstrap de Wakaama. All\u00ed encontrar\u00e1s un fichero de configuraci\u00f3n ( bootstrap_server.ini ) para el proceso de bootstrapping , cuyo contenido es completamente estructurado. El servidor, ante una petici\u00f3n de bootstrapping por parte de un cliente, responde en funci\u00f3n del contenido del fichero, que sigue las siguientes directivas: Las secciones soportadas son [Server] y [Endpoint] . [Server] describe una cuenta en un servidor LWM2M: Las claves soportadas en esta secci\u00f3n son: id: Identificador del servidor. (OBLIGATORIO). uri: URI del servidor LWM2M (OBLIGATORIO). bootstrap: YES o NO. Determina si este servidor es un servidor de bootstrap. Su valor por defecto es NO. lifetime: tiempo de vida del registro (opcional). security: modo de seguridad. Valores soportados: NoSec, PSK, RPK and Certificate (OBLIGATORIO). public: clave p\u00fablica o identidad del cliente, definida por el recurso /0/x/3 . server: clave p\u00fablica del servidor, definida por el recurso /0/x/4 . secret: clave privada definida por el recurso /0/x/5 . [Endpoint] contiene las operaciones de bootstrapping Si no se especifica un nombre (Name) las operaciones se enviar\u00e1n a cualquier cliente desconocido que solicite bootstrapping Si se especifica, las operaciones se enviar\u00e1n s\u00f3lo al cliente con el correspondiente nombre. Las operaciones se env\u00edan en el orden definido en el fichero. Las claves soportadas en esta secci\u00f3n son: - Name: Nombre del cliente (OPCIONAL). - Delete: Debe ser una URI LWM2M v\u00e1lida, incluida / . Env\u00eda una operaci\u00f3n delete en la URI indicada. - Server: [Value] es un ID de servidor que debe existir en la secci\u00f3n correspondiente. Env\u00eda operaciones de escritura sobre el objeto correspondiente del cliente para definir el servidor sobre el que debe conectar. Tarea Analiza e intenta entender el contenido por defecto del fichero de bootstrapping proporcionado. Puedes de momento obviar los par\u00e1metros referentes a seguridad. Tarea entregable Modifica el fichero de configuraci\u00f3n para que, ante la petici\u00f3n de un cliente con nombre determinado, conecte, por este orden, a un servidor LWM2M en la m\u00e1quina local, y al servidor de pruebas de Leshan en Internet. Adem\u00e1s, elimina cualquier intento de borrado de recursos en la informaci\u00f3n de bootstrapping para dicho cliente. Para arrancar el servidor bootstrap , basta con ejecutar (puedes utilizar otro fichero de configuraci\u00f3n): ./build/bootstrap_server -f bootstrap_server.ini El servidor quedar\u00e1 a la espera de peticiones por parte del cualquier cliente en el puerto 5685, tal y como indica su salida. Se puede forzar un proceso de bootstrapping con el comando boot , pero en este punto no es necesario. A continuaci\u00f3n, lanzaremos un cliente indicando que deseamos un proceso de bootstrapping contra el servidor local. Aseg\u00farate de dar un nombre a tu dispositivo que te permita diferenciarlo de cualquier otro : Nota importante Antes de realizar este ejercicio, debes modificar el servidor de prueba por leshan.eclipseprojects.io . ./lwm2mclient -4 -h localhost -p 5685 -b -c -n midispositivo Trying to bind LWM2M Client to port 56830 LWM2M Client \"testlwm2mclient\" started on port 56830 > New Battery Level: 38 value changed! Opening connection to server at localhost:5685 -> State: STATE_BOOTSTRAPPING -> State: STATE_BOOTSTRAPPING -> State: STATE_BOOTSTRAPPING Observa que las opciones de invocaci\u00f3n han cambiado, y hemos usado -b para indicar que deseamos un proceso de bootstrapping contra el servidor proporcionado. Como nota adicional, la opci\u00f3n -c simplemente actualiza de forma peri\u00f3dica la lectura del nivel de bater\u00eda (esto no es en absoluto obligatorio, pero as\u00ed podremos observar sus cambios desde el servidor). Si todo ha ido bien, el cliente estar\u00e1 ahora registrado en dos servidores: el local Wakaama (observa su salida) y el remoto Leshan, al que puedes acceder a trav\u00e9s de la direcci\u00f3n leshan.eclipseprojects.io . Eclipse Leshan. Despliegue de un servidor local En este punto, tu cliente deber\u00eda estar conectado tanto a tu servidor LWM2M Wakaama local, como a un servidor Leshan en la nube. Aprovecha esta situaci\u00f3n para observar las funcionalides del servidor Leshan. Deber\u00edas, para un dispositivo con nombre \"foo\" observar algo como esto: Observa que todos y cada uno de los objetos de los que hablamos anteriormente se muestran ahora en pantalla tras el proceso de registro. Adem\u00e1s, para aquellos que son bien conocidos (estandarizados por la OMA), se muestran nombres legibles, no s\u00f3lo URIs. Tarea Busca y observa el recurso que te indica el nivel de bater\u00eda del cliente, y observa c\u00f3mo se actualiza autom\u00e1ticamente cuando var\u00eda en el cliente (ver\u00e1s a la vez un cambio en el servidor y un mensaje en el cliente). Interact\u00faa con el objeto de test que se defini\u00f3 anteriormente. En todos los casos, observa que, efectivamente, el tr\u00e1fico generado corresponde al esperado. Para replicar dicha instalaci\u00f3n en tu m\u00e1quina local, rescata la instalaci\u00f3n de Leshan que realizaste en la primera parte de la pr\u00e1ctica, y arranca el servidor LWM2M usando la siguiente orden: java -jar leshan-demo-server/target/leshan-demo-server-*-SNAPSHOT-jar-with-dependencies.jar Tarea entregable Arranca el servidor Leshan para que escuche en un puerto diferente al que est\u00e1 escuchando ya el servidor Wakaama, para que puedan convivir en la misma m\u00e1quina. Modifica tu proceso de provisionamiento para que el cliente o clientes se conecten a ambos servidores. Tarea entregable El principal objetivo de esta parte es que seas capaz de definir un objeto e instanciarlo, con una cantidad de recursos suficientemente rica como para observar y ejercitar las capacidades de LWM2M en general, y de Eclipse Wakaama en particular. Por ello, se pide que definas, en primer lugar, uno o m\u00faltiples objetos y sus recursos que podr\u00edan formar parte de un hipot\u00e9tico sensor IoT. En segundo lugar, se pide que, siguiendo las directivas del c\u00f3digo analizado, lo implementes en Eclipse Wakaama y seas capaz de interactuar con \u00e9l desde un servidor Leshan y/o Wakaama utilizando adem\u00e1s un proceso de provisionamiento o bootstrapping . Librer\u00eda Anjay Anjay es una librer\u00eda C que implementa el protocolo OMA LwM2M y est\u00e1 especialmente orientada al desarrollo de clientes en nodos IoT. El proyecto fue creado y es mantenido activamente por AVSystem y la documentaci\u00f3n puede consultarse en el siguiente enlace . Anjay est\u00e1 disponible como componente ESP-IDF y continuaci\u00f3n vamos a probar un cliente para la placa ESP32-DevKitC. Para el ello es preciso descargar el c\u00f3digo mediante los siguietes comandos: git clone https://github.com/AVSystem/Anjay-esp32-client.git cd Anjay-esp32-client git submodule update --init --recursive Tarea Abre el proyecto con la extensi\u00f3n ESP-IDF, config\u00faralo para conectarlo al servidor Leshan local (sin seguridad) y pr\u00faebalo. Presta especial atenci\u00f3n tanto al uso como a la implementaci\u00f3n el objeto push button . Tarea entregable (opcional) Implementar en Anjay el objeto definido en la secci\u00f3n anterior (no es necesario emplear bootstrapping ).","title":"Pr\u00e1ctica 8"},{"location":"RPI-II/P8/#practica-8-el-protocolo-lwm2m","text":"","title":"Pr\u00e1ctica 8. El protocolo LWM2M"},{"location":"RPI-II/P8/#objetivos","text":"Familiarizarse con el protocolo LWM2M, tanto en la interacci\u00f3n con servidores como en la generaci\u00f3n y definici\u00f3n de objetos y recursos. Familiarizarse con el protocolo de bootstrapping LWM2M y entender su importancia en entornos reales. Conocer dos herramientas para el desarrollo de sistemas basados en LWM2M: Wakaama y Leshan. Experimentar con el proceso de definici\u00f3n de objetos en Wakaama. Observar y poner en marcha un proceso de provisionamiento ( bootstrapping ) usando Wakaama. Desplegar servidores locales LWM2M usando tanto Wakaama como Leshan.","title":"Objetivos"},{"location":"RPI-II/P8/#el-protocolo-lwm2m","text":"OMA Lightweight M2M (LWM2M) es un protocolo impulsado por la Open Mobile Alliance para la comunicaci\u00f3n M2M entre dispositivos y su gesti\u00f3n en entornos IoT. LWM2M se construye por defecto sobre el protocolo CoAP, y soporta, a nivel de transporte, el protocolo UDP (en versiones recientes soporta tambi\u00e9n otros protocolos de transporte). Entre las funcionalidades b\u00e1sicas de LWM2M destacan la existencia de servidores LWM2M, bootstrapping , control de acceso, gesti\u00f3n de dispositivos, actualizaciones de firmware , localizaci\u00f3n o estad\u00edsticas de conectividad. Adem\u00e1s, soporta seguridad a trav\u00e9s de DTLS. Concretamente, la primera especificaci\u00f3n de LWM2M (versi\u00f3n 1.0) introdujo las siguientes caracter\u00edsticas b\u00e1sicas: Definici\u00f3n de un modelo simple para la definici\u00f3n de recursos, basado en objetos. Definici\u00f3n de operaciones de creaci\u00f3n, consulta, modificaci\u00f3n, borrado y configuraci\u00f3n de recursos. Observaci\u00f3n/notificaci\u00f3n sobre recursos. Soporte para formato de datos JSON, texto plano y TLV. Colas de mensajes para soportar modos de bajo consumo en dispositivos. Soporte para m\u00faltiples servidores LWM2M. Objetos b\u00e1sicos LWM2M: Seguridad, Servidor, Control de Acceso, Dispositivo, Conectividad, Actualizaci\u00f3n de Firmware, Localizaci\u00f3n, Estad\u00edsticas de Conectividad. Para m\u00e1s informaci\u00f3n sobre los objetos predefinidos, consulta el siguiente enlace . Versiones subsiguientes del protocolo (1.1 y 1.2) introdujeron caracter\u00edsticas adicionales, como por ejemplo: Mejora del proceso de bootstrapping . Mejora del soporte para PKI. Soporte para TCP/TLS. Soporte para CBOR. Soporte para MQTT y HTTP como protocolos subyacentes.","title":"El protocolo LWM2M"},{"location":"RPI-II/P8/#implementaciones-lwm2m","text":"En la presente pr\u00e1ctica, utilizaremos dos paquetes de software pertenecientes al proyecto Eclipse IoT, ambos con soporte completo para LWM2M. Cada uno de ellos presenta ventajas e inconvenientes que es necesario conocer.","title":"Implementaciones LWM2M"},{"location":"RPI-II/P8/#eclipse-wakaama","text":"Eclipse Wakaama es un conjunto de ficheros fuente escritos en C que permiten ser integrados en cualquier proyecto para proporcionar funcionalidad de cliente , servidor y servidor de bootstrap LWM2M hasta su versi\u00f3n 1.1. En el lado cliente, Wakaama permite la definici\u00f3n de objetos conforme al est\u00e1ndar, as\u00ed como la recepci\u00f3n de comandos desde servidores y su enrutado hacia el objeto u objetos correspondientes. Desde el punto de vista servidor, Wakaama proporciona APIs para enviar comandos a clientes LWM2M registrados. Todo el proyecto es compatible con POSIX, y en esta pr\u00e1ctica experimentaremos con su funcionalidad trabajando desde Linux (modo cliente, servidor y servidor de bootstrap ) y desde el ESP32 (modo cliente).","title":"Eclipse Wakaama"},{"location":"RPI-II/P8/#instalacion","text":"Utilizaremos una versi\u00f3n espec\u00edfica que permitir\u00e1 ser ejecutada tanto en Linux como en el ESP32. Para ello, clonamos en primer lugar la versi\u00f3n correspondiente del proyecto (es importante que utilices este commit espec\u00edfico): git clone https://github.com/eclipse/wakaama.git cd wakaama git reset --hard 31d64c0c41fae9653c1fa53ef58d1a44e49017fa El proyecto Wakaama proporciona cuatro componentes que utilizaremos durante la pr\u00e1ctica, todos dentro del directorio examples : bootstrap_server : implementa un servidor de bootstrap con l\u00ednea de comandos propia. client : implementa un cliente complejo, con definici\u00f3n de nueve objetos que siguen las especificaciones de la OMA m\u00e1s uno propio, y soporte para bootstrapping . lightclient : implementa un cliente sencillo, con definici\u00f3n de tres objetos seg\u00fan especificaciones OMA y un cuarto objeto propio. server : implementa un servidor LWM2M que ofrece l\u00ednea de comandos para la interacci\u00f3n con clientes registrados. El modo de compilar cada uno de los ejemplos es exactamente el mismo: Dir\u00edgete al directorio del ejemplo. Crea un directorio build y accede a \u00e9l. Configura el proyecto con la orden cmake .. . Compila el ejemplo con la orden make . Si todo ha ido bien, deber\u00edas tener un binario distinto en el directorio build correspondiente, con los que trabajar\u00e1s el resto de la pr\u00e1ctica. Tarea Compila cada uno de los ejemplos anteriormente mencionados en tu m\u00e1quina virtual, utilizando los par\u00e1metros por defecto para cada uno de ellos.","title":"Instalaci\u00f3n"},{"location":"RPI-II/P8/#eclipse-leshan","text":"Eclipse Leshan es un proyecto alternativo que proporciona implementaciones en Java de clientes, servidores y servidores de bootstrap LWM2M, y est\u00e1 especialmente dise\u00f1ado para ser adaptable y extensible, permitiendo a los desarrolladores implementar sus propias versiones de cada uno de los tres anteriores elmentos adaptados a sus necesidades espec\u00edficas. Al igual que Wakaama, Leshan proporciona la definici\u00f3n e interacci\u00f3n con objetos IPSO, construcci\u00f3n sobre DTLS y utilizaci\u00f3n de CoAP como protocolo subyacente. Adem\u00e1s, el proyecto proporciona dos servidores de test que resultan muy \u00fatiles a la hora de desarrollar, v\u00e9ase: Servidor LWM2M en leshan.eclipseprojects.io , disponible en coap://leshan.eclipseprojects.io:5683 y coaps://leshan.eclipseprojects.io:5684 . Servidor de bootstrap en leshan.eclipseprojects.io/bs , disponible en coap://leshan.eclipseprojects.io:5783 y coaps://leshan.eclipseprojects.io:5784 .","title":"Eclipse Leshan"},{"location":"RPI-II/P8/#instalacion_1","text":"Instala en primer lugar los prerequisitos necesarios para la correcta instalaci\u00f3n de Leshan (pueden variar en funci\u00f3n de tu distribuci\u00f3n Linux): sudo apt-get update sudo apt-get install openjdk-17-jdk maven git-core Clona el repositorio oficial de Leshan desde la siguiente direcci\u00f3n: git clone https://github.com/eclipse/leshan.git Por \u00faltimo, compila el proyecto: cd leshan mvn clean install Tras la fase de instalaci\u00f3n, podr\u00e1s lanzar tanto el servidor LWM2M: java -jar leshan-demo-server/target/leshan-demo-server-*-SNAPSHOT-jar-with-dependencies.jar La opci\u00f3n -h te permitir\u00e1 observar la ayuda del servidor. Como el servidor de bootstrapping : java -jar leshan-demo-bsserver/target/leshan-demo-bsserver-*-SNAPSHOT-jar-with-dependencies.jar La opci\u00f3n -h te permitir\u00e1 observar la ayuda del servidor. En ambos casos, la salida asociada a la ejecuci\u00f3n de los servidores nos indicar\u00e1n la URL que podremos consultar desde cualquier navegador para obtener informaci\u00f3n del mismo, as\u00ed como la URL y puerto de escucha de cada uno, que deberemos indicar en los clientes correspondientes. Tarea Instala Eclipse Leshan y arranca el servidor LWM2M. Accede a la p\u00e1gina web de gesti\u00f3n y comprueba que efectivamente funciona. A continucaci\u00f3n, detenlo y haz lo propio con el servidor de bootstrapping .","title":"Instalaci\u00f3n"},{"location":"RPI-II/P8/#eclipse-wakaama-cliente-y-servidor-lwm2m","text":"El objetivo principal de esta parte de la pr\u00e1ctica ser\u00e1 disponer de un sistema completo LWM2M basado en un cliente y dos servidores (uno LWM2M, otro de bootstrapping ), todos funcionando bajo Eclipse Wakaama. Para ello, en primer lugar, arrancaremos el servidor Wakaama en una de las terminales. Observa que el servidor, tras arrancar, expone una sencilla l\u00ednea de comandos que podemos aprovechar para interactuar con \u00e9l: ./lwm2mserver > help help Type 'help [COMMAND]' for more details on a command. list List registered clients. read Read from a client. disc Discover resources of a client. write Write to a client. time Write time-related attributes to a client. attr Write value-related attributes to a client. clear Clear attributes of a client. exec Execute a client resource. del Delete a client Object instance. create Create an Object instance. observe Observe from a client. cancel Cancel an observe. q Quit the server. La orden help muestra la ayuda global, pudi\u00e9ndose especializar para cada comando concreto: > help read read CLIENT# URI CLIENT#: client number as returned by command 'list' URI: uri to read such as /3, /3/0/2, /1024/11, /1024/0/1 Result will be displayed asynchronously. Si en este instante listamos un los clientes registrados, veremos que no hay ninguno: > list No client. En segundo lugar, vamos a arrancar el cliente Wakaama. Por defecto, este cliente intentar\u00e1 conectar con un servidor LWM2M existente en localhost , puerto 5683. En cualquier caso, estos valores pueden modificarse en la propia invocaci\u00f3n (consulta la opci\u00f3n -h para m\u00e1s informaci\u00f3n sobre par\u00e1metros disponibles): ./lwm2mclient Trying to bind LWM2M Client to port 56830 LWM2M Client \"testlwm2mclient\" started on port 56830 > Opening connection to server at ::1:5683 -> State: STATE_REGISTERING 13 bytes received from [::1]:5683 64 41 69 06 06 69 E8 86 82 72 64 01 30 dAi..i...rd.0 -> State: STATE_READY > help help Type 'help [COMMAND]' for more details on a command. list List known servers. change Change the value of resource. update Trigger a registration update bootstrap Initiate a DI bootstrap process dispb Display current backup of objects/instances/resources (only security and server objects are backupped) ls List Objects and Instances disp Display current objects/instances/resources dump Dump an Object add Add support of object 31024 rm Remove support of object 31024 quit Quit the client gracefully. ^C Quit the client abruptly (without sending a de-register message). > -> State: STATE_READY Al igual que el servidor, el cliente soporta la introducci\u00f3n de comandos por parte del usuario. Observa que hemos ejecutado el comando help para mostrar los comandos disponibles. Adem\u00e1s, el cliente ha pasado desde un estado STATE_REGISTERING a un estado STATE_READY , lo que significa que se ha registrado correctamente en el servidor con el nombre testlwm2mclient . Observa ahora la salida del servidor, y ver\u00e1s que \u00e9ste ha realizado un proceso de descubrimiento de recursos en el cliente conectado. Concretamente, el servidor reporta la informaci\u00f3n relativa al nuevo cliente conectado: New client #0 registered. Client #0: name: \"testlwm2mclient\" version: \"1.1\" binding: \"UDP\" lifetime: 300 sec objects: /1/0, /2/0, /3/0, /4/0, /5/0, /6/0, /7/0, /31024/10, /31024/11, /31024/12, Concretamente, el n\u00famero asociado al cliente es el 0 . Podemos recuperar esta informaci\u00f3n en todo momento con el comando list en el servidor. En el cliente, puedes seleccionar el nombre que se utilizar\u00e1 en el proceso de registro con la opci\u00f3n -n . Tarea entregable Observa, utilizando Wireshark, el proceso de registro de un cliente en un servidor, y analiza el contenido del mensaje o mensajes intercambiados entre ambos. \u00bfQu\u00e9 protocolos se utilizan? El cliente con el que estamos trabajando es suficientemente complejo en su funcionamiento, y permite observar c\u00f3mo se implementa el soporte tanto para objetos predefinidos por la OMA como para objetos propios. Concretamente, el cliente implementa nueve objetos distintos: Security Object ( id=0 ). Server Object ( id=1 ). Access Control Object ( id=2 ), como un simple esqueleto, sin funcionalidad asociada. Device Object ( id=3 ), que contiene (y devuelve) valores espec\u00edficos codificados en base al ap\u00e9ndice E de la especificaci\u00f3n t\u00e9cnica de LWM2M. Connectivity Monitoring Object ( id=4 ), como un simple esqueleto, sin funcionalidad. Firmware Update Object ( id=5 ), como un simple esqueleto, sin funcionalidad. Location Object ( id=6 ), como un simple esqueleto, sin funcionalidad. Connectivity Statistics Object ( id=7 ), como un simple esqueleto, sin funcionalidad. Test Object ( id=31024 ), con la siguiente descripci\u00f3n: Objetos: Objeto ID Multiples Instancias Obligatorio Test 31024 S\u00ed No Recurso: Nombre ID Operaciones M\u00faltiples Instancias Obligatorio Tipo Rango test 1 R/W No Yes Integer 0-255 exec 2 E No Yes dec 3 R/W No Yes Float En el cliente, el comando dump nos permitir\u00e1 observar el contenido de una instancia determinada de un objeto, o de todas ellas. En el servidor, el comando read nos permitir\u00e1 hacer lo propio. Tarea entregable Analiza el valor actual de los objetos /3 y el objeto de test, tanto desde el cliente (comando dump ) como desde el servidor (comando read ). En \u00faltimo caso, realiza una captura de tr\u00e1fico v\u00eda Wireshark y analiza los mensajes intercambiados entre ambos extremos. Para escribir en un determinado recurso desde el servidor, podemos hacer uso del comando write de la siguiente forma: write 0 /31024/10/1 91 As\u00ed, estar\u00edamos escribiendo en el recurso 1 de la instancia 10 del objeto 31024 el valor entero 91. Tarea entregable Realiza escrituras en objetos del cliente y analiza el nuevo valor, comprobando que efectivamente se han llevado a cabo. Realiza una captura de tr\u00e1fico v\u00eda Wireshark y analiza los mensajes intercambiados entre ambos extremos en el caso de una escritura. Observa tambi\u00e9n que el servidor permite la observaci\u00f3n de recursos espec\u00edficos (comando observe ). Experimenta con esta opci\u00f3n y observa el tr\u00e1fico generado (puedes modificar el valor de un recurso desde el propio cliente y ver qu\u00e9 ocurre en el servidor). Por \u00faltimo, con la orden quit desconectamos del servidor. Observa tambi\u00e9n los mensajes CoAP que se generan en este caso.","title":"Eclipse Wakaama. Cliente y servidor LWM2M"},{"location":"RPI-II/P8/#definicion-de-un-objeto-en-eclipse-wakaama","text":"Como has podido observar, el ejemplo de cliente define una serie de objetos, algunos especificados por la OMA, y otros personalizados. En este \u00faltimo caso, al que nos referiremos como test_object , se utilizan e ilustran algunas de las funcionalidades b\u00e1sicas de Wakaama como infraestructura para el desarrollo de Smart Objects v\u00eda LWM2M. Observa tanto el c\u00f3digo del cliente LWM2M (fichero fuente lwm2mclient.c del ejemplo client ) como la definici\u00f3n del objeto de test (fichero fuente test_object.c ). El primer fichero implementa la l\u00f3gica principal del cliente, incluyendo gesti\u00f3n de la conexi\u00f3n, l\u00f3gica de an\u00e1lisis de comandos introducidos por el usuario, gesti\u00f3n de bootstrapping , etc. Concretamente, nos interesa analizar las l\u00edneas relativas a la invocaci\u00f3n de la funci\u00f3n get_test_object , en cuyo interior se definen tanto los recursos como el comportamiento de nuestro cliente ante distintos tipos de operaciones sobre ellos. Observa que, al igual que para nuestro objeto de test, existen funciones similares para el resto de objetos definidos (obviamente podr\u00edan existir m\u00e1s), con un fichero fuente donde se define el comportamiento de cada uno de ellos. Uno de estos objetos es test_object.c . La principal funci\u00f3n de entrada a este m\u00f3dulo es precisamente get_test_object() . Observa que, en ella, se define el identificador del objeto, as\u00ed como cada uno de los recursos que expone (en este caso, tres), sus valores iniciales, y las funciones que se utilizar\u00e1n como callbacks asociados a cada posible operaci\u00f3n: lwm2m_object_t * testObj; testObj = (lwm2m_object_t *)lwm2m_malloc(sizeof(lwm2m_object_t)); if (NULL != testObj) { int i; prv_instance_t * targetP; memset(testObj, 0, sizeof(lwm2m_object_t)); testObj->objID = TEST_OBJECT_ID; for (i=0 ; i < 3 ; i++) { targetP = (prv_instance_t *)lwm2m_malloc(sizeof(prv_instance_t)); if (NULL == targetP) return NULL; memset(targetP, 0, sizeof(prv_instance_t)); targetP->shortID = 10 + i; targetP->test = 20 + i; targetP->dec = -30 + i + (double)i/100.0; testObj->instanceList = LWM2M_LIST_ADD(testObj->instanceList, targetP); } /* * From a single instance object, two more functions are available. * - The first one (createFunc) create a new instance and filled it with the provided informations. If an ID is * provided a check is done for verifying his disponibility, or a new one is generated. * - The other one (deleteFunc) delete an instance by removing it from the instance list (and freeing the memory * allocated to it) */ testObj->readFunc = prv_read; testObj->discoverFunc = prv_discover; testObj->writeFunc = prv_write; testObj->executeFunc = prv_exec; testObj->createFunc = prv_create; testObj->deleteFunc = prv_delete; } return testObj; Estas funciones de callback est\u00e1n definidas en el propio fichero, y su contenido es personalizable en funci\u00f3n del dise\u00f1o del objeto. Observemos, por ejemplo, el contenido de la funci\u00f3n asociada a la lectura, prv_read : static uint8_t prv_read(uint16_t instanceId, int * numDataP, lwm2m_data_t ** dataArrayP, lwm2m_object_t * objectP) { prv_instance_t * targetP; int i; targetP = (prv_instance_t *)lwm2m_list_find(objectP->instanceList, instanceId); if (NULL == targetP) return COAP_404_NOT_FOUND; if (*numDataP == 0) { *dataArrayP = lwm2m_data_new(2); if (*dataArrayP == NULL) return COAP_500_INTERNAL_SERVER_ERROR; *numDataP = 2; (*dataArrayP)[0].id = 1; (*dataArrayP)[1].id = 3; } for (i = 0 ; i < *numDataP ; i++) { switch ((*dataArrayP)[i].id) { case 1: lwm2m_data_encode_int(targetP->test, *dataArrayP + i); break; case 2: return COAP_405_METHOD_NOT_ALLOWED; case 3: lwm2m_data_encode_float(targetP->dec, *dataArrayP + i); break; default: return COAP_404_NOT_FOUND; } } return COAP_205_CONTENT; } Observa que en primer lugar se busca la instancia del objeto solicitada, devolvi\u00e9ndose el error correspondiente en caso de no existir (puedes comprobar esta funcionalidad solicitando desde el servidor la lectura de una instancia inexistente). El par\u00e1metro numDataP nos indica el recurso concreto que se desea leer, o todos si dicho valor es 0. Tras tomar el valor actual a servir, \u00e9ste se codifica en funci\u00f3n del tipo de datos predefinido para el recurso espec\u00edfico solicitado. En caso de no estar soportado el m\u00e9todo para un recurso espec\u00edfico, se devuelve el error correspondiente (en este caso 405 ). En caso de solicitar un recurso inexistente, se devuelve el error 404 . Tarea Comprueba que el comportamiento del objeto de test es el esperado, interactuando con \u00e9l desde el servidor utilizando todos los m\u00e9todos disponibles. Puedes modificar su comportamiento, a\u00f1adir invocaciones a rutinas de log , o lo que consideres de utilidad.","title":"Definici\u00f3n de un objeto en Eclipse Wakaama"},{"location":"RPI-II/P8/#eclipse-wakaama-bootstrapping","text":"En este punto, el cliente Wakaama se conecta directamente con el servidor que hemos lanzado, y cuya direcci\u00f3n IP y puerto son los proporcionados por defecto en el c\u00f3digo. Llevado el cliente a un sensor, esto har\u00eda que nunca pudiese variar, durante el ciclo de vida del mismo, el servidor (o servidores) a los que conecta. Esto hace tambi\u00e9n que un cliente pueda \u00fanicamente conectar con un servidor LWM2M, cuando en algunas ocasiones es deseable replicar los mensajes enviados a m\u00faltiples servidores, bien por razones de tolerancia a fallos, o bien por necesidades de la aplicaci\u00f3n. Para solucionar este problema, los firmwares de f\u00e1brica suelen conocer \u00fanicamente la direcci\u00f3n o direcciones fijas de uno o varios servidores de bootstrap que, ante peticiones de provisionamiento, proporcionan al cliente las credenciales de seguridad y las direcciones de los servidores LWM2M en los que deben registrarse. As\u00ed, resulta sencillo manejar din\u00e1micamente ambos aspectos sin necesitar reflashear el firmware del sensor. En nuestro caso, utilizaremos un sencillo servidor de bootstrap proporcionado por Wakaama, aunque Leshan ofrece mecanismos mucho m\u00e1s sofisticados para realizar este mismo proceso, con su propio esqueleto de servidor bootstrap e interfaces REST (con monitores web) para gestionar el proceso. En primer lugar, dir\u00edgete al directorio que contiene el servidor bootstrap de Wakaama. All\u00ed encontrar\u00e1s un fichero de configuraci\u00f3n ( bootstrap_server.ini ) para el proceso de bootstrapping , cuyo contenido es completamente estructurado. El servidor, ante una petici\u00f3n de bootstrapping por parte de un cliente, responde en funci\u00f3n del contenido del fichero, que sigue las siguientes directivas: Las secciones soportadas son [Server] y [Endpoint] . [Server] describe una cuenta en un servidor LWM2M: Las claves soportadas en esta secci\u00f3n son: id: Identificador del servidor. (OBLIGATORIO). uri: URI del servidor LWM2M (OBLIGATORIO). bootstrap: YES o NO. Determina si este servidor es un servidor de bootstrap. Su valor por defecto es NO. lifetime: tiempo de vida del registro (opcional). security: modo de seguridad. Valores soportados: NoSec, PSK, RPK and Certificate (OBLIGATORIO). public: clave p\u00fablica o identidad del cliente, definida por el recurso /0/x/3 . server: clave p\u00fablica del servidor, definida por el recurso /0/x/4 . secret: clave privada definida por el recurso /0/x/5 . [Endpoint] contiene las operaciones de bootstrapping Si no se especifica un nombre (Name) las operaciones se enviar\u00e1n a cualquier cliente desconocido que solicite bootstrapping Si se especifica, las operaciones se enviar\u00e1n s\u00f3lo al cliente con el correspondiente nombre. Las operaciones se env\u00edan en el orden definido en el fichero. Las claves soportadas en esta secci\u00f3n son: - Name: Nombre del cliente (OPCIONAL). - Delete: Debe ser una URI LWM2M v\u00e1lida, incluida / . Env\u00eda una operaci\u00f3n delete en la URI indicada. - Server: [Value] es un ID de servidor que debe existir en la secci\u00f3n correspondiente. Env\u00eda operaciones de escritura sobre el objeto correspondiente del cliente para definir el servidor sobre el que debe conectar. Tarea Analiza e intenta entender el contenido por defecto del fichero de bootstrapping proporcionado. Puedes de momento obviar los par\u00e1metros referentes a seguridad. Tarea entregable Modifica el fichero de configuraci\u00f3n para que, ante la petici\u00f3n de un cliente con nombre determinado, conecte, por este orden, a un servidor LWM2M en la m\u00e1quina local, y al servidor de pruebas de Leshan en Internet. Adem\u00e1s, elimina cualquier intento de borrado de recursos en la informaci\u00f3n de bootstrapping para dicho cliente. Para arrancar el servidor bootstrap , basta con ejecutar (puedes utilizar otro fichero de configuraci\u00f3n): ./build/bootstrap_server -f bootstrap_server.ini El servidor quedar\u00e1 a la espera de peticiones por parte del cualquier cliente en el puerto 5685, tal y como indica su salida. Se puede forzar un proceso de bootstrapping con el comando boot , pero en este punto no es necesario. A continuaci\u00f3n, lanzaremos un cliente indicando que deseamos un proceso de bootstrapping contra el servidor local. Aseg\u00farate de dar un nombre a tu dispositivo que te permita diferenciarlo de cualquier otro : Nota importante Antes de realizar este ejercicio, debes modificar el servidor de prueba por leshan.eclipseprojects.io . ./lwm2mclient -4 -h localhost -p 5685 -b -c -n midispositivo Trying to bind LWM2M Client to port 56830 LWM2M Client \"testlwm2mclient\" started on port 56830 > New Battery Level: 38 value changed! Opening connection to server at localhost:5685 -> State: STATE_BOOTSTRAPPING -> State: STATE_BOOTSTRAPPING -> State: STATE_BOOTSTRAPPING Observa que las opciones de invocaci\u00f3n han cambiado, y hemos usado -b para indicar que deseamos un proceso de bootstrapping contra el servidor proporcionado. Como nota adicional, la opci\u00f3n -c simplemente actualiza de forma peri\u00f3dica la lectura del nivel de bater\u00eda (esto no es en absoluto obligatorio, pero as\u00ed podremos observar sus cambios desde el servidor). Si todo ha ido bien, el cliente estar\u00e1 ahora registrado en dos servidores: el local Wakaama (observa su salida) y el remoto Leshan, al que puedes acceder a trav\u00e9s de la direcci\u00f3n leshan.eclipseprojects.io .","title":"Eclipse Wakaama. Bootstrapping"},{"location":"RPI-II/P8/#eclipse-leshan-despliegue-de-un-servidor-local","text":"En este punto, tu cliente deber\u00eda estar conectado tanto a tu servidor LWM2M Wakaama local, como a un servidor Leshan en la nube. Aprovecha esta situaci\u00f3n para observar las funcionalides del servidor Leshan. Deber\u00edas, para un dispositivo con nombre \"foo\" observar algo como esto: Observa que todos y cada uno de los objetos de los que hablamos anteriormente se muestran ahora en pantalla tras el proceso de registro. Adem\u00e1s, para aquellos que son bien conocidos (estandarizados por la OMA), se muestran nombres legibles, no s\u00f3lo URIs. Tarea Busca y observa el recurso que te indica el nivel de bater\u00eda del cliente, y observa c\u00f3mo se actualiza autom\u00e1ticamente cuando var\u00eda en el cliente (ver\u00e1s a la vez un cambio en el servidor y un mensaje en el cliente). Interact\u00faa con el objeto de test que se defini\u00f3 anteriormente. En todos los casos, observa que, efectivamente, el tr\u00e1fico generado corresponde al esperado. Para replicar dicha instalaci\u00f3n en tu m\u00e1quina local, rescata la instalaci\u00f3n de Leshan que realizaste en la primera parte de la pr\u00e1ctica, y arranca el servidor LWM2M usando la siguiente orden: java -jar leshan-demo-server/target/leshan-demo-server-*-SNAPSHOT-jar-with-dependencies.jar Tarea entregable Arranca el servidor Leshan para que escuche en un puerto diferente al que est\u00e1 escuchando ya el servidor Wakaama, para que puedan convivir en la misma m\u00e1quina. Modifica tu proceso de provisionamiento para que el cliente o clientes se conecten a ambos servidores. Tarea entregable El principal objetivo de esta parte es que seas capaz de definir un objeto e instanciarlo, con una cantidad de recursos suficientemente rica como para observar y ejercitar las capacidades de LWM2M en general, y de Eclipse Wakaama en particular. Por ello, se pide que definas, en primer lugar, uno o m\u00faltiples objetos y sus recursos que podr\u00edan formar parte de un hipot\u00e9tico sensor IoT. En segundo lugar, se pide que, siguiendo las directivas del c\u00f3digo analizado, lo implementes en Eclipse Wakaama y seas capaz de interactuar con \u00e9l desde un servidor Leshan y/o Wakaama utilizando adem\u00e1s un proceso de provisionamiento o bootstrapping .","title":"Eclipse Leshan. Despliegue de un servidor local"},{"location":"RPI-II/P8/#libreria-anjay","text":"Anjay es una librer\u00eda C que implementa el protocolo OMA LwM2M y est\u00e1 especialmente orientada al desarrollo de clientes en nodos IoT. El proyecto fue creado y es mantenido activamente por AVSystem y la documentaci\u00f3n puede consultarse en el siguiente enlace . Anjay est\u00e1 disponible como componente ESP-IDF y continuaci\u00f3n vamos a probar un cliente para la placa ESP32-DevKitC. Para el ello es preciso descargar el c\u00f3digo mediante los siguietes comandos: git clone https://github.com/AVSystem/Anjay-esp32-client.git cd Anjay-esp32-client git submodule update --init --recursive Tarea Abre el proyecto con la extensi\u00f3n ESP-IDF, config\u00faralo para conectarlo al servidor Leshan local (sin seguridad) y pr\u00faebalo. Presta especial atenci\u00f3n tanto al uso como a la implementaci\u00f3n el objeto push button . Tarea entregable (opcional) Implementar en Anjay el objeto definido en la secci\u00f3n anterior (no es necesario emplear bootstrapping ).","title":"Librer\u00eda Anjay"},{"location":"RPI-II/P8_old/","text":"Pr\u00e1ctica 7. El protocolo LWM2M Objetivos Familiarizarse con el protocolo LWM2M, tanto en la interacci\u00f3n con servidores como en la generaci\u00f3n y definici\u00f3n de objetos y recursos. Familiarizarse con el protocolo de bootstrapping LWM2M y entender su importancia en entornos reales. Conocer dos herramientas para el desarrollo de sistemas basados en LWM2M: Wakaama y Leshan. Experimentar con el proceso de definici\u00f3n de objetos en Wakaama. Observar y poner en marcha un proceso de provisionamiento ( bootstrapping ) usando Wakaama. Desplegar servidores locales LWM2M usando tanto Wakaama como Leshan. El protocolo LWM2M OMA Lightweight M2M (LWM2M) es un protocolo impulsado por la Open Mobile Alliance para la comunicaci\u00f3n M2M entre dispositivos y su gesti\u00f3n en entornos IoT. LWM2M est\u00e1 construido sobre el protocolo CoAP, y soporta, a nivel de transporte, el protocolo UDP (tambi\u00e9n presenta soporte para SMS). Entre las funcionalidades b\u00e1sicas de LWM2M destacan la existencia de servidores LWM2M, bootstrapping , control de acceso, gesti\u00f3n de dispositivos, actualizaciones de firmware , localizaci\u00f3n o estad\u00edsticas de conectividad. Adem\u00e1s, soporta seguridad a trav\u00e9s de DTLS. Concretamente, la primera especificaci\u00f3n de LWM2M (versi\u00f3n 1.0) introdujo las siguientes caracter\u00edsticas b\u00e1sicas: Definici\u00f3n de un modelo simple para la definici\u00f3n de recursos, basado en objetos. Definici\u00f3n de operaciones de creaci\u00f3n, consulta, modificaci\u00f3n, borrado y configuraci\u00f3n de recursos. Observaci\u00f3n/notificaci\u00f3n sobre recursos. Soporte para formato de datos JSON, texto plano y TLV. Colas de mensajes para soportar modos de bajo consumo en dispositivos. Soporte para m\u00faltiples servidores LWM2M. Objetos b\u00e1sicos LWM2M: Seguridad, Servidor, Control de Acceso, Dispositivo, Conectividad, Actualizaci\u00f3n de Firmware, Localizaci\u00f3n, Estad\u00edsticas de Conectividad. Para m\u00e1s informaci\u00f3n sobre los objetos predefinidos, consulta el siguiente enlace . Versiones subsiguientes del protocolo (1.1 y 1.2) introdujeron caracter\u00edsticas adicionales, como por ejemplo: Mejora del proceso de bootstrapping . Mejora del soporte para PKI. Soporte para TCP/TLS. Soporte para CBOR. Soporte para MQTT y HTTP como protocolos subyacentes. Implementaciones LWM2M En la presente pr\u00e1ctica, utilizaremos dos paquetes de software pertenecientes al proyecto Eclipse IoT, ambos con soporte completo para LWM2M. Cada uno de ellos presenta ventajas e inconvenientes que es necesario conocer. Eclipse Wakaama Eclipse Wakaama es un conjunto de ficheros fuente escritos en C que permiten ser integrados en cualquier proyecto para proporcionar funcionalidad de cliente , servidor y servidor de bootstrap LWM2M hasta su versi\u00f3n 1.1. En el lado cliente, Wakaama permite la definici\u00f3n de objetos conforme al est\u00e1ndar, as\u00ed como la recepci\u00f3n de comandos desde servidores y su enrutado hacia el objeto u objetos correspondientes. Desde el punto de vista servidor, Wakaama proporciona APIs para enviar comandos a clientes LWM2M registrados. Todo el proyecto es compatible con POSIX, y en esta pr\u00e1ctica experimentaremos con su funcionalidad trabajando desde Linux (modo cliente, servidor y servidor de bootstrap ) y desde el ESP32 (modo cliente). Instalaci\u00f3n Utilizaremos una versi\u00f3n espec\u00edfica que permitir\u00e1 ser ejecutada tanto en Linux como en el ESP32. Para ello, clonamos en primer lugar la versi\u00f3n correspondiente del proyecto (es importante que utilices este commit espec\u00edfico): git clone https://github.com/eclipse/wakaama.git cd wakaama git reset --hard 31d64c0c41fae9653c1fa53ef58d1a44e49017fa El proyecto Wakaama proporciona cuatro componentes que utilizaremos durante la pr\u00e1ctica, todos dentro del directorio examples : bootstrap_server : implementa un servidor de bootstrap con l\u00ednea de comandos propia. client : implementa un cliente complejo, con definici\u00f3n de nueve objetos que siguen las especificaciones de la OMA m\u00e1s uno propio, y soporte para bootstrapping . lightclient : implementa un cliente sencillo, con definici\u00f3n de tres objetos seg\u00fan especificaciones OMA y un cuarto objeto propio. server : implementa un servidor LWM2M que ofrece l\u00ednea de comandos para la interacci\u00f3n con clientes registrados. El modo de compilar cada uno de los ejemplos es exactamente el mismo: Dir\u00edgete al directorio del ejemplo. Crea un directorio build y accede a \u00e9l. Configura el proyecto con la orden cmake .. . Compila el ejemplo con la orden make . Si todo ha ido bien, deber\u00edas tener un binario distinto en el directorio build correspondiente, con los que trabajar\u00e1s el resto de la pr\u00e1ctica. Tarea Compila cada uno de los ejemplos anteriormente mencionados en tu m\u00e1quina virtual, utilizando los par\u00e1metros por defecto para cada uno de ellos. Eclipse Leshan Eclipse Leshan es un proyecto alternativo que proporciona implementaciones en Java de clientes, servidores y servidores de bootstrap LWM2M, y est\u00e1 especialmente dise\u00f1ado para ser adaptable y extensible, permitiendo a los desarrolladores implementar sus propias versiones de cada uno de los tres anteriores elmentos adaptados a sus necesidades espec\u00edficas. Al igual que Wakaama, Leshan proporciona la definici\u00f3n e interacci\u00f3n con objetos IPSO, construcci\u00f3n sobre DTLS y utilizaci\u00f3n de CoAP como protocolo subyacente. Adem\u00e1s, el proyecto proporciona dos servidores de test que resultan muy \u00fatiles a la hora de desarrollar, v\u00e9ase: Servidor LWM2M en leshan.eclipseprojects.io , disponible en coap://leshan.eclipseprojects.io:5683 y coaps://leshan.eclipseprojects.io:5684 . Servidor de bootstrap en leshan.eclipseprojects.io/bs , disponible en coap://leshan.eclipseprojects.io:5783 y coaps://leshan.eclipseprojects.io:5784 . Instalaci\u00f3n Instala en primer lugar los prerequisitos necesarios para la correcta instalaci\u00f3n de Leshan (pueden variar en funci\u00f3n de tu distribuci\u00f3n Linux): sudo apt-get update sudo apt-get install openjdk-14-jdk maven git-core Clona el repositorio oficial de Leshan desde la siguiente direcci\u00f3n: git clone https://github.com/eclipse/leshan.git Por \u00faltimo, compila el proyecto: cd leshan mvn clean install Tras la fase de instalaci\u00f3n, podr\u00e1s lanzar tanto el servidor LWM2M: java -jar leshan-server-demo/target/leshan-server-demo-*-SNAPSHOT-jar-with-dependencies.jar La opci\u00f3n -h te permitir\u00e1 observar la ayuda del servidor. Como el servidor de bootstrapping : java -jar leshan-bsserver-demo/target/leshan-bsserver-demo-*-SNAPSHOT-jar-with-dependencies.jar La opci\u00f3n -h te permitir\u00e1 observar la ayuda del servidor. En ambos casos, la salida asociada a la ejecuci\u00f3n de los servidores nos indicar\u00e1n la URL que podremos consultar desde cualquier navegador para obtener informaci\u00f3n del mismo, as\u00ed como la URL y puerto de escucha de cada uno, que deberemos indicar en los clientes correspondientes. Tarea Instala Eclipse Leshan y arranca el servidor LWM2M. Accede a la p\u00e1gina web de gesti\u00f3n y comprueba que efectivamente funciona. A continucaci\u00f3n, detenlo y haz lo propio con el servidor de bootstrapping . Eclipse Wakaama. Cliente y servidor LWM2M El objetivo principal de esta parte de la pr\u00e1ctica ser\u00e1 disponer de un sistema completo LWM2M basado en un cliente y dos servidores (uno LWM2M, otro de bootstrapping ), todos funcionando bajo Eclipse Wakaama. Para ello, en primer lugar, arrancaremos el servidor Wakaama en una de las terminales. Observa que el servidor, tras arrancar, expone una sencilla l\u00ednea de comandos que podemos aprovechar para interactuar con \u00e9l: ./lwm2mserver > help help Type 'help [COMMAND]' for more details on a command. list List registered clients. read Read from a client. disc Discover resources of a client. write Write to a client. time Write time-related attributes to a client. attr Write value-related attributes to a client. clear Clear attributes of a client. exec Execute a client resource. del Delete a client Object instance. create Create an Object instance. observe Observe from a client. cancel Cancel an observe. q Quit the server. La orden help muestra la ayuda global, pudi\u00e9ndose especializar para cada comando concreto: > help read read CLIENT# URI CLIENT#: client number as returned by command 'list' URI: uri to read such as /3, /3/0/2, /1024/11, /1024/0/1 Result will be displayed asynchronously. Si en este instante listamos un los clientes registrados, veremos que no hay ninguno: > list No client. En segundo lugar, vamos a arrancar el cliente Wakaama. Por defecto, este cliente intentar\u00e1 conectar con un servidor LWM2M existente en localhost , puerto 5683. En cualquier caso, estos valores pueden modificarse en la propia invocaci\u00f3n (consulta la opci\u00f3n -h para m\u00e1s informaci\u00f3n sobre par\u00e1metros disponibles): ./lwm2mclient Trying to bind LWM2M Client to port 56830 LWM2M Client \"testlwm2mclient\" started on port 56830 > Opening connection to server at ::1:5683 -> State: STATE_REGISTERING 13 bytes received from [::1]:5683 64 41 69 06 06 69 E8 86 82 72 64 01 30 dAi..i...rd.0 -> State: STATE_READY > help help Type 'help [COMMAND]' for more details on a command. list List known servers. change Change the value of resource. update Trigger a registration update bootstrap Initiate a DI bootstrap process dispb Display current backup of objects/instances/resources (only security and server objects are backupped) ls List Objects and Instances disp Display current objects/instances/resources dump Dump an Object add Add support of object 31024 rm Remove support of object 31024 quit Quit the client gracefully. ^C Quit the client abruptly (without sending a de-register message). > -> State: STATE_READY Al igual que el servidor, el cliente soporta la introducci\u00f3n de comandos por parte del usuario. Observa que hemos ejecutado el comando help para mostrar los comandos disponibles. Adem\u00e1s, el cliente ha pasado desde un estado STATE_REGISTERING a un estado STATE_READY , lo que significa que se ha registrado correctamente en el servidor con el nombre testlwm2mclient . Observa ahora la salida del servidor, y ver\u00e1s que \u00e9ste ha realizado un proceso de descubrimiento de recursos en el cliente conectado. Concretamente, el servidor reporta la informaci\u00f3n relativa al nuevo cliente conectado: New client #0 registered. Client #0: name: \"testlwm2mclient\" version: \"1.1\" binding: \"UDP\" lifetime: 300 sec objects: /1/0, /2/0, /3/0, /4/0, /5/0, /6/0, /7/0, /31024/10, /31024/11, /31024/12, Concretamente, el n\u00famero asociado al cliente es el 0 . Podemos recuperar esta informaci\u00f3n en todo momento con el comando list en el servidor. En el cliente, puedes seleccionar el nombre que se utilizar\u00e1 en el proceso de registro con la opci\u00f3n -n . Tarea entregable Observa, utilizando Wireshark, el proceso de registro de un cliente en un servidor, y analiza el contenido del mensaje o mensajes intercambiados entre ambos. \u00bfQu\u00e9 protocolos se utilizan? El cliente con el que estamos trabajando es suficientemente complejo en su funcionamiento, y permite observar c\u00f3mo se implementa el soporte tanto para objetos predefinidos por la OMA como para objetos propios. Concretamente, el cliente implementa nueve objetos distintos: Security Object ( id=0 ). Server Object ( id=1 ). Access Control Object ( id=2 ), como un simple esqueleto, sin funcionalidad asociada. Device Object ( id=3 ), que contiene (y devuelve) valores espec\u00edficos codificados en base al ap\u00e9ndice E de la especificaci\u00f3n t\u00e9cnica de LWM2M. Connectivity Monitoring Object ( id=4 ), como un simple esqueleto, sin funcionalidad. Firmware Update Object ( id=5 ), como un simple esqueleto, sin funcionalidad. Location Object ( id=6 ), como un simple esqueleto, sin funcionalidad. Connectivity Statistics Object ( id=7 ), como un simple esqueleto, sin funcionalidad. Test Object ( id=31024 ), con la siguiente descripci\u00f3n: Objetos: Objeto ID Multiples Instancias Obligatorio Test 31024 S\u00ed No Recurso: Nombre ID Operaciones M\u00faltiples Instancias Obligatorio Tipo Rango test 1 R/W No Yes Integer 0-255 exec 2 E No Yes dec 3 R/W No Yes Float En el cliente, el comando dump nos permitir\u00e1 observar el contenido de una instancia determinada de un objeto, o de todas ellas. En el servidor, el comando read nos permitir\u00e1 hacer lo propio. Tarea entregable Analiza el valor actual de los objetos /3 y el objeto de test, tanto desde el cliente (comando dump ) como desde el servidor (comando read ). En \u00faltimo caso, realiza una captura de tr\u00e1fico v\u00eda Wireshark y analiza los mensajes intercambiados entre ambos extremos. Para escribir en un determinado recurso desde el servidor, podemos hacer uso del comando write de la siguiente forma: write 0 /31024/10/1 91 As\u00ed, estar\u00edamos escribiendo en el recurso 1 de la instancia 10 del objeto 31024 el valor entero 91. Tarea entregable Realiza escrituras en objetos del cliente y analiza el nuevo valor, comprobando que efectivamente se han llevado a cabo. Realiza una captura de tr\u00e1fico v\u00eda Wireshark y analiza los mensajes intercambiados entre ambos extremos en el caso de una escritura. Observa tambi\u00e9n que el servidor permite la observaci\u00f3n de recursos espec\u00edficos (comando observe ). Experimenta con esta opci\u00f3n y observa el tr\u00e1fico generado (puedes modificar el valor de un recurso desde el propio cliente y ver qu\u00e9 ocurre en el servidor). Por \u00faltimo, con la orden quit desconectamos del servidor. Observa tambi\u00e9n los mensajes CoAP que se generan en este caso. Definici\u00f3n de un objeto en Eclipse Wakaama Como has podido observar, el ejemplo de cliente define una serie de objetos, algunos especificados por la OMA, y otros personalizados. En este \u00faltimo caso, al que nos referiremos como test_object , se utilizan e ilustran algunas de las funcionalidades b\u00e1sicas de Wakaama como infraestructura para el desarrollo de Smart Objects v\u00eda LWM2M. Observa tanto el c\u00f3digo del cliente LWM2M (fichero fuente lwm2mclient.c del ejemplo client ) como la definici\u00f3n del objeto de test (fichero fuente test_object.c ). El primer fichero implementa la l\u00f3gica principal del cliente, incluyendo gesti\u00f3n de la conexi\u00f3n, l\u00f3gica de an\u00e1lisis de comandos introducidos por el usuario, gesti\u00f3n de bootstrapping , etc. Concretamente, nos interesa analizar las l\u00edneas relativas a la invocaci\u00f3n de la funci\u00f3n get_test_object , en cuyo interior se definen tanto los recursos como el comportamiento de nuestro cliente ante distintos tipos de operaciones sobre ellos. Observa que, al igual que para nuestro objeto de test, existen funciones similares para el resto de objetos definidos (obviamente podr\u00edan existir m\u00e1s), con un fichero fuente donde se define el comportamiento de cada uno de ellos. Uno de estos objetos es test_object.c . La principal funci\u00f3n de entrada a este m\u00f3dulo es precisamente get_test_object() . Observa que, en ella, se define el identificador del objeto, as\u00ed como cada uno de los recursos que expone (en este caso, tres), sus valores iniciales, y las funciones que se utilizar\u00e1n como callbacks asociados a cada posible operaci\u00f3n: lwm2m_object_t * testObj; testObj = (lwm2m_object_t *)lwm2m_malloc(sizeof(lwm2m_object_t)); if (NULL != testObj) { int i; prv_instance_t * targetP; memset(testObj, 0, sizeof(lwm2m_object_t)); testObj->objID = TEST_OBJECT_ID; for (i=0 ; i < 3 ; i++) { targetP = (prv_instance_t *)lwm2m_malloc(sizeof(prv_instance_t)); if (NULL == targetP) return NULL; memset(targetP, 0, sizeof(prv_instance_t)); targetP->shortID = 10 + i; targetP->test = 20 + i; targetP->dec = -30 + i + (double)i/100.0; testObj->instanceList = LWM2M_LIST_ADD(testObj->instanceList, targetP); } /* * From a single instance object, two more functions are available. * - The first one (createFunc) create a new instance and filled it with the provided informations. If an ID is * provided a check is done for verifying his disponibility, or a new one is generated. * - The other one (deleteFunc) delete an instance by removing it from the instance list (and freeing the memory * allocated to it) */ testObj->readFunc = prv_read; testObj->discoverFunc = prv_discover; testObj->writeFunc = prv_write; testObj->executeFunc = prv_exec; testObj->createFunc = prv_create; testObj->deleteFunc = prv_delete; } return testObj; Estas funciones de callback est\u00e1n definidas en el propio fichero, y su contenido es personalizable en funci\u00f3n del dise\u00f1o del objeto. Observemos, por ejemplo, el contenido de la funci\u00f3n asociada a la lectura, prv_read : static uint8_t prv_read(uint16_t instanceId, int * numDataP, lwm2m_data_t ** dataArrayP, lwm2m_object_t * objectP) { prv_instance_t * targetP; int i; targetP = (prv_instance_t *)lwm2m_list_find(objectP->instanceList, instanceId); if (NULL == targetP) return COAP_404_NOT_FOUND; if (*numDataP == 0) { *dataArrayP = lwm2m_data_new(2); if (*dataArrayP == NULL) return COAP_500_INTERNAL_SERVER_ERROR; *numDataP = 2; (*dataArrayP)[0].id = 1; (*dataArrayP)[1].id = 3; } for (i = 0 ; i < *numDataP ; i++) { switch ((*dataArrayP)[i].id) { case 1: lwm2m_data_encode_int(targetP->test, *dataArrayP + i); break; case 2: return COAP_405_METHOD_NOT_ALLOWED; case 3: lwm2m_data_encode_float(targetP->dec, *dataArrayP + i); break; default: return COAP_404_NOT_FOUND; } } return COAP_205_CONTENT; } Observa que en primer lugar se busca la instancia del objeto solicitada, devolvi\u00e9ndose el error correspondiente en caso de no existir (puedes comprobar esta funcionalidad solicitando desde el servidor la lectura de una instancia inexistente). El par\u00e1metro numDataP nos indica el recurso concreto que se desea leer, o todos si dicho valor es 0. Tras tomar el valor actual a servir, \u00e9ste se codifica en funci\u00f3n del tipo de datos predefinido para el recurso espec\u00edfico solicitado. En caso de no estar soportado el m\u00e9todo para un recurso espec\u00edfico, se devuelve el error correspondiente (en este caso 405 ). En caso de solicitar un recurso inexistente, se devuelve el error 404 . Tarea Comprueba que el comportamiento del objeto de test es el esperado, interactuando con \u00e9l desde el servidor utilizando todos los m\u00e9todos disponibles. Puedes modificar su comportamiento, a\u00f1adir invocaciones a rutinas de log , o lo que consideres de utilidad. Eclipse Wakaama. Bootstrapping En este punto, el cliente Wakaama se conecta directamente con el servidor que hemos lanzado, y cuya direcci\u00f3n IP y puerto son los proporcionados por defecto en el c\u00f3digo. Llevado el cliente a un sensor, esto har\u00eda que nunca pudiese variar, durante el ciclo de vida del mismo, el servidor (o servidores) a los que conecta. Esto hace tambi\u00e9n que un cliente pueda \u00fanicamente conectar con un servidor LWM2M, cuando en algunas ocasiones es deseable replicar los mensajes enviados a m\u00faltiples servidores, bien por razones de tolerancia a fallos, o bien por necesidades de la aplicaci\u00f3n. Para solucionar este problema, los firmwares de f\u00e1brica suelen conocer \u00fanicamente la direcci\u00f3n o direcciones fijas de uno o varios servidores de bootstrap que, ante peticiones de provisionamiento, proporcionan al cliente las credenciales de seguridad y las direcciones de los servidores LWM2M en los que deben registrarse. As\u00ed, resulta sencillo manejar din\u00e1micamente ambos aspectos sin necesitar reflashear el firmware del sensor. En nuestro caso, utilizaremos un sencillo servidor de bootstrap proporcionado por Wakaama, aunque Leshan ofrece mecanismos mucho m\u00e1s sofisticados para realizar este mismo proceso, con su propio esqueleto de servidor bootstrap e interfaces REST (con monitores web) para gestionar el proceso. En primer lugar, dir\u00edgete al directorio que contiene el servidor bootstrap de Wakaama. All\u00ed encontrar\u00e1s un fichero de configuraci\u00f3n ( bootstrap_server.ini ) para el proceso de bootstrapping , cuyo contenido es completamente estructurado. El servidor, ante una petici\u00f3n de bootstrapping por parte de un cliente, responde en funci\u00f3n del contenido del fichero, que sigue las siguientes directivas: Las secciones soportadas son [Server] y [Endpoint] . [Server] describe una cuenta en un servidor LWM2M: Las claves soportadas en esta secci\u00f3n son: id: Identificador del servidor. (OBLIGATORIO). uri: URI del servidor LWM2M (OBLIGATORIO). bootstrap: YES o NO. Determina si este servidor es un servidor de bootstrap. Su valor por defecto es NO. lifetime: tiempo de vida del registro (opcional). security: modo de seguridad. Valores soportados: NoSec, PSK, RPK and Certificate (OBLIGATORIO). public: clave p\u00fablica o identidad del cliente, definida por el recurso /0/x/3 . server: clave p\u00fablica del servidor, definida por el recurso /0/x/4 . secret: clave privada definida por el recurso /0/x/5 . [Endpoint] contiene las operaciones de bootstrapping Si no se especifica un nombre (Name) las operaciones se enviar\u00e1n a cualquier cliente desconocido que solicite bootstrapping Si se especifica, las operaciones se enviar\u00e1n s\u00f3lo al cliente con el correspondiente nombre. Las operaciones se env\u00edan en el orden definido en el fichero. Las claves soportadas en esta secci\u00f3n son: - Name: Nombre del cliente (OPCIONAL). - Delete: Debe ser una URI LWM2M v\u00e1lida, incluida / . Env\u00eda una operaci\u00f3n delete en la URI indicada. - Server: [Value] es un ID de servidor que debe existir en la secci\u00f3n correspondiente. Env\u00eda operaciones de escritura sobre el objeto correspondiente del cliente para definir el servidor sobre el que debe conectar. Tarea Analiza e intenta entender el contenido por defecto del fichero de bootstrapping proporcionado. Puedes de momento obviar los par\u00e1metros referentes a seguridad, ya que los trataremos en la pr\u00f3xima pr\u00e1ctica. Tarea entregable Modifica el fichero de configuraci\u00f3n para que, ante la petici\u00f3n de un cliente con nombre determinado, conecte, por este orden, a un servidor LWM2M en la m\u00e1quina local, y al servidor de pruebas de Leshan en Internet. Adem\u00e1s, elimina cualquier intento de borrado de recursos en la informaci\u00f3n de bootstrapping para dicho cliente. Para arrancar el servidor bootstrap , basta con ejecutar (puedes utilizar otro fichero de configuraci\u00f3n): ./build/bootstrap_server -f bootstrap_server.ini El servidor quedar\u00e1 a la espera de peticiones por parte del cualquier cliente en el puerto 5685, tal y como indica su salida. Se puede forzar un proceso de bootstrapping con el comando boot , pero en este punto no es necesario. A continuaci\u00f3n, lanzaremos un cliente indicando que deseamos un proceso de bootstrapping contra el servidor local. Aseg\u00farate de dar un nombre a tu dispositivo que te permita diferenciarlo de cualquier otro : Nota importante Antes de realizar este ejercicio, debes modificar una l\u00ednea del fichero lwm2mclient.c , reemplazando la l\u00ednea que contiene data.addressFamily = AF_INET6; por data.addressFamily = AF_INET; . ./lwm2mclient -h localhost -p 5685 -b -c -n midispositivo Trying to bind LWM2M Client to port 56830 LWM2M Client \"testlwm2mclient\" started on port 56830 > New Battery Level: 38 value changed! Opening connection to server at localhost:5685 -> State: STATE_BOOTSTRAPPING -> State: STATE_BOOTSTRAPPING -> State: STATE_BOOTSTRAPPING Observa que las opciones de invocaci\u00f3n han cambiado, y hemos usado -b para indicar que deseamos un proceso de bootstrapping contra el servidor proporcionado. Como nota adicional, la opci\u00f3n -c simplemente actualiza de forma peri\u00f3dica la lectura del nivel de bater\u00eda (esto no es en absoluto obligatorio, pero as\u00ed podremos observar sus cambios desde el servidor). Si todo ha ido bien, el cliente estar\u00e1 ahora registrado en dos servidores: el local Wakaama (observa su salida) y el remoto Leshan, al que puedes acceder a trav\u00e9s de la direcci\u00f3n leshan.eclipseprojects.io . Eclipse Leshan. Despliegue de un servidor local En este punto, tu cliente deber\u00eda estar conectado tanto a tu servidor LWM2M Wakaama local, como a un servidor Leshan en la nube. Aprovecha esta situaci\u00f3n para observar las funcionalides del servidor Leshan. Deber\u00edas, para un dispositivo con nombre \"foo\" observar algo como esto: Observa que todos y cada uno de los objetos de los que hablamos anteriormente se muestran ahora en pantalla tras el proceso de registro. Adem\u00e1s, para aquellos que son bien conocidos (estandarizados por la OMA), se muestran nombres legibles, no s\u00f3lo URIs. Tarea Busca y observa el recurso que te indica el nivel de bater\u00eda del cliente, y observa c\u00f3mo se actualiza autom\u00e1ticamente cuando var\u00eda en el cliente (ver\u00e1s a la vez un cambio en el servidor y un mensaje en el cliente). Interact\u00faa con el objeto de test que se defini\u00f3 anteriormente. En todos los casos, observa que, efectivamente, el tr\u00e1fico generado corresponde al esperado. Para replicar dicha instalaci\u00f3n en tu m\u00e1quina local, rescata la instalaci\u00f3n de Leshan que realizaste en la primera parte de la pr\u00e1ctica, y arranca el servidor LWM2M usando la siguiente orden: java -jar leshan-server-demo/target/leshan-server-demo-*-SNAPSHOT-jar-with-dependencies.jar Tarea entregable Arranca el servidor Leshan para que escuche en un puerto diferente al que est\u00e1 escuchando ya el servidor Wakaama, para que puedan convivir en la misma m\u00e1quina. Modifica tu proceso de provisionamiento para que el cliente o clientes se conecten a ambos servidores. Tarea entregable El principal objetivo de esta parte es que seas capaz de definir un objeto e instanciarlo, con una cantidad de recursos suficientemente rica como para observar y ejercitar las capacidades de LWM2M en general, y de Eclipse Wakaama en particular. Por ello, se pide que definas, en primer lugar, uno o m\u00faltiples objetos y sus recursos que podr\u00edan formar parte de un hipot\u00e9tico sensor IoT. En segundo lugar, se pide que, siguiendo las directivas del c\u00f3digo analizado, lo implementes en Eclipse Wakaama y seas capaz de interactuar con \u00e9l desde un servidor Leshan y/o Wakaama utilizando adem\u00e1s un proceso de provisionamiento o bootstrapping .","title":"Pr\u00e1ctica 7. El protocolo LWM2M"},{"location":"RPI-II/P8_old/#practica-7-el-protocolo-lwm2m","text":"","title":"Pr\u00e1ctica 7. El protocolo LWM2M"},{"location":"RPI-II/P8_old/#objetivos","text":"Familiarizarse con el protocolo LWM2M, tanto en la interacci\u00f3n con servidores como en la generaci\u00f3n y definici\u00f3n de objetos y recursos. Familiarizarse con el protocolo de bootstrapping LWM2M y entender su importancia en entornos reales. Conocer dos herramientas para el desarrollo de sistemas basados en LWM2M: Wakaama y Leshan. Experimentar con el proceso de definici\u00f3n de objetos en Wakaama. Observar y poner en marcha un proceso de provisionamiento ( bootstrapping ) usando Wakaama. Desplegar servidores locales LWM2M usando tanto Wakaama como Leshan.","title":"Objetivos"},{"location":"RPI-II/P8_old/#el-protocolo-lwm2m","text":"OMA Lightweight M2M (LWM2M) es un protocolo impulsado por la Open Mobile Alliance para la comunicaci\u00f3n M2M entre dispositivos y su gesti\u00f3n en entornos IoT. LWM2M est\u00e1 construido sobre el protocolo CoAP, y soporta, a nivel de transporte, el protocolo UDP (tambi\u00e9n presenta soporte para SMS). Entre las funcionalidades b\u00e1sicas de LWM2M destacan la existencia de servidores LWM2M, bootstrapping , control de acceso, gesti\u00f3n de dispositivos, actualizaciones de firmware , localizaci\u00f3n o estad\u00edsticas de conectividad. Adem\u00e1s, soporta seguridad a trav\u00e9s de DTLS. Concretamente, la primera especificaci\u00f3n de LWM2M (versi\u00f3n 1.0) introdujo las siguientes caracter\u00edsticas b\u00e1sicas: Definici\u00f3n de un modelo simple para la definici\u00f3n de recursos, basado en objetos. Definici\u00f3n de operaciones de creaci\u00f3n, consulta, modificaci\u00f3n, borrado y configuraci\u00f3n de recursos. Observaci\u00f3n/notificaci\u00f3n sobre recursos. Soporte para formato de datos JSON, texto plano y TLV. Colas de mensajes para soportar modos de bajo consumo en dispositivos. Soporte para m\u00faltiples servidores LWM2M. Objetos b\u00e1sicos LWM2M: Seguridad, Servidor, Control de Acceso, Dispositivo, Conectividad, Actualizaci\u00f3n de Firmware, Localizaci\u00f3n, Estad\u00edsticas de Conectividad. Para m\u00e1s informaci\u00f3n sobre los objetos predefinidos, consulta el siguiente enlace . Versiones subsiguientes del protocolo (1.1 y 1.2) introdujeron caracter\u00edsticas adicionales, como por ejemplo: Mejora del proceso de bootstrapping . Mejora del soporte para PKI. Soporte para TCP/TLS. Soporte para CBOR. Soporte para MQTT y HTTP como protocolos subyacentes.","title":"El protocolo LWM2M"},{"location":"RPI-II/P8_old/#implementaciones-lwm2m","text":"En la presente pr\u00e1ctica, utilizaremos dos paquetes de software pertenecientes al proyecto Eclipse IoT, ambos con soporte completo para LWM2M. Cada uno de ellos presenta ventajas e inconvenientes que es necesario conocer.","title":"Implementaciones LWM2M"},{"location":"RPI-II/P8_old/#eclipse-wakaama","text":"Eclipse Wakaama es un conjunto de ficheros fuente escritos en C que permiten ser integrados en cualquier proyecto para proporcionar funcionalidad de cliente , servidor y servidor de bootstrap LWM2M hasta su versi\u00f3n 1.1. En el lado cliente, Wakaama permite la definici\u00f3n de objetos conforme al est\u00e1ndar, as\u00ed como la recepci\u00f3n de comandos desde servidores y su enrutado hacia el objeto u objetos correspondientes. Desde el punto de vista servidor, Wakaama proporciona APIs para enviar comandos a clientes LWM2M registrados. Todo el proyecto es compatible con POSIX, y en esta pr\u00e1ctica experimentaremos con su funcionalidad trabajando desde Linux (modo cliente, servidor y servidor de bootstrap ) y desde el ESP32 (modo cliente).","title":"Eclipse Wakaama"},{"location":"RPI-II/P8_old/#instalacion","text":"Utilizaremos una versi\u00f3n espec\u00edfica que permitir\u00e1 ser ejecutada tanto en Linux como en el ESP32. Para ello, clonamos en primer lugar la versi\u00f3n correspondiente del proyecto (es importante que utilices este commit espec\u00edfico): git clone https://github.com/eclipse/wakaama.git cd wakaama git reset --hard 31d64c0c41fae9653c1fa53ef58d1a44e49017fa El proyecto Wakaama proporciona cuatro componentes que utilizaremos durante la pr\u00e1ctica, todos dentro del directorio examples : bootstrap_server : implementa un servidor de bootstrap con l\u00ednea de comandos propia. client : implementa un cliente complejo, con definici\u00f3n de nueve objetos que siguen las especificaciones de la OMA m\u00e1s uno propio, y soporte para bootstrapping . lightclient : implementa un cliente sencillo, con definici\u00f3n de tres objetos seg\u00fan especificaciones OMA y un cuarto objeto propio. server : implementa un servidor LWM2M que ofrece l\u00ednea de comandos para la interacci\u00f3n con clientes registrados. El modo de compilar cada uno de los ejemplos es exactamente el mismo: Dir\u00edgete al directorio del ejemplo. Crea un directorio build y accede a \u00e9l. Configura el proyecto con la orden cmake .. . Compila el ejemplo con la orden make . Si todo ha ido bien, deber\u00edas tener un binario distinto en el directorio build correspondiente, con los que trabajar\u00e1s el resto de la pr\u00e1ctica. Tarea Compila cada uno de los ejemplos anteriormente mencionados en tu m\u00e1quina virtual, utilizando los par\u00e1metros por defecto para cada uno de ellos.","title":"Instalaci\u00f3n"},{"location":"RPI-II/P8_old/#eclipse-leshan","text":"Eclipse Leshan es un proyecto alternativo que proporciona implementaciones en Java de clientes, servidores y servidores de bootstrap LWM2M, y est\u00e1 especialmente dise\u00f1ado para ser adaptable y extensible, permitiendo a los desarrolladores implementar sus propias versiones de cada uno de los tres anteriores elmentos adaptados a sus necesidades espec\u00edficas. Al igual que Wakaama, Leshan proporciona la definici\u00f3n e interacci\u00f3n con objetos IPSO, construcci\u00f3n sobre DTLS y utilizaci\u00f3n de CoAP como protocolo subyacente. Adem\u00e1s, el proyecto proporciona dos servidores de test que resultan muy \u00fatiles a la hora de desarrollar, v\u00e9ase: Servidor LWM2M en leshan.eclipseprojects.io , disponible en coap://leshan.eclipseprojects.io:5683 y coaps://leshan.eclipseprojects.io:5684 . Servidor de bootstrap en leshan.eclipseprojects.io/bs , disponible en coap://leshan.eclipseprojects.io:5783 y coaps://leshan.eclipseprojects.io:5784 .","title":"Eclipse Leshan"},{"location":"RPI-II/P8_old/#instalacion_1","text":"Instala en primer lugar los prerequisitos necesarios para la correcta instalaci\u00f3n de Leshan (pueden variar en funci\u00f3n de tu distribuci\u00f3n Linux): sudo apt-get update sudo apt-get install openjdk-14-jdk maven git-core Clona el repositorio oficial de Leshan desde la siguiente direcci\u00f3n: git clone https://github.com/eclipse/leshan.git Por \u00faltimo, compila el proyecto: cd leshan mvn clean install Tras la fase de instalaci\u00f3n, podr\u00e1s lanzar tanto el servidor LWM2M: java -jar leshan-server-demo/target/leshan-server-demo-*-SNAPSHOT-jar-with-dependencies.jar La opci\u00f3n -h te permitir\u00e1 observar la ayuda del servidor. Como el servidor de bootstrapping : java -jar leshan-bsserver-demo/target/leshan-bsserver-demo-*-SNAPSHOT-jar-with-dependencies.jar La opci\u00f3n -h te permitir\u00e1 observar la ayuda del servidor. En ambos casos, la salida asociada a la ejecuci\u00f3n de los servidores nos indicar\u00e1n la URL que podremos consultar desde cualquier navegador para obtener informaci\u00f3n del mismo, as\u00ed como la URL y puerto de escucha de cada uno, que deberemos indicar en los clientes correspondientes. Tarea Instala Eclipse Leshan y arranca el servidor LWM2M. Accede a la p\u00e1gina web de gesti\u00f3n y comprueba que efectivamente funciona. A continucaci\u00f3n, detenlo y haz lo propio con el servidor de bootstrapping .","title":"Instalaci\u00f3n"},{"location":"RPI-II/P8_old/#eclipse-wakaama-cliente-y-servidor-lwm2m","text":"El objetivo principal de esta parte de la pr\u00e1ctica ser\u00e1 disponer de un sistema completo LWM2M basado en un cliente y dos servidores (uno LWM2M, otro de bootstrapping ), todos funcionando bajo Eclipse Wakaama. Para ello, en primer lugar, arrancaremos el servidor Wakaama en una de las terminales. Observa que el servidor, tras arrancar, expone una sencilla l\u00ednea de comandos que podemos aprovechar para interactuar con \u00e9l: ./lwm2mserver > help help Type 'help [COMMAND]' for more details on a command. list List registered clients. read Read from a client. disc Discover resources of a client. write Write to a client. time Write time-related attributes to a client. attr Write value-related attributes to a client. clear Clear attributes of a client. exec Execute a client resource. del Delete a client Object instance. create Create an Object instance. observe Observe from a client. cancel Cancel an observe. q Quit the server. La orden help muestra la ayuda global, pudi\u00e9ndose especializar para cada comando concreto: > help read read CLIENT# URI CLIENT#: client number as returned by command 'list' URI: uri to read such as /3, /3/0/2, /1024/11, /1024/0/1 Result will be displayed asynchronously. Si en este instante listamos un los clientes registrados, veremos que no hay ninguno: > list No client. En segundo lugar, vamos a arrancar el cliente Wakaama. Por defecto, este cliente intentar\u00e1 conectar con un servidor LWM2M existente en localhost , puerto 5683. En cualquier caso, estos valores pueden modificarse en la propia invocaci\u00f3n (consulta la opci\u00f3n -h para m\u00e1s informaci\u00f3n sobre par\u00e1metros disponibles): ./lwm2mclient Trying to bind LWM2M Client to port 56830 LWM2M Client \"testlwm2mclient\" started on port 56830 > Opening connection to server at ::1:5683 -> State: STATE_REGISTERING 13 bytes received from [::1]:5683 64 41 69 06 06 69 E8 86 82 72 64 01 30 dAi..i...rd.0 -> State: STATE_READY > help help Type 'help [COMMAND]' for more details on a command. list List known servers. change Change the value of resource. update Trigger a registration update bootstrap Initiate a DI bootstrap process dispb Display current backup of objects/instances/resources (only security and server objects are backupped) ls List Objects and Instances disp Display current objects/instances/resources dump Dump an Object add Add support of object 31024 rm Remove support of object 31024 quit Quit the client gracefully. ^C Quit the client abruptly (without sending a de-register message). > -> State: STATE_READY Al igual que el servidor, el cliente soporta la introducci\u00f3n de comandos por parte del usuario. Observa que hemos ejecutado el comando help para mostrar los comandos disponibles. Adem\u00e1s, el cliente ha pasado desde un estado STATE_REGISTERING a un estado STATE_READY , lo que significa que se ha registrado correctamente en el servidor con el nombre testlwm2mclient . Observa ahora la salida del servidor, y ver\u00e1s que \u00e9ste ha realizado un proceso de descubrimiento de recursos en el cliente conectado. Concretamente, el servidor reporta la informaci\u00f3n relativa al nuevo cliente conectado: New client #0 registered. Client #0: name: \"testlwm2mclient\" version: \"1.1\" binding: \"UDP\" lifetime: 300 sec objects: /1/0, /2/0, /3/0, /4/0, /5/0, /6/0, /7/0, /31024/10, /31024/11, /31024/12, Concretamente, el n\u00famero asociado al cliente es el 0 . Podemos recuperar esta informaci\u00f3n en todo momento con el comando list en el servidor. En el cliente, puedes seleccionar el nombre que se utilizar\u00e1 en el proceso de registro con la opci\u00f3n -n . Tarea entregable Observa, utilizando Wireshark, el proceso de registro de un cliente en un servidor, y analiza el contenido del mensaje o mensajes intercambiados entre ambos. \u00bfQu\u00e9 protocolos se utilizan? El cliente con el que estamos trabajando es suficientemente complejo en su funcionamiento, y permite observar c\u00f3mo se implementa el soporte tanto para objetos predefinidos por la OMA como para objetos propios. Concretamente, el cliente implementa nueve objetos distintos: Security Object ( id=0 ). Server Object ( id=1 ). Access Control Object ( id=2 ), como un simple esqueleto, sin funcionalidad asociada. Device Object ( id=3 ), que contiene (y devuelve) valores espec\u00edficos codificados en base al ap\u00e9ndice E de la especificaci\u00f3n t\u00e9cnica de LWM2M. Connectivity Monitoring Object ( id=4 ), como un simple esqueleto, sin funcionalidad. Firmware Update Object ( id=5 ), como un simple esqueleto, sin funcionalidad. Location Object ( id=6 ), como un simple esqueleto, sin funcionalidad. Connectivity Statistics Object ( id=7 ), como un simple esqueleto, sin funcionalidad. Test Object ( id=31024 ), con la siguiente descripci\u00f3n: Objetos: Objeto ID Multiples Instancias Obligatorio Test 31024 S\u00ed No Recurso: Nombre ID Operaciones M\u00faltiples Instancias Obligatorio Tipo Rango test 1 R/W No Yes Integer 0-255 exec 2 E No Yes dec 3 R/W No Yes Float En el cliente, el comando dump nos permitir\u00e1 observar el contenido de una instancia determinada de un objeto, o de todas ellas. En el servidor, el comando read nos permitir\u00e1 hacer lo propio. Tarea entregable Analiza el valor actual de los objetos /3 y el objeto de test, tanto desde el cliente (comando dump ) como desde el servidor (comando read ). En \u00faltimo caso, realiza una captura de tr\u00e1fico v\u00eda Wireshark y analiza los mensajes intercambiados entre ambos extremos. Para escribir en un determinado recurso desde el servidor, podemos hacer uso del comando write de la siguiente forma: write 0 /31024/10/1 91 As\u00ed, estar\u00edamos escribiendo en el recurso 1 de la instancia 10 del objeto 31024 el valor entero 91. Tarea entregable Realiza escrituras en objetos del cliente y analiza el nuevo valor, comprobando que efectivamente se han llevado a cabo. Realiza una captura de tr\u00e1fico v\u00eda Wireshark y analiza los mensajes intercambiados entre ambos extremos en el caso de una escritura. Observa tambi\u00e9n que el servidor permite la observaci\u00f3n de recursos espec\u00edficos (comando observe ). Experimenta con esta opci\u00f3n y observa el tr\u00e1fico generado (puedes modificar el valor de un recurso desde el propio cliente y ver qu\u00e9 ocurre en el servidor). Por \u00faltimo, con la orden quit desconectamos del servidor. Observa tambi\u00e9n los mensajes CoAP que se generan en este caso.","title":"Eclipse Wakaama. Cliente y servidor LWM2M"},{"location":"RPI-II/P8_old/#definicion-de-un-objeto-en-eclipse-wakaama","text":"Como has podido observar, el ejemplo de cliente define una serie de objetos, algunos especificados por la OMA, y otros personalizados. En este \u00faltimo caso, al que nos referiremos como test_object , se utilizan e ilustran algunas de las funcionalidades b\u00e1sicas de Wakaama como infraestructura para el desarrollo de Smart Objects v\u00eda LWM2M. Observa tanto el c\u00f3digo del cliente LWM2M (fichero fuente lwm2mclient.c del ejemplo client ) como la definici\u00f3n del objeto de test (fichero fuente test_object.c ). El primer fichero implementa la l\u00f3gica principal del cliente, incluyendo gesti\u00f3n de la conexi\u00f3n, l\u00f3gica de an\u00e1lisis de comandos introducidos por el usuario, gesti\u00f3n de bootstrapping , etc. Concretamente, nos interesa analizar las l\u00edneas relativas a la invocaci\u00f3n de la funci\u00f3n get_test_object , en cuyo interior se definen tanto los recursos como el comportamiento de nuestro cliente ante distintos tipos de operaciones sobre ellos. Observa que, al igual que para nuestro objeto de test, existen funciones similares para el resto de objetos definidos (obviamente podr\u00edan existir m\u00e1s), con un fichero fuente donde se define el comportamiento de cada uno de ellos. Uno de estos objetos es test_object.c . La principal funci\u00f3n de entrada a este m\u00f3dulo es precisamente get_test_object() . Observa que, en ella, se define el identificador del objeto, as\u00ed como cada uno de los recursos que expone (en este caso, tres), sus valores iniciales, y las funciones que se utilizar\u00e1n como callbacks asociados a cada posible operaci\u00f3n: lwm2m_object_t * testObj; testObj = (lwm2m_object_t *)lwm2m_malloc(sizeof(lwm2m_object_t)); if (NULL != testObj) { int i; prv_instance_t * targetP; memset(testObj, 0, sizeof(lwm2m_object_t)); testObj->objID = TEST_OBJECT_ID; for (i=0 ; i < 3 ; i++) { targetP = (prv_instance_t *)lwm2m_malloc(sizeof(prv_instance_t)); if (NULL == targetP) return NULL; memset(targetP, 0, sizeof(prv_instance_t)); targetP->shortID = 10 + i; targetP->test = 20 + i; targetP->dec = -30 + i + (double)i/100.0; testObj->instanceList = LWM2M_LIST_ADD(testObj->instanceList, targetP); } /* * From a single instance object, two more functions are available. * - The first one (createFunc) create a new instance and filled it with the provided informations. If an ID is * provided a check is done for verifying his disponibility, or a new one is generated. * - The other one (deleteFunc) delete an instance by removing it from the instance list (and freeing the memory * allocated to it) */ testObj->readFunc = prv_read; testObj->discoverFunc = prv_discover; testObj->writeFunc = prv_write; testObj->executeFunc = prv_exec; testObj->createFunc = prv_create; testObj->deleteFunc = prv_delete; } return testObj; Estas funciones de callback est\u00e1n definidas en el propio fichero, y su contenido es personalizable en funci\u00f3n del dise\u00f1o del objeto. Observemos, por ejemplo, el contenido de la funci\u00f3n asociada a la lectura, prv_read : static uint8_t prv_read(uint16_t instanceId, int * numDataP, lwm2m_data_t ** dataArrayP, lwm2m_object_t * objectP) { prv_instance_t * targetP; int i; targetP = (prv_instance_t *)lwm2m_list_find(objectP->instanceList, instanceId); if (NULL == targetP) return COAP_404_NOT_FOUND; if (*numDataP == 0) { *dataArrayP = lwm2m_data_new(2); if (*dataArrayP == NULL) return COAP_500_INTERNAL_SERVER_ERROR; *numDataP = 2; (*dataArrayP)[0].id = 1; (*dataArrayP)[1].id = 3; } for (i = 0 ; i < *numDataP ; i++) { switch ((*dataArrayP)[i].id) { case 1: lwm2m_data_encode_int(targetP->test, *dataArrayP + i); break; case 2: return COAP_405_METHOD_NOT_ALLOWED; case 3: lwm2m_data_encode_float(targetP->dec, *dataArrayP + i); break; default: return COAP_404_NOT_FOUND; } } return COAP_205_CONTENT; } Observa que en primer lugar se busca la instancia del objeto solicitada, devolvi\u00e9ndose el error correspondiente en caso de no existir (puedes comprobar esta funcionalidad solicitando desde el servidor la lectura de una instancia inexistente). El par\u00e1metro numDataP nos indica el recurso concreto que se desea leer, o todos si dicho valor es 0. Tras tomar el valor actual a servir, \u00e9ste se codifica en funci\u00f3n del tipo de datos predefinido para el recurso espec\u00edfico solicitado. En caso de no estar soportado el m\u00e9todo para un recurso espec\u00edfico, se devuelve el error correspondiente (en este caso 405 ). En caso de solicitar un recurso inexistente, se devuelve el error 404 . Tarea Comprueba que el comportamiento del objeto de test es el esperado, interactuando con \u00e9l desde el servidor utilizando todos los m\u00e9todos disponibles. Puedes modificar su comportamiento, a\u00f1adir invocaciones a rutinas de log , o lo que consideres de utilidad.","title":"Definici\u00f3n de un objeto en Eclipse Wakaama"},{"location":"RPI-II/P8_old/#eclipse-wakaama-bootstrapping","text":"En este punto, el cliente Wakaama se conecta directamente con el servidor que hemos lanzado, y cuya direcci\u00f3n IP y puerto son los proporcionados por defecto en el c\u00f3digo. Llevado el cliente a un sensor, esto har\u00eda que nunca pudiese variar, durante el ciclo de vida del mismo, el servidor (o servidores) a los que conecta. Esto hace tambi\u00e9n que un cliente pueda \u00fanicamente conectar con un servidor LWM2M, cuando en algunas ocasiones es deseable replicar los mensajes enviados a m\u00faltiples servidores, bien por razones de tolerancia a fallos, o bien por necesidades de la aplicaci\u00f3n. Para solucionar este problema, los firmwares de f\u00e1brica suelen conocer \u00fanicamente la direcci\u00f3n o direcciones fijas de uno o varios servidores de bootstrap que, ante peticiones de provisionamiento, proporcionan al cliente las credenciales de seguridad y las direcciones de los servidores LWM2M en los que deben registrarse. As\u00ed, resulta sencillo manejar din\u00e1micamente ambos aspectos sin necesitar reflashear el firmware del sensor. En nuestro caso, utilizaremos un sencillo servidor de bootstrap proporcionado por Wakaama, aunque Leshan ofrece mecanismos mucho m\u00e1s sofisticados para realizar este mismo proceso, con su propio esqueleto de servidor bootstrap e interfaces REST (con monitores web) para gestionar el proceso. En primer lugar, dir\u00edgete al directorio que contiene el servidor bootstrap de Wakaama. All\u00ed encontrar\u00e1s un fichero de configuraci\u00f3n ( bootstrap_server.ini ) para el proceso de bootstrapping , cuyo contenido es completamente estructurado. El servidor, ante una petici\u00f3n de bootstrapping por parte de un cliente, responde en funci\u00f3n del contenido del fichero, que sigue las siguientes directivas: Las secciones soportadas son [Server] y [Endpoint] . [Server] describe una cuenta en un servidor LWM2M: Las claves soportadas en esta secci\u00f3n son: id: Identificador del servidor. (OBLIGATORIO). uri: URI del servidor LWM2M (OBLIGATORIO). bootstrap: YES o NO. Determina si este servidor es un servidor de bootstrap. Su valor por defecto es NO. lifetime: tiempo de vida del registro (opcional). security: modo de seguridad. Valores soportados: NoSec, PSK, RPK and Certificate (OBLIGATORIO). public: clave p\u00fablica o identidad del cliente, definida por el recurso /0/x/3 . server: clave p\u00fablica del servidor, definida por el recurso /0/x/4 . secret: clave privada definida por el recurso /0/x/5 . [Endpoint] contiene las operaciones de bootstrapping Si no se especifica un nombre (Name) las operaciones se enviar\u00e1n a cualquier cliente desconocido que solicite bootstrapping Si se especifica, las operaciones se enviar\u00e1n s\u00f3lo al cliente con el correspondiente nombre. Las operaciones se env\u00edan en el orden definido en el fichero. Las claves soportadas en esta secci\u00f3n son: - Name: Nombre del cliente (OPCIONAL). - Delete: Debe ser una URI LWM2M v\u00e1lida, incluida / . Env\u00eda una operaci\u00f3n delete en la URI indicada. - Server: [Value] es un ID de servidor que debe existir en la secci\u00f3n correspondiente. Env\u00eda operaciones de escritura sobre el objeto correspondiente del cliente para definir el servidor sobre el que debe conectar. Tarea Analiza e intenta entender el contenido por defecto del fichero de bootstrapping proporcionado. Puedes de momento obviar los par\u00e1metros referentes a seguridad, ya que los trataremos en la pr\u00f3xima pr\u00e1ctica. Tarea entregable Modifica el fichero de configuraci\u00f3n para que, ante la petici\u00f3n de un cliente con nombre determinado, conecte, por este orden, a un servidor LWM2M en la m\u00e1quina local, y al servidor de pruebas de Leshan en Internet. Adem\u00e1s, elimina cualquier intento de borrado de recursos en la informaci\u00f3n de bootstrapping para dicho cliente. Para arrancar el servidor bootstrap , basta con ejecutar (puedes utilizar otro fichero de configuraci\u00f3n): ./build/bootstrap_server -f bootstrap_server.ini El servidor quedar\u00e1 a la espera de peticiones por parte del cualquier cliente en el puerto 5685, tal y como indica su salida. Se puede forzar un proceso de bootstrapping con el comando boot , pero en este punto no es necesario. A continuaci\u00f3n, lanzaremos un cliente indicando que deseamos un proceso de bootstrapping contra el servidor local. Aseg\u00farate de dar un nombre a tu dispositivo que te permita diferenciarlo de cualquier otro : Nota importante Antes de realizar este ejercicio, debes modificar una l\u00ednea del fichero lwm2mclient.c , reemplazando la l\u00ednea que contiene data.addressFamily = AF_INET6; por data.addressFamily = AF_INET; . ./lwm2mclient -h localhost -p 5685 -b -c -n midispositivo Trying to bind LWM2M Client to port 56830 LWM2M Client \"testlwm2mclient\" started on port 56830 > New Battery Level: 38 value changed! Opening connection to server at localhost:5685 -> State: STATE_BOOTSTRAPPING -> State: STATE_BOOTSTRAPPING -> State: STATE_BOOTSTRAPPING Observa que las opciones de invocaci\u00f3n han cambiado, y hemos usado -b para indicar que deseamos un proceso de bootstrapping contra el servidor proporcionado. Como nota adicional, la opci\u00f3n -c simplemente actualiza de forma peri\u00f3dica la lectura del nivel de bater\u00eda (esto no es en absoluto obligatorio, pero as\u00ed podremos observar sus cambios desde el servidor). Si todo ha ido bien, el cliente estar\u00e1 ahora registrado en dos servidores: el local Wakaama (observa su salida) y el remoto Leshan, al que puedes acceder a trav\u00e9s de la direcci\u00f3n leshan.eclipseprojects.io .","title":"Eclipse Wakaama. Bootstrapping"},{"location":"RPI-II/P8_old/#eclipse-leshan-despliegue-de-un-servidor-local","text":"En este punto, tu cliente deber\u00eda estar conectado tanto a tu servidor LWM2M Wakaama local, como a un servidor Leshan en la nube. Aprovecha esta situaci\u00f3n para observar las funcionalides del servidor Leshan. Deber\u00edas, para un dispositivo con nombre \"foo\" observar algo como esto: Observa que todos y cada uno de los objetos de los que hablamos anteriormente se muestran ahora en pantalla tras el proceso de registro. Adem\u00e1s, para aquellos que son bien conocidos (estandarizados por la OMA), se muestran nombres legibles, no s\u00f3lo URIs. Tarea Busca y observa el recurso que te indica el nivel de bater\u00eda del cliente, y observa c\u00f3mo se actualiza autom\u00e1ticamente cuando var\u00eda en el cliente (ver\u00e1s a la vez un cambio en el servidor y un mensaje en el cliente). Interact\u00faa con el objeto de test que se defini\u00f3 anteriormente. En todos los casos, observa que, efectivamente, el tr\u00e1fico generado corresponde al esperado. Para replicar dicha instalaci\u00f3n en tu m\u00e1quina local, rescata la instalaci\u00f3n de Leshan que realizaste en la primera parte de la pr\u00e1ctica, y arranca el servidor LWM2M usando la siguiente orden: java -jar leshan-server-demo/target/leshan-server-demo-*-SNAPSHOT-jar-with-dependencies.jar Tarea entregable Arranca el servidor Leshan para que escuche en un puerto diferente al que est\u00e1 escuchando ya el servidor Wakaama, para que puedan convivir en la misma m\u00e1quina. Modifica tu proceso de provisionamiento para que el cliente o clientes se conecten a ambos servidores. Tarea entregable El principal objetivo de esta parte es que seas capaz de definir un objeto e instanciarlo, con una cantidad de recursos suficientemente rica como para observar y ejercitar las capacidades de LWM2M en general, y de Eclipse Wakaama en particular. Por ello, se pide que definas, en primer lugar, uno o m\u00faltiples objetos y sus recursos que podr\u00edan formar parte de un hipot\u00e9tico sensor IoT. En segundo lugar, se pide que, siguiendo las directivas del c\u00f3digo analizado, lo implementes en Eclipse Wakaama y seas capaz de interactuar con \u00e9l desde un servidor Leshan y/o Wakaama utilizando adem\u00e1s un proceso de provisionamiento o bootstrapping .","title":"Eclipse Leshan. Despliegue de un servidor local"},{"location":"RPI-II/P9_old/","text":"Pr\u00e1ctica 9. Node-RED Introducci\u00f3n y objetivos Node-RED es una herramienta de c\u00f3digo abierto desarrollada inicialmente por IBM y que, estando orientada a flujos de datos, proporciona mecanismos para asociar dispositivos hardware, APIs y servicios online dentro de un ecosistema IoT. Node-RED es una herramienta gr\u00e1fica, utilizable desde cualquier navegador web, que permite la craci\u00f3n y edici\u00f3n de flujos de datos que tomen datos de entrada (mediante nodos de entrada), los procesen (mediante nodos de procesamiento) y proporcionen salidas (mediante nodos de salida). Todos los elementos, incluyendo flujos complejos definidos por el usuario, pueden almacenarse en formato JSON para ser importados a continuaci\u00f3n en otras instalaciones. Node-RED permite la interconexi\u00f3n de elementos software y hardware mediante virtualmente cualquier protocolo conocido, facilitando el despliegue de infraestructuras IoT. El desarrollo de la pr\u00e1ctica difiere sobre el utilizado en pr\u00e1cticas anteriores. En este caso, el presente bolet\u00edn \u00fanicamente incluye informaci\u00f3n e instrucciones para la instalaci\u00f3n de la herramienta Node-RED en la m\u00e1quina virtual del curso (alternativamente, es posible instalar Node-RED en cualquier m\u00e1quina f\u00edsica), as\u00ed como la propuesta de ejercicio entregable a dise\u00f1ar e implementar. Se proporcionar\u00e1n las explicaciones y demostraciones necesarias durante la sesi\u00f3n de laboratorio para entender los conceptos b\u00e1sicos relativos a la instalaci\u00f3n y uso b\u00e1sico de la herramienta Node-RED. Instalaci\u00f3n y puesta en marcha Para instalar Node-RED en la m\u00e1quina virtual del curso, es suficiente con utilizar el gestor npm : sudo npm install -g --unsafe-perm node-red Al finalzar, si todo ha ido bien, deber\u00edas observar una salida similar a la siguiente: + node-red@1.1.0 added 332 packages from 341 contributors in 18.494s found 0 vulnerabilities En caso de que se muestre un mensaje indicando que la versi\u00f3n de Node.js no es compatible y que se requiera al menos una versi\u00f3n 14, es preciso actualizarlo mediante los siguientes comandos: curl -fsSL https://deb.nodesource.com/setup_14.x | sudo -E bash - sudo apt-get install -y nodejs Para ejecutar Node-RED, una vez instalado, es posible utilizar la orden node-red desde cualquier terminal. Para detener el proceso, es suficiente con utilizar Ctrl-C : $ node-red Welcome to Node-RED =================== 30 Jun 23:43:39 - [info] Node-RED version: v1.1.0 30 Jun 23:43:39 - [info] Node.js version: v10.21.0 30 Jun 23:43:39 - [info] Darwin 18.7.0 x64 LE 30 Jun 23:43:39 - [info] Loading palette nodes 30 Jun 23:43:44 - [warn] rpi-gpio : Raspberry Pi specific node set inactive 30 Jun 23:43:44 - [info] Settings file : /Users/nol/.node-red/settings.js 30 Jun 23:43:44 - [info] HTTP Static : /Users/nol/node-red/web 30 Jun 23:43:44 - [info] Context store : 'default' [module=localfilesystem] 30 Jun 23:43:44 - [info] User directory : /Users/nol/.node-red 30 Jun 23:43:44 - [warn] Projects disabled : set editorTheme.projects.enabled=true to enable 30 Jun 23:43:44 - [info] Creating new flows file : flows_noltop.json 30 Jun 23:43:44 - [info] Starting flows 30 Jun 23:43:44 - [info] Started flows 30 Jun 23:43:44 - [info] Server now running at http://127.0.0.1:1880/red/ Con el software arrancado, es posible acceder al editor Node-RED a trav\u00e9s de la direcci\u00f3n http://localhost:1880 en cualquier navegador. Tras arrancarlo, observar\u00e1s cuatro \u00e1reas en el editor: Barra principal , en la parte superior, con los botones Deploy y de Men\u00fa principal . Panel de nodos , en la parte izquierda, que proporciona acceso directo a todos los nodos disponibles en Node-RED. Es posible instalar nuevos nodos a trav\u00e9s de la Paleta de Nodos, disponible a trav\u00e9s del men\u00fa principal ( Manage Palette ). Estos nodos pueden ser arrastrados al editor para conformar nuevos flujos de datos. Panel de edici\u00f3n o espacio de trabajo , en la parte central de la pantalla, donde podr\u00e1s arrastrar y unir nuevos nodos. Es posible crear nuevos flujos en pesta\u00f1as independientes. Panel de informaci\u00f3n , en la parte derecha de la pantalla, donde destaca el bot\u00f3n Debug , mediante el cual veremos la salida de los nodos de tipo Debug en nuestros flujos. Ejemplo 1 Se muestra a continuaci\u00f3n un breve ejemplo b\u00e1sico de utilizaci\u00f3n del editor Node-RED, que incluye el uso de nodos Inject , Debug y Function . Nodo Inject El nodo Inject permite inyectar mensajes en un flujo, bien pulsando en el bot\u00f3n asociado al nodo, o estableciendo un intervalo de tiempo entre inyecciones. Busca en el panel izquierdo un nodo de tipo Inject y arr\u00e1stralo al espacio de trabajo. En el panel de informaci\u00f3n podr\u00e1s consultar los datos asociados al nodo, as\u00ed como informaci\u00f3n de ayuda para utilizarlo. Nodo Debug El nodo Debug permite que cualquier mensaje entrante se muestre en el panel de depuraci\u00f3n, en la parte derecha de la pantalla. Por defecto, \u00fanicamente muestra el payload del mensaje, aunque puede configurarse para mostrar el objeto completo. Arrastra un nodo de tipo Debug al espacio de trabajo. Uni\u00f3n y despliegue ( Deploy ) Conecta los nodos Inject y Debug estableciendo un enlace ( Wire ) entre ambos. Despliega el flujo usando el bot\u00f3n Deploy en la barra principal de Node-RED. Esto desplegar\u00e1 el fujo en el servidor. Selecciona la opci\u00f3n Debug en el panel de informaci\u00f3n, y presiona el bot\u00f3n del nodo Inject . Deber\u00edas ver n\u00fameros aparecer en el panel. Por defecto, el nodo Inject emite el n\u00famero de milisegundos desde el 1 de enero de 1970 como payload . Modifica (temporalmente) el nodo Debug para que muestre todo el mensaje en lugar del payload . Despliega de nuevo el flujo y observa las diferencias. Vuelve a configurar el nodo Debug tal y como estaba cuando lo insertaste. Nodo Function El nodo Function permite procesar el mensaje de entrada mediante una funci\u00f3n JavaScript. Borra el Wire existente y a\u00f1ade un nodo Function entre los nodos Inject y Debug . Haz doble clic en el nuevo nodo para abrir el di\u00e1logo de edici\u00f3n. Copia el siguiente c\u00f3digo en el campo Function : // Create a Date object from the payload var date = new Date(msg.payload); // Change the payload to be a formatted Date string msg.payload = date.toString(); // Return the message so it can be sent on return msg; Clica en Done y despliega el flujo. Observa que, ahora, los mensajes de depuraci\u00f3n muestran marcas de tiempo en formato visible. Ten en cuenta que un nodo siempre recibe un mensaje ( msg ) de entrada y devuelve un mensaje ( msg ) de salida. Ambos objetos contienen, por convenio, un campo payload . Para m\u00e1s informaci\u00f3n sobre el uso de funciones y trabajo con mensajes, incluyendo m\u00faltiples valores de retorno y trabajo con valores globales a todo el entorno, se recomienda estudiar la siguiente documentaci\u00f3n: Trabajo con mensajes : enlace a documentaci\u00f3n . Trabajo con funciones : enlace a documentaci\u00f3n . Ejemplo 2 Nodo Inject En el anterior ejemplo, vimos c\u00f3mo crear un nodo Inject para activar el flujo cuando se pulsaba su bot\u00f3n asociado. En este ejemplo, vamos a configurar el nodo Inject para que active el flujo en intervalos regulares. Arrastra un nuevo nodo Inject en el espacio de trabajo. Clica en \u00e9l dos veces y, en el di\u00e1logo de edici\u00f3n, usala opci\u00f3n Repeat interval , fij\u00e1ndolo en un intervalo regular. Cierra el di\u00e1logo de edici\u00f3n. Nodo HTTP Request El nodo de tipo HTTP Request puede utilizarse para descargar una p\u00e1gina web o recurso HTTP. A\u00f1ade uno al espacio de trabajo, y ed\u00edtalo para que su propiedad URL apunte a https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/significant_month.csv . Esta URL es un repositorio de terremotos en el \u00faltimo mes, pulicado por el organismo oficial correspondiente, devueltos en formato CSV. Nodo CSV A\u00f1ade un nuevo nodo CSV y edita sus propiedades. Activa la opci\u00f3n First row contains column names y finaliza la edici\u00f3n. Nodo Debug y cableado A\u00f1ade un nodo Debug y une los nodos creados: Conecta la salida del nodo Inject a la entrada del nodo HTTP Request . Conecta la salida del nodo HTTP Request a la entrada del nodo CSV . Conecta la salida del nodo CSV a la entrada del nodo Debug . Nodo Switch A\u00f1ade un nodo Switch al espacio de trabajo. Edita sus propiedades y configuralo para comprobar la propiedad msg.payload.mag , usando la operaci\u00f3n >= sobre un valor num\u00e9rico y el valor 6.2 , por ejemplo. A\u00f1ade un segundo Wire entre el nodo CSV y el nodo Switch . Nodo Change A\u00f1ade un nodo Change , conectado a la salida del nodo Switch . Configuralo para establecer el valor de msg.payload a ALARMA . Nodo Debug A\u00f1ade un nodo Debug y despliega el flujo. En el panel de Debug , deber\u00e1s obsevar, para cada activaci\u00f3n del nodo Inject , una salida similar a esta: msg.payload : Object {\"time\":\"2017-11-19T15:09:03.120Z\",\"latitude\":-21.5167,\"longitude\":168.5426,\"depth\":14.19,\"mag\":6.6,\"magType\":\"mww\",\"gap\":21,\"dmin\":0.478,\"rms\":0.86,\"net\":\"us\",\"id\":\"us2000brgk\",\"updated\":\"2017-11-19T17:10:58.449Z\",\"place\":\"68km E of Tadine, New Caledonia\",\"type\":\"earthquake\",\"horizontalError\":6.2,\"depthError\":2.8,\"magError\":0.037,\"magNst\":72,\"status\":\"reviewed\",\"locationSource\":\"us\",\"magSource\":\"us\"} Puedes clicar en la peque\u00f1a flecha a la izquierda de cada propiedad para expandirla y examinar sus contenidos. Si existe cualquier terremoto de magnitud mayor a 6.2 , observar\u00e1s una salida adicional: msg.payload : string(6) \"ALARMA\" Para m\u00e1s informaci\u00f3n sobre los nodos b\u00e1sicos en Node-RED, puedes consultar: The Core Nodes : enlace a documentaci\u00f3n . Cliente MQTT y despliegue de un panel de control El nodo MQTT in permite realizar suscripciones a topics determinados en brokers MQTT. Arrastra un nuevo nodo MQTT in en tu espacio de trabajo y configura el broker asociado a localhost , puerto por defecto. Establece un topic de inter\u00e9s. Conecta un nodo Debug y despliega el flujo. Desde tu consola, publica mensajes v\u00eda mosquitto_pub y comprueba que, efectivamente, son visibles en Node-RED. A continuaci\u00f3n, crearemos un peque\u00f1o panel de control para la representaci\u00f3n gr\u00e1fica del valor publicado. En primer lugar, deber\u00e1s instalar el nodo node-red-dashboard desde el men\u00fa principal, opci\u00f3n Manage palette . Tras su instalaci\u00f3n, ver\u00e1s que aparecen nuevos nodos en el panel de nodos; \u00e9stos nos permitir\u00e1n dise\u00f1ar e implementar un panel de control b\u00e1sico basado en Widgets . Arrastra un nodo de tipo Gauge al espacio de trabajo, y configura sus valores por defecto. Conecta la salida de tu nodo MQTT in a la entrada del nuevo nodo Gauge . Despliega el flujo, y navega hasta http://localhost:1880/ui , donde deber\u00e1s observar el panel de control con el widget que has creado. Interact\u00faa con \u00e9l publicando mensajes v\u00eda MQTT. Para m\u00e1s informaci\u00f3n sobre el despliegue de paneles de control, puedes consultar: Node-Red-Dashboard : enlace a documentaci\u00f3n . Documentaci\u00f3n adicional Las gu\u00edas de usuario oficiales de Node-RED son un buen punto de partida para profundizar en el uso de la infraestructura. De entre ellas, la parte m\u00e1s importante para comenzar es la que introduce los conceptos b\u00e1sicos de Node-RED, incluyendo el trabajo con nodos, flujos, contexto (importante para trabajar con valores globales y compartidos por todos los nodos en un flujo, por ejemplo), mensajes, wires , etc.: Node-RED Concepts : enlace a documentaci\u00f3n . La gu\u00eda Node-RED Guide contiene interesante documentaci\u00f3n adicional/avanzada tanto en el despliegue de flujos como en el uso de paneles de control locales o usando servicios remotos (por ejemplo, Freeboard ): Node-RED Guide : enlace a documentaci\u00f3n . Ejercicio entregable Se pide estudiar la documentaci\u00f3n asociada a Node-RED, tanto en su web oficial como en la gu\u00eda de programaci\u00f3n Node-RED Guide (espec\u00edficamente sus cuatro primeras partes. Junto con la explicaci\u00f3n proporcionada por el profesor y los anteriores ejemplos, este estudio permitir\u00e1 el desarrollo de la pr\u00e1ctica. Tarea entregable La pr\u00e1ctica consiste en el dise\u00f1o y desarrollo de un sistema basado en flujos de datos construido sobre Node-RED, que implemente un mecanismo de monitorizaci\u00f3n de par\u00e1metros ambientales (por ejemplo, temperatura) y notificaci\u00f3n (alarmas) ante ciertas circunstancias (por ejemplo, superar una determinada temperatura fijada como umbral). Los alumnos dise\u00f1ar\u00e1n el sistema y lo implementar\u00e1n, cumpliendo las siguientes premisas: (2 puntos) . El sistema utilizar\u00e1, al menos , un dispositivo externo (ESP32, SensorTag, Tel\u00e9fono M\u00f3vil, ...) para la recolecci\u00f3n de datos. Se valorar\u00e1 el uso de m\u00e1s de un dispositivo. (2 puntos) . El sistema depositar\u00e1 o interactuar\u00e1 con, al menos , un sistema externo (servidor de correo, Twitter, Telegram, IBM Bluemix, ...). (2 puntos) . El sistema depositar\u00e1 los datos observados en alg\u00fan medio persistente (Base de Datos no relacional, ficheros, ...) para permitir su posterior an\u00e1lisis y en un panel de control. ** (2 puntos)**. El sistema actuar\u00e1 como un sistema de alarma \u00fanicamente ante ciertas condiciones de entrada (por ejemplo, al recibir un valor desde un sensor superior a un umbral establecido; dicho valor podr\u00eda, por ejemplo, configurarse v\u00eda MQTT o a trav\u00e9s de un panel de control). (2 puntos) . El sistema utilizar\u00e1, al menos, un tipo de nodo no instalado por defecto en la instalaci\u00f3n b\u00e1sica de Node-RED. Se entregar\u00e1 el fichero o ficheros JSON que describen los nodos, as\u00ed como una breve memoria que describa el sistema dise\u00f1ado y el trabajo realizado, haciendo hincapi\u00e9 en las dificultades encontradas y aquellos aspectos que se consideren de inter\u00e9s por parte del alumno/a.","title":"Pr\u00e1ctica 9. Node-RED"},{"location":"RPI-II/P9_old/#practica-9-node-red","text":"","title":"Pr\u00e1ctica 9. Node-RED"},{"location":"RPI-II/P9_old/#introduccion-y-objetivos","text":"Node-RED es una herramienta de c\u00f3digo abierto desarrollada inicialmente por IBM y que, estando orientada a flujos de datos, proporciona mecanismos para asociar dispositivos hardware, APIs y servicios online dentro de un ecosistema IoT. Node-RED es una herramienta gr\u00e1fica, utilizable desde cualquier navegador web, que permite la craci\u00f3n y edici\u00f3n de flujos de datos que tomen datos de entrada (mediante nodos de entrada), los procesen (mediante nodos de procesamiento) y proporcionen salidas (mediante nodos de salida). Todos los elementos, incluyendo flujos complejos definidos por el usuario, pueden almacenarse en formato JSON para ser importados a continuaci\u00f3n en otras instalaciones. Node-RED permite la interconexi\u00f3n de elementos software y hardware mediante virtualmente cualquier protocolo conocido, facilitando el despliegue de infraestructuras IoT. El desarrollo de la pr\u00e1ctica difiere sobre el utilizado en pr\u00e1cticas anteriores. En este caso, el presente bolet\u00edn \u00fanicamente incluye informaci\u00f3n e instrucciones para la instalaci\u00f3n de la herramienta Node-RED en la m\u00e1quina virtual del curso (alternativamente, es posible instalar Node-RED en cualquier m\u00e1quina f\u00edsica), as\u00ed como la propuesta de ejercicio entregable a dise\u00f1ar e implementar. Se proporcionar\u00e1n las explicaciones y demostraciones necesarias durante la sesi\u00f3n de laboratorio para entender los conceptos b\u00e1sicos relativos a la instalaci\u00f3n y uso b\u00e1sico de la herramienta Node-RED.","title":"Introducci\u00f3n y objetivos"},{"location":"RPI-II/P9_old/#instalacion-y-puesta-en-marcha","text":"Para instalar Node-RED en la m\u00e1quina virtual del curso, es suficiente con utilizar el gestor npm : sudo npm install -g --unsafe-perm node-red Al finalzar, si todo ha ido bien, deber\u00edas observar una salida similar a la siguiente: + node-red@1.1.0 added 332 packages from 341 contributors in 18.494s found 0 vulnerabilities En caso de que se muestre un mensaje indicando que la versi\u00f3n de Node.js no es compatible y que se requiera al menos una versi\u00f3n 14, es preciso actualizarlo mediante los siguientes comandos: curl -fsSL https://deb.nodesource.com/setup_14.x | sudo -E bash - sudo apt-get install -y nodejs Para ejecutar Node-RED, una vez instalado, es posible utilizar la orden node-red desde cualquier terminal. Para detener el proceso, es suficiente con utilizar Ctrl-C : $ node-red Welcome to Node-RED =================== 30 Jun 23:43:39 - [info] Node-RED version: v1.1.0 30 Jun 23:43:39 - [info] Node.js version: v10.21.0 30 Jun 23:43:39 - [info] Darwin 18.7.0 x64 LE 30 Jun 23:43:39 - [info] Loading palette nodes 30 Jun 23:43:44 - [warn] rpi-gpio : Raspberry Pi specific node set inactive 30 Jun 23:43:44 - [info] Settings file : /Users/nol/.node-red/settings.js 30 Jun 23:43:44 - [info] HTTP Static : /Users/nol/node-red/web 30 Jun 23:43:44 - [info] Context store : 'default' [module=localfilesystem] 30 Jun 23:43:44 - [info] User directory : /Users/nol/.node-red 30 Jun 23:43:44 - [warn] Projects disabled : set editorTheme.projects.enabled=true to enable 30 Jun 23:43:44 - [info] Creating new flows file : flows_noltop.json 30 Jun 23:43:44 - [info] Starting flows 30 Jun 23:43:44 - [info] Started flows 30 Jun 23:43:44 - [info] Server now running at http://127.0.0.1:1880/red/ Con el software arrancado, es posible acceder al editor Node-RED a trav\u00e9s de la direcci\u00f3n http://localhost:1880 en cualquier navegador. Tras arrancarlo, observar\u00e1s cuatro \u00e1reas en el editor: Barra principal , en la parte superior, con los botones Deploy y de Men\u00fa principal . Panel de nodos , en la parte izquierda, que proporciona acceso directo a todos los nodos disponibles en Node-RED. Es posible instalar nuevos nodos a trav\u00e9s de la Paleta de Nodos, disponible a trav\u00e9s del men\u00fa principal ( Manage Palette ). Estos nodos pueden ser arrastrados al editor para conformar nuevos flujos de datos. Panel de edici\u00f3n o espacio de trabajo , en la parte central de la pantalla, donde podr\u00e1s arrastrar y unir nuevos nodos. Es posible crear nuevos flujos en pesta\u00f1as independientes. Panel de informaci\u00f3n , en la parte derecha de la pantalla, donde destaca el bot\u00f3n Debug , mediante el cual veremos la salida de los nodos de tipo Debug en nuestros flujos.","title":"Instalaci\u00f3n y puesta en marcha"},{"location":"RPI-II/P9_old/#ejemplo-1","text":"Se muestra a continuaci\u00f3n un breve ejemplo b\u00e1sico de utilizaci\u00f3n del editor Node-RED, que incluye el uso de nodos Inject , Debug y Function .","title":"Ejemplo 1"},{"location":"RPI-II/P9_old/#nodo-inject","text":"El nodo Inject permite inyectar mensajes en un flujo, bien pulsando en el bot\u00f3n asociado al nodo, o estableciendo un intervalo de tiempo entre inyecciones. Busca en el panel izquierdo un nodo de tipo Inject y arr\u00e1stralo al espacio de trabajo. En el panel de informaci\u00f3n podr\u00e1s consultar los datos asociados al nodo, as\u00ed como informaci\u00f3n de ayuda para utilizarlo.","title":"Nodo Inject"},{"location":"RPI-II/P9_old/#nodo-debug","text":"El nodo Debug permite que cualquier mensaje entrante se muestre en el panel de depuraci\u00f3n, en la parte derecha de la pantalla. Por defecto, \u00fanicamente muestra el payload del mensaje, aunque puede configurarse para mostrar el objeto completo. Arrastra un nodo de tipo Debug al espacio de trabajo.","title":"Nodo Debug"},{"location":"RPI-II/P9_old/#union-y-despliegue-deploy","text":"Conecta los nodos Inject y Debug estableciendo un enlace ( Wire ) entre ambos. Despliega el flujo usando el bot\u00f3n Deploy en la barra principal de Node-RED. Esto desplegar\u00e1 el fujo en el servidor. Selecciona la opci\u00f3n Debug en el panel de informaci\u00f3n, y presiona el bot\u00f3n del nodo Inject . Deber\u00edas ver n\u00fameros aparecer en el panel. Por defecto, el nodo Inject emite el n\u00famero de milisegundos desde el 1 de enero de 1970 como payload . Modifica (temporalmente) el nodo Debug para que muestre todo el mensaje en lugar del payload . Despliega de nuevo el flujo y observa las diferencias. Vuelve a configurar el nodo Debug tal y como estaba cuando lo insertaste.","title":"Uni\u00f3n y despliegue (Deploy)"},{"location":"RPI-II/P9_old/#nodo-function","text":"El nodo Function permite procesar el mensaje de entrada mediante una funci\u00f3n JavaScript. Borra el Wire existente y a\u00f1ade un nodo Function entre los nodos Inject y Debug . Haz doble clic en el nuevo nodo para abrir el di\u00e1logo de edici\u00f3n. Copia el siguiente c\u00f3digo en el campo Function : // Create a Date object from the payload var date = new Date(msg.payload); // Change the payload to be a formatted Date string msg.payload = date.toString(); // Return the message so it can be sent on return msg; Clica en Done y despliega el flujo. Observa que, ahora, los mensajes de depuraci\u00f3n muestran marcas de tiempo en formato visible. Ten en cuenta que un nodo siempre recibe un mensaje ( msg ) de entrada y devuelve un mensaje ( msg ) de salida. Ambos objetos contienen, por convenio, un campo payload . Para m\u00e1s informaci\u00f3n sobre el uso de funciones y trabajo con mensajes, incluyendo m\u00faltiples valores de retorno y trabajo con valores globales a todo el entorno, se recomienda estudiar la siguiente documentaci\u00f3n: Trabajo con mensajes : enlace a documentaci\u00f3n . Trabajo con funciones : enlace a documentaci\u00f3n .","title":"Nodo Function"},{"location":"RPI-II/P9_old/#ejemplo-2","text":"","title":"Ejemplo 2"},{"location":"RPI-II/P9_old/#nodo-inject_1","text":"En el anterior ejemplo, vimos c\u00f3mo crear un nodo Inject para activar el flujo cuando se pulsaba su bot\u00f3n asociado. En este ejemplo, vamos a configurar el nodo Inject para que active el flujo en intervalos regulares. Arrastra un nuevo nodo Inject en el espacio de trabajo. Clica en \u00e9l dos veces y, en el di\u00e1logo de edici\u00f3n, usala opci\u00f3n Repeat interval , fij\u00e1ndolo en un intervalo regular. Cierra el di\u00e1logo de edici\u00f3n.","title":"Nodo Inject"},{"location":"RPI-II/P9_old/#nodo-http-request","text":"El nodo de tipo HTTP Request puede utilizarse para descargar una p\u00e1gina web o recurso HTTP. A\u00f1ade uno al espacio de trabajo, y ed\u00edtalo para que su propiedad URL apunte a https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/significant_month.csv . Esta URL es un repositorio de terremotos en el \u00faltimo mes, pulicado por el organismo oficial correspondiente, devueltos en formato CSV.","title":"Nodo HTTP Request"},{"location":"RPI-II/P9_old/#nodo-csv","text":"A\u00f1ade un nuevo nodo CSV y edita sus propiedades. Activa la opci\u00f3n First row contains column names y finaliza la edici\u00f3n.","title":"Nodo CSV"},{"location":"RPI-II/P9_old/#nodo-debug-y-cableado","text":"A\u00f1ade un nodo Debug y une los nodos creados: Conecta la salida del nodo Inject a la entrada del nodo HTTP Request . Conecta la salida del nodo HTTP Request a la entrada del nodo CSV . Conecta la salida del nodo CSV a la entrada del nodo Debug .","title":"Nodo Debug y cableado"},{"location":"RPI-II/P9_old/#nodo-switch","text":"A\u00f1ade un nodo Switch al espacio de trabajo. Edita sus propiedades y configuralo para comprobar la propiedad msg.payload.mag , usando la operaci\u00f3n >= sobre un valor num\u00e9rico y el valor 6.2 , por ejemplo. A\u00f1ade un segundo Wire entre el nodo CSV y el nodo Switch .","title":"Nodo Switch"},{"location":"RPI-II/P9_old/#nodo-change","text":"A\u00f1ade un nodo Change , conectado a la salida del nodo Switch . Configuralo para establecer el valor de msg.payload a ALARMA .","title":"Nodo Change"},{"location":"RPI-II/P9_old/#nodo-debug_1","text":"A\u00f1ade un nodo Debug y despliega el flujo. En el panel de Debug , deber\u00e1s obsevar, para cada activaci\u00f3n del nodo Inject , una salida similar a esta: msg.payload : Object {\"time\":\"2017-11-19T15:09:03.120Z\",\"latitude\":-21.5167,\"longitude\":168.5426,\"depth\":14.19,\"mag\":6.6,\"magType\":\"mww\",\"gap\":21,\"dmin\":0.478,\"rms\":0.86,\"net\":\"us\",\"id\":\"us2000brgk\",\"updated\":\"2017-11-19T17:10:58.449Z\",\"place\":\"68km E of Tadine, New Caledonia\",\"type\":\"earthquake\",\"horizontalError\":6.2,\"depthError\":2.8,\"magError\":0.037,\"magNst\":72,\"status\":\"reviewed\",\"locationSource\":\"us\",\"magSource\":\"us\"} Puedes clicar en la peque\u00f1a flecha a la izquierda de cada propiedad para expandirla y examinar sus contenidos. Si existe cualquier terremoto de magnitud mayor a 6.2 , observar\u00e1s una salida adicional: msg.payload : string(6) \"ALARMA\" Para m\u00e1s informaci\u00f3n sobre los nodos b\u00e1sicos en Node-RED, puedes consultar: The Core Nodes : enlace a documentaci\u00f3n .","title":"Nodo Debug"},{"location":"RPI-II/P9_old/#cliente-mqtt-y-despliegue-de-un-panel-de-control","text":"El nodo MQTT in permite realizar suscripciones a topics determinados en brokers MQTT. Arrastra un nuevo nodo MQTT in en tu espacio de trabajo y configura el broker asociado a localhost , puerto por defecto. Establece un topic de inter\u00e9s. Conecta un nodo Debug y despliega el flujo. Desde tu consola, publica mensajes v\u00eda mosquitto_pub y comprueba que, efectivamente, son visibles en Node-RED. A continuaci\u00f3n, crearemos un peque\u00f1o panel de control para la representaci\u00f3n gr\u00e1fica del valor publicado. En primer lugar, deber\u00e1s instalar el nodo node-red-dashboard desde el men\u00fa principal, opci\u00f3n Manage palette . Tras su instalaci\u00f3n, ver\u00e1s que aparecen nuevos nodos en el panel de nodos; \u00e9stos nos permitir\u00e1n dise\u00f1ar e implementar un panel de control b\u00e1sico basado en Widgets . Arrastra un nodo de tipo Gauge al espacio de trabajo, y configura sus valores por defecto. Conecta la salida de tu nodo MQTT in a la entrada del nuevo nodo Gauge . Despliega el flujo, y navega hasta http://localhost:1880/ui , donde deber\u00e1s observar el panel de control con el widget que has creado. Interact\u00faa con \u00e9l publicando mensajes v\u00eda MQTT. Para m\u00e1s informaci\u00f3n sobre el despliegue de paneles de control, puedes consultar: Node-Red-Dashboard : enlace a documentaci\u00f3n .","title":"Cliente MQTT y despliegue de un panel de control"},{"location":"RPI-II/P9_old/#documentacion-adicional","text":"Las gu\u00edas de usuario oficiales de Node-RED son un buen punto de partida para profundizar en el uso de la infraestructura. De entre ellas, la parte m\u00e1s importante para comenzar es la que introduce los conceptos b\u00e1sicos de Node-RED, incluyendo el trabajo con nodos, flujos, contexto (importante para trabajar con valores globales y compartidos por todos los nodos en un flujo, por ejemplo), mensajes, wires , etc.: Node-RED Concepts : enlace a documentaci\u00f3n . La gu\u00eda Node-RED Guide contiene interesante documentaci\u00f3n adicional/avanzada tanto en el despliegue de flujos como en el uso de paneles de control locales o usando servicios remotos (por ejemplo, Freeboard ): Node-RED Guide : enlace a documentaci\u00f3n .","title":"Documentaci\u00f3n adicional"},{"location":"RPI-II/P9_old/#ejercicio-entregable","text":"Se pide estudiar la documentaci\u00f3n asociada a Node-RED, tanto en su web oficial como en la gu\u00eda de programaci\u00f3n Node-RED Guide (espec\u00edficamente sus cuatro primeras partes. Junto con la explicaci\u00f3n proporcionada por el profesor y los anteriores ejemplos, este estudio permitir\u00e1 el desarrollo de la pr\u00e1ctica. Tarea entregable La pr\u00e1ctica consiste en el dise\u00f1o y desarrollo de un sistema basado en flujos de datos construido sobre Node-RED, que implemente un mecanismo de monitorizaci\u00f3n de par\u00e1metros ambientales (por ejemplo, temperatura) y notificaci\u00f3n (alarmas) ante ciertas circunstancias (por ejemplo, superar una determinada temperatura fijada como umbral). Los alumnos dise\u00f1ar\u00e1n el sistema y lo implementar\u00e1n, cumpliendo las siguientes premisas: (2 puntos) . El sistema utilizar\u00e1, al menos , un dispositivo externo (ESP32, SensorTag, Tel\u00e9fono M\u00f3vil, ...) para la recolecci\u00f3n de datos. Se valorar\u00e1 el uso de m\u00e1s de un dispositivo. (2 puntos) . El sistema depositar\u00e1 o interactuar\u00e1 con, al menos , un sistema externo (servidor de correo, Twitter, Telegram, IBM Bluemix, ...). (2 puntos) . El sistema depositar\u00e1 los datos observados en alg\u00fan medio persistente (Base de Datos no relacional, ficheros, ...) para permitir su posterior an\u00e1lisis y en un panel de control. ** (2 puntos)**. El sistema actuar\u00e1 como un sistema de alarma \u00fanicamente ante ciertas condiciones de entrada (por ejemplo, al recibir un valor desde un sensor superior a un umbral establecido; dicho valor podr\u00eda, por ejemplo, configurarse v\u00eda MQTT o a trav\u00e9s de un panel de control). (2 puntos) . El sistema utilizar\u00e1, al menos, un tipo de nodo no instalado por defecto en la instalaci\u00f3n b\u00e1sica de Node-RED. Se entregar\u00e1 el fichero o ficheros JSON que describen los nodos, as\u00ed como una breve memoria que describa el sistema dise\u00f1ado y el trabajo realizado, haciendo hincapi\u00e9 en las dificultades encontradas y aquellos aspectos que se consideren de inter\u00e9s por parte del alumno/a.","title":"Ejercicio entregable"}]}