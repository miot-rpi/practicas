<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>Práctica 4 - Redes, Protocolos e Interfaces</title>
        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">

        <script src="../../js/jquery-1.10.2.min.js" defer></script>
        <script src="../../js/bootstrap-3.0.3.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
            <div class="container">

                <!-- Collapsed navigation -->
                <div class="navbar-header">
                    <!-- Expander button -->
                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="../..">Redes, Protocolos e Interfaces</a>
                </div>

                <!-- Expanded navigation -->
                <div class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li >
                                <a href="../..">Calendario</a>
                            </li>
                            <li class="dropdown active">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">RPI-I <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../P1/">Práctica 1</a>
</li>
                                    
<li >
    <a href="../P2/">Práctica 2</a>
</li>
                                    
<li >
    <a href="../P3/">Práctica 3</a>
</li>
                                    
<li class="active">
    <a href="./">Práctica 4</a>
</li>
                                    
<li >
    <a href="../P5/">Práctica 5</a>
</li>
                                    
<li >
    <a href="../P6/">Práctica 6</a>
</li>
                                    
<li >
    <a href="../P7/">Práctica 7</a>
</li>
                                    
<li >
    <a href="../P8/">Práctica 8</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">RPI-II <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../../RPI-II/P1/">Práctica 1</a>
</li>
                                    
<li >
    <a href="../../RPI-II/P2/">Práctica 2</a>
</li>
                                    
<li >
    <a href="../../RPI-II/P3/">Práctica 3</a>
</li>
                                    
<li >
    <a href="../../RPI-II/P4/">Práctica 4</a>
</li>
                                    
<li >
    <a href="../../RPI-II/P5/">Práctica 5</a>
</li>
                                    
<li >
    <a href="../../RPI-II/P6/">Práctica 6 (I)</a>
</li>
                                    
<li >
    <a href="../../RPI-II/P6-II/">Práctica 6 (II)</a>
</li>
                                    
<li >
    <a href="../../RPI-II/P7/">Práctica 7</a>
</li>
                                    
<li >
    <a href="../../RPI-II/P8/">Práctica 8</a>
</li>
                                    
<li >
    <a href="../../RPI-II/P9/">Práctica 9</a>
</li>
                                    
<li >
    <a href="../../RPI-II/P10/">Práctica 10</a>
</li>
                                </ul>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav navbar-right">
                        <li>
                            <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li >
                                <a rel="next" href="../P3/">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li >
                                <a rel="prev" href="../P5/">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="main active"><a href="#practica-4-bluetooth-low-energy-ble">Práctica 4. Bluetooth Low Energy (BLE)</a></li>
        <li class="main "><a href="#objetivos">Objetivos</a></li>
        <li class="main "><a href="#implementacion-de-un-servidor-gatt-basado-en-tablas">Implementación de un servidor GATT basado en tablas</a></li>
            <li><a href="#introduccion">Introducción</a></li>
            <li><a href="#inclusion-de-encabezados">Inclusión de encabezados</a></li>
            <li><a href="#la-tabla-de-servicios">La tabla de servicios</a></li>
            <li><a href="#punto-de-entrada">Punto de entrada</a></li>
            <li><a href="#inicializacion-del-controlador-y-de-la-pila-bluetooth">Inicialización del controlador y de la pila Bluetooth</a></li>
            <li><a href="#perfiles-de-aplicacion-application-profiles">Perfiles de aplicación (Application profiles)</a></li>
            <li><a href="#parametros-gap">Parámetros GAP</a></li>
            <li><a href="#el-manejador-de-eventos-gap">El manejador de eventos GAP</a></li>
            <li><a href="#manejadores-de-eventos-gatt">Manejadores de eventos GATT</a></li>
            <li><a href="#creacion-de-servicios-y-caracteristicas-con-una-tabla-de-atributos">Creación de Servicios y Características con una Tabla de Atributos</a></li>
            <li><a href="#inicializacion-del-servicio">Inicialización del servicio</a></li>
        <li class="main "><a href="#interaccion-a-traves-de-un-cliente-gatt">Interacción a través de un cliente GATT</a></li>
            <li><a href="#uso-de-hcitool-y-gatttool-en-modo-cliente">Uso de hcitool y gatttool en modo cliente</a></li>
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<h1 id="practica-4-bluetooth-low-energy-ble">Práctica 4. Bluetooth Low Energy (BLE)</h1>
<h1 id="objetivos">Objetivos</h1>
<ul>
<li>Diseccionar en detalle un <em>firmware</em> de construcción de tabla GATT (servidor
GATT) utilizando la API de ESP-IDF.</li>
<li>Aprender a utilizar la herramienta <code>gatttool</code> para interactuar con el servidor GATT.</li>
<li>Modificar el servidor GATT para que acepte peticiones de notificación por parte del cliente,
y para que publique bajo demanda valores actualizados para una determinada característica.</li>
</ul>
<h1 id="implementacion-de-un-servidor-gatt-basado-en-tablas">Implementación de un servidor GATT basado en tablas</h1>
<h2 id="introduccion">Introducción</h2>
<p>En esta práctica, desplegaremos un servidor GATT utilizando la API de ESP-IDF
para tal fin. Dicha API expone las funcionalidades de Bluedroid, la pila
Bluetooth (incluyendo BLE) que proporciona ESP-IDF para el desarrollo de 
aplicaciones Bluetooth. </p>
<p>El ejemplo con el que trabajaremos reside en el directorio 
<code>examples/bluetooth/bluedroid/ble/gatt_server_service_table</code>. Debido a la 
complejidad del ejemplo (al menos en su parte inicial), la presente práctica
procede, en primer lugar, con un recorrido por la preparación y construcción
del servidor siguiendo una estructura de tabla que define los servicios y
características que se implementarán en el mismo. </p>
<p>El ejemplo implementa el perfile <em>Heart Rate Profile</em> definido en la
<a href="https://www.bluetooth.com/specifications/profiles-overview">especificación Bluetooth</a>,
y sigue la siguiente estructura:</p>
<div align="center"><img src="img/Heart_Rate_Service.png" width = "450" alt="Table-like data structure representing the Heart Rate Service" align=center /> </div>

<p>Desplegaremos, por tanto, tres características. De ellas, la más importante
para nosotros será el valor de medición de ritmo cardiaco, con su valor
(<em>Heart Rate Measurement Value</em>) y su configuración de notificaciones
(<em>Heart Rate Measurement Notification Configuration</em>).</p>
<h2 id="inclusion-de-encabezados">Inclusión de encabezados</h2>
<p>Los siguientes ficheros de cabecera son necesarios para dotar de funcionalidad
BLE a nuestro <em>firmware</em>:</p>
<pre><code class="language-c">#include &quot;freertos/FreeRTOS.h&quot;
#include &quot;freertos/task.h&quot;
#include &quot;freertos/event_groups.h&quot;
#include &quot;esp_system.h&quot;
#include &quot;esp_log.h&quot;
#include &quot;nvs_flash.h&quot;
#include &quot;bt.h&quot;
#include &quot;bta_api.h&quot;

#include &quot;esp_gap_ble_api.h&quot;
#include &quot;esp_gatts_api.h&quot;
#include &quot;esp_bt_defs.h&quot;
#include &quot;esp_bt_main.h&quot;
#include &quot;esp_bt_main.h&quot;
#include “gatts_table_creat_demo.h&quot;
</code></pre>
<p>Estos encabezados son necesarios para un correcto funcionamiento de <em>FreeRTOS</em>
y de sus componentes, incluyendo funcionalidad relativa a <em>logging</em> y 
almacenamiento no volátil. 
Son especialmente interesantes los ficheros <code>bt.h</code>, <code>esp_bt_main.h</code>, 
<code>esp_gap_ble_api.h</code> y <code>esp_gatts_api.h</code>, ya que exponen la API BLE necesaria
para la implementación del <em>firmware</em>:</p>
<ul>
<li><code>bt.h</code>: implementa el controlador Bluetooth.</li>
<li><code>esp_bt_main.h</code>: implementa las rutinas de inicialización y activación de la pila Bluedroid.</li>
<li><code>esp_gap_ble_api.h</code>: implementa la configuración GAP (parámetros de anuncios y conexión).</li>
<li><code>esp_gatts_api.h</code>: immplementa la configuración del servidor GATT (por ejemplo, la creación de servicios y características).</li>
</ul>
<h2 id="la-tabla-de-servicios">La tabla de servicios</h2>
<p>El fichero de encabezado <a href="../main/gatts_table_creat_demo.h">gatts_table_creat_demo.h</a> 
contiene una enumeración de los servicios y características deseadas:</p>
<pre><code class="language-c">enum
{
    HRS_IDX_SVC,

    HRS_IDX_HR_MEAS_CHAR,
    HRS_IDX_HR_MEAS_VAL,
    HRS_IDX_HR_MEAS_NTF_CFG,

    HRS_IDX_BOBY_SENSOR_LOC_CHAR,
    HRS_IDX_BOBY_SENSOR_LOC_VAL,

    HRS_IDX_HR_CTNL_PT_CHAR,
    HRS_IDX_HR_CTNL_PT_VAL,

    HRS_IDX_NB,
};
</code></pre>
<p>Los elementos de la anterior estructura se han incluido en el mismo orden
que los atributos del <em>Heart Rate Profile</em>, comenzando con el servicio, seguido
por las características del mismo. Además, la característica <em>Heart Rate Measurement</em>
dispone de configuración propia (<em>Client Characteristic Configuration</em>,
o CCC), un descriptor que <strong>describe si la característica tiene las notificaciones
activas</strong>. Todos estos índices pueden utilizarse para identificar a cada elemento 
a la hora de crear la tabla de atributos:</p>
<ul>
<li><code>HRS_IDX_SVC</code>: índice del servicio Heart Rate.</li>
<li><code>HRS_IDX_HR_MEAS_CHAR</code>: índice de la característica Heart Rate Measurement.</li>
<li><code>HRS_IDX_HR_MEAS_VAL</code>: índice del valor Heart Rate Measurement. </li>
<li><code>HRS_IDX_HR_MEAS_NTF_CFG</code>: índice de la configuración de notificaciones (CCC) Heart Rate Measurement.</li>
<li><code>HRS_IDX_BOBY_SENSOR_LOC_CHAR</code>: índice de la característica Heart Rate Body Sensor Location.</li>
<li><code>HRS_IDX_BOBY_SENSOR_LOC_VAL</code>: índice del valor Heart Rate Body Sensor Location.</li>
<li><code>HRS_IDX_HR_CTNL_PT_CHAR</code>: índice de la característica Heart Rate Control Point.</li>
<li><code>HRS_IDX_HR_CTNL_PT_VAL</code>: índice del valor Heart Rate Control Point.</li>
<li><code>HRS_IDX_NB</code>: número de elementos d ela tabla.</li>
</ul>
<h2 id="punto-de-entrada">Punto de entrada</h2>
<p>El punto de entrada de la aplicación (<code>app_main()</code>) se implementa como 
sigue:</p>
<pre><code class="language-c">void app_main()
{
    esp_err_t ret;

    // Initialize NVS.
    ret = nvs_flash_init();
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
        ESP_ERROR_CHECK(nvs_flash_erase());
        ret = nvs_flash_init();
    }
    ESP_ERROR_CHECK( ret );

    esp_bt_controller_config_t bt_cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT();
    ret = esp_bt_controller_init(&amp;bt_cfg);
    if (ret) {
        ESP_LOGE(GATTS_TABLE_TAG, &quot;%s enable controller failed\n&quot;, __func__);
        return;
    }

    ret = esp_bt_controller_enable(ESP_BT_MODE_BLE);
    if (ret) {
        ESP_LOGE(GATTS_TABLE_TAG, &quot;%s enable controller failed\n&quot;, __func__);
        return;
    }

    ESP_LOGI(GATTS_TABLE_TAG, &quot;%s init bluetooth\n&quot;, __func__);
    ret = esp_bluedroid_init();
    if (ret) {
        ESP_LOGE(GATTS_TABLE_TAG, &quot;%s init bluetooth failed\n&quot;, __func__);
        return;
    }
    ret = esp_bluedroid_enable();
    if (ret) {
        ESP_LOGE(GATTS_TABLE_TAG, &quot;%s enable bluetooth failed\n&quot;, __func__);
        return;
    }

    esp_ble_gatts_register_callback(gatts_event_handler);
    esp_ble_gap_register_callback(gap_event_handler);
    esp_ble_gatts_app_register(ESP_HEART_RATE_APP_ID);
    return;
}
</code></pre>
<p>La función principal procede incializando el almacenamiento no volátil, para 
almacenar los parámetros necesarios en memoria <em>flash</em>:</p>
<pre><code class="language-c">ret = nvs_flash_init();
</code></pre>
<h2 id="inicializacion-del-controlador-y-de-la-pila-bluetooth">Inicialización del controlador y de la pila Bluetooth</h2>
<p>La función principal inicializa también el controlador Bluetooth, creando
en primer lugar una estructura de configuración para tal fin de tipo 
<code>esp_bt_controller_config_t</code> con valores por defecto dictados por la macro               <code>BT_CONTROLLER_INIT_CONFIG_DEFAULT()</code>. </p>
<p>El controlador Bluetooth implementa el <em>Host Controller Interface</em> (HCI), la
capa de enlace y la capa física BLE; es, por tanto, transparente para el programador. 
La configuración incluye el tamaño de pila reservado al controlador, prioridad 
y baudios para la transmisión. Con estas configuraciones, el controlador
puede ser inicializado y activado con la función <code>esp_bt_controller_init()</code>:</p>
<pre><code class="language-c">esp_bt_controller_config_t bt_cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT();
ret = esp_bt_controller_init(&amp;bt_cfg);
</code></pre>
<p>A continuación, el controlador activa el modo BLE:</p>
<pre><code class="language-c">ret = esp_bt_controller_enable(ESP_BT_MODE_BLE);
</code></pre>
<p>Existen cuatro modos de funcioinamiento Bluetooth:</p>
<ol>
<li><code>ESP_BT_MODE_IDLE</code>: Bluetooth no funcional</li>
<li><code>ESP_BT_MODE_BLE</code>: Modo BLE</li>
<li><code>ESP_BT_MODE_CLASSIC_BT</code>: Modo BT Clásico</li>
<li><code>ESP_BT_MODE_BTDM</code>: Modo Dual (BLE + BT Clásico)</li>
</ol>
<p>Tras la incialización del controlador Bluetooth, la pila Bluedroid (que 
incluye APIs tanto para BLE como para Bluetooth Clásico) debe ser inicializada
y activada:</p>
<pre><code class="language-c">ret = esp_bluedroid_init();
ret = esp_bluedroid_enable();
</code></pre>
<p>La pila Bluetooth está, a partir de este punto, lista para funcionar, pero todavía
no se ha implementado ninguna lógica de aplicación. Dicha funcionalidad
se define con el clásico mecanismo basado en eventos, que pueden ser emitidos,
por ejemplo, cuando otro dispositivo intenta leer o escribir parámetros, o
establecer una conexión. </p>
<p>Existen dos gestores de eventos relacionados con BLE: los manejadores 
(<em>handlers</em>) GAP y GATT. La aplicación necesita registrar una función de 
<em>callback</em> para cada manejador, para permitir a la aplicación conocer qué 
funciones se invocarán eventos de tipo GAP y GATT:</p>
<pre><code class="language-c">esp_ble_gatts_register_callback(gatts_event_handler);
esp_ble_gap_register_callback(gap_event_handler);
</code></pre>
<p>Las funciones <code>gatts_event_handler()</code> y <code>gap_event_handler()</code> 
manejan todos los eventos emitidos por la pila BLE hacia la plicación.</p>
<h2 id="perfiles-de-aplicacion-application-profiles">Perfiles de aplicación (<em>Application profiles</em>)</h2>
<p>Como se ha dicho, el objetivo es implementar un Perfil de Aplicación 
para el servicio <em>Heart Rate</em>. Un Perfil de Aplicación es un mecanismo que
permite agrupar funcionalidad diseñada para ser utilizada por un cliente
de la aplicación, por ejemplo, una aplicación móvil. En este sentido, 
diferentes tipos de perfiles pueden acomodarse en un mismo servidor.</p>
<p>El Identifificador de Perfil de Aplicación (<em>Application Profile ID</em>) es un valor
seleccionable por el usuario para identificar cada perfil; su uso se recude al
registro del perfil en la pila Bluetooth. En el ejemplo, el ID es <code>0x55</code>.</p>
<pre><code class="language-c">#define HEART_PROFILE_NUM                       1
#define HEART_PROFILE_APP_IDX                   0
#define ESP_HEART_RATE_APP_ID                   0x55
</code></pre>
<p>Los perfiles se almacenan en el array <code>heart_rate_profile_tab</code>. 
Al haber un único perfil en el ejemplo, sólo se almacena un elemento en el 
array, con índice 0 (tal y como se define en <code>HEART_PROFILE_APP_IDX</code>). 
Además, es necesario inicializar la función de <em>callback</em> manejadora de los
eventos del perfil. Cada aplicación en el servidor GATT utiliza una interfaz
diferenciada, representada por el parámetro <code>gats_if</code>. Para la incialización,
este parámetro se iguala a <code>ESP_GATT_IF_NONE</code>; 
cuando la aplicación se registre, más adelante, el parámetro <code>gatts_if</code> se 
actualizará con la interfaz generada automáticamente por la pila Bluetooth.</p>
<pre><code class="language-c">/* One gatt-based profile one app_id and one gatts_if, this array will store the gatts_if returned by ESP_GATTS_REG_EVT */
static struct gatts_profile_inst heart_rate_profile_tab[HEART_PROFILE_NUM] = {
    [HEART_PROFILE_APP_IDX] = {
        .gatts_cb = gatts_profile_event_handler,
        .gatts_if = ESP_GATT_IF_NONE,       /* Not get the gatt_if, so initial is ESP_GATT_IF_NONE */
    },

};
</code></pre>
<p>El registro de la aplicación tiene lugar en la función <code>app_main()</code>,
utilizando la función <code>esp_ble_gatts_app_register()</code>:</p>
<pre><code class="language-c">esp_ble_gatts_app_register(ESP_HEART_RATE_APP_ID);
</code></pre>
<h2 id="parametros-gap">Parámetros GAP</h2>
<p>El evento de registro de aplicación es el primero que se invoca durante
la vida de un programa. Este ejemplo utiliza este evento para configurar 
parámetros GAP (de anuncio). Las funciones asociadas son:</p>
<ul>
<li><code>esp_ble_gap_set_device_name()</code>: utilizada para establecer el nombre del dispositivo anunciado.</li>
<li><code>esp_ble_gap_config_adv_data()</code>: usada para configurar datos estándar de anuncio.</li>
</ul>
<p>La función utilizada para configurar los parámetros estándar 
(<code>esp_ble_gap_config_adv_data()</code>) toma un puntero a una estructura de tipo <code>esp_ble_adv_data_t</code>. La estructura <code>esp_ble_adv_data_t</code> dispone de los siguientes campos:</p>
<pre><code class="language-c">typedef struct {
    bool set_scan_rsp;    /*!&lt; Set this advertising data as scan response or not*/
    bool include_name;    /*!&lt; Advertising data include device name or not */
    bool include_txpower; /*!&lt; Advertising data include TX power */
    int min_interval;     /*!&lt; Advertising data show slave preferred connection min interval */
    int max_interval;     /*!&lt; Advertising data show slave preferred connection max interval */
    int appearance;       /*!&lt; External appearance of device */
    uint16_t manufacturer_len; /*!&lt; Manufacturer data length */
    uint8_t *p_manufacturer_data; /*!&lt; Manufacturer data point */
    uint16_t service_data_len;    /*!&lt; Service data length */
    uint8_t *p_service_data;      /*!&lt; Service data point */
    uint16_t service_uuid_len;    /*!&lt; Service uuid length */
    uint8_t *p_service_uuid;      /*!&lt; Service uuid array point */
    uint8_t flag;         /*!&lt; Advertising flag of discovery mode, see BLE_ADV_DATA_FLAG detail */
} esp_ble_adv_data_t;
</code></pre>
<p>En el ejemplo, la estructura se incializará como sigue:</p>
<pre><code class="language-c">static esp_ble_adv_data_t heart_rate_adv_config = {
    .set_scan_rsp = false,
    .include_name = true,
    .include_txpower = true,
    .min_interval = 0x0006,
    .max_interval = 0x0010,
    .appearance = 0x00,
    .manufacturer_len = 0, //TEST_MANUFACTURER_DATA_LEN,
    .p_manufacturer_data =  NULL, //&amp;test_manufacturer[0],
    .service_data_len = 0,
    .p_service_data = NULL,
    .service_uuid_len = sizeof(heart_rate_service_uuid),
    .p_service_uuid = heart_rate_service_uuid,
    .flag = (ESP_BLE_ADV_FLAG_GEN_DISC | ESP_BLE_ADV_FLAG_BREDR_NOT_SPT),
};
</code></pre>
<p>Los intervalos mínimos y máximos de conexión se establecen en unidades de
1.25 ms. En el ejemplo, el intervalo de conexión mínimo preferido se establece, 
por tanto, en 7.5 ms y el máximo en 20 ms.</p>
<p>El <em>payload</em> del anuncio puede almacenar hasta 31 bytes de datos. 
Es posible que algunos parámetros los superen, pero en dicho caso el stack
BLE cortará el mensaje y eliminará aquellos que superen el tamaño máximo.
Por último, para establecer el nombre del dispositivo se puede utilizar la 
función <code>esp_ble_gap_set_device_name()</code>. </p>
<p>Para regitrar el manejador de eventos, procedemos de la siguiente forma:</p>
<pre><code class="language-c">static void gatts_profile_event_handler(esp_gatts_cb_event_t event, 
esp_gatt_if_t gatts_if, esp_ble_gatts_cb_param_t *param)
{
    ESP_LOGE(GATTS_TABLE_TAG, &quot;event = %x\n&quot;,event);
    switch (event) {
        case ESP_GATTS_REG_EVT:
            ESP_LOGI(GATTS_TABLE_TAG, &quot;%s %d\n&quot;, __func__, __LINE__);
            esp_ble_gap_set_device_name(SAMPLE_DEVICE_NAME);
            ESP_LOGI(GATTS_TABLE_TAG, &quot;%s %d\n&quot;, __func__, __LINE__);
            esp_ble_gap_config_adv_data(&amp;heart_rate_adv_config);
            ESP_LOGI(GATTS_TABLE_TAG, &quot;%s %d\n&quot;, __func__, __LINE__);
…
</code></pre>
<h2 id="el-manejador-de-eventos-gap">El manejador de eventos GAP</h2>
<p>Una vez establecidos los datos de anuncio, se emite un evento de tipo 
<code>ESP_GAP_BLE_ADV_DATA_SET_COMPLETE_EVT</code>, que será manejado por el manejador
 GAP configurado. Además, se emite también un evento de tipo
 <code>ESP_GAP_BLE_SCAN_RSP_DATA_SET_COMPLETE_EVT</code> si se ha configurado una respuesta
 al escaneado.
Así, el manejador puede utilizar cualquiera de estos dos eventos para comenzar
con el proceso de anuncio, utilizando la función
<code>esp_ble_gap_start_advertising()</code>:</p>
<pre><code class="language-c">static void gap_event_handler(esp_gap_ble_cb_event_t event, esp_ble_gap_cb_param_t *param)
{   
    ESP_LOGE(GATTS_TABLE_TAG, &quot;GAP_EVT, event %d\n&quot;, event);

    switch (event) {
    case ESP_GAP_BLE_ADV_DATA_SET_COMPLETE_EVT:
        esp_ble_gap_start_advertising(&amp;heart_rate_adv_params);
        break;
    case ESP_GAP_BLE_ADV_START_COMPLETE_EVT:
        //advertising start complete event to indicate advertising start successfully or failed
        if (param-&gt;adv_start_cmpl.status != ESP_BT_STATUS_SUCCESS) {
            ESP_LOGE(GATTS_TABLE_TAG, &quot;Advertising start failed\n&quot;);
        }
        break;
    default:
        break;
    }
}
</code></pre>
<p>La función de inicio de anuncios toma una estructura de tipo 
<code>esp_ble_adv_params_t</code> con los parámetros de anuncio requeridos:</p>
<pre><code class="language-c">/// Advertising parameters
typedef struct {
    uint16_t adv_int_min; /*!&lt; Minimum advertising interval for undirected and low duty cycle directed advertising.
    Range: 0x0020 to 0x4000
    Default: N = 0x0800 (1.28 second)
    Time = N * 0.625 msec
    Time Range: 20 ms to 10.24 sec */
    uint16_t adv_int_max; /*!&lt; Maximum advertising interval for undirected and low duty cycle directed advertising.
    Range: 0x0020 to 0x4000
    Default: N = 0x0800 (1.28 second)
    Time = N * 0.625 msec
    Time Range: 20 ms to 10.24 sec */
    esp_ble_adv_type_t adv_type;            /*!&lt; Advertising type */
    esp_ble_addr_type_t own_addr_type;      /*!&lt; Owner bluetooth device address type */
    esp_bd_addr_t peer_addr;                /*!&lt; Peer device bluetooth device address */
    esp_ble_addr_type_t peer_addr_type;     /*!&lt; Peer device bluetooth device address type */
    esp_ble_adv_channel_t channel_map;      /*!&lt; Advertising channel map */
    esp_ble_adv_filter_t adv_filter_policy; /*!&lt; Advertising filter policy */
} esp_ble_adv_params_t;
</code></pre>
<p>Nótese como <code>esp_ble_gap_config_adv_data()</code> configura los datos que son
aunciados al cliente y toma una estructura de tipo <code>esp_ble_adv_data_t structure</code>, 
mientras que <code>esp_ble_gap_start_advertising()</code> hace que el servidor realmente
comience a anunciar, tomando una estructura de tipo <code>esp_ble_adv_params_t</code>. 
Los datos de anuncio son aquellos que realmente se envían al cliente, mientras
que los parámetros de anuncio son la configuración requerida por la pila BLE
para actuar correctamente.</p>
<p>Para este ejemplo, los parámetros de anuncio se inicializarán como sigue:</p>
<pre><code class="language-c">static esp_ble_adv_params_t heart_rate_adv_params = {
    .adv_int_min        = 0x20,
    .adv_int_max        = 0x40,
    .adv_type           = ADV_TYPE_IND,
    .own_addr_type      = BLE_ADDR_TYPE_PUBLIC,
    //.peer_addr            =
    //.peer_addr_type       =
    .channel_map        = ADV_CHNL_ALL,
    .adv_filter_policy = ADV_FILTER_ALLOW_SCAN_ANY_CON_ANY,
};
</code></pre>
<p>Estos parámetros configuran el intervalo de anuncio entre 20 ms y 40 ms. 
El anuncio es de tipo <code>ADV_TYPE_IND</code> (tipo genérico), destinados a ningún dispositivo
central en particular, y anuncia que el servidor GATT es conectable. El tipo 
de dirección es público, utiliza todos los canales y permite peticiones de 
escaneo y conexión por parte de cualquier dispositivo central.</p>
<p>Si el proceso de anuncio se inició correctamente, se emitirá un evento de tipo
<code>ESP_GAP_BLE_ADV_START_COMPLETE_EVT</code>, que en este ejemplo se utiliza para comprobar
si el estado de anuncio es realmente <em>anunciando</em> u otro, en cuyo caso se 
emitirá un mensaje de error:</p>
<pre><code class="language-c">...
    case ESP_GAP_BLE_ADV_START_COMPLETE_EVT:
        //advertising start complete event to indicate advertising start successfully or failed
        if (param-&gt;adv_start_cmpl.status != ESP_BT_STATUS_SUCCESS) {
            ESP_LOGE(GATTS_TABLE_TAG, &quot;Advertising start failed\n&quot;);
        }
        break;
...
</code></pre>
<h2 id="manejadores-de-eventos-gatt">Manejadores de eventos GATT</h2>
<p>Al registrar un Pefil de Aplicación, se emite un evento de tipo
<code>ESP_GATTS_REG_EVT</code>. 
Los parámetros asociados al evento son:</p>
<pre><code class="language-c">esp_gatt_status_t status;    /*!&lt; Operation status */
uint16_t app_id;             /*!&lt; Application id which input in register API */
</code></pre>
<p>Además de los anteriores parámetros, el evento también contiene la interfaz
GATT asignada por la pila BLE, a utilizar a partir de ahora. El evento es capturado
por el manejador <code>gatts_event_handler()</code>, que almacena la interfaz generada
en la tabla de perfiles, y la reenvía al manejador de eventos correspondiente 
al perfil:</p>
<pre><code class="language-c">static void gatts_event_handler(esp_gatts_cb_event_t event, esp_gatt_if_t gatts_if, esp_ble_gatts_cb_param_t *param)
{
    ESP_LOGI(GATTS_TABLE_TAG, &quot;EVT %d, gatts if %d\n&quot;, event, gatts_if);

    /* If event is register event, store the gatts_if for each profile */
    if (event == ESP_GATTS_REG_EVT) {
        if (param-&gt;reg.status == ESP_GATT_OK) {
            heart_rate_profile_tab[HEART_PROFILE_APP_IDX].gatts_if = gatts_if;
        } else {
            ESP_LOGI(GATTS_TABLE_TAG, &quot;Reg app failed, app_id %04x, status %d\n&quot;,
                    param-&gt;reg.app_id,
                    param-&gt;reg.status);
            return;
        }
    }

    do {
        int idx;
        for (idx = 0; idx &lt; HEART_PROFILE_NUM; idx++) {
            if (gatts_if == ESP_GATT_IF_NONE || /* ESP_GATT_IF_NONE, not specify a certain gatt_if, need to call every profile cb function */
            gatts_if == heart_rate_profile_tab[idx].gatts_if) {
                if (heart_rate_profile_tab[idx].gatts_cb) {
                    heart_rate_profile_tab[idx].gatts_cb(event, gatts_if, param);
                }
            }
        }
    } while (0);
}
</code></pre>
<h2 id="creacion-de-servicios-y-caracteristicas-con-una-tabla-de-atributos">Creación de Servicios y Características con una Tabla de Atributos</h2>
<p>Aprovecharemos el evento de tipo Registro para crear una tabla de atributos
de perfil utilizando la función <code>esp_ble_gatts_create_attr_tab()</code>.
Esta función toma como argumento una estructura de tipo <code>esp_gatts_attr_db_t</code>,
que corresponde a una tabla de <em>lookup</em> 
indexada por los valores de la enumeración definidos en el fichero de cabecera.
La estructura <code>esp_gatts_attr_db_t</code> tiene dos miembros:</p>
<pre><code class="language-c">esp_attr_control_t    attr_control;       /*!&lt; The attribute control type*/
esp_attr_desc_t       att_desc;           /*!&lt; The attribute type*/
</code></pre>
<ul>
<li>
<p><code>attr_control</code> es el parámetro de autorespuesta, típicamente fijado a 
<code>ESP_GATT_AUTO_RSP</code> para permitir que la pila BLE reponda automáticamente a los
mensajes de lectura o escritura cuando dichos eventos son recibidos. 
Una opción alternativa es <code>ESP_GATT_RSP_BY_APP</code> que permite respuestas 
manuales utilizando la función <code>esp_ble_gatts_send_response()</code>.</p>
</li>
<li>
<p><code>att_desc</code> es la descripción del atributo, formada por:</p>
</li>
</ul>
<pre><code class="language-c">uint16_t uuid_length;      /*!&lt; UUID length */  
uint8_t  *uuid_p;          /*!&lt; UUID value */  
uint16_t perm;             /*!&lt; Attribute permission */        
uint16_t max_length;       /*!&lt; Maximum length of the element*/    
uint16_t length;           /*!&lt; Current length of the element*/    
uint8_t  *value;           /*!&lt; Element value array*/ 
</code></pre>
<p>Por ejemplo, el primer elemento de la tabla en el ejemplo es el atributo de servicio:</p>
<pre><code class="language-c">[HRS_IDX_SVC]                       =
    {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&amp;primary_service_uuid, ESP_GATT_PERM_READ,
      sizeof(uint16_t), sizeof(heart_rate_svc), (uint8_t *)&amp;heart_rate_svc}},
</code></pre>
<p>Los valores de inicialización son:</p>
<ul>
<li><code>[HRS_IDX_SVC]</code>: Inicializador en la tabla.</li>
<li><code>ESP_GATT_AUTO_RSP</code>: configuración de respuesta automática, fijada en este
    caso a respuesta automática por parte de la pila BLE.</li>
<li><code>ESP_UUID_LEN_16</code>: longitudo del UUID fijada a 16 bits.</li>
<li><code>(uint8_t *)&amp;primary_service_uuid</code>: UUID para identificar al servicio como primario (0x2800).</li>
<li><code>ESP_GATT_PERM_READ</code>: Permisos de lectura para el servicio.</li>
<li><code>sizeof(uint16_t)</code>: Longitud máxima del UUID del servicio (16 bits).</li>
<li><code>sizeof(heart_rate_svc)</code>: Longitud del servicio, en este caso 16 bits (fijada por el tamaño de la variable <em>heart_rate_svc</em>).</li>
<li><code>(uint8_t *)&amp;heart_rate_svc</code>: Valor del atributo servicio fijada a la 
 variable the variable <em>heart_rate_svc</em>, que contiene el UUID del <em>Heart Rate Service</em> (0x180D).</li>
</ul>
<p>El resto de atributos se inicializan de forma similar. Algunos atributos también
tienen activa la propiedad <em>NOTIFY</em>, que se establece vía 
<code>&amp;char_prop_notify</code>. La tabla completa se inicializa como sigue:</p>
<pre><code class="language-c">/// Full HRS Database Description - Used to add attributes into the database
static const esp_gatts_attr_db_t heart_rate_gatt_db[HRS_IDX_NB] =
{
    // Heart Rate Service Declaration
    [HRS_IDX_SVC]                       =
    {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&amp;primary_service_uuid, ESP_GATT_PERM_READ,
      sizeof(uint16_t), sizeof(heart_rate_svc), (uint8_t *)&amp;heart_rate_svc}},

    // Heart Rate Measurement Characteristic Declaration
    [HRS_IDX_HR_MEAS_CHAR]            =
    {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&amp;character_declaration_uuid, ESP_GATT_PERM_READ,
      CHAR_DECLARATION_SIZE,CHAR_DECLARATION_SIZE, (uint8_t *)&amp;char_prop_notify}},

    // Heart Rate Measurement Characteristic Value
    [HRS_IDX_HR_MEAS_VAL]               =
    {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&amp;heart_rate_meas_uuid, ESP_GATT_PERM_READ,
      HRPS_HT_MEAS_MAX_LEN,0, NULL}},

    // Heart Rate Measurement Characteristic - Client Characteristic Configuration Descriptor
    [HRS_IDX_HR_MEAS_NTF_CFG]           =
    {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&amp;character_client_config_uuid, ESP_GATT_PERM_READ|ESP_GATT_PERM_WRITE,
      sizeof(uint16_t),sizeof(heart_measurement_ccc), (uint8_t *)heart_measurement_ccc}},

    // Body Sensor Location Characteristic Declaration
    [HRS_IDX_BOBY_SENSOR_LOC_CHAR]  =
    {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&amp;character_declaration_uuid, ESP_GATT_PERM_READ,
      CHAR_DECLARATION_SIZE,CHAR_DECLARATION_SIZE, (uint8_t *)&amp;char_prop_read}},

    // Body Sensor Location Characteristic Value
    [HRS_IDX_BOBY_SENSOR_LOC_VAL]   =
    {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&amp;body_sensor_location_uuid, ESP_GATT_PERM_READ,
      sizeof(uint8_t), sizeof(body_sensor_loc_val), (uint8_t *)body_sensor_loc_val}},

    // Heart Rate Control Point Characteristic Declaration
    [HRS_IDX_HR_CTNL_PT_CHAR]          =
    {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&amp;character_declaration_uuid, ESP_GATT_PERM_READ,
      CHAR_DECLARATION_SIZE,CHAR_DECLARATION_SIZE, (uint8_t *)&amp;char_prop_read_write}},

    // Heart Rate Control Point Characteristic Value
    [HRS_IDX_HR_CTNL_PT_VAL]             =
    {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&amp;heart_rate_ctrl_point, ESP_GATT_PERM_WRITE|ESP_GATT_PERM_READ,
      sizeof(uint8_t), sizeof(heart_ctrl_point), (uint8_t *)heart_ctrl_point}},
};
</code></pre>
<h2 id="inicializacion-del-servicio">Inicialización del servicio</h2>
<p>Cuando la tabla se crea, se emite un evento de tipo <code>ESP_GATTS_CREAT_ATTR_TAB_EVT</code>. 
Este evento tiene los siguientes parámetros asociados:</p>
<pre><code class="language-c">esp_gatt_status_t status;    /*!&lt; Operation status */
esp_bt_uuid_t svc_uuid;      /*!&lt; Service uuid type */
uint16_t num_handle;         /*!&lt; The number of the attribute handle to be added to the gatts database */
uint16_t *handles;           /*!&lt; The number to the handles */
</code></pre>
<p>Este ejemplo utiliza este evento para mostrar información y comprobar que el 
tamaño de la tabla creada es igual al número de elementos en la enumeración
<code>HRS_IDX_NB</code>. Si la tabla se creó correctamente, los manejadores de atributos se copian
en la tabla de manejadores <code>heart_rate_handle_table</code> y el servicio se inicicaliza
utilizando la función <code>esp_ble_gatts_start_service()</code>:</p>
<pre><code class="language-c">case ESP_GATTS_CREAT_ATTR_TAB_EVT:{
        ESP_LOGI(GATTS_TABLE_TAG, &quot;The number handle =%x\n&quot;,param-&gt;add_attr_tab.num_handle);
        if (param-&gt;add_attr_tab.status != ESP_GATT_OK){
            ESP_LOGE(GATTS_TABLE_TAG, &quot;Create attribute table failed, error code=0x%x&quot;, param-&gt;add_attr_tab.status);
        }
        else if (param-&gt;add_attr_tab.num_handle != HRS_IDX_NB){
            ESP_LOGE(GATTS_TABLE_TAG, &quot;Create attribute table abnormally, num_handle (%d) \
                    doesn't equal to HRS_IDX_NB(%d)&quot;, param-&gt;add_attr_tab.num_handle, HRS_IDX_NB);
        }
        else {
            memcpy(heart_rate_handle_table, param-&gt;add_attr_tab.handles, sizeof(heart_rate_handle_table));
            esp_ble_gatts_start_service(heart_rate_handle_table[HRS_IDX_SVC]);
        }
        break;
</code></pre>
<p>Los manejadores almacenados son números que identifican cada atributo. Estos manejadores
pueden usarse para determinar qué característica está siendo leída o escrita,
y por tanto pueden ser proporcionados a otros puntos de la aplicación para manejar
distintas acciones.</p>
<p>Finalmente, la tabla <code>heart_rate_handle_table</code> contiene el Perfil de Aplicación
en forma de estructura con información sobre los parámetros de los atributos y 
la interfaz GATT, ID de conexión, permisos e ID de aplicación. La estructura
presenta los siguientes campos (no todos se usan en el ejemplo):</p>
<pre><code class="language-c">struct gatts_profile_inst {
    esp_gatts_cb_t gatts_cb;
    uint16_t gatts_if;
    uint16_t app_id;
    uint16_t conn_id;
    uint16_t service_handle;
    esp_gatt_srvc_id_t service_id;
    uint16_t char_handle;
    esp_bt_uuid_t char_uuid;
    esp_gatt_perm_t perm;
    esp_gatt_char_prop_t property;
    uint16_t descr_handle;
    esp_bt_uuid_t descr_uuid;
};
</code></pre>
<h1 id="interaccion-a-traves-de-un-cliente-gatt">Interacción a través de un cliente GATT</h1>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Para desarrollar esta parte de la práctica, deberás importar la máquina 
virtual del curso en el PC del laboratorio, y hacer visible a ella el
dispositivo Bluetooth del equipo de laboratorio.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Existen multitud de herramientas que permiten gestionar la conexión
al servidor GATT. En Linux, utilizaremos <code>hcitool</code> y <code>gatttool</code>; en 
Windows, puedes utilizar una herramienta llamada <code>Bluetooth LE Explorer</code>,
que implementa, aunque de forma gráfica, la misma funcionalidad.</p>
</div>
<h2 id="uso-de-hcitool-y-gatttool-en-modo-cliente">Uso de <code>hcitool</code> y <code>gatttool</code> en modo cliente</h2>
<h3 id="escaneando-dispositivos-disponibles-hcitool">Escaneando dispositivos disponibles: <code>hcitool</code></h3>
<p><code>hcitool</code> es una herramienta de línea de comandos que permite gestionar
la interfaz Bluetooth del equipo en el que se ejecuta. En nuestro caso, 
necesitaremos determinar la dirección MAC Bluetooth de nuestro servidor.
Para ello, en primer lugar, realizaremos un escaneado de los dispsitivos
BLE disponibles en el entorno utilizando la orden:</p>
<pre><code class="language-sh">sudo hcitool lescan
</code></pre>
<p>Si todo ha ido bien, se mostrará una línea por dispositivo BLE disponible
y en fase de anuncio. Entre ellos, deberemos encontrar nuestro dispositivo,
para recordar su dirección MAC.</p>
<div class="admonition note">
<p class="admonition-title">Tarea</p>
<p>Edita el fichero <code>main/gatts_table_creat_demo.c</code> y modifica el nombre
de tu dispositivo, que se anunciará en cada anuncio emitido en la fase
de <code>advertising</code>. Para ello, debes modificar el valor de la macro
<code>SAMPLE_DEVICE_NAME</code>.
A continuación, compila y flashea el ejemplo, y comienza una sesión de
escaneado de dispositivos BLE mediante la orden:
<code>sudo hcitool lescan</code>.
Deberás observar tu dispositivo en una de las líneas. Anota o recuerda
su dirección MAC.</p>
</div>
<h3 id="interactuando-con-el-servidor-gatt-gatttool">Interactuando con el servidor GATT: <code>gatttool</code></h3>
<p>Una vez obtenida la dirección MAC Bluetooth del dispositivo, deberemos proceder
en dos fases. La primera de ellas es el emparejado al dispostivo desde tu
consola. La segunda, la interacción con la tabla GATT. En ambos casos, se
utilizará la herramienta <code>gatttool</code> desde línea de comandos.</p>
<p>Para comenzar una sesión <code>gatttool</code>, invocaremos a la herramienta en modo
interactivo, utilizando la orden:</p>
<pre><code class="language-sh">gatttool -b MAC -I
</code></pre>
<p>Esto abrirá una consola interactiva, a la espera de las ordenes correspondientes.</p>
<p>Para realizar el emparejamiento, y considerando que la MAC Bluetooth es 
ya conocida, utilizaremos la orden <code>connect</code>. Si todo ha ido bien, deberemos observar
un cambio en el color del prompt, y un mensaje <em>Connection successful</em>. En este punto,
observa como en la salida de depuración del ESP32 se muestran los mensajes
correspondientes al proceso de emparejamiento.</p>
<p>Desde la terminal de <code>gatttool</code>, puedes ejecutar en cualquier momento la 
orden <code>help</code> para obtener ayuda (en forma de lista de comandos disponibles):</p>
<pre><code class="language-sh">gatttool -b 24:6F:28:36:60:B2 -I
[24:6F:28:36:60:B2][LE]&gt; connect
Attempting to connect to 24:6F:28:36:60:B2
Connection successful
[24:6F:28:36:60:B2][LE]&gt; help
help                                           Show this help
exit                                           Exit interactive mode
quit                                           Exit interactive mode
connect         [address [address type]]       Connect to a remote device
disconnect                                     Disconnect from a remote device
primary         [UUID]                         Primary Service Discovery
included        [start hnd [end hnd]]          Find Included Services
characteristics [start hnd [end hnd [UUID]]]   Characteristics Discovery
char-desc       [start hnd] [end hnd]          Characteristics Descriptor Discovery
char-read-hnd   &lt;handle&gt;                       Characteristics Value/Descriptor Read by handle
char-read-uuid  &lt;UUID&gt; [start hnd] [end hnd]   Characteristics Value/Descriptor Read by UUID
char-write-req  &lt;handle&gt; &lt;new value&gt;           Characteristic Value Write (Write Request)
char-write-cmd  &lt;handle&gt; &lt;new value&gt;           Characteristic Value Write (No response)
sec-level       [low | medium | high]          Set security level. Default: low
mtu             &lt;value&gt;                        Exchange MTU for GATT/ATT
</code></pre>
<p>Comenzaremos consultando la lista de características del servidor GATT.</p>
<div class="admonition note">
<p class="admonition-title">Tarea</p>
<p>Mediante el comando correspondiente (<code>characteristics</code>), 
consulta y anota las características disponibles en tu servidor GATT.</p>
</div>
<p>Una de estas características será de crucial interés, ya que nos permitirá
acceder, a través de su UUID, a la medición instantánea de ritmo cardíaco, así
como a la configuración de notificaciones sobre dicho valor. Para determinar 
cuál de las líneas es la que nos interesa, observa el valor de UUID devuelta
para cada una de ellas, y determina, en función de la macro <code>GATTS_CHAR_UUID_TEST_A</code>
de cuál se trata.</p>
<p>Para interactuar con dicha característica, necesitaremos un manejador 
(<em>handler</em>) que permita un uso más sencillo de la misma desde la herramienta
<code>gatttool</code>. Dicho manejador se muestra, para cada línea, tras la cadena
<em>char value handle</em>. </p>
<div class="admonition note">
<p class="admonition-title">Tarea</p>
<p>El manejador que permite leer desde la característica *Heart Rate Value"
tiene un manejador de tipo carácter asociado. Anota su valor.</p>
</div>
<p>Para leer el valor de la característica, podemos utilizar su manejador asociado.
Así, podemos obtener dicho valor con un comando de lectura, en este caso
<code>char-read-hnd manejador</code>.</p>
<div class="admonition note">
<p class="admonition-title">Tarea</p>
<p>Obtén los datos de lectura de la característica de medición del valor
de monitorización de ritmo cardíaco. ¿Cuáles son? Deberías observar un 
valor de retorno de cuatro bytes con valor 0x00. Estos valores corresponden
a los de la variable <code>char_value</code> de tu código. Modifícalos, recompila y 
vuelve a <em>flashear</em> el código. ¿Han variado?</p>
</div>
<div class="admonition note">
<p class="admonition-title">Tarea</p>
<p>Intenta ahora escribir en la anterior característica. Para ello, utiliza
el comando <code>char-write-cmd handler valor</code>, siendo valor, por ejemplo, 
<code>11223344</code>. ¿Es posible? ¿Por qué?</p>
</div>
<p>Escribiremos a continuación en la característica de configuración del servicio
de montorización. Para ello, utilizaremos el manejador siguiente al utilizado
anteriormente. Esto es, si se nos devolvió, por ejemplo, un manejador
<code>0x0001</code> para el valor de monitorización, el valor de configuración será 
<code>0x0002</code>.</p>
<div class="admonition note">
<p class="admonition-title">Tarea</p>
<p>Intenta ahora escribir en la característica de configuración. Para ello, utiliza
el comando <code>char-write-cmd handler valor</code>, siendo valor, por ejemplo, 
<code>0100</code>. ¿Es posible? ¿Por qué?</p>
</div>
<p>Como habrás observado, es posible leer desde el valor de monitorización, y 
escribir en el valor de configuración. Utilizaremos esta última característica
para configurar las notificaciones sobre el valor de monitorización. De este
modo, cada vez que se desee enviar dicho valor a los clientes que tengan 
activada la notificación, éstos la recibirán sin necesidad de cambio alguno.</p>
<p>Para ello, necesitamos modificar algunas partes de nuestro código. Específicamente, 
necesitaremos:</p>
<ol>
<li>Crear una nueva tarea que, periódicamente, modifique el valor de monitorización
de ritmo cardíaco (leyéndolo desde un sensor, si está disponible, o, en nuestro caso
generando un valor aleatorio). Dicha tarea consistirá en un bucle infinito que, 
en cualquier caso, sólo enviará datos al cliente si la notificación está activa,
con un intervalo de envío de un segundo:</li>
</ol>
<pre><code class="language-c">static void publish_data_task(void *pvParameters)
{
    while (1) {
        ESP_LOGI(&quot;APP&quot;, &quot;Sending data...&quot;); 

        // Paso 1: Actualizo valor...

        // Paso 2: Si notificación activa...

        // Paso 3: Envío datos...

        // Paso 4: Duermo un segundo...
        vTaskDelay( 1000. / portTICK_PERIOD_MS);
    }
}
</code></pre>
<p>Esta rutina deberá crearse en respuesta al evento de conexión por parte de un
cliente, utilizando, por ejemplo, la invocación a:</p>
<pre><code class="language-c">xTaskCreate(&amp;publish_data_task, &quot;publish_data_task&quot;, 4096, NULL, 5, NULL);
</code></pre>
<ol>
<li>
<p>La actualización del valor, realizada periódicamente y de forma aleatoria,
modificará el byte 1 de la variable <code>char_value</code>, tomando un valor aleatorio
entre 0 y 255 (como nota adicional, los pulsómetros actuales soportan valores
mayores para ritmo cardiaco, aunque la configuración de esta funcionalidad
está fuera del alcance de la práctica).</p>
</li>
<li>
<p>La comprobación de la activación o no de la notificación se realiza consultando
los dos bytes de la variable <code>heart_meaurement_ccc</code>. Si dichos valores
son <code>0x01</code> y <code>0x00</code> (posiciones 0 y 1, respectivamente), las notificaciones 
están activas, y por tanto, se realizará el envío de notificación.</p>
</li>
<li>
<p>Para enviar la notificación, utilizaremos la siguiente función:</p>
</li>
</ol>
<pre><code class="language-c">esp_ble_gatts_send_indicate(heart_rate_profile_tab[0].gatts_if, 
                                      heart_rate_profile_tab[0].conn_id,
                                      heart_rate_handle_table[IDX_CHAR_VAL_A],
                                      sizeof(char_value), char_value, false);
</code></pre>
<p>La activación de notificaciones desde <code>gatttool</code> se realizará mediante 
la escritura del valor <code>0x0100</code> en la característica de configuración, esto es:</p>
<pre><code class="language-sh">char-write-cmd HANDLER 0100
</code></pre>
<p>Nuestro <em>firmware</em> deberá modificarse para que, al recibir dicho valor en 
la característica, se sobreescriba el contenido de la variable
<code>heart_measurement_ccc</code>. Esta escritura debe realizarse en respuesta al
evento <code>ESP_GATTS_WRITE_EVT</code>.</p>
<div class="admonition danger">
<p class="admonition-title">Tarea entregable</p>
<p>Modifica el firmware original para que, periódicamente (cada segundo) notifique
el valor de ritmo cardíaco a los clientes conectados.</p>
<p>Si además modificas las UUID por las proporcionadas en la especificación 
Bluetooth para el Servicio <em>Heart Rate</em> y todo ha sido configurado correctamente,
tu ESP32 debería poder interactuar con cualquier monitor de ritmo cardiaco para, 
por ejemplo, Android. Para ello, utiliza las siguientes UUIDs:</p>
<ul>
<li>static const uint16_t GATTS_SERVICE_UUID_TEST      = 0x180D; //0x00FF;</li>
<li>static const uint16_t GATTS_CHAR_UUID_TEST_A       = 0x2A37; //0xFF01;</li>
<li>static const uint16_t GATTS_CHAR_UUID_TEST_B       = 0x2A38; //0xFF02;</li>
<li>static const uint16_t GATTS_CHAR_UUID_TEST_C       = 0x2A39; //0xFF03;</li>
</ul>
<p>Entrega el código modificado, así como evidencias (capturas de pantalla)
que demuestren que un cliente <code>gatttool</code> suscrito a notificaciones recibe, 
cada segundo, la actualización de ritmo cardíaco por parte del sensor.</p>
</div></div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../js/base.js" defer></script>
        <script src="../../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="Keyboard Shortcuts Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Keyboard Shortcuts</h4>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
