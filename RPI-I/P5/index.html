<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>Práctica 5 - Master IoT UCM - Prácticas RPI</title>
        <link href="../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">

        <script src="../../js/jquery-1.10.2.min.js" defer></script>
        <script src="../../js/bootstrap.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../..">Master IoT UCM - Prácticas RPI</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="navitem">
                                <a href="../.." class="nav-link">Calendario</a>
                            </li>
                            <li class="dropdown active">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">RPI-I <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../P1/" class="dropdown-item">Práctica 1</a>
</li>
                                    
<li>
    <a href="../P2/" class="dropdown-item">Práctica 2</a>
</li>
                                    
<li>
    <a href="../P3/" class="dropdown-item">Práctica 3</a>
</li>
                                    
<li>
    <a href="../P4/" class="dropdown-item">Práctica 4</a>
</li>
                                    
<li>
    <a href="./" class="dropdown-item active">Práctica 5</a>
</li>
                                    
<li>
    <a href="../P6/" class="dropdown-item">Práctica 6</a>
</li>
                                    
<li>
    <a href="../P7/" class="dropdown-item">Práctica 7</a>
</li>
                                    
<li>
    <a href="../P8/" class="dropdown-item">Práctica 8</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">RPI-II <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../RPI-II/P1/" class="dropdown-item">Práctica 1</a>
</li>
                                    
<li>
    <a href="../../RPI-II/P2/" class="dropdown-item">Práctica 2</a>
</li>
                                    
<li>
    <a href="../../RPI-II/P3/" class="dropdown-item">Práctica 3</a>
</li>
                                    
<li>
    <a href="../../RPI-II/P4/" class="dropdown-item">Práctica 4</a>
</li>
                                    
<li>
    <a href="../../RPI-II/P5/" class="dropdown-item">Práctica 5</a>
</li>
                                    
<li>
    <a href="../../RPI-II/P6/" class="dropdown-item">Práctica 6 (I)</a>
</li>
                                    
<li>
    <a href="../../RPI-II/P6-II/" class="dropdown-item">Práctica 6 (II)</a>
</li>
                                    
<li>
    <a href="../../RPI-II/P7/" class="dropdown-item">Práctica 7</a>
</li>
                                    
<li>
    <a href="../../RPI-II/P8/" class="dropdown-item">Práctica 8</a>
</li>
                                    
<li>
    <a href="../../RPI-II/P9/" class="dropdown-item">Práctica 9</a>
</li>
                                    
<li>
    <a href="../../RPI-II/P10/" class="dropdown-item">Práctica 10</a>
</li>
                                </ul>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../P4/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="../P6/" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-light">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#practica-4-bluetooth-mesh-ble-mesh" class="nav-link">Práctica 4. Bluetooth Mesh (BLE MESH)</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#objetivos" class="nav-link">Objetivos</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#requisitos-previos" class="nav-link">Requisitos previos</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#ejemplo-para-el-modelo-on-off-model" class="nav-link">Ejemplo para el modelo ON-OFF MODEL</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#ejemplo-para-el-modelo-sensor-model" class="nav-link">Ejemplo para el modelo SENSOR MODEL</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="practica-4-bluetooth-mesh-ble-mesh">Práctica 4. Bluetooth Mesh (BLE MESH)</h1>
<h2 id="objetivos">Objetivos</h2>
<ul>
<li>
<p>Poner en práctica los conceptos estudiados en teoría en relación a BLE MESH,
específicamente provisionamiento y modelos cliente/servidor.</p>
</li>
<li>
<p>Desplegar una infraestructura de provisionamiento de un modelo ONOFF GENERIC
SERVER con provisionamiento desde aplicación móvil para el control remoto de 
encendido/apagado LED.</p>
</li>
<li>
<p>Desplegar una infraestructura de provisionamiento de un modelo GENERIC SENSOR 
con provisionamiento desde ESP32.</p>
</li>
</ul>
<h2 id="requisitos-previos">Requisitos previos</h2>
<p>En primer lugar, instala la última versión de ESP-IDF para el desarrollo de
esta práctica. Asegúrate de que, tras el clonado del repostitorio, realizas
la instalación de requisitos correspondiente, y de que exportas las
variables de entorno (vía <code>export.sh</code>) correctas. Es importante que te 
asegures de la correcta configuración del entorno.</p>
<p>En segundo lugar, deberás rellenar la hoja Excel correspondiente a tu puesto
con la dirección MAC Bluetooth de tu dispositivo, que podrás obtener con 
cualquier mecanismo que hayas utilizado en prácticas anteriores.</p>
<p>Los códigos que estudiaremos en la práctica se encuentran en el directorio
<code>examples/bluetooth/esp_ble_mesh/ble_mesh_node</code> en el caso del sistema
<em>OnOff</em> (primera parte de la práctica) y 
<code>ble_mesh_sensor_model</code> en el caso del modelo sensor (segunda parte de
la práctica).</p>
<p>Por último, descarga e instala la aplicación (disponible para Android e IOS)
<code>nRF Mesh</code>.</p>
<h2 id="ejemplo-para-el-modelo-on-off-model">Ejemplo para el modelo ON-OFF MODEL</h2>
<h3 id="el-servidor-on-off">El servidor ON-OFF</h3>
<p>El servidor implementa un único elemento, en el cual se integran dos modelos
distintos:</p>
<ol>
<li><em>Modelo Configuration Server</em>, que implementa la configuración de 
claves de aplicación (<em>AppKey</em>), así como configuraciones genéricas del servidor
como suscripciones, tamaño de TTL o funcionalidad de <em>relay</em> de mensajes.</li>
<li><em>Modelo Generic OnOff Server</em>, que implementa la funcionalidad básica de
encendido/apagado de una luz.</li>
</ol>
<p>El código en el fichero <code>ble_mesh_demo_main.c</code> contiene la funcionalidad
básica del servidor, que podemos resumir en:</p>
<ul>
<li>Inicialización de la pila BLE (<em>bluedroid</em>).</li>
<li>Inicialización de la pila BLE Mesh.</li>
<li>Registro de las funciones de <em>callback</em> para el proceso de provisionamiento
y del modelo o modelos implementados.</li>
<li>Implementación e inicialización del elemento BLE Mesh.</li>
<li>Implementación e inicialización del modelo <em>Configuration Server</em> y 
<em>Generic OnOff Server</em>.</li>
<li>Soporte para operaciones <em>Get Opcode</em> y <em>Set Opcode</em> en el modelo de configuración.</li>
</ul>
<h4 id="analisis-basico-de-codigo">Análisis básico de código</h4>
<ul>
<li>
<p><strong>Inicialización y activación de la pila BLE Mesh</strong></p>
<p>Tras la inicialización del sistema, la tarea principal (<em>app_main</em>) se encarga
de la incialización de las pilas BLE y BLE Mesh:</p>
</li>
</ul>
<pre><code class="language-c">void app_main(void)
{
    int err;

    ESP_LOGI(TAG, &quot;Initializing...&quot;);

    board_init();

    err = bluetooth_init();

    if (err) {
        ESP_LOGE(TAG, &quot;esp32_bluetooth_init failed (err %d)&quot;, err);
        return;
    }

    /* Initializes the Bluetooth Mesh Subsystem */
    err = ble_mesh_init();
    if (err) {
        ESP_LOGE(TAG, &quot;Bluetooth mesh init failed (err %d)&quot;, err);
    }
}
</code></pre>
<p>En particular, el código incluye invocaciones a <code>bluetooth_init()</code> y
<code>ble_mesh_init()</code>, que se encargan de ambas inicializaciones.</p>
<p>La inicialización de la pila BLE Mesh requiere alguna explicación adicional:</p>
<pre><code class="language-c">static esp_err_t ble_mesh_init(void)
{
    int err = 0;

    memcpy(dev_uuid + 2, esp_bt_dev_get_address(), BLE_MESH_ADDR_LEN);

    // See comment 1
     esp_ble_mesh_register_prov_callback(esp_ble_mesh_prov_cb);
    esp_ble_mesh_register_custom_model_callback(esp_ble_mesh_model_cb);

    err = esp_ble_mesh_init(&amp;provision, &amp;composition);
    if (err) {
        ESP_LOGE(TAG, &quot;Initializing mesh failed (err %d)&quot;, err);
        return err;
    }

    esp_ble_mesh_node_prov_enable(ESP_BLE_MESH_PROV_ADV | ESP_BLE_MESH_PROV_GATT);

    ESP_LOGI(TAG, &quot;BLE Mesh Node initialized&quot;);

    board_led_operation(LED_G, LED_ON);

    return err;
}
</code></pre>
<p>Observa que el código incluye la siguiente funcionalidad:</p>
<ul>
<li>
<p><code>esp_ble_mesh_register_prov_callback(esp_ble_mesh_prov_cb)</code>: registra
la función de <em>callback</em> para la pila BLE Mesh. Esta función se ejecuta
durante el proceso de configuración, y permite a la pila BLE Mesh generar
eventos y notificar a la aplicación sobre hitos importantes en el proceso
de configuración. Los eventos principales que pueden emitirse son:</p>
<ul>
<li><code>ESP_BLE_MESH_PROVISION_REG_EVT</code>: generado cuando se completa el proceso de incialización de BLE Mesh.</li>
<li><code>ESP_BLE_MESH_NODE_PROV_LINK_OPEN_EVT</code>: generado cuando un provisionador y un dispositivo no provisionado establecen un enlace.</li>
<li><code>ESP_BLE_MESH_NODE_PROV_LINK_CLOSE_EVT</code>: generado para notificar a la aplicación que se ha roto un enlace con un
dispositivo asociado.</li>
<li><code>ESP_BLE_MESH_NODE_PROV_COMPLETE_EVT</code>: recibido por la aplicación cuando el proceso de provisionamiento se completa.</li>
</ul>
</li>
<li>
<p><code>esp_ble_mesh_register_custom_model_callback(esp_ble_mesh_model_cb)</code>: registra
la función de <em>callback</em> asociada al modelo. Esta función se utiliza cuando el
otro extremo de la comunicación solicita operaciones sobre el modelo, y es
capaz de emitir los siguientes eventos principales:</p>
<ul>
<li><code>ESP_BLE_MESH_MODEL_OPERATION_EVT</code>: se puede generar en dos situaciones:<ul>
<li>El modelo servidor recibe un <em>Get Status</em> o <em>Set Status</em> desde un modelo cliente.</li>
<li>El modelo cliente recibe un <em>Status State</em> desde un modelo servidor.</li>
</ul>
</li>
<li><code>ESP_BLE_MESH_MODEL_SEND_COMP_EVT</code>: generado después de que el modelo servidor
  envíe un <em>Status State</em> a través de la función <code>esp_ble_mesh_server_model_send_msg</code>.</li>
<li><code>ESP_BLE_MESH_MODEL_PUBLISH_COMP_EVT</code>: generado después de que la aplicación 
complete la invocación a <code>esp_ble_mesh_model_publish_msg</code> para publicar mensajes.</li>
<li><code>ESP_BLE_MESH_CLIENT_MODEL_SEND_TIMEOUT_EVT</code>: generado cuando el modelo cliente
invoca a la función <code>esp_ble_mesh_client_model_send_msg</code>, pero no recibe 
mensaje de <code>ACK</code> de vuelta.</li>
<li><code>ESP_BLE_MESH_MODEL_PUBLISH_UPDATE_EVT</code>: generado después de que la aplicación
configure la función de publicación para enviar de forma periódica mensajes al
otro extremo.</li>
</ul>
</li>
<li>
<p><code>esp_ble_mesh_node_prov_enable(ESP_BLE_MESH_PROV_ADV | ESP_BLE_MESH_PROV_GATT)</code>: activa el proceso de Anuncio y Escaneo, haciendo visible al dispositivo para potenciales provisionadores que estén a la escucha.</p>
</li>
<li>
<p><code>board_led_operation(LED_G, LED_ON)</code>: inicializa un hipotético LED RGB, que se controlará remotamente.</p>
</li>
</ul>
<p>En este punto, la inicialización de la pila BLE Mesh debería estar completa, por lo que
un provisionador podría identificar dispositivos para privisonamiento de parámetros de red 
y transmisión de datos.</p>
<h4 id="implementacion-de-la-estructura-ble-mesh-element">Implementación de la estructura BLE Mesh Element</h4>
<p>A continuación, se detallan los pasos necesarios para, en el servidor:</p>
<ul>
<li>Completar la inicialización del sistema.</li>
<li>Añadir un elemento y un modelo al servidor.</li>
<li>Elegir distintas implementaciones de encriptación.</li>
<li>Declarar las características de <em>Proxy</em>, <em>Relay</em>, <em>Low Power</em> y <em>Friend</em> del nodo.</li>
</ul>
<p>En primer lugar, para declarar y definir un elemento y un modelo asociado, utilizaremos
las siguientes estructuras:</p>
<pre><code class="language-c">/*!&lt; Abstraction that describes a BLE Mesh Element.
    This structure is associated with bt_mesh_elem in mesh_access.h */
typedef struct {
    /* Element Address, it is assigned during provisioning. */
    uint16_t element_addr;

    /* Location Descriptor (GATT Bluetooth Namespace Descriptors) */
    const uint16_t location;

    /* Model count */
    const uint8_t sig_model_count;
    const uint8_t vnd_model_count;

    /* Models */
    esp_ble_mesh_model_t *sig_models;
    esp_ble_mesh_model_t *vnd_models;
} esp_ble_mesh_elem_t;
</code></pre>
<p>Así, podemos mantener información sobre los elementos disponibles en el vector
<code>elements</code>:</p>
<pre><code class="language-c">static esp_ble_mesh_elem_t elements[] = {
    ESP_BLE_MESH_ELEMENT(0, root_models, ESP_BLE_MESH_MODEL_NONE),
};
</code></pre>
<p>La implementación y definición de un modelo se realiza de forma similar:</p>
<pre><code class="language-c">static esp_err_t ble_mesh_init(void)
{
    int err = 0;

    memcpy(dev_uuid + 2, esp_bt_dev_get_address(), BLE_MESH_ADDR_LEN);

    // See comment 1
     esp_ble_mesh_register_prov_callback(esp_ble_mesh_prov_cb);
    esp_ble_mesh_register_custom_model_callback(esp_ble_mesh_model_cb);

    err = esp_ble_mesh_init(&amp;provision, &amp;composition);
    if (err) {
        ESP_LOGE(TAG, &quot;Initializing mesh failed (err %d)&quot;, err);
        return err;
    }

    esp_ble_mesh_node_prov_enable(ESP_BLE_MESH_PROV_ADV | ESP_BLE_MESH_PROV_GATT);

    ESP_LOGI(TAG, &quot;BLE Mesh Node initialized&quot;);

    board_led_operation(LED_G, LED_ON);

    return err;
}
</code></pre>
<p>Del mismo modo, podemos usar el array <code>root_models</code> para almacenar los modelos
creados:</p>
<pre><code class="language-c">static esp_ble_mesh_model_t root_models[] = {
    ESP_BLE_MESH_MODEL_CFG_SRV(&amp;config_server),
    ESP_BLE_MESH_SIG_MODEL(ESP_BLE_MESH_MODEL_ID_GEN_ONOFF_SRV, onoff_op,
    &amp;onoff_pub, &amp;led_state[0]),
};
</code></pre>
<p>Distintos modelos requieren diferentes macros (en este caso, ya que vamos 
a implementar un modelo <em>Generic OnOff Server</em>, hemos utilizado 
<code>ESP_BLE_MESH_MODEL_ID_GEN_ONOFF_SRV</code>). </p>
<p>Otra estructura importante en un modelo son los punteros 
<code>esp_ble_mesh_model_op_t *op</code>. Estas estructuras apuntan a la estrcutura de 
operación que define el <strong>estado</strong> del modelo. Generalmente, hay dos tipos
de modelos en BLE Mesh:</p>
<ul>
<li><strong>Modelo servidor</strong>:<ul>
<li>Consiste en uno o varios estados que pueden existir y abarcar varios elementos.</li>
<li>Define los mensajes enviados/recibidos por el modelo, junto con el comportamiento del elemento. Por ejemplo, un cambio entre On y Off en un interruptor indica el estado de On/Off en el modelo.</li>
</ul>
</li>
<li><strong>Modelo cliente</strong>:<ul>
<li>Define los mensajes usados por el cliente para solicitar, modificar o usar
el estado del servidor. Por ejemplo, un cambio entre un On y Off en un interruptor (cliente) indica el mensaje de On/Off enviado por el cliente.</li>
</ul>
</li>
</ul>
<p>El siguiente código muestra la declaración de la estructura operación asociada
al Modelo del servidor:</p>
<pre><code class="language-c">/*!&lt; Model operation context.
    This structure is associated with bt_mesh_model_op in mesh_access.h */
typedef struct {
    const uint32_t    opcode;   /* Opcode encoded with the ESP_BLE_MESH_MODEL_OP_* macro */
    const size_t      min_len;  /* Minimum required message length */
    esp_ble_mesh_cb_t param_cb; /* The callback is only used for the BLE Mesh stack, not for the app layer. */
} esp_ble_mesh_model_op_t;
</code></pre>
<p>Existe tres variables en la declaración:</p>
<ul>
<li><code>opcode</code>: código de operación asociado al estado. </li>
<li><code>min_len</code>: tamaño mínimo de los mensajes recibidos por el estado. Por ejemplo,
para <em>OnOff Get State</em>, el tamaño es 0 (estamos leyendo), mientras que en
el caso de <em>OnOff Set State</em>, el tamaño es 2 (incluye el valor a escribir).</li>
<li><code>param_cb</code>: parámetro interno utilizado por la pila BLE Mesh, típicamente
inicializado a 0.</li>
</ul>
<p>Así, la definición en el servidor quedaría:</p>
<pre><code class="language-c">static esp_ble_mesh_model_op_t onoff_op[] = {
    { ESP_BLE_MESH_MODEL_OP_GEN_ONOFF_GET, 0, 0},
    { ESP_BLE_MESH_MODEL_OP_GEN_ONOFF_SET, 2, 0},
    { ESP_BLE_MESH_MODEL_OP_GEN_ONOFF_SET_UNACK, 2, 0},
    /* Each model operation struct array must use this terminator
     * as the end tag of the operation uint. */
    ESP_BLE_MESH_MODEL_OP_END,
};
</code></pre>
<h3 id="el-cliente-on-off">El cliente ON-OFF</h3>
<p>El cliente resulta mucho más sencillo en su funcionamiento. De forma genérica,
simplemente define un modelo <em>Client ON/OFF</em> y espera a ser provisionado. Una
vez completado el proceso de provisionamento, espera a la pulsación de uno de 
los botones en la placa (RESET) para el envío a todos los nodos en la misma red de
una solicitud de modificación en el estado de activación de las luces.</p>
<p>Concretamente, nos interesan las siguientes definiciones. En el fichero
<code>board.c</code>, observa la respusta a la pulsación del botón:</p>
<pre><code class="language-c">
static void button_tap_cb(void* arg)
{
    ESP_LOGI(TAG, &quot;tap cb (%s)&quot;, (char *)arg);

    example_ble_mesh_send_gen_onoff_set();
}

static void board_button_init(void)
{
    button_handle_t btn_handle = iot_button_create(BUTTON_IO_NUM, BUTTON_ACTIVE_LEVEL);
    if (btn_handle) {
        iot_button_set_evt_cb(btn_handle, BUTTON_CB_RELEASE, button_tap_cb, &quot;RELEASE&quot;);
    }
}

void board_init(void)
{
    board_led_init();
    board_button_init();
}
</code></pre>
<p>La función invocada, <code>example_ble_mesh_send_gen_onoff_set</code>, realiza el envío
de una operación de tipo <code>SET</code> a <em>todos los miembros de la red</em>:</p>
<pre><code class="language-c">void example_ble_mesh_send_gen_onoff_set(void)
{
    esp_ble_mesh_generic_client_set_state_t set = {0};
    esp_ble_mesh_client_common_param_t common = {0};
    esp_err_t err = ESP_OK;

    common.opcode = ESP_BLE_MESH_MODEL_OP_GEN_ONOFF_SET_UNACK;
    common.model = onoff_client.model;
    common.ctx.net_idx = store.net_idx;
    common.ctx.app_idx = store.app_idx;
    common.ctx.addr = 0xFFFF;   /* to all nodes */
    common.ctx.send_ttl = 3;
    common.ctx.send_rel = false;
    common.msg_timeout = 0;     /* 0 indicates that timeout value from menuconfig will be used */
    common.msg_role = ROLE_NODE;

    set.onoff_set.op_en = false;
    set.onoff_set.onoff = store.onoff;
    set.onoff_set.tid = store.tid++;

    err = esp_ble_mesh_generic_client_set_state(&amp;common, &amp;set);
    if (err) {
        ESP_LOGE(TAG, &quot;Send Generic OnOff Set Unack failed&quot;);
        return;
    }

    store.onoff = !store.onoff;
    mesh_example_info_store(); /* Store proper mesh example info */
}
</code></pre>
<p>Observa cómo el mensaje se enviará a <em>todos los nodos de la red</em> (<code>common.ctx.addr = 0xFFFF;</code>).</p>
<h3 id="provisionamiento-y-control-desde-una-aplicacion-movil">Provisionamiento y control desde una aplicación móvil</h3>
<p>En primer lugar, nos dividiremos en grupos de 3-4 personas. Uno de vosotros, 
utilizando la aplicación móvil <em>nRF Mesh</em>, actuará como provisionador de la
red, proporcionando claves de red y aplicación, así como información básica
de red (por ejemplo, direcciones unicast). Además, podrá crear grupos y 
suscribir/desuscribir modelos a dichos grupos.</p>
<p>Además, se requiere que uno de vuestros ESP32 actúe como cliente, y el resto
como servidores. Así, emularemos una sala con múltiples luces, y un sólo 
interruptor que controlará su estado de encendido/apagado.</p>
<ul>
<li><em>PASO 1</em>: en la pantalla inicial se nos mostrarán los nodos ya provisionados. En nuestro caso, inicialmente ninguno.</li>
</ul>
<p><img alt="" src="img/APP/00_pantalla_inicial.png" /></p>
<ul>
<li><em>PASO 2</em>: pincharemos sobre <em>ADD NODE</em>, y provisionaremos, uno a uno, todos los nodos que deseemos que formen parte de nuestra red (sólo aquellos que forman parte de tu grupo de compañeros):</li>
</ul>
<p><img alt="" src="img/APP/01_provisionamiento_inicial.png" /></p>
<ul>
<li><em>PASO 3</em>: antes de provisionar, generamos información de red para el nuevo nodo (lo <em>identificamos</em>), presionando en <em>IDENTIFY</em>:</li>
</ul>
<p><img alt="" src="img/APP/02_provisionando_nodo.png" /></p>
<ul>
<li><em>PASO 4</em>: una vez generada la información de red, provisionamos el nodo (<em>PROVISION</em>):</li>
</ul>
<p><img alt="" src="img/APP/03_provisionando_nodo2.png" /></p>
<ul>
<li><em>PASO 5</em>: si todo ha ido bien, se nos mostrará un mensaje de éxito como el siguiente:</li>
</ul>
<p><img alt="" src="img/APP/04_nodo_provisionado.png" /></p>
<ul>
<li><em>PASO 6</em>: tras repetir este paso con todos los nodos de nuestro grupo, veremos una pantalla
como la siguiente. Observa y anota las direcciones unicast de cada nodo. Los nodos
con un elemento son el cliente OnOff; los nodos con tres elementos (sólo usaremos el primero) son 
los servidores OnOff:</li>
</ul>
<p><img alt="" src="img/APP/05_nodos_provisionados.png" /></p>
<p>A continuación, generarás un grupo de nodos. Esto nos permitirá suscribir a modelos al mismo, y publicar
mensajes que se transmitirán a todos los modelos del grupo.</p>
<ul>
<li><em>PASO 7</em>: crea un nuevo grupo pulsando el botón <code>+</code>. Dale el nombre y la dirección que desees, por ejemplo,
<em>Sala de Estar</em>, <code>0xC000</code>. Si todo ha ido bien, se especificará que en el único grupo disponible no hay ningún
dispositivo suscrito/asociado.</li>
</ul>
<p><img alt="" src="img/APP/06_grupos.png" /></p>
<p>A continuación, suscribiremos a cada modelo de los servidores y clientes (de tipo <em>Generic On Off Server</em> y 
<em>Generic On Off Client</em>) al grupo creado. Esto lo harás nodo a nodo, en primer lugar pincando en 
el modelo concreto:</p>
<p><img alt="" src="img/APP/07_anadiendo_grupo.png" /></p>
<p>Y a continuación asociando una clave de aplicación (<em>BIND KEY</em>) y suscribiendo (<em>SUBSCRIBE</em>)
al grupo deseado:</p>
<p><img alt="" src="img/APP/08_generic_onoff_client.png" />
<img alt="" src="img/APP/09_generic_onoff_client_bindkey.png" />
<img alt="" src="img/APP/10_suscrito_sala_estar.png" /></p>
<p>Ahora, si vuelves a la descripción del grupo, verás que, tras pinchar, observas dos luces (o una por servidor)
y un interruptor (correspondiente al cliente):</p>
<p><img alt="" src="img/APP/11_estado_sala_estar.png" /></p>
<p>En este punto, si estás monitorizando la salida de todos los ESP32, verás que el estado del LED cambia
a petición de la aplicación. Además, verás que también cambia si presionas el botón correspondiente del 
interruptor (<em>RESET</em>) en la placa.</p>
<div class="admonition danger">
<p class="admonition-title">Tarea entregable</p>
<p>El cliente envía, tras presionar un botón, el mensaje de tipo <code>SET</code> a todos los nodos de la red. Modifícalo
para que únicamente se envíe a los pertenecientes a tu grupo. Prueba a suscribir/desuscribir un modelo del
grupo, y verás como ya no recibe los mensajes de solicitud de modificación de estado.</p>
</div>
<h2 id="ejemplo-para-el-modelo-sensor-model">Ejemplo para el modelo SENSOR MODEL</h2>
<p>En este ejemplo, se implementa la creación de un cliente de modelo sensor que, además, es provisionador, y
un servidor de modelo sensor configurable. </p>
<p>El modelo <em>Sensor Server</em> es un modelo que permite exponer series de datos de sensorización. 
El modelo <em>Sensor Client</em> se usa para consumir valores de sensorización (<em>Sensor states</em>) 
expuestos por el servidor.</p>
<p>Estos estados se componen de las siguientes partes:</p>
<ul>
<li>Estado <em>Sensor Descriptor</em>. Describe los datos del sensor, y es inmutable durante su vida.</li>
<li>Estado <em>Sensor Setting</em>. Controla los parámetros del sensor. Por ejemplo, podría indicar su sensibilidad, y
podría ser ajustado remotamente para prevenir que un sensor de movimiento se disparase ante pequeños movimientos.</li>
<li>Estado <em>Sensor Cadence</em>. Controla la cadencia de sensorización.</li>
<li>Estado <em>Sensor Data</em>. Contiene los valores de sensorización. Realmente, representa uno o más pares <em>Property ID</em>-<em>Valor</em>.</li>
<li>Estado <em>Sensor Series Column</em>. Sólo utilizado si se considera cada uno de los valores como perteneciente a una serie de datos.</li>
</ul>
<p>En el ejemplo <em>client</em>, el dispositivo es a la vez un provisionador y un cliente. Una vez 
el dispositivo servidor es provisionado y configurado, los usuarios pueden presionar el botón de
la placa para enviar al servidor peticiones que, sucesivamente, devolverán el siguiente estado del
sensor en orden (<em>Descriptor</em>, <em>Setting</em>, <em>Cadence</em>, ...).</p>
<p>En el ejemplo <em>server</em>, el dispositivo no provisonado implementa un modelo <em>Sensor Server</em>. El 
servidor soporta dos instancias de estados: la pimrea (<em>Property ID 0x0056</em>) representaría
la temperatura <em>Indoor</em>; la segunda (<em>Property ID 0x005B ) representaría la temperatura
</em>Outdoor*. Todos los datos, en estos ejemplos, están preinicializados. </p>
<h3 id="puesta-en-marcha">Puesta en marcha</h3>
<p>En primer lugar, arranca en tu grupo un nodo cliente/provisionador, y monitoriza su salida. Cuando un 
compañero/a arranque un nodo servidor, verás que es provisionado por tu cliente, otorgándole una
dirección unicast. Anótala.</p>
<p>El funcionamiento general del sistema es:</p>
<ol>
<li>El dispositivo A ejecuta el ejemplo <em>client</em>, y el dispositivo B ejecuta el ejemplo <em>server</em>.</li>
<li>A actúa como provisionador. Tras recibir una petición por parte de B, lo provisiona y almacena su dirección. Observarás la MAC BLE (UUID) de B en el proceso de provisionamiento desde A.</li>
<li>En A, cada pulsación del botón supondrá una petición al nodo B.</li>
<li>Sucesivamente, estas peticiones serán, en orden y por cada pulsación:<ul>
<li><em>Sensor Descriptor</em>.</li>
<li><em>Sensor Cadence</em>.</li>
<li><em>Sensor Settings</em>.</li>
<li><em>Sensor Data</em>.</li>
<li><em>Sensor Series</em>.</li>
</ul>
</li>
</ol>
<div class="admonition note">
<p class="admonition-title">Tarea</p>
<p>Estudia el código del cliente y del servidor, y observa a qué nodo se envían las peticiones
desde el cliente, qué operaciones se solicitan en cada pulsación de botón, y qué datos devuelve
el servidor en cada caso.</p>
</div>
<div class="admonition danger">
<p class="admonition-title">Tarea entregable</p>
<p>Modifica el código de cliente y/o servidor para que los valores de sensorización que se consulten en cada pulsación
del botón no sean <strong>todos</strong> los del modelo del <strong>último</strong> nodo provisonado, como ahora se hace, sino únicamente los
datos de sensorización (<em>Sensor Data State</em>) de <strong>todos</strong>  los nodos provisionados. Así, si hay tres nodos provisionados,
cada pulsación nos devolverá el valor de sensorización de uno de ellos, por orden de provisionamiento.
Como funcionalidad adicional, sólo se provisionará automáticamente a aquellos nodos autorizados (los que pertenecen a tu sala, por ejemplo).
Por último, opcionalmente, se pide que el valor sensorizado varíe aleatoriamente de forma periódica en el servidor, con una cadencia predeterminada (la modificación remota de la cadencia queda como ejercicio avanzado).</p>
</div></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../js/base.js" defer></script>
        <script src="../../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
