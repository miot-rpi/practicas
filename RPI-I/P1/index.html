<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>Práctica 1 - Master IoT UCM - Prácticas RPI</title>
        <link href="../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">

        <script src="../../js/jquery-1.10.2.min.js" defer></script>
        <script src="../../js/bootstrap.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../..">Master IoT UCM - Prácticas RPI</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="navitem">
                                <a href="../.." class="nav-link">Calendario</a>
                            </li>
                            <li class="dropdown active">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">RPI-I <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="./" class="dropdown-item active">Práctica 1</a>
</li>
                                    
<li>
    <a href="../P2/" class="dropdown-item">Práctica 2</a>
</li>
                                    
<li>
    <a href="../P3/" class="dropdown-item">Práctica 3</a>
</li>
                                    
<li>
    <a href="../P4/" class="dropdown-item">Práctica 4</a>
</li>
                                    
<li>
    <a href="../P5/" class="dropdown-item">Práctica 5</a>
</li>
                                    
<li>
    <a href="../P6/" class="dropdown-item">Práctica 6</a>
</li>
                                    
<li>
    <a href="../P7/" class="dropdown-item">Práctica 7</a>
</li>
                                    
<li>
    <a href="../P8/" class="dropdown-item">Práctica 8</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">RPI-II <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../RPI-II/P1/" class="dropdown-item">Práctica 1</a>
</li>
                                    
<li>
    <a href="../../RPI-II/P2/" class="dropdown-item">Práctica 2</a>
</li>
                                    
<li>
    <a href="../../RPI-II/P3/" class="dropdown-item">Práctica 3</a>
</li>
                                    
<li>
    <a href="../../RPI-II/P4/" class="dropdown-item">Práctica 4</a>
</li>
                                    
<li>
    <a href="../../RPI-II/P5/" class="dropdown-item">Práctica 5</a>
</li>
                                    
<li>
    <a href="../../RPI-II/P6/" class="dropdown-item">Práctica 6 (I)</a>
</li>
                                    
<li>
    <a href="../../RPI-II/P6-II/" class="dropdown-item">Práctica 6 (II)</a>
</li>
                                    
<li>
    <a href="../../RPI-II/P7/" class="dropdown-item">Práctica 7</a>
</li>
                                    
<li>
    <a href="../../RPI-II/P8/" class="dropdown-item">Práctica 8</a>
</li>
                                    
<li>
    <a href="../../RPI-II/P9/" class="dropdown-item">Práctica 9</a>
</li>
                                    
<li>
    <a href="../../RPI-II/P10/" class="dropdown-item">Práctica 10</a>
</li>
                                </ul>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../.." class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="../P2/" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#practica-1-introduccion-al-entorno-de-desarrollo-esp-idf" class="nav-link">Práctica 1. Introducción al entorno de desarrollo ESP-IDF</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#objetivos" class="nav-link">Objetivos</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#introduccion" class="nav-link">Introducción</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#flujo-de-trabajo-entorno-basado-en-linea-de-comandos" class="nav-link">Flujo de trabajo. Entorno basado en línea de comandos</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#flujo-de-trabajo-entorno-basado-en-platformio" class="nav-link">Flujo de trabajo. Entorno basado en PlatformIO</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#analisis-de-un-proyecto-sencillo-hola-mundo-en-esp-idf" class="nav-link">Análisis de un proyecto sencillo (Hola, mundo) en ESP-IDF</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#personalizacion-del-proyecto" class="nav-link">Personalización del proyecto</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#gestion-de-redes-wifi-ejemplo-1-escaneado-de-redes-wifi" class="nav-link">Gestión de redes WiFi. Ejemplo 1. Escaneado de redes WiFi</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#gestion-de-redes-wifi-ejemplo-2-gestion-de-eventos-de-red" class="nav-link">Gestión de redes WiFi. Ejemplo 2. Gestión de eventos de red</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="practica-1-introduccion-al-entorno-de-desarrollo-esp-idf">Práctica 1. Introducción al entorno de desarrollo ESP-IDF</h1>
<h2 id="objetivos">Objetivos</h2>
<ul>
<li>
<p>Conocer dos entornos básicos de desarrollo para el ESP32: uno basado
  en línea de comandos, y otro en la herramienta PlatformIO</p>
</li>
<li>
<p>Ser capaz de compilar, <em>flashear</em> y monitorizar proyectos sencillos basados
  en ESP-IDF</p>
</li>
<li>
<p>Entender el funcionamiento básico de una aplicación ESP-IDF que haga uso de
  las capacidades WiFi del ESP32</p>
</li>
<li>
<p>Personalizar variables de configuración de proyectos ESP-IDF</p>
</li>
<li>
<p>Responder a eventos básicos de red en ESP-IDF</p>
</li>
</ul>
<h2 id="introduccion">Introducción</h2>
<p>ESP-IDF (<em>Espressif IoT Development Framework</em>) es el entorno de desarrollo
oficial de Espressif para los SoCs ESP32 y ESP32-S. Este entorno de desarrollo
y conjunto de herramientas permite desarrollar <em>firmwares</em> eficientes para 
dichas placas utilizando las interfaces de comunicación WiFi y Bluetooth, así
como gestionar múltiples características de los SoCs que iremos desgranando 
en futuras prácticas. </p>
<p>ESP-IDF utiliza como base <a href="https://freertos.org">FreeRTOS</a> para la construcción
del <em>firmware</em>, aunque añade multitud de componentes para ofrecer un soporte
de mayor nivel para la interacción con protocolos de comunicación de bajo y 
alto nivel, la mayoría de ellos enfocados al ámbito de comunicación en Internet
de las Cosas.</p>
<p>La presente práctica pretende ser una introducción básica a la puesta en 
marcha del entorno de desarrollo ESP-IDF sobre un sistema operativo Linux,
ofreciendo dos alternativas básicas: línea de comandos y un plugin específico
para VSCode (PlatformIO). Además, veremos de forma superficial la estructura 
básica de un programa sencillo desarrollado usando ESP-IDF, así como ejemplos
básicos para la puesta en marcha de la interfaz WiFi sobre una placa ESP32.</p>
<div class="admonition danger">
<p class="admonition-title">Recuerda</p>
<p>La presente práctica no tiene tarea entregable asociada más allá de una 
memoria justificativa del trabajo realizado. Por tanto, recuerda apuntar
y reportar los pasos y tareas realizadas durante su desarrollo para plasmarlas
en una breve memoria entregable final.</p>
</div>
<h2 id="flujo-de-trabajo-entorno-basado-en-linea-de-comandos">Flujo de trabajo. Entorno basado en línea de comandos</h2>
<h3 id="instalacion-de-prerequisitos">Instalación de prerequisitos</h3>
<p>ESP-IDF requiere ciertos paquetes software instalados en el sistema para poder
desarrollar los códigos y descargarlos sobre el ESP32. Se muestran a 
continuación los requisitos y modo de instalación para máquinas Ubuntu/Debian
(como la máquina virtual del curso), aunque la documentación de ESP-IDF
incluye instrucciones para otras distribuciones y sistemas operativos, 
incluyendo Windows y MacOS.</p>
<p>En tu máquina virtual, instala los paquetes necesarios utilizando (como
superusuario):</p>
<pre><code class="language-sh">sudo apt-get install git wget flex bison gperf python python3-pip python-setuptools cmake ninja-build ccache libffi-dev libssl-dev dfu-util
</code></pre>
<p>Además, es necesario, en todo caso, que el usuario que estés utilizando pertenezca
al grupo <code>dialout</code> (puedes editar el fichero <code>/etc/group</code> añadiendo a tu 
usuario a la línea que indica el grupo correspondiente, e iniciando de nuevo
tu sesión).</p>
<p>Instala y configura Python 3 para su uso por defecto en tu 
distribución:</p>
<pre><code class="language-sh">sudo apt-get install python3 python3-pip python3-setuptools
sudo update-alternatives --install /usr/bin/python python /usr/bin/python3 10
</code></pre>
<h3 id="obtencion-de-esp-idf">Obtención de ESP-IDF</h3>
<p>Utilizaremos las versiones de ESP-IDF a obtener directamente desde el 
repositorio Github oficial (concretamente, en su versión 4.1). Para ello,
ejecuta desde tu directorio de inicio:</p>
<pre><code class="language-sh">mkdir -p ~/esp
cd ~/esp
git clone --recursive https://github.com/espressif/esp-idf.git
cd esp-idf
git fetch
git checkout release/v4.1
git pull
git submodule update --init --recursive
</code></pre>
<h3 id="instalacion-de-herramientas-adicionales">Instalación de herramientas adicionales</h3>
<p>Desde el directorio <code>esp-idf</code>, ejecuta el script <code>install.sh</code> para instalar
las herramientas (<em>toolchain</em>) específicas para tu versión:</p>
<pre><code class="language-sh">sh install.sh
</code></pre>
<h3 id="preparacion-del-entorno">Preparación del entorno</h3>
<p>Tras el inicio de cada sesión, deberás establecer valores correctos para ciertas
variables de entorno. Afortunadamente, se proporciona un script (<code>export.sh</code>)
que te permitirá establecerlas de forma automática:</p>
<pre><code class="language-sh">. export.sh
</code></pre>
<p>Puedes añadir esta línea en cualquier fichero de inicio de sesión para no tener
que ejecutar el comando cada vez.</p>
<p>En cualquier caso, en este punto deberías tener acceso a un programa llamado
<code>idf.py</code>, a través del cual gestionaremos el flujo de trabajo. Compruébalo y 
observa si la version de IDF con la que estás trabajando es efectivamente la
4.1 (el número de subversión podría variar en tu salida):</p>
<pre><code class="language-sh">$ idf.py --version
ESP-IDF v4.1-332-g7b7c64107
</code></pre>
<h3 id="preparacion-del-proyecto">Preparación del proyecto</h3>
<p>En esta primera parte, nos basaremos en un ejemplo sencillo de código desarrollado
en base a ESP-IDF. No es el objetivo de esta práctica analizar en detalle los
la estructura de dicho código (al menos de momento), sino utilizarlo para ilustrar
el flujo de trabajo típico en un proyecto ESP-IDF.</p>
<div class="admonition danger">
<p class="admonition-title">Recuerda</p>
<p>Tras la ejecución del script <code>export.sh</code>, tendrás definida una variable
de entorno llamada <code>IDF_PATH</code>. Consulta su valor y comprueba que apunta,
efectivamente, al directorio de instalación de IDF. La utilizaremos a 
partir de ahora para referirnos a él.</p>
</div>
<p>Para empezar, toma el ejemplo <code>hello_world</code> proporcionado como parte de la instalación
básica de IDF, y cópialo en cualquier directorio del sistema de ficheros:</p>
<pre><code class="language-sh">cp -R $IDF_PATH/examples/get-started/hello_world $HOME/
cd $HOME/hello_world
</code></pre>
<h3 id="compilacion">Compilación</h3>
<p>El proceso de compilación básico utiliza el script <code>idf.py</code>:</p>
<pre><code class="language-sh">idf.py build
</code></pre>
<p>Si todo ha ido bien, en el directorio <code>build</code> se habrán generado los objetos
y binarios listos para ser <em>flasheados</em> en el ESP32.</p>
<h3 id="flasheado"><em>Flasheado</em></h3>
<p>El proceso de <em>flasheado</em> básico utiliza el script <code>idf.py</code>:</p>
<pre><code class="language-sh">idf.py -p PUERTO flash
</code></pre>
<p>En este punto, el ESP32 debe estar conectado utilizando el cable microUSB, y
si estás trabajando en una máquina virtual, debe haberse hecho visible a la 
misma (por ejemplo, en VirtualBox, a través del menú <em>Dispositivos-&gt;USB-&gt;Silicon Labs USB to UART Bridge Controller</em>).</p>
<p>En todo caso, la salida del comando <code>dmesg</code> tras la conexión del dispositivo 
te proporcionará información sobre el PUERTO que debes utilizar en el proceso
de <em>flasheado</em> y montorización posterior.</p>
<h3 id="monitorizacion">Monitorización</h3>
<p>Si todo ha ido bien, el proceso de monitorización nos permitirá observar la
salida del programa que tenemos ejecutando en la placa. Para ello, de nuevo,
usamos el <em>script</em> <code>idf.py</code>:</p>
<pre><code class="language-sh">idf.py -p PUERTO monitor
</code></pre>
<div class="admonition danger">
<p class="admonition-title">Nota</p>
<p>Comprueba que, efectivamente, puedes realizar el proceso de compilación,
<em>flasheado</em> y monitorización del programa sobre la placa ESP32. Recuerda
que el botón <code>EN</code>, justo al lado del conector microUSB, forzará un 
reseteo de la misma.</p>
</div>
<h2 id="flujo-de-trabajo-entorno-basado-en-platformio">Flujo de trabajo. Entorno basado en PlatformIO</h2>
<p>El anterior flujo de trabajo puede también desarrollarse desde otros entornos
de desarrollo. En nuestro caso, se muestran a continuación los pasos principales
para la integración de ESP-IDF con VSCode, utilizando la plataforma 
<a href="http://platformio.org">PlatformIO</a>. Las máquinas virtuales proporcionadas
en el curso ya tienen instalada la última versión de PlatformIO y ESP-IDF, por lo
que se refiere al lector a la documentación oficial de PlatformIO para llevar a
cabo dicha instalación en otros sistemas operativos.</p>
<h3 id="configuracion-de-un-proyecto">Configuración de un proyecto</h3>
<p>La forma más sencilla de crear un nuevo proyecto consiste en pulsar el botón
<em>PlatformIO Home</em> situado en la parte inferior de la pantalla:</p>
<p><img alt="foo" src="img/PlatformIO/1.png" /></p>
<p>A continuación, clica en <em>New Project</em> y selecciona como placa de desarrollo
<em>ESP DevkitC</em> o <em>Espressif ESP32 Dev Module</em>. Selecciona <em>ESP-IDF</em> 
como <em>framework</em> de desarrollo para el proyecto:</p>
<p><img alt="foo" src="img/PlatformIO/2.png" /></p>
<h3 id="adicion-de-ficheros-a-un-proyecto">Adición de ficheros a un proyecto</h3>
<p>Crea un nuevo fichero <code>main.c</code> (si no existe) en el directorio <code>src</code> de tu 
proyecto, o modifica el que ya existe utilizando, por ejemplo, el siguiente
código:</p>
<pre><code class="language-c">#include &lt;string.h&gt;
#include &quot;freertos/FreeRTOS.h&quot;
#include &quot;freertos/task.h&quot;
#include &quot;esp_system.h&quot;
#include &quot;esp_wifi.h&quot;
#include &quot;esp_event.h&quot;
#include &quot;esp_log.h&quot;
#include &quot;nvs_flash.h&quot;

#include &quot;lwip/err.h&quot;
#include &quot;lwip/sys.h&quot;

#define EXAMPLE_ESP_WIFI_SSID      &quot;mywifissid&quot;
#define EXAMPLE_ESP_WIFI_PASS      &quot;mywifipass&quot;
#define EXAMPLE_MAX_STA_CONN       (3)

static const char *TAG = &quot;wifi softAP&quot;;

static void wifi_event_handler(void* arg, esp_event_base_t event_base,
                                    int32_t event_id, void* event_data)
{
    if (event_id == WIFI_EVENT_AP_STACONNECTED) {
        wifi_event_ap_staconnected_t* event = (wifi_event_ap_staconnected_t*) event_data;
        ESP_LOGI(TAG, &quot;station &quot;MACSTR&quot; join, AID=%d&quot;,
                 MAC2STR(event-&gt;mac), event-&gt;aid);
    } else if (event_id == WIFI_EVENT_AP_STADISCONNECTED) {
        wifi_event_ap_stadisconnected_t* event = (wifi_event_ap_stadisconnected_t*) event_data;
        ESP_LOGI(TAG, &quot;station &quot;MACSTR&quot; leave, AID=%d&quot;,
                 MAC2STR(event-&gt;mac), event-&gt;aid);
    }
}

void wifi_init_softap()
{
    tcpip_adapter_init();
    ESP_ERROR_CHECK(esp_event_loop_create_default());

    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
    ESP_ERROR_CHECK(esp_wifi_init(&amp;cfg));

    ESP_ERROR_CHECK(esp_event_handler_register(WIFI_EVENT, ESP_EVENT_ANY_ID, &amp;wifi_event_handler, NULL));

    wifi_config_t wifi_config = {
        .ap = {
            .ssid = EXAMPLE_ESP_WIFI_SSID,
            .ssid_len = strlen(EXAMPLE_ESP_WIFI_SSID),
            .password = EXAMPLE_ESP_WIFI_PASS,
            .max_connection = EXAMPLE_MAX_STA_CONN,
            .authmode = WIFI_AUTH_WPA_WPA2_PSK
        },
    };
    if (strlen(EXAMPLE_ESP_WIFI_PASS) == 0) {
        wifi_config.ap.authmode = WIFI_AUTH_OPEN;
    }

    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_AP));
    ESP_ERROR_CHECK(esp_wifi_set_config(ESP_IF_WIFI_AP, &amp;wifi_config));
    ESP_ERROR_CHECK(esp_wifi_start());

    ESP_LOGI(TAG, &quot;wifi_init_softap finished. SSID:%s password:%s&quot;,
             EXAMPLE_ESP_WIFI_SSID, EXAMPLE_ESP_WIFI_PASS);
}

void app_main()
{
    //Initialize NVS
    esp_err_t ret = nvs_flash_init();
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
      ESP_ERROR_CHECK(nvs_flash_erase());
      ret = nvs_flash_init();
    }
    ESP_ERROR_CHECK(ret);

    ESP_LOGI(TAG, &quot;ESP_WIFI_MODE_AP&quot;);
    wifi_init_softap();
}
</code></pre>
<p>De momento no analizaremos el funcionamiento del código (lo haremos más adelante)
pero básicamente establece un Punto de Acceso inalámbrico abierto a conexiones
autenticadas vía WPA2.</p>
<h3 id="compilacion-del-proyecto">Compilación del proyecto</h3>
<p>Para compilar del proyecto, despliega la paleta de comandos (menú <code>View -&gt; Command Palette</code>)
y ejecuta la orden <code>PlatformIO: Build</code> desde ella. También puedes presionar
el botón <code>Build</code> (con forma de <em>check</em>) en la barra inferior de PlatformIO:</p>
<p><img alt="foo" src="img/PlatformIO/3.png" /></p>
<p>Si todo ha ido bien, deberías ver un mensaje final similar al siguiente en la
terminal del sistema:</p>
<p><img alt="foo" src="img/PlatformIO/4.png" /></p>
<h3 id="flasheado-del-proyecto">Flasheado del proyecto</h3>
<p>Para llevar a cabo el proceso de subida (<em>upload</em>) del proyecto a la placa, 
podemos utilizar la orden <code>PlatformIO: Upload</code> a través de la paleta de comandos,
o bien presionar el botón correspondiente en la barra inferior (con un símbolo
de flecha a izquierda):</p>
<p><img alt="foo" src="img/PlatformIO/5.png" /></p>
<h3 id="monitorizacion-del-proyecto">Monitorización del proyecto</h3>
<p>Por último, podemos monitorizar el proyecto utilizando la orden <code>PlatformIO: Monitor</code>
de la paleta de comandos o a través de la barra inferior, usando el botón con 
un enchufe como símbolo:</p>
<p><img alt="foo" src="img/PlatformIO/6.png" /></p>
<h2 id="analisis-de-un-proyecto-sencillo-hola-mundo-en-esp-idf">Análisis de un proyecto sencillo (<em>Hola, mundo</em>) en ESP-IDF</h2>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Las siguientes tareas pueden realizarse desde línea de comandos o utilizando
PlatformIO. Para familiarizarse con en entorno de bajo nivel, sin embargo,
se sugiere el uso de línea de comandos.</p>
</div>
<p>Observa la estructura general del directorio <code>hello_world</code> que compilaste
anteriormente. Específicamente, nos interesará inspeccionar la estructura
básica de un programa principal para ESP-IDF, en este caso <code>hello_world_main.c</code>.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &quot;sdkconfig.h&quot;
#include &quot;freertos/FreeRTOS.h&quot;
#include &quot;freertos/task.h&quot;
#include &quot;esp_system.h&quot;
#include &quot;esp_spi_flash.h&quot;

void app_main(void)
{
    printf(&quot;Hello world!\n&quot;);

    /* Print chip information */
    esp_chip_info_t chip_info;
    esp_chip_info(&amp;chip_info);
    printf(&quot;This is %s chip with %d CPU cores, WiFi%s%s, &quot;,
            CONFIG_IDF_TARGET,
            chip_info.cores,
            (chip_info.features &amp; CHIP_FEATURE_BT) ? &quot;/BT&quot; : &quot;&quot;,
            (chip_info.features &amp; CHIP_FEATURE_BLE) ? &quot;/BLE&quot; : &quot;&quot;);

    printf(&quot;silicon revision %d, &quot;, chip_info.revision);

    printf(&quot;%dMB %s flash\n&quot;, spi_flash_get_chip_size() / (1024 * 1024),
            (chip_info.features &amp; CHIP_FEATURE_EMB_FLASH) ? &quot;embedded&quot; : &quot;external&quot;);

    printf(&quot;Minimum free heap size: %d bytes\n&quot;, esp_get_minimum_free_heap_size());

    for (int i = 10; i &gt;= 0; i--) {
        printf(&quot;Restarting in %d seconds...\n&quot;, i);
        vTaskDelay(1000 / portTICK_PERIOD_MS);
    }
    printf(&quot;Restarting now.\n&quot;);
    fflush(stdout);
    esp_restart();
}
</code></pre>
<p>A alto nivel, la función <code>app_main</code> es el punto de entrada a todo programa
desarrollado usando ESP-IDF. De modo más específico, tras la 
<a href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-guides/general-notes.html">carga del sistema</a>, la llamada <em>tarea principal</em> (<em>main task</em>) ejecuta el
código proporcionado por el usuario e implementado en la función <code>app_main</code>. Tanto
el tamaño de pila asignado como la prioridad de esta tarea puede ser configuradas
por el desarrollador a través del sistema de configuración de ESP-IDF (lo veremos
más adelante). Normalmente, esta función se utiliza para llevar a cabo tareas
iniciales de configuración o para crear y lanzar a ejecución otras tareas. De
cualquier modo (como es el caso), se puede implementar cualquier funcionalidad
dentro de la función <code>app_main</code>.</p>
<p>En este ejemplo, se muestra en primer lugar información genérica sobre el 
SoC que está ejecutando el <em>firmware</em>:</p>
<pre><code class="language-c">/* Print chip information */
    esp_chip_info_t chip_info;
    esp_chip_info(&amp;chip_info);
    printf(&quot;This is %s chip with %d CPU cores, WiFi%s%s, &quot;,
            CONFIG_IDF_TARGET,
            chip_info.cores,
            (chip_info.features &amp; CHIP_FEATURE_BT) ? &quot;/BT&quot; : &quot;&quot;,
            (chip_info.features &amp; CHIP_FEATURE_BLE) ? &quot;/BLE&quot; : &quot;&quot;);

    printf(&quot;silicon revision %d, &quot;, chip_info.revision);

    printf(&quot;%dMB %s flash\n&quot;, spi_flash_get_chip_size() / (1024 * 1024),
            (chip_info.features &amp; CHIP_FEATURE_EMB_FLASH) ? &quot;embedded&quot; : &quot;external&quot;);

    printf(&quot;Minimum free heap size: %d bytes\n&quot;, esp_get_minimum_free_heap_size());
</code></pre>
<p>A continuación, dentro de un bucle sencillo, el sistema muestra un mensaje 
y difiere la ejecución de la tarea durante un período determinado de tiempo
utilizando la función <a href="https://www.freertos.org/a00127.html">vTaskDelay</a> de
FreeRTOS. Esta función recibe el número de <em>ticks</em> de reloj que se desea utilizar,
por lo que el tiempo real que la tarea diferirá su ejecución depende de la 
duración de dicho <em>tick</em>. Por ello,  la constante <code>portTIC_PERIOD_MS</code> puede
utilizarse para calcular dicho tiempo:</p>
<pre><code class="language-c">    for (int i = 10; i &gt;= 0; i--) {
        printf(&quot;Restarting in %d seconds...\n&quot;, i);
        vTaskDelay(1000 / portTICK_PERIOD_MS);
    }
</code></pre>
<p>Finalmente, la tarea reinicia el sistema tras la finalización de la tarea
principal:</p>
<pre><code class="language-c">    printf(&quot;Restarting now.\n&quot;);
    fflush(stdout);
    esp_restart();
</code></pre>
<div class="admonition note">
<p class="admonition-title">Tarea</p>
<p>Modifica el período de suspensión de la tarea para que sea mayor o menor,
y comprueba que efectivamente esto modifica el comportamiento del 
<em>firmware</em> cargado. Modifica el programa para que se muestre también por
pantalla si el SoC tiene capacidades WiFi y si incluye memoria FLASH (para
ello, puedes consultar <a href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/system/system.html#_CPPv415esp_chip_info_t">la siguiente página</a>).</p>
</div>
<h3 id="creacion-de-tareas">Creación de tareas</h3>
<p>El anterior proyecto puede replantearse para que no sea la tarea principal la
que ejecute la lógica del programa. Para ello, es necesario introducir 
brevemente la API básica para gestión (en nuestro caso, creación) de tareas. 
Verás muchos más detalles sobre esta API en la asignatura ANIOT, por lo que 
no veremos aquí más detalles de los estrictamente necesarios. </p>
<p>La función <code>xTaskCreate</code> (incluida en <code>task.h</code>) permite la creación de nuevas
tareas:</p>
<pre><code class="language-c"> BaseType_t xTaskCreate( TaskFunction_t pvTaskCode,
                         const char * const pcName,
                         configSTACK_DEPTH_TYPE usStackDepth,
                         void *pvParameters,
                         UBaseType_t uxPriority,
                         TaskHandle_t *pxCreatedTask
                        );
</code></pre>
<p>Concretamente, crea una nueva tarea y la añade a la lista de tareas listas para
ejecución, recibiendo como parámetros:</p>
<ul>
<li><code>pvTaskCode</code>: Puntero a la función de entrada para la tarea. Las tareas suelen
    implementarse como un bucle infinito, y no debería, en su cuerpo, retornar
    o simplemente finalizar abruptamente. En cambio, una tarea puede ser 
    destruida externamente a través de su manejador (último parámetro en 
    la creación), o internamente (desde el propio código de la tarea), tal y 
    como se muestra en el siguiente ejemplo extraído directamente desde la
    documentación de FreeRTOS:</li>
</ul>
<pre><code class="language-c"> void vATaskFunction( void *pvParameters )
    {
        for( ;; )
        {
            -- Task application code here. --
        }

        /* Tasks must not attempt to return from their implementing
        function or otherwise exit.  In newer FreeRTOS port
        attempting to do so will result in an configASSERT() being
        called if it is defined.  If it is necessary for a task to
        exit then have the task call vTaskDelete( NULL ) to ensure
        its exit is clean. */
        vTaskDelete( NULL );
    }
</code></pre>
<ul>
<li>
<p><code>pcName</code>: Nombre (en forma de cadena) descriptivo de la tarea a ejecutar, 
    típicamente usado en tiempo de depuración.</p>
</li>
<li>
<p><code>usStackDepth</code>: Número de palabras a alojar para utilizar como pila para la
    tarea.</p>
</li>
<li>
<p><code>pvParameters</code>: Parámetros a proporcionar a la función de entrada para la
    tarea.</p>
</li>
<li>
<p><code>uxPriority</code>: Prioridad asignada a la tarea.</p>
</li>
<li>
<p><code>pxCreatedTask</code>: Manejador opcional para la tarea.</p>
</li>
</ul>
<p>Así, la funcionalidad del programa <code>Hola, mundo</code> que hemos analizado 
anteriormente, podría reestrcturarse en base a una única tarea:</p>
<pre><code class="language-c">void hello_task(void *pvParameter)
{
    printf(&quot;Hello world!\n&quot;);
    for (int i = 10; i &gt;= 0; i--) {
        printf(&quot;Restarting in %d seconds...\n&quot;, i);
        vTaskDelay(1000 / portTICK_RATE_MS);
    }
    printf(&quot;Restarting now.\n&quot;);
    fflush(stdout);
    esp_restart();
}
</code></pre>
<p>Que podría ser creada desde la tarea principal:</p>
<pre><code class="language-c">void app_main()
{
    nvs_flash_init();
    xTaskCreate( &amp;hello_task, &quot;hello_task&quot;, 2048, NULL, 5, NULL );
}
</code></pre>
<div class="admonition note">
<p class="admonition-title">Tarea</p>
<p>Implementa una modificación del programa <code>hello_world</code> que implemente
y planifique dos tareas independientes con distinta funcionalidad (en este
caso, es suficiente con mostrar por pantalla algún mensaje) y distintos
tiempos de suspensión. Comprueba que, efectivamente, ambas tareas se 
ejecutan concurrentemente.</p>
</div>
<h2 id="personalizacion-del-proyecto">Personalización del proyecto</h2>
<p>ESP-IDF utiliza la biblioteca <code>kconfiglib</code> para proporcionar un sistema de 
configuracion de proyectos en tiempo de compilación sencillo y extensible. Para
ilustrar su funcionamiento, utilizaremos el ejemplo <code>blink</code> que puedes encontrar
en la distribución de ESP-IDF que has clonado anteriormente (copia el ejemplo
en cualquier punto de tu jerarquía de directorios antes de comenzar). </p>
<p>Para configurar un proyecto ESP-IDF, simplemente utiliza la siguiente orden:</p>
<pre><code class="language-sh">idf.py menuconfig
</code></pre>
<p>La ejecución de la orden anterior te permitirá navegar por un conjunto de 
opciones de carácter general, que te permitirán configurar las características
específicas del proyecto a compilar (por ejemplo, seleccionando los componentes
que deseas habilitar en la construcción del mismo).</p>
<div class="admonition note">
<p class="admonition-title">Tarea</p>
<p>Navega por las opciones que aparecen en los menús de configuración para
familiarizarte con ellos. Los utilizarás en futuras prácticas.</p>
</div>
<p>En el proyecto <code>blink</code>, observa que una de las opciones del menú de navegación,
llamada <em>Example configuration</em>, incluye una opción llamada <em>Blink GPIO number</em>.
Más allá de su funcionalidad (define el número de pin GPIO a activar/desactivar
para iluminar un LED), es de interés para nosotros el hecho de que esta opción
de configuración definirá en tiempo de compilación el valor de una constante 
(en este caso <code>CONFIG_BLINK_GPIO</code>) que podemos utilizar directamente en cualquier
fichero de nuestro proyecto. </p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Observa el uso que da el código del proyecto <code>blink</code> a la constante 
<code>CONFIG_BLINK_GPIO</code>.</p>
</div>
<p>Esta opción de configuración no forma parte de las opciones por defecto de 
ESP-IDF, sino que ha sido añadida por los desarrolladores del proyecto <code>blink</code>.
Observa y estudia el formato y contenido del fichero <code>main/Kconfig.projbuild</code>
que se proporciona como parte del fichero. En él, se definen las características
(nombre, rango, valor por defecto y descripcion) de la opción de configuración
a definir.</p>
<div class="admonition note">
<p class="admonition-title">Tarea</p>
<p>Modifica el proyecto <code>hello_world</code> para que defina dos opciones de configuración
que permitirán definir el tiempo de espera de cada una de las dos tareas que
hayas definido en tu anterior solución. Haz uso de ellas en tu código y 
comprueba que efectivamente su modificación a través del sistema de menús
permite una personalización del comportamiento de tus códigos.</p>
</div>
<h2 id="gestion-de-redes-wifi-ejemplo-1-escaneado-de-redes-wifi">Gestión de redes WiFi. Ejemplo 1. Escaneado de redes WiFi</h2>
<p>A modo de ejemplo, y en preparación para los códigos con los que trabajaremos
en futuras prácticas,  vamos a analizar a continuación un ejemplo concreto de
<em>firmware</em> cuya tarea es el escaneado de redes inalámbricas al alcance del ESP32,
y su reporte a través del puerto serie del mismo. Para cada red escaneada, se
reportarán sus características principales.</p>
<div class="admonition note">
<p class="admonition-title">Tarea</p>
<p>Compila, flashea y monitoriza el ejemplo <code>scan</code> situado en el directorio
<code>examples/wifi/scan</code>. Recuerda copiarlo antes a cualquier otro directorio
de tu <em>home</em>. Antes de compilarlo, modifica el número máximo de redes a 
escanear a través del menú de configuración del ejemplo para ampliarlo a 20.
Crea un punto de acceso WiFi con tu teléfono móvil y observa que, efectivamente,
es escaneado por el ejemplo.</p>
</div>
<p>Observa su funcionamiento. Realmente, el <em>firmware</em> simplemente escanea un 
subconjunto de las redes disponibles, reportando algunas de sus características
(por ejemplo, SSID, modo de autenticación o canal primario). </p>
<div class="admonition note">
<p class="admonition-title">Tarea</p>
<p>Analiza el código de la función <code>wifi_scan</code> (tarea principal). Específicamente,
céntrate en las líneas que permiten activar y configurar el escaneado de 
redes. Intenta entender el funcionamiento general del programa, consultando
y apuntando el cometido de cada línea, con especial interés a aquellas
funciones con prefijo <code>esp_wifi_*</code>. Anota en la memoria entregable el 
cometido de cada una de ellas, consultando la <a href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/network/esp_wifi.html">documentación oficial</a>.</p>
</div>
<h2 id="gestion-de-redes-wifi-ejemplo-2-gestion-de-eventos-de-red">Gestión de redes WiFi. Ejemplo 2. Gestión de eventos de red</h2>
<p>El segundo ejemplo consiste en la creación de un <em>firmware</em> para conexión del 
ESP32 a un punto de acceso existente. Este ejemplo nos permitirá observar, a 
grandes rasgos, el sistema de gestión de eventos en FreeRTOS/ESP-IDF, que
estudiarás en más detalle en ANIOT y que permite gestionar, entre otros, las
respuestas a eventos de red, como por ejemplo la obtención de dirección IP
o la conexión exitosa a un punto de acceso.</p>
<div class="admonition note">
<p class="admonition-title">Tarea</p>
<p>Compila, flashea y monitoriza el ejemplo <code>station</code> situado en el directorio
<code>examples/wifi/getting_started</code>. Recuerda copiarlo antes a cualquier otro directorio
de tu <em>home</em>. Antes de compilarlo, modifica el SSID de la red al que conectará,
así como la contraseña elegida (puedes usar el mismo punto de acceso que
creaste anteriormente como objetivo de tu conexión) a través del sistema
de menús de configuración.</p>
</div>
<p>Observa su funcionamiento. El <em>firmware</em> simplemente inicializa el dispositivo
en modo <em>station</em> (en contraposición al modo <em>Access Point</em>, que veremos en 
la próxima sesión), realizando una conexión al punto de acceso preconfigurado
a través del menú de configuración.</p>
<p>Analiza el código de la función <code>wifi_init_sta</code>. Esta función, que implementa
la tarea principal, se divide básicamente en dos partes:</p>
<ul>
<li><strong>Gestión de eventos</strong>. Observa el mecanismo mediante el cual se registra
y se asocia la recepción de un evento a la ejecución de un manejador o función
determinada.</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Pregunta</p>
<p>¿Qué eventos se asocian a la ejecución de qué función en el <em>firmware</em> que
estás estudiando?</p>
</div>
<ul>
<li><strong>Configuración de la conexión a un punto de acceso</strong>. La configuración 
de la conexión se realiza a través de los campos correspondientes de una
estructura de tipo <code>wifi_config_t</code>. Observa los campos básicos que necesita,
cómo fuerza el uso de WPA2 y cómo recoge los datos de conexión (SSID y contraseña)
a través del sistema de configuración. Observa también cómo, una vez realizadas
dichas personalizaciones, inicializa el sistema de comunicación inalámbrica
a través de <code>esp_wifi_start()</code>. Consulta la documentación relativa a dichas
funciones y anota en tu memoria entregable aquellos aspectos que consideres 
más relevantes.</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Tarea</p>
<p>Modifica el <em>firmware</em> para que el <em>handler</em> de tratamiento de la obtención
de una dirección IP sea independiente del tratamiento del resto de eventos
del sistema WiFi que ya se están considerando. Comprueba que, efectivamente
sigue observándose la salida asociada a dicho evento, aun cuando ambas 
funciones sean independientes. Entrega o añade a la memoria el código 
modificado.</p>
</div></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../js/base.js" defer></script>
        <script src="../../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
