<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>Práctica 5 - Master IoT UCM - Prácticas RPI</title>
        <link href="../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">

        <script src="../../js/jquery-1.10.2.min.js" defer></script>
        <script src="../../js/bootstrap.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../..">Master IoT UCM - Prácticas RPI</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="navitem">
                                <a href="../.." class="nav-link">Calendario</a>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">RPI-I <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../RPI-I/P1/" class="dropdown-item">Práctica 1</a>
</li>
                                    
<li>
    <a href="../../RPI-I/P2/" class="dropdown-item">Práctica 2</a>
</li>
                                    
<li>
    <a href="../../RPI-I/P3/" class="dropdown-item">Práctica 3</a>
</li>
                                    
<li>
    <a href="../../RPI-I/P4/" class="dropdown-item">Práctica 4</a>
</li>
                                    
<li>
    <a href="../../RPI-I/P5/" class="dropdown-item">Práctica 5</a>
</li>
                                    
<li>
    <a href="../../RPI-I/P6/" class="dropdown-item">Práctica 6</a>
</li>
                                    
<li>
    <a href="../../RPI-I/P7/" class="dropdown-item">Práctica 7</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown active">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">RPI-II <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../P1/" class="dropdown-item">Práctica 1</a>
</li>
                                    
<li>
    <a href="../P2/" class="dropdown-item">Práctica 2</a>
</li>
                                    
<li>
    <a href="../P3/" class="dropdown-item">Práctica 3</a>
</li>
                                    
<li>
    <a href="../P4/" class="dropdown-item">Práctica 4</a>
</li>
                                    
<li>
    <a href="./" class="dropdown-item active">Práctica 5</a>
</li>
                                    
<li>
    <a href="../P6/" class="dropdown-item">Práctica 6 (I)</a>
</li>
                                    
<li>
    <a href="../P6-II/" class="dropdown-item">Práctica 6 (II)</a>
</li>
                                    
<li>
    <a href="../P7/" class="dropdown-item">Práctica 7</a>
</li>
                                    
<li>
    <a href="../P8/" class="dropdown-item">Práctica 8</a>
</li>
                                    
<li>
    <a href="../P9/" class="dropdown-item">Práctica 9</a>
</li>
                                    
<li>
    <a href="../P10/" class="dropdown-item">Práctica 10</a>
</li>
                                </ul>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../P4/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="../P6/" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#practica-5-servidores-rest-y-representacion-de-la-informacion-json-y-cbor" class="nav-link">Práctica 5. Servidores REST y representación de la información. JSON y CBOR</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#objetivos" class="nav-link">Objetivos</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#desarrollo-de-un-servidor-rest-en-esp-idf" class="nav-link">Desarrollo de un servidor REST en ESP-IDF</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#representacion-de-la-informacion-json" class="nav-link">Representación de la información. JSON</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#representacion-de-la-informacion-cbor" class="nav-link">Representación de la información. CBOR</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="practica-5-servidores-rest-y-representacion-de-la-informacion-json-y-cbor">Práctica 5. Servidores REST y representación de la información. JSON y CBOR</h1>
<h2 id="objetivos">Objetivos</h2>
<ul>
<li>
<p>Entender los mecanismos ofrecidos por ESP-IDF para la creación de 
un servidor REST HTTP.</p>
</li>
<li>
<p>Implementar, a través de los mecanismos ofrecidos por ESP-IDF, una API
REST extendida en el ESP32.</p>
</li>
<li>
<p>Entender los conceptos básicos de representación de datos a través
de JSON.</p>
</li>
<li>
<p>Implementar, a través de la biblioteca <code>cJSON</code>, un tipo de mensaje
personalizado para los intercambios de datos entre cliente y servidor.</p>
</li>
<li>
<p>Entender los conceptos básicos de representación de datos a través
de CBOR, y evaluar sus ventajas con respecto a JSON.</p>
</li>
<li>
<p>Implementar, a través de la biblioteca <code>tinycbor</code>, un tipo de mensaje
personalizado para los intercambios de datos entre cliente y servidor, comparando
los tamaños de <em>payload</em> con respecto al intercambio JSON.</p>
</li>
</ul>
<h2 id="desarrollo-de-un-servidor-rest-en-esp-idf">Desarrollo de un servidor REST en ESP-IDF</h2>
<p>En la primera parte de la práctica, veremos cómo desarrollar, utilizando las
funcionalidades ofrecidas por ESP-IDF, un servidor HTTP que exponga una API
REST mediante la cual será posible interactuar, en modos lectura y escritura,
con un servidor (en nuestro caso, un dispositivo ESP32). 
Concretamente, trabajaremos con el ejemplo 
<code>example/protocols/http_server/rest_server</code> de la distribución de IDF 
(versión 4.1).</p>
<h3 id="descripcion-de-la-api">Descripción de la API</h3>
<p>El ejemplo que estudiaremos construye una sencilla interfaz (API) con
tres <em>endpoints</em> que permiten interactuar con distintas funcionalidades
del ESP32. Nótese que tanto las URLs como la funcionalidad asociada a ellas
es totalmente personalizable, y puede ser ampliada de acuerdo a las necesidades
de nuestra aplicación.</p>
<p>La siguiente tabla resume la funcionalidad de cada <em>endpoint</em>, así como
posibles ejemplos de valores enviados o devueltos a/por el servidor:</p>
<table>
<thead>
<tr>
<th>API</th>
<th>Método</th>
<th>Ejemplo de recurso leído/escrito</th>
<th>Descripción</th>
<th>URL</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/api/v1/system/info</code></td>
<td><code>GET</code></td>
<td>{<br />version:"v4.0-dev",<br />cores:2<br />}</td>
<td>Utilizado por los clientes para obtener información de la placa (versión, número de cores, ...)</td>
<td><code>/</code></td>
</tr>
<tr>
<td><code>/api/v1/temp/raw</code></td>
<td><code>GET</code></td>
<td>{<br />raw:22<br />}</td>
<td>Utilizado por los clientes para obtener datos de temperatura desde un sensor (no disponible en el ESP32)</td>
<td><code>/chart</code></td>
</tr>
<tr>
<td><code>/api/v1/light/brightness</code></td>
<td><code>POST</code></td>
<td>{ <br />red:160,<br />green:160,<br />blue:160<br />}</td>
<td>Utilizado por los clientes para escribir en la placa valores de control para controlar la luminosidad de LEDs</td>
<td><code>/light</code></td>
</tr>
</tbody>
</table>
<h3 id="configuracion-y-compilacion-del-ejemplo">Configuración y compilación del ejemplo</h3>
<p>En primer lugar, configura, compila y flashea el ejemplo mencionado. En este
caso, las instrucciones se dividen en dos partes: compilación del <em>firmware</em>
para el ESP32, y preparación de un cliente web sencillo que nos permitirá 
observar la interacción con el mismo. Esta última parte no es estrictamente
necesaria, pero nos ayudará en la interacción con el dispositivo de forma 
visual hasta que veamos cómo hacerlo a través de línea de comandos.</p>
<p>A través del menú de configuración,
configura un nombre para el dispositivo (por ejemplo, 'esp_home_tunombre'),
e indica que el modo de despliegue (<code>Website deploy mode</code>) sea
<em>Deploy website to SPI Nor Flash</em>. Por último, configura las credenciales
del punto de acceso WiFi al que conectará, siguiendo la metodología habitual.</p>
<p>En segundo lugar, necesitamos instalar los componentes necesarios para 
desplegar el cliente web. Para ello, navega al subdirectorio <code>front/web-demo</code>,
donde reside el código fuente del cliente. Ejecuta los siguientes comandos
para instalar las dependencias necesarias:</p>
<pre><code class="language-sh">sudo apt-get install npm node-vue*
npm install
npm run build 
</code></pre>
<p>En este punto, ya podrás ejecutar, desde el directorio base del ejemplo, la
orden de compilación y flasheado:</p>
<pre><code class="language-sh">idf.py build
idf.py flash
idf.py monitor
</code></pre>
<h3 id="interaccion-con-el-dispositivo-via-interfaz-web">Interacción con el dispositivo vía interfaz web</h3>
<p>Si todo ha ido bien, podrás observar en la salida de monitorización la
IP proporcionada al ESP32. Abre un navegador en la máquina virtual o 
en tu PC (estando conectada a la misma red que tu ESP32), navega hacia 
la dirección IP del ESP32, y deberías observar una página como la siguiente:</p>
<p><img alt="" src="img/captura1.png" /></p>
<p>Esta es una página web servida por el propio ESP32, que te permitirá interactuar
con él. Concretamente, la página dispone de dos funcionalidades:</p>
<ul>
<li>
<p><strong>Chart</strong>: consulta periódicamente el valor de temperatura devuelto por
el ESP32 a través del <em>endpoint</em> <code>/api/v1/temp/raw</code>.</p>
</li>
<li>
<p><strong>Light</strong>: permite enviar al ESP32 nuevos valores para las tres componentes
de luminosidad que hipotéticamente podría equipar el ESP32.</p>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Tarea</p>
<p>Interactúa con el sensor de luminosidad del ESP32 enviando distintos
valores. Observa cómo la salida de monitorización del ESP32 responde mostrando
los valores recibidos. Analiza el tráfico generado para una de dichas peticiones
utilizando Wireshark. ¿Cómo se codifican los datos en el envío? ¿Cómo se
codifican los datos periódicos de temperatura recibidos?</p>
</div>
<h3 id="interaccion-con-el-dispositivo-via-linea-de-comandos-curl">Interacción con el dispositivo vía línea de comandos (<code>curl</code>)</h3>
<p><code>curl</code> es una herramienta orientada a la transferencia de archivos por red.     Entre
otras (muchas) funcionalidades, <code>curl</code> soporta los métodos <code>GET</code> y <code>PUT</code> del 
protocolo HTTP, justo las necesarias para realizar peticiones de lectura y 
escritura sobre nuestro servidor HTTP REST. </p>
<p>Concretamente, para realizar una petición HTTP <code>GET</code> sobre nuestro servidor, 
podemos ejecutar:</p>
<pre><code class="language-sh">curl http://IP/URI
</code></pre>
<p>Por ejemplo, la petición:</p>
<pre><code class="language-sh">curl http://192.168.1.26/api/v1/temp/raw
</code></pre>
<p>(siendo <code>192.168.1.26</code> la IP del ESP32)
nos responderá con el valor de temperatura instantánea.</p>
<p>Del mismo modo, para escribir (método <code>POST</code>) sobre el servidor, utilizaremos
el parámetro <code>-d</code>, seguido del recurso que queramos enviar. Ten en cuenta
que es responsabilidad del cliente enviar un recurso bien formado e interpretable
por el dispositivo:</p>
<pre><code class="language-sh">curl -d '{&quot;red&quot;:70,&quot;green&quot;:80,&quot;blue&quot;:99}' -H &quot;Content-Type: application/json&quot; 
-X POST http://192.168.1.26/api/v1/light/brightness
</code></pre>
<p>Observa que hemos incluido el tipo de recurso enviado (<code>JSON</code>) y la operacion
solicitada (<code>POST</code>). Volveremos a esto en breve.</p>
<div class="admonition note">
<p class="admonition-title">Tarea</p>
<p>Comprueba que, efectivamente, el tráfico generado por las anteriores órdenes
es el mismo que el que observaste en el caso del  cliente web. Observa qué 
ocurre si consultas un <em>endpoint</em> inexistente, o si envías un JSON mal
formado o con información incorrecta.</p>
</div>
<h3 id="implementacion-de-un-servidor-http-con-api-rest">Implementación de un servidor HTTP con API REST</h3>
<p>La implementación de un servidor HTTP en ESP-IDF se delega al componente
<em>HTTP Server</em>, que implementa toda la funcionalida necesaria para tal fin
de forma eficiente y ligera. La construcción de un servidor puede
resumirse en tres funciones principales (observa la implementación de la
funcion <code>start_rest_server</code> en el fichero <code>rest_server.c</code>) del ejemplo:</p>
<ul>
<li>
<p><code>httpd_start</code>: crea una instancia de servidor HTTP, y aloja recursos para
ella según la configuración proporcionada. En función del tráfico generado
(URIs solicitadas), se utilizarán manejadores específicos definidos por el 
usuario para analizarlo y, en caso necesario, enviar respuestas al cliente
correspondiente.</p>
</li>
<li>
<p><code>httpd_stop</code>: finaliza el servidor HTTP, cerrando cualquier conexión
previamente establecida con clientes.</p>
</li>
<li>
<p><code>httpd_register_uri_handler</code>: registra un manejador (una función definida
por el usuario) para tratar una petición sobre una URI determinada. La estructura
proporcionada dispone de campos para indicar la URI destino (<code>uri</code>), el 
método que se espera recibir (<code>method</code>, por ejemplo <code>HTTPD_GET</code>
o <code>HTTPD_POST</code>) y un puntero a una función que procesará la petición
recibida a través de la URI indicada. Dicha función sólo se ejecutará si
el método coincide con el indicado.</p>
</li>
</ul>
<p>La función <code>start_rest_server</code> del ejemplo proporciona los mecanismos básicos
para la creación de la API anteriormente descrita. Así, para crear el 
<em>endpoint</em> <code>/api/v1/system/info</code>, procederemos, en primer lugar, registrándolo
en el servidor, preparando previamente la estructura de tipo <code>httpd_uri_t</code>:</p>
<pre><code class="language-c">httpd_uri_t system_info_get_uri = {
        .uri = &quot;/api/v1/system/info&quot;,
        .method = HTTP_GET,
        .handler = system_info_get_handler,
        .user_ctx = rest_context
    };
    httpd_register_uri_handler(server, &amp;system_info_get_uri);
</code></pre>
<p>En este caso, la operación asociada a la invocación del handler será, exclusivamente
<code>GET</code>; de hecho, si invocamos a un método <code>POST</code> sobre este <em>endpoint</em>, el 
servidor nos responderá automáticamente con un aviso que indicará que dicho método
no está soportado.</p>
<p>El procesamiento de la petición <code>GET</code> se realiza en la función 
<code>system_info_get_handler</code>, y el esquema que se sigue es, en cualquier caso,
sencillo:</p>
<pre><code class="language-c">static esp_err_t system_info_get_handler(httpd_req_t *req)
{
    // Preparación del tipo de respuesta.
    httpd_resp_set_type(req, &quot;application/json&quot;);

    // Preparación del buffer de respuesta.
    char * buffer = // En el ejemplo preparamos un buffer JSON.

    // Envío de respuesta.
    https_resp_sendstr( req, buffer  );

    return ESP_OK;
</code></pre>
<p>Alternativamente, si la respuesta es binaria, podríamos utilizar la función
<code>https_resp_send( req, buffer, buffer_len  )</code> para procesarla y enviarla 
(lo necesitarás para enviar un buffer binario CBOR).</p>
<p>La creación de un <em>endpoint</em> con soporte para método <code>POST</code>
resulta algo más larga, aunque el registro del mismo no difiere del ejemplo
anterior:</p>
<pre><code class="language-c">    /* URI handler for light brightness control */
    httpd_uri_t light_brightness_post_uri = {
        .uri = &quot;/api/v1/light/brightness&quot;,
        .method = HTTP_POST,
        .handler = light_brightness_post_handler,
        .user_ctx = rest_context
    };
    httpd_register_uri_handler(server, &amp;light_brightness_post_uri);
</code></pre>
<p>Observa el cuerpo de la función <code>light_brightness_post_handler</code>. La recepción
del objeto enviado por parte del cliente se realiza en base a múltiples
invocaciones a la rutina <code>httpd_req_recv</code>:</p>
<pre><code class="language-c">/* Simple handler for light brightness control */
static esp_err_t light_brightness_post_handler(httpd_req_t *req)
{
    int total_len = req-&gt;content_len;
    int cur_len = 0;
    char *buf = ((rest_server_context_t *)(req-&gt;user_ctx))-&gt;scratch;
    int received = 0;
    if (total_len &gt;= SCRATCH_BUFSIZE) {
        /* Respond with 500 Internal Server Error */
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, &quot;content too long&quot;);
        return ESP_FAIL;
    }
    while (cur_len &lt; total_len) {
        received = httpd_req_recv(req, buf + cur_len, total_len);
        if (received &lt;= 0) {
            /* Respond with 500 Internal Server Error */
            httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, &quot;Failed to post control value&quot;);
            return ESP_FAIL;
        }
        cur_len += received;
    }
    buf[total_len] = '\0';

    /// A partir de este punto, disponemos en buf del objeto recibido vía HTTP.
    /// ... 
</code></pre>
<div class="admonition danger">
<p class="admonition-title">Tarea entregable</p>
<p>Observa y estudia los códigos de los manejadores implementados en el ejemplo. 
Extiende la API proporcionada para crear un nuevo <em>endpoint</em> que permita
obtener la temperatura (número aleatorio), pero transformándola a 
grados Fahrenheit. En este caso, el valor devuelto en el fichero 
JSON será un número en punto flotante (en la siguiente sección te
se explicará cómo hacerlo, por lo que de momento puedes enviar 
únicamente la parte entera del mismo). </p>
</div>
<h2 id="representacion-de-la-informacion-json">Representación de la información. JSON</h2>
<p>JSON es un formato de representación de datos en modo texto para el
intercambio de datos entre sistemas informáticos. Se creó inicialmente
como una notación literal de los objetos Javascript, pero dada su amplia
aceptación (realmente como alternativa a XML), se considera a día de hoy
un componente totalmente independiente al lenguaje.</p>
<p>Los tipos de datos soportados por JSON incluyen:</p>
<ul>
<li>
<p>Valores numéricos: permitiendo números con y sin signo, y con parte
decimla en notación separada por puntos.</p>
</li>
<li>
<p>Cadenas: secuencias de cero o más caracteres.</p>
</li>
<li>
<p>Booleanos: <code>true</code> y <code>false</code>.</p>
</li>
<li>
<p>Arrays: listas ordenadas de cero o más valores de cualquier tipo, separados
por comas y encerrados entre corchetes.</p>
</li>
<li>
<p>Objetos: colecciones no ordenadas de pares <code>&lt;nombre&gt;:&lt;valor&gt;</code>, separados
por comas y encerrados entre llaves.</p>
</li>
</ul>
<p>ESP-IDF incluye el componente <a href="https://github.com/DaveGamble/cJSON">cJSON</a>
para parsear y construir objetos de tipo JSON de forma sencilla y consistente.
La biblioteca cJSON representa datos JSON utilizando una estructura sencilla, 
véase:</p>
<pre><code class="language-c">/* The cJSON structure: */
typedef struct cJSON
{
    struct cJSON *next;
    struct cJSON *prev;
    struct cJSON *child;
    int type;
    char *valuestring;
    /* writing to valueint is DEPRECATED, use cJSON_SetNumberValue instead */
    int valueint;
    double valuedouble;
    char *string;
} cJSON;
</code></pre>
<p>El campo <code>type</code> informa sobre el tipo de dato contenido en el objeto, véase:</p>
<ul>
<li><code>cJSON_False</code> (<code>cJSON_IsFalse()</code>): representa un valor booleano falso.</li>
<li><code>cJSON_True</code> (<code>cJSON_IsTrue()</code>): representa un valor booleano verdadero.</li>
<li><code>cJSON_NULL</code> (<code>cJSON_IsNULL()</code>): representa un valor nulo.</li>
<li><code>cJSON_Number</code> (<code>cJSON_IsNumber()</code>): representa un valor numérico. Dicho
valor se almacena en el campo <code>valuedouble</code> como flotante y en <code>valueint</code>
como entero.</li>
<li><code>cJSON_String</code> (<code>cJSON_IsString()</code>): representa un valor cadena, y se 
almacena en el campo <code>valuestring</code> como un array de bytes terminado por
el carácter nulo ('\0').</li>
<li><code>cJSON_Array</code> (<code>cJSON_IsArray()</code>): representa un array de valores. En el
campo <code>child</code> se almacena una lista enlazada con los elementos del array, 
terminada en NULL.</li>
<li><code>cJSON_Object</code> (<code>cJSON_IsObject()</code>): representa un valor objeto. Sus
valores se almacenan de la misma manera que el array anterior, pero en el
campo <code>string</code> se almacenan además las claves del objeto a modo de lista.</li>
</ul>
<h3 id="creacion-y-parseado-de-una-estructura-json">Creación y parseado de una estructura JSON</h3>
<p>Para cada tipo de datos, existe una rutina asociada con nombre
<code>cJSON_Create...</code> que permite crear un item del tipo correspondiente.
Todas estas funciones alojan memoria suficiente como para albergar 
el dato creado. </p>
<p>Dado un objeto JSON en forma de cadena, es posible analizarlo (parsearlo)
utilizando la función <code>cJSON_Parse</code>:</p>
<pre><code class="language-c">cJSON * json = cJSON_Parse( string );
</code></pre>
<p>Para imprimir el contenido de una estructura JSON en modo texto, podemos
hacer uso de la función <code>cJSON_Print(json)</code>:</p>
<pre><code class="language-c">char * string = cJSON_Print( json );
</code></pre>
<h3 id="ejemplos">Ejemplos</h3>
<p>Observa de nuevo el contenido de las funciones manejadoras en nuestro servidor
REST. Concretamente, céntrate en la función <code>system_info_get_handler</code>, que
construye un objeto JSON con dos campos, de tipo cadena ("version")
y numérico ("cores"):</p>
<pre><code class="language-c">/* Simple handler for getting system handler */
static esp_err_t system_info_get_handler(httpd_req_t *req)
{
    // Preparación del tipo de datos de la respuesta.
    httpd_resp_set_type(req, &quot;application/json&quot;);

    // Creación del objeto JSON.
    cJSON *root = cJSON_CreateObject();

    // Obtención del dato.
    esp_chip_info_t chip_info;
    esp_chip_info(&amp;chip_info);

    // Anyadimos un campo de tipo cadena.
    cJSON_AddStringToObject(root, &quot;version&quot;, IDF_VER);

    // Anyadimos un campo de tipo numérico.
    cJSON_AddNumberToObject(root, &quot;cores&quot;, chip_info.cores);

    // Imprimimos a cadena previo al envío.
    const char *sys_info = cJSON_Print(root);

    // Enviamos cabecera + objeto JSON en modo texto vía HTTP.
    httpd_resp_sendstr(req, sys_info);

    // Liberamos recursos.
    free((void *)sys_info);

    // Liberamos recursos del objeto JSON.
    cJSON_Delete(root);

    return ESP_OK;
}
</code></pre>
<p>La función <code>light_brightness_post_handler</code> realiza un parseado del objeto
JSON recibido. Observa su cuerpo:</p>
<pre><code class="language-c">    // buf contiene la cadena recibida a través de HTTP (método POST).
    // ...
    // Parseamos el objeto JSON.
    cJSON *root = cJSON_Parse(buf);

    // Obtenemos tres valores numéricos (RGB).
    int red = cJSON_GetObjectItem(root, &quot;red&quot;)-&gt;valueint;
    int green = cJSON_GetObjectItem(root, &quot;green&quot;)-&gt;valueint;
    int blue = cJSON_GetObjectItem(root, &quot;blue&quot;)-&gt;valueint;

    // Mostramos por pantalla los valores parseados.
    ESP_LOGI(REST_TAG, &quot;Light control: red = %d, green = %d, blue = %d&quot;, red, green, blue);

    // Liberamos recursos JSON.
    cJSON_Delete(root);

    // Enviamos una respuesta generica en modo texto.
    httpd_resp_sendstr(req, &quot;Post control value successfully&quot;);

    return ESP_OK;
</code></pre>
<div class="admonition danger">
<p class="admonition-title">Tarea entregable</p>
<p>Extiende la tarea anterior para añadir el dato en formato punto flotante
de la temperatura en grados Fahrenheit.</p>
</div>
<div class="admonition danger">
<p class="admonition-title">Tarea entregable</p>
<p>Crea un nuevo <em>endpoint</em> que utilice un formato más complejo de objetos
JSON, incluyendo distintos tipos de datos que puedan dar respuesta a 
un hipotético entorno IoT. Documenta la API generada y el formato de los
objetos que has diseñado. Puedes, si así lo deseas, incluir capturas
Wireshark para ilustrar el intercambio de mensajes producido. Nos interesará,
especialmente, el número de bytes transportados para enviar/recibir tus
mensajes JSON.</p>
</div>
<h2 id="representacion-de-la-informacion-cbor">Representación de la información. CBOR</h2>
<p>CBOR (<em>Concise Binary Object Representation</em>) es el formato de serialización
de datos recomendado en muchos de los <em>stacks</em> IoT, específicamente en aquellos
basados en CoAP. Pese a ser un formato binario, CBOR guarda similitudes con
JSON, ya que sigue su mismo modelo de datos: valores numéricos, <em>strings</em>,
arrays, mapas (objetos en JSON) y valores booleanos y nulos. </p>
<p>Sin embargo, a diferencia de JSON, un objeto CBOR es autodescriptivo, y en
este punto radica una de sus ventajas: es posible intercambiar datos entre
un cliente y un servidor sin ceñirse a un esquema de datos concreto conocido
por ambas partes.</p>
<p>El hecho de ser un formato binario implica mejoras sustanciales con respecto a
JSON, por ejemplo al transportar datos binarios (claves de cifrado, datos
gráficos, o valores flotantes sensorizados, entre otros muchos); estos
datos solían codificarse en JSON utilizando, por ejemplo, formato <em>base64</em>, 
añadiendo complejidad al proceso de codificación/decodificación. 
En general, el uso de un formato binario implica menor complejidad a la hora
de ser integrado en aplicaciones, y es por esta razón por la que se considera
óptimo para nodos de bajas prestaciones, típicos en IoT. </p>
<p>El formato CBOR está documentado en el <a href="https://tools.ietf.org/html/rfc7049">RFC 7049</a>,
y por tanto se considera un estándar bien documentado y estable de cara al futuro.</p>
<h3 id="cbor-en-el-esp32">CBOR en el ESP32</h3>
<p>ESP-IDF incluye la biblioteca <code>tinyCBOR</code> como implementación ligera del estándar,
que permite tanto codificar distintos tipos de datos a formato CBOR, parsear
estructuras CBOR y convertir dichas estructuras tanto a formato texto visualizable
como a JSON. TinyCBOR está mantenido como proyecto de software libre por parte
de Intel, y su documentación detallada (se sugiere consultarla) se encuentra
disponible en el siguiente <a href="https://intel.github.io/tinycbor/current/">enlace</a>.</p>
<p>Estudiaremos el funcionamiento de <code>tinyCBOR</code> a través de un ejemplo
funcional (lo puedes encontrar en <code>examples/protocols/cbor</code>). El ejemplo
muestra los mecanismos necesarios para, en primer lugar, crear un objeto
CBOR completo utilizando la biblioteca, y en segundo lugar, el mecanismo
para convertir dicho objeto a representación JSON, así como para parsearlo
manualmente.</p>
<p>En primer lugar, compila, flashea y ejecuta el ejemplo. 
Verás que la salida debería ser similar a la siguiente:</p>
<pre><code class="language-sh">I (320) example: encoded buffer size 67
I (320) example: convert CBOR to JSON
[{&quot;chip&quot;:&quot;esp32&quot;,&quot;unicore&quot;:false,&quot;ip&quot;:[192,168,1,100]},3.1400001049041748,&quot;simple(99)&quot;,&quot;2019-07-10 09:00:00+0000&quot;,&quot;undefined&quot;]
I (340) example: decode CBOR manually
Array[
  Map{
    chip
    esp32
    unicore
    false
    ip
    Array[
      192
      168
      1
      100
    ]
  }
  3.14
  simple(99)
  2019-07-10 09:00:00+0000
  undefined
]
</code></pre>
<p>Observa que la estructura del objeto CBOR será medianamente compleja: constará
de un array formado por cinco elementos:</p>
<ol>
<li>Un <em>mapa</em> (conjunto no ordenado de pares <em>clave-valor</em>), combinando cadenas,
booleanos y un segundo array para especificar una dirección IP.</li>
<li>Un valor flotante (3.14).</li>
<li>Un valor numérico "simple" (99).</li>
<li>Una fecha (en forma de cadena).</li>
<li>Un valor indefinido.</li>
</ol>
<p>El <em>firmware</em> procede en tres etapas:</p>
<h3 id="etapa-1-creacion-codificacion-del-objeto-cbor">Etapa 1: creación (codificación) del objeto CBOR</h3>
<p>Observa el cuerpo de la tarea principal (<code>app_main</code>). El codificador 
CBOR se basa en dos variables:</p>
<pre><code class="language-c">CborEncoder Root_encoder; // Codificador CBOR.
uint8_t buf[100];         // Buffer para alojar el objeto CBOR (array de bytes). 
</code></pre>
<p>En segundo lugar, y ya que utilizaremos un array y un mapa, necesitaremos
constructores especiales para dichos objetos:</p>
<pre><code class="language-c">// Creación de Array.
CborEncoder array_encoder;
CborEncoder map_encoder;

cbor_encoder_create_array(&amp;root_encoder, &amp;array_encoder, 5); // [
  // 1. Creación del Mapa.
  cbor_encoder_create_map(&amp;array_encoder, &amp;map_encoder, 3); // {
</code></pre>
<p>A partir de este punto, podemos proceder con la construcción de los objetos
siguiendo el esquema deseado:</p>
<pre><code class="language-c">  // chip: esp32 (cadena:cadena)
  cbor_encode_text_stringz(&amp;map_encoder, &quot;chip&quot;);
  cbor_encode_text_stringz(&amp;map_encoder, &quot;esp32&quot;);

  // unicore: false (cadena:booleano)
  cbor_encode_text_stringz(&amp;map_encoder, &quot;unicore&quot;);
  cbor_encode_boolean(&amp;map_encoder, false);

  // IP:[192,168,1,100] (cadena:array)
  cbor_encode_text_stringz(&amp;map_encoder, &quot;ip&quot;);

    CborEncoder array2;

    cbor_encoder_create_array(&amp;map_encoder, &amp;array2, 4); // [

    // Valores numéricos.
    cbor_encode_uint(&amp;array2, 192);
    cbor_encode_uint(&amp;array2, 168);
    cbor_encode_uint(&amp;array2, 1);
    cbor_encode_uint(&amp;array2, 100);

    cbor_encoder_close_container(&amp;map_encoder, &amp;array2);        // ]

 cbor_encoder_close_container(&amp;array_encoder, &amp;map_encoder); // }

// 2. Flotante
cbor_encode_float(&amp;array_encoder, 3.14);

// 3. Valor simple
cbor_encode_simple_value(&amp;array_encoder, 99);

// 4. Cadena
cbor_encode_text_stringz(&amp;array_encoder, &quot;2019-07-10 09:00:00+0000&quot;);

// 5. Undefined value.
cbor_encode_undefined(&amp;array_encoder);
cbor_encoder_close_container(&amp;root_encoder, &amp;array_encoder); // ]

// Mostramos el tamaño del buffer creado.
ESP_LOGI(TAG, &quot;encoded buffer size %d&quot;, cbor_encoder_get_buffer_size(&amp;root_encoder, buf));
</code></pre>
<h3 id="etapa-2-conversion-a-json">Etapa 2: conversión a JSON</h3>
<p>La conversión a JSON (típicamente por motivos de visualización o depuración), 
puede realizarse del siguiente modo:</p>
<pre><code class="language-c">    // Initialize the cbor parser and the value iterator
    cbor_parser_init(buf, sizeof(buf), 0, &amp;root_parser, &amp;it);

    ESP_LOGI(TAG, &quot;convert CBOR to JSON&quot;);
    // Dump the values in JSON format
    cbor_value_to_json(stdout, &amp;it, 0);
</code></pre>
<h3 id="etapa-3-parseado-manual-de-un-objeto-cbor">Etapa 3: parseado manual de un objeto CBOR</h3>
<p>Por último, el parseado manual del objeto CBOR se deja como ejercicio de estudio
para el alumno, y está implementado en la función <code>example_dump_cbor_buffer</code>
del ejemplo. Básicamente, la función itera por cada uno de los elementos
del objeto CBOR, consultando el tipo de cada elemento y actuando en consecuencia.
Para aquellos tipos complejos (e.g. arrays o mapas), la función se invoca
recursivamente hasta encontrar un elemento de tipo básico. En este caso, 
simplemente imprime por pantalla su valor (e.g. en el caso de un entero,
caso <code>CborIntegerType</code>).</p>
<div class="admonition danger">
<p class="admonition-title">Tarea entregable</p>
<p>Se pide extender la API REST con un nuevo <em>endpoint</em> que permita obtener
la misma información que el <em>endpoint</em> JSON desarrollado en la anterior
tarea, pero en esta ocasión, utilizando formato CBOR. El objetivo del 
ejercicio es comparar la cantidad de tráfico generado en cada 
representación, por lo que se sugiere que el objeto intercambiado 
sea relativamente complejo (es decir, incluya disintos tipos de datos numéricos,
arrays, o mapas). A continuación se incluyen notas adicionales que te 
permitirán depurar tu desarrollo, observando los valores devueltos
por el servidor HTTP.</p>
</div>
<h3 id="notas-adicionales-creacion-y-consulta-de-un-endpoint-cbor-en-la-api-rest">Notas adicionales: creación y consulta de un <em>endpoint</em> CBOR en la API REST</h3>
<p>Las modificaciones a realizar en la función manejadora del <em>endpoint</em> para 
responder con un objeto CBOR son mínimas. De hecho, se centran simplemente en 
el tipo de respuesta y el mecanismo a usar para enviarla, véase:</p>
<pre><code class="language-c">static esp_err_t system_info_get_handler(httpd_req_t *req)
{
    // Tipo de respuesta.
    httpd_resp_set_type(req, &quot;application/cbor&quot;);

    CborEncoder root_encoder;
    uint8_t buf[100];

    // Codificador CBOR.
    cbor_encoder_init(&amp;root_encoder, buf, sizeof(buf), 0);

    // Codificamos CBOR.
    // ...

    // Enviamos respuesta, consultando previamente el tamaño del buffer codificado.
    httpd_resp_send(req, (char*)buf, cbor_encoder_get_buffer_size( &amp;root_encoder, buf));

    return ESP_OK;
</code></pre>
<p>Para consultar desde línea de comandos sobre este <em>endpoint</em>, podemos utilizar
directamente <code>curl</code>, volcando la salida recibida a un fichero (por
ejemplo, <code>output.cbor</code>):</p>
<pre><code class="language-sh">curl http://192.168.1.26/api/v1/system/info &gt; output.cbor
</code></pre>
<p>Si visualizas el contenido del fichero, verás que contiene datos binarios
difícilmente interpretables. A continuación veremos distintos mecanismos
de visualización.</p>
<h3 id="notas-adicionales-visualizacion-de-datos-cbor">Notas adicionales: visualización de datos CBOR</h3>
<p>Una opción de visualización consiste en utilizar la web <a href="http://cbor.me/">cbor.me</a>.
En el panel derecho, podrás pegar el contenido binario leído. Si necesitas
realizar la conversión antes de pegarlo en la web, puedes hacerlo con la orden:</p>
<pre><code class="language-sh">xxd -ps output.cbor
</code></pre>
<p>Un ejemplo de salida (a pegar en el panel derecho de la web), podría ser:</p>
<pre><code class="language-sh">$ xxd -ps output.cbor 
85a3646368697065657370333267756e69636f7265f46269708418c018a8
011864fa4048f5c3f8637818323031392d30372d31302030393a30303a30
302b30303030f7
</code></pre>
<p>Deberías observar una salida similar a la siguiente (ten en cuenta que 
la herramiente automáticamente indenta el contenido del panel derecho; 
recuerda que simplemente debes pegar la salida generada por <code>xxd</code>):</p>
<p><img alt="" src="img/cbor.me.png" /></p>
<p>Otra opción de visualización puede ser un programa Python (podrías integrarlo
en tu servidor TCP/UDP, por ejemplo), que haga uso del módulo <code>cbor2</code>
 (<a href="https://pypi.org/project/cbor2/">documentación</a>). Para
comprobar su funcionamiento, primero instálalo:</p>
<pre><code class="language-sh">pip install cbor2
</code></pre>
<p>Y comprueba si efectivamente funciona utilizando el siguiente programa Python:</p>
<pre><code class="language-python">from cbor2 import dumps, loads, dump, load

with open('output.cbor', 'rb') as fp:
    obj = load(fp)

print(obj)
</code></pre>
<p>Al ejecutarlo, observarás el contenido del objeto:</p>
<pre><code class="language-sh">python cbor.py
[{'chip': 'esp32', 'unicore': False, 'ip': [192, 168, 1, 100]}, 3.140000104904175, CBORSimpleValue(value=99), '2019-07-10 09:00:00+0000', undefined]
</code></pre></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../js/base.js" defer></script>
        <script src="../../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
