<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>Práctica 1 (I) - Master IoT UCM - Prácticas RPI/LSI</title>
        <link href="../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css">

        <script src="../../js/jquery-1.10.2.min.js" defer></script>
        <script src="../../js/bootstrap.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../..">Master IoT UCM - Prácticas RPI/LSI</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="navitem">
                                <a href="../.." class="nav-link">Calendario</a>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">LSI <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../LSI/Lab0/" class="dropdown-item">Laboratorio 0</a>
</li>
                                    
<li>
    <a href="../../LSI/Lab1/" class="dropdown-item">Laboratorio 1</a>
</li>
                                    
<li>
    <a href="../../LSI/Lab2/" class="dropdown-item">Laboratorio 2</a>
</li>
                                    
<li>
    <a href="../../LSI/Lab3/" class="dropdown-item">Laboratorio 3</a>
</li>
                                    
<li>
    <a href="../../LSI/Lab4/" class="dropdown-item">Laboratorio 4</a>
</li>
                                    
<li>
    <a href="../../LSI/Lab5/" class="dropdown-item">Laboratorio 5</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">RPI-I <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../RPI-I/P1/" class="dropdown-item">Práctica 1</a>
</li>
                                    
<li>
    <a href="../../RPI-I/P2/" class="dropdown-item">Práctica 2</a>
</li>
                                    
<li>
    <a href="../../RPI-I/P3/" class="dropdown-item">Práctica 3</a>
</li>
                                    
<li>
    <a href="../../RPI-I/P4/" class="dropdown-item">Práctica 4</a>
</li>
                                    
<li>
    <a href="../../RPI-I/P5/" class="dropdown-item">Práctica 5</a>
</li>
                                    
<li>
    <a href="../../RPI-I/P6/" class="dropdown-item">Práctica 6</a>
</li>
                                    
<li>
    <a href="../../RPI-I/P7/" class="dropdown-item">Práctica 7</a>
</li>
                                    
<li>
    <a href="../../RPI-I/P8/" class="dropdown-item">Práctica 8</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown active">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">RPI-II <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="./" class="dropdown-item active">Práctica 1 (I)</a>
</li>
                                    
<li>
    <a href="../P1_II/" class="dropdown-item">Práctica 1 (II)</a>
</li>
                                    
<li>
    <a href="../P6/" class="dropdown-item">Práctica 2 (I)</a>
</li>
                                    
<li>
    <a href="../P6-II/" class="dropdown-item">Práctica 2 (II)</a>
</li>
                                    
<li>
    <a href="../P5/" class="dropdown-item">Práctica 3</a>
</li>
                                    
<li>
    <a href="../P7/" class="dropdown-item">Práctica 4</a>
</li>
                                    
<li>
    <a href="../P3/" class="dropdown-item">Práctica 5</a>
</li>
                                    
<li>
    <a href="../P10/" class="dropdown-item">Práctica 6</a>
</li>
                                    
<li>
    <a href="../P8/" class="dropdown-item">Práctica 7</a>
</li>
                                    
<li>
    <a href="../P11/" class="dropdown-item">Práctica 8</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">ANIOT <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../ANIOT/P1/" class="dropdown-item">Práctica 1</a>
</li>
                                    
<li>
    <a href="../../ANIOT/P2/" class="dropdown-item">Práctica 2</a>
</li>
                                    
<li>
    <a href="../../ANIOT/P3/" class="dropdown-item">Práctica 3</a>
</li>
                                    
<li>
    <a href="../../ANIOT/P4/" class="dropdown-item">Práctica 4</a>
</li>
                                    
<li>
    <a href="../../ANIOT/P5/" class="dropdown-item">Práctica 5</a>
</li>
                                    
<li>
    <a href="../../ANIOT/P6/" class="dropdown-item">Práctica 6</a>
</li>
                                    
<li>
    <a href="../../ANIOT/P7/" class="dropdown-item">Práctica 7</a>
</li>
                                    
<li>
    <a href="../../ANIOT/P8/" class="dropdown-item">Práctica 8</a>
</li>
                                </ul>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../../RPI-I/P8/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="../P1_II/" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#practica-1-parte-1-programacion-con-sockets-en-c" class="nav-link">Práctica 1 (Parte 1). Programación con sockets en C</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#objetivos" class="nav-link">Objetivos</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#introduccion" class="nav-link">Introducción</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#la-api-de-sockets-en-c" class="nav-link">La API de sockets en C</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#ejemplos" class="nav-link">Ejemplos</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#capturas-de-trafico-via-wireshark" class="nav-link">Capturas de tráfico vía Wireshark</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="practica-1-parte-1-programacion-con-sockets-en-c">Práctica 1 (Parte 1). Programación con sockets en C</h1>
<h2 id="objetivos">Objetivos</h2>
<ul>
<li>Familiarizarse con la API de <em>sockets</em> en C.</li>
<li>Desarrollar esquemas básicos de sistemas cliente/servidor TCP y UDP
  utilizando C.</li>
<li>Ser capaces de analizar el tráfico generado en una conexión TCP y UDP a 
  través de Wireshark.</li>
<li>Diseñar un protocolo de capa de aplicación para simular una aplicación
  cliente/servidor utilizando TCP y UDP para interactuar entre un cliente y un
  servidor bajo un sistema operativo Linux.</li>
</ul>
<h2 id="introduccion">Introducción</h2>
<p>La historia de los <em>sockets</em> se remonta al origen de ARPANET, en 1971, y su
posterior estandarización en forma de API dentro del sistema operativo
<em>Berkeley Software Distribution (BSD)</em>, liberado en 1983, bajo el nombre
de <em>sockets de Berkeley</em>.</p>
<p>Con la popularización de Internet en los años 90, y de la mano de la
<em>World Wide Web</em>, la programación de red sufrió también una notable evolución.
Los servidores web y los navegadores no fueron (ni son) las únicas aplicaciones
basadas en <em>sockets</em>. De hecho, los sistemas cliente/servidor son a día de hoy
ubicuos e incluyen, por supuesto, a todos los protocolos de alto nivel que
dan soporte a Internet de las Cosas. De hecho, a día de hoy, aunque los 
potocolos de alto nivel (capa de aplicación) han evolucionado hasta niveles
de sofisticación no considerados en sus inicios, la API de bajo nivel sobre
la que se basan se mantiene inalterada.</p>
<p>El tipo más común de aplicaciones basadas en <em>sockets</em> se basa en el paradigma
cliente/servidor, donde una de las partes actúa como <strong>servidor</strong>, esperando
pasivamente conexiones desde un conjunto de uno o más <strong>clientes</strong>. A 
continuación, veremos cómo desarrollar este tipo de paradigma desde Python,
utilizando <em>sockets Berkeley</em>. Existen también los llamados <em>Unix domain
sockets</em>, que permiten la comunicación directa entre procesos en el mismo
<em>host</em>, aunque quedan fuera de nuestro interés en el ámbito de IoT.</p>
<p>En la práctica anterior, vimos cómo desarrollar sistemas cliente/servidor
sencillos utilizando Python, tanto en sus variantes TCP como UDP.
El objetivo de la presente práctica es estudiar y desarrollar componentes
de red (clientes y servidores TCP y UDP) que puedan ejecutarse sobre el 
ESP32 haciendo uso de las facilidades propuestas por ESP-IDF. Además, 
demostraremos que es posible hacer interactuar clientes y servidores ejecutándose
indistintamente en la máquina virtual (programados vía Python) y en la propia
placa (utilizando la API de sockets de C).</p>
<h2 id="la-api-de-sockets-en-c">La API de sockets en C</h2>
<h3 id="funciones-para-ordenacion-de-bytes">Funciones para ordenacion de bytes</h3>
<p>Como TCP/IP es un estándar universal, y permite comunicaciones entre cualquier
plataforma y arquitectura, es necesario disponer de un método de ordenación
de los bytes para que máquinas <em>big-endian</em> y <em>little-endian</em> puedan comunicarse
de forma transparente y correcta. Para ello, se suelen proporcionar rutinas
de reordenación de bytes. En plataformas donde los datos ya están correctamente
ordenados, estas funciones no tienen ninguna funcionalidad especial, pero en
cualquier caso, es necesario utilizarlas siempre para que la comunicación
entre pares sea correcta. Las funciones típicas de reordenación de datos
son cuatro: <code>htons</code>, <code>htonl</code>, <code>ntohs</code> y <code>ntohl</code>. Su nombre explica correctamente
su semántica: <em>host to network (short)</em>
<em>host to network (long)</em>, <em>network to host (short)</em> y <em>network to host (long)</em>,
convirtiendo tipos de datos <em>short</em> y <em>long</em> desde el formato utilizado en
transmisiones de red (<em>network</em>) a representación en el <em>host</em>. Así, siempre
que enviemos un dato binario por la red, deberá ser transformado utilizando 
<code>hton*</code> y cuando lo recibamos y debamos procesarlo, utilizando <code>ntoh*</code>.</p>
<h3 id="estructuras-de-datos">Estructuras de datos</h3>
<p>Antes de estudiar la API de <em>sockets</em> básica, es necesario mostrar el cometido
de un conjunto de estructuras de datos utilizadas comúnmente en todas ellas. La
más importante es <code>sockaddr_in</code>, que se define como sigue:</p>
<pre><code class="language-c">struct sockaddr_in
{
    short          sin_family;
    u_short        sin_port;
    struct in_addr sin_addr;
    char           sin_zero[8];
};
</code></pre>
<p>La estructura <code>in_addr</code> utilizada en <code>sockaddr_in</code> se define como:</p>
<pre><code class="language-c">struct in_addr
{
    u_long s_addr;
};
</code></pre>
<p>Ésta consiste en un campo de tipo <code>unsigned long int</code> que contiene la 
dirección IP que se asociará con el socket. </p>
<p>La estructura <code>sockaddr_in</code> contiene dos campos importantes: </p>
<ul>
<li><code>sin_family</code>: que indica al socket qué familia de protocolos se utilizarán 
  (usaremos la constante <code>AF_INET</code> para IPv4).</li>
<li><code>sin_port</code>: que indica el puerto asociado al socket.</li>
</ul>
<h3 id="api-basica">API básica</h3>
<h4 id="socket"><code>socket()</code></h4>
<ul>
<li>Prototipo:</li>
</ul>
<pre><code class="language-c">int socket(int family, int type, int protocol);
</code></pre>
<ul>
<li>
<p>Descripción: Crea un <em>endpoint</em> de comunicación y devuelve un descriptor 
  de fichero para manejarlo.</p>
</li>
<li>
<p>Parámetros: </p>
<ul>
<li><code>family</code>:  <code>AF_INET</code> (IPv4), <code>AF_INET6</code> (IPv6).</li>
<li><code>type</code>: <code>SOCK_DGRAM</code> (UDP), <code>SOCK_STREAM</code> (TCP), <code>SOCK_RAW</code>.</li>
<li><code>protocol</code>: Típicamente 0 (no usado en sockets de Internet).</li>
</ul>
</li>
<li>
<p>Valor de retorno: Si tiene éxito, devuelve el descriptor de <em>socket</em>.
                    Devuelve <code>-1</code> si se produce un error.</p>
</li>
<li>
<p>Detalles: consultad la página de manual de <code>socket</code> (<code>man socket</code>).</p>
</li>
</ul>
<h4 id="bind"><code>bind()</code></h4>
<ul>
<li>Prototipo:</li>
</ul>
<pre><code class="language-c">int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
</code></pre>
<ul>
<li>
<p>Descripción: Asocia un <em>socket</em> a una dirección especificada por <code>addr</code>.
  Normalmente, es necesario asignar una dirección local vía esta función
  antes de que un socket TCP pueda recibir conexiones.</p>
</li>
<li>
<p>Parámetros: </p>
<ul>
<li><code>sockfd</code>:  descriptor de <em>socket</em> (devuelto por <code>socket</code>).</li>
<li><code>addr</code>: dirección a asociar (véase estructura en sección anterior).</li>
<li><code>addrlen</code>: longitud (en bytes) de la anterior estructura.</li>
</ul>
</li>
<li>
<p>Valor de retorno: Si tiene éxito, devuelve 0.
                    Devuelve <code>-1</code> si se produce un error.</p>
</li>
<li>
<p>Detalles: consultad la página de manual de <code>bind</code> (<code>man bind</code>).</p>
</li>
</ul>
<h4 id="listen"><code>listen()</code></h4>
<ul>
<li>Prototipo:</li>
</ul>
<pre><code class="language-c">int listen(int sockfd, int backlog);
</code></pre>
<ul>
<li>
<p>Descripción: Marca el <em>socket</em> proporcionado como <em>pasivo</em>, esto es, 
  un <em>socket</em> que podrá ser utilizado para aceptar conexiones entrantes
  usando la llamada <code>accept</code>.</p>
</li>
<li>
<p>Parámetros: </p>
<ul>
<li><code>sockfd</code>:  descriptor de <em>socket</em> (devuelto por <code>socket</code>).</li>
<li><code>backlog</code>: longitud máxima que podrá tener la cola de conexiones pendientes
para el <em>socket</em>. Si se sobrepasa, el cliente recibirá un error en su
intento de conexión.</li>
</ul>
</li>
<li>
<p>Valor de retorno: Si tiene éxito, devuelve 0.
                    Devuelve <code>-1</code> si se produce un error.</p>
</li>
<li>
<p>Detalles: consultad la página de manual de <code>listen</code> (<code>man listen</code>).</p>
</li>
</ul>
<h4 id="accept"><code>accept()</code></h4>
<ul>
<li>Prototipo:</li>
</ul>
<pre><code class="language-c">int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
</code></pre>
<ul>
<li>
<p>Descripción: En <em>sockets</em> orientados a conexión, extrae la primera solicitud
  de conexión de la cola de conexiones pendientes para el <em>socket</em> proporcionado,
  crea un nuevo <em>socket conectado</em> y devuelve su descriptor. </p>
</li>
<li>
<p>Parámetros: </p>
<ul>
<li><code>sockfd</code>:  descriptor de <em>socket</em> (devuelto por <code>socket</code>).</li>
<li><code>addr</code>:  es un puntero a una estructura de tipo <code>sockaddr</code>, cuyos campos
  serán rellenados con los datos de dirección del socket remoto.</li>
<li><code>addrlen</code>: tamaño de la estructura <code>addr</code>.</li>
</ul>
</li>
<li>
<p>Valor de retorno: Si tiene éxito, devuelve el descriptor de socket.
                    Devuelve <code>-1</code> si se produce un error.</p>
</li>
<li>
<p>Detalles: consultad la página de manual de <code>accept</code> (<code>man accept</code>).</p>
</li>
</ul>
<h4 id="connect"><code>connect()</code></h4>
<ul>
<li>Prototipo:</li>
</ul>
<pre><code class="language-c">int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
</code></pre>
<ul>
<li>
<p>Descripción: Conecta el <em>socket</em> proporcionada a la dirección especificada por
  <code>addr</code>. Si el <em>socket</em> es UDP, <code>addr</code> será la dirección a la que se enviarán
  los datagramas por defecto, y la única desde la que se recibirán datagramas.
  En caso de TCP, esta llamada inicia el proceso de conexión a la dirección
  especificada.</p>
</li>
<li>
<p>Parámetros: </p>
<ul>
<li><code>sockfd</code>:  descriptor de <em>socket</em> (devuelto por <code>socket</code>).</li>
<li><code>addr</code>:  es un puntero a una estructura de tipo <code>sockaddr</code>, cuyos campos
  indican la dirección de conexión destino.</li>
<li><code>addrlen</code>: tamaño de la estructura <code>addr</code>.</li>
</ul>
</li>
<li>
<p>Valor de retorno: Si tiene éxito, devuelve el descriptor de socket.
                    Devuelve <code>-1</code> si se produce un error.</p>
</li>
<li>
<p>Detalles: consultad la página de manual de <code>connect</code> (<code>man connect</code>).</p>
</li>
</ul>
<h4 id="send"><code>send()</code></h4>
<ul>
<li>Prototipo:</li>
</ul>
<pre><code class="language-c">ssize_t send(int sockfd, const void *buf, size_t len, int flags);
</code></pre>
<ul>
<li>
<p>Descripción: En un <em>socket</em> en estado <em>conectado</em> (con receptor conocido)
  transmite mensajes a un socket remoto.</p>
</li>
<li>
<p>Parámetros: </p>
<ul>
<li><code>sockfd</code>:  descriptor de <em>socket</em> de envío.</li>
<li><code>buf</code>:  <em>buffer</em> de envío donde se almacena el mensaje a enviar.</li>
<li><code>len</code>: número de bytes a enviar.</li>
</ul>
</li>
<li>
<p>Valor de retorno: Si tiene éxito, devuelve el número de bytes enviados.
                    Devuelve <code>-1</code> si se produce un error.</p>
</li>
<li>
<p>Detalles: consultad la página de manual de <code>send</code> (<code>man send</code>).</p>
</li>
</ul>
<h4 id="recvrecvfrom"><code>recv()</code>/<code>recvfrom()</code></h4>
<ul>
<li>Prototipos:</li>
</ul>
<pre><code class="language-c">ssize_t recv(int sockfd, void *buf, size_t len, int flags);

ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,
                 struct sockaddr *src_addr, socklen_t *addrlen);

</code></pre>
<ul>
<li>
<p>Descripción: Reciben mensajes desde un  <em>socket</em>, tanto en sockets orientados
  como no orientados a conexión. <code>recvfrom</code>, a diferencia de <code>recv</code>, recibe
  parámetros de salida adicionales que almacenan información sobre la dirección
  origen del mensaje.</p>
</li>
<li>
<p>Parámetros: </p>
<ul>
<li><code>sockfd</code>:  descriptor de <em>socket</em> de recepción.</li>
<li><code>buf</code>:  <em>buffer</em> de recepción donde se almacena el mensaje a recibir.</li>
<li><code>len</code>: número de bytes a recibir.</li>
<li><code>src_addr</code>: dirección del extremo remoto del socket (origen de la comunicación).</li>
<li><code>addrlen</code>: tamaño de la estructura <code>src_addr</code>.</li>
</ul>
</li>
<li>
<p>Valor de retorno: Si tiene éxito, devuelve el número de bytes recibidos.
                    Devuelve <code>-1</code> si se produce un error.</p>
</li>
<li>
<p>Detalles: consultad las páginas de manual de <code>recv</code> y <code>recv_from</code> (<code>man recv</code> y 
  <code>man recv_from</code>).</p>
</li>
</ul>
<h4 id="close"><code>close()</code></h4>
<ul>
<li>Prototipo:</li>
</ul>
<pre><code class="language-c">int close(int fd);
</code></pre>
<ul>
<li>
<p>Descripción: Cierra un socket.</p>
</li>
<li>
<p>Parámetros: </p>
<ul>
<li><code>fd</code>:  descriptor de <em>socket</em>.</li>
</ul>
</li>
<li>
<p>Detalles: consultad la página de manual de <code>close</code> (<code>man close</code>).</p>
</li>
</ul>
<h2 id="ejemplos">Ejemplos</h2>
<p>Se proporcionan a continuación ejemplos completos de uso de la API de <em>sockets</em>
en C para el desarrollo de sistemas cliente/servidor sencillos. Para cada 
uno de ellos, comprueba que, efectivamente, el uso y secuencia de aplicación
de cada llamada sigue las directivas de la figura:</p>
<p><img alt="flow" src="img/flow.png" /></p>
<div class="admonition note">
<p class="admonition-title">Tarea 1.1</p>
<p>Compila (utilizando la oren <code>gcc ejemplo.c -o ejemplo.x</code> desde
una terminal) y a continuación ejecuta (<code>./ejemplo.x</code>) cada par
de códigos y comprueba su funcionamiento. Estudia con detenimiento el uso
de cada rutina y como efectivamente siguen las directivas marcadas 
anteriormente. Si no tienes experiencia en desarrollo en C, consulta las 
páginas de manual correspondientes, o con tu profesor, para resolver todas
tus dudas. Asegúrate de entender el proceso de compilación, enlazado y 
ejecución de un binario.</p>
</div>
<h3 id="ejemplo-un-cliente-tcp">Ejemplo: un cliente TCP</h3>
<pre><code class="language-c">#include &lt;arpa/inet.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;unistd.h&gt;
#include &lt;netinet/in.h&gt;


int main() {
        const int server_port = 9000;

        struct sockaddr_in server_address;
        memset(&amp;server_address, 0, sizeof(server_address));
        server_address.sin_family = AF_INET;

        server_address.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);
        server_address.sin_port = htons(server_port);

        int sock;
        if ((sock = socket(PF_INET, SOCK_STREAM, 0)) &lt; 0) {
                printf(&quot;Error en socket\n&quot;);
                return 1;
        }

        if (connect(sock, (struct sockaddr*)&amp;server_address,
                    sizeof(server_address)) &lt; 0) {
                printf(&quot;Error en connect\n&quot;);
                return 1;
        }

        const char* data_to_send = &quot;Hola, RPI!!&quot;;
        send(sock, data_to_send, strlen(data_to_send), 0);

        int n = 0;
        int len = 0, maxlen = 100;
        char buffer[maxlen];
        char* pbuffer = buffer;

        if ((n = recv(sock, pbuffer, maxlen, 0)) &gt; 0) {
                pbuffer += n;
                maxlen -= n;
                len += n;

                buffer[len] = '\0';
                printf(&quot;Recibido: '%s'\n&quot;, buffer);
        }

        close(sock);
        return 0;
}
</code></pre>
<h3 id="ejemplo-un-servidor-tcp">Ejemplo: un servidor TCP</h3>
<pre><code class="language-c">#include &lt;arpa/inet.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;

int main(int argc, char *argv[]) {
        int SERVER_PORT = 9000;

        struct sockaddr_in server_address;
        memset(&amp;server_address, 0, sizeof(server_address));
        server_address.sin_family = AF_INET;

        server_address.sin_port = htons(SERVER_PORT);

        server_address.sin_addr.s_addr = htonl(INADDR_ANY);

        int listen_sock;
        if ((listen_sock = socket(PF_INET, SOCK_STREAM, 0)) &lt; 0) {
                printf(&quot;Error en socket\n&quot;);
                return 1;
        }

        if ((bind(listen_sock, (struct sockaddr *)&amp;server_address,
                  sizeof(server_address))) &lt; 0) {
                printf(&quot;Error en bind\n&quot;);
                return 1;
        }

        int wait_size = 16;  

        if (listen(listen_sock, wait_size) &lt; 0) {
                printf(&quot;Error en listen\n&quot;);
                return 1;
        }

        struct sockaddr_in client_address;
        int client_address_len = 0;

        while (true) {
                int sock;
                if ((sock =
                         accept(listen_sock, (struct sockaddr *)&amp;client_address,
                                &amp;client_address_len)) &lt; 0) {
                        printf(&quot;Error en accept\n&quot;);
                        return 1;
                }

                int n = 0;
                int len = 0, maxlen = 100;
                char buffer[maxlen];
                char *pbuffer = buffer;

                printf(&quot;Cliente conectado con IP: %s\n&quot;,
                       inet_ntoa(client_address.sin_addr));

                while ((n = recv(sock, pbuffer, maxlen, 0)) &gt; 0) {
                        pbuffer += n;
                        maxlen -= n;
                        len += n;

                        printf(&quot;Recibido: '%s'\n&quot;, buffer);

                        send(sock, buffer, len, 0);
                }

                close(sock);
        }

        close(listen_sock);
        return 0;
}
</code></pre>
<div class="admonition note">
<p class="admonition-title">Tarea 1.2</p>
<p>Reproduce el funcionamiento del anterior sistema cliente/servidor <em>echo</em>
utilizando UDP.</p>
</div>
<h2 id="capturas-de-trafico-via-wireshark">Capturas de tráfico vía Wireshark</h2>
<p>Wireshark es una herramienta de código abierto ampliamente utilizada para 
analizar protocolos de comunicación de red en cualquiera de las capas de la pila 
TCP/IP (como también en otros protocolos). Wireshark implementa un amplio 
abanico de filtros para definir criterios de búsqueda en las capturas de
tráfico, aunque de momento, en nuestro caso, no será necesario utilizar filtros
específicos.</p>
<p>Para arrancar Wireshark en la máquina virtual proporcionada (o en cualquier
instalación básica Linux), teclea en tu terminal:</p>
<pre><code class="language-bash">$ sudo wireshark
</code></pre>
<p>Tras el arranque, podemos comenzar una nueva captura de tráfico a través
del menú <code>Capture</code>, opción <code>Start</code>. La pantalla de selección de interfaz 
nos permitirá definir en qué interfaz de red se realizará la captura. En 
nuestro caso, ya que vamos a comunicar dos procesos en la misma máquina, 
elegiremos la interfaz de <em>Loopback</em> (lo) y comenzaremos la captura.</p>
<div class="admonition note">
<p class="admonition-title">Tarea 1.3</p>
<p>Arranca Wireshark y prepara una captura sobre la interfaz de <em>loopback</em> de tu máquina.
Ejecuta el servidor <em>echo</em> TCP y el cliente correspondiente, y analiza
el tráfico generado. Especialmente, fíjate en el proceso de establecimiento
de conexión en tres vías, paquetes de <em>Acknowledge</em> tras el envío de cada
mensaje y, en general, en cualquier otro aspecto que consideres de interés.</p>
</div>
<h3 id="construccion-de-mensajes">Construcción de mensajes</h3>
<p>Para enviar mensajes que encapsulen distintos tipos de datos en una sola
invocación, puedes definir un mensaje como el siguiente:</p>
<pre><code class="language-c">typedef struct {
  int x;
  int y;
} mensaje;
</code></pre>
<p>Dando valor a cada campo y a continuación enviándolo proporcionando la dirección
de inicio de la estructura, del siguiente modo:</p>
<pre><code class="language-c">mensaje.x = x; mensaje.y = y;
send( socketfd, &amp;mensaje, sizeof( mensaje ), 0 );
</code></pre>
<div class="admonition note">
<p class="admonition-title">Tarea 1.4</p>
<p>Se pide diseñar un sistema cliente/servidor programado en C, que 
simule el envío de un conjunto de datos sensorizados desde un cliente
hacia un servidor. El protocolo a utilizar (formato de datos enviado
por la red a nivel de aplicación) 
debe ser propuesto por el alumno/a y descrito previamente
al desarrollo. Se valorará el uso de múltiples tipos de datos tanto en
el envío de datos sensorizados como de posibles respuestas por parte
del servidor. Se desarrollará una versión utilizando TCP y otra
equivalente usando UDP. El cliente enviará los datos de forma periódica y
éstos se generarán de modo aleatorio.</p>
<p>A modo de entrega, se solicitan los códigos desarrollados, así como un 
análisis del tráfico generado, considerando la sobrecarga (en bytes 
reales enviados) introducida por cada protocolo de capa de transporte.</p>
</div></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../js/base.js" defer></script>
        <script src="../../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
