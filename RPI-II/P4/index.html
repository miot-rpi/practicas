<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>Práctica 4 - Redes, Protocolos e Interfaces</title>
        <link href="../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">

        <script src="../../js/jquery-1.10.2.min.js" defer></script>
        <script src="../../js/bootstrap.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../..">Redes, Protocolos e Interfaces</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="navitem">
                                <a href="../.." class="nav-link">Calendario</a>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">RPI-I <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../RPI-I/P1/" class="dropdown-item">Práctica 1</a>
</li>
                                    
<li>
    <a href="../../RPI-I/P2/" class="dropdown-item">Práctica 2</a>
</li>
                                    
<li>
    <a href="../../RPI-I/P3/" class="dropdown-item">Práctica 3</a>
</li>
                                    
<li>
    <a href="../../RPI-I/P4/" class="dropdown-item">Práctica 4</a>
</li>
                                    
<li>
    <a href="../../RPI-I/P5/" class="dropdown-item">Práctica 5</a>
</li>
                                    
<li>
    <a href="../../RPI-I/P6/" class="dropdown-item">Práctica 6</a>
</li>
                                    
<li>
    <a href="../../RPI-I/P7/" class="dropdown-item">Práctica 7</a>
</li>
                                    
<li>
    <a href="../../RPI-I/P8/" class="dropdown-item">Práctica 8</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown active">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">RPI-II <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../P1/" class="dropdown-item">Práctica 1</a>
</li>
                                    
<li>
    <a href="../P2/" class="dropdown-item">Práctica 2</a>
</li>
                                    
<li>
    <a href="../P3/" class="dropdown-item">Práctica 3</a>
</li>
                                    
<li>
    <a href="./" class="dropdown-item active">Práctica 4</a>
</li>
                                    
<li>
    <a href="../P5/" class="dropdown-item">Práctica 5</a>
</li>
                                    
<li>
    <a href="../P6/" class="dropdown-item">Práctica 6</a>
</li>
                                    
<li>
    <a href="../P7/" class="dropdown-item">Práctica 7</a>
</li>
                                    
<li>
    <a href="../P8/" class="dropdown-item">Práctica 8</a>
</li>
                                    
<li>
    <a href="../P9/" class="dropdown-item">Práctica 9</a>
</li>
                                    
<li>
    <a href="../P10/" class="dropdown-item">Práctica 10</a>
</li>
                                </ul>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../P3/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="../P5/" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#practica-4-protocolos-basicos-de-capa-de-aplicacion-websockets" class="nav-link">Práctica 4. Protocolos básicos de capa de aplicación. Websockets</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#objetivos" class="nav-link">Objetivos</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#ejemplo-basico-sistema-clienteservidor-usando-websockets-en-python" class="nav-link">Ejemplo básico: sistema cliente/servidor usando Websockets en Python</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#interactuando-con-un-navegador-web" class="nav-link">Interactuando con un navegador web</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#un-ejemplo-mas-complejo-sincronizacion-entre-multiples-clientes" class="nav-link">Un ejemplo más complejo: sincronización entre múltiples clientes</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#websockets-en-el-esp32" class="nav-link">Websockets en el ESP32</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#ejercicio-entregable-comunicacion-asincrona" class="nav-link">Ejercicio entregable: Comunicación asíncrona</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="practica-4-protocolos-basicos-de-capa-de-aplicacion-websockets">Práctica 4. Protocolos básicos de capa de aplicación. Websockets</h1>
<h2 id="objetivos">Objetivos</h2>
<ul>
<li>Conocer el módulo Python <em>websockets</em> para desarrollar sistemas básicos
  cliente/servidor utilizando <em>websockets</em>.</li>
<li>Estudar el intercambio de mensajes entre un cliente y un servidor 
  <em>websockets</em>, tanto en la fase de <em>handshake</em> como de intercambio de datos.</li>
<li>Conseguir interactuar con un servidor <em>websockets</em> utilizando un navegador
  web como cliente.</li>
<li>Estudiar mecanismos de mantenimiento y publicación de estado a clientes 
  conectados, típicos en un entorno IoT.</li>
<li>Estudiar el componente <em>websockets client</em> en ESP-IDF, y desarrollar un 
  <em>firmware</em> básico que interactúe con un servidor Python.</li>
<li>Introducir la gestión de objetos JSON en ESP-IDF.</li>
</ul>
<h2 id="ejemplo-basico-sistema-clienteservidor-usando-websockets-en-python">Ejemplo básico: sistema cliente/servidor usando Websockets en Python</h2>
<p>En primer lugar, introducimos el uso del módulo Python
<code>websockets</code>, que proporciona
toda la funcionalidad necesaria para desarrollar sistemas cliente/servidor
utilizando <em>websockets</em>.</p>
<p>El módulo <code>websockets</code> proporciona la funcionalidad necesaria tanto a nivel de cliente
como de servidor para implementar sistemas basados en dicho protocolo. Concretamente,
las funciones de alto nivel que proporciona están basadas en una API de bajo
nivel que implementa las dos fases principales del protocolo <em>websockets</em>:</p>
<ol>
<li><em>Handshake</em> de apertura de comunicación, en forma de peticiones <em>HTTP upgrade</em>.</li>
<li>Transferencia de datos, y finalización de la comunicación con un <em>handshake</em> de cierre
de conexión.</li>
</ol>
<p>La primera fase está diseñada para integrarse con software HTTP (cliente y servidor)
existente, y proporciona una implementación mínima para construir, parsear y 
validar peticiones y respuestas HTTP.</p>
<p>La segunda fase implementa el núcleo del protocolo <em>websockets</em>, y proporciona
una implementación completa basada en el 
módulo <a href="https://docs.python.org/3/library/asyncio.html">asyncio</a>) 
de Python. </p>
<p>Para utilizar el módulo <code>websockets</code> de Python, primero lo instalaremos vía
<code>pip</code>:</p>
<pre><code class="sh">pip install websockets
</code></pre>

<p>Un ejemplo básico se puede basar en un cliente que envía una cadena a un 
servidor, y queda a la espera de recibir un mensaje de respuesta por parte
de éste, tal y como hemos visto en otras prácticas. </p>
<p>Desarrollar la parte servidora para dicha aplicación resulta sencillo. Observa
el siguiente código:</p>
<pre><code class="python">#!/usr/bin/env python

import asyncio
import websockets

async def hello(websocket, path):
    name = await websocket.recv()
    print(f&quot;&lt; {name}&quot;)

    greeting = f&quot;Hello {name}!&quot;

    await websocket.send(greeting)
    print(f&quot;&gt; {greeting}&quot;)

start_server = websockets.serve(hello, &quot;localhost&quot;, 8765)

asyncio.get_event_loop().run_until_complete(start_server)
asyncio.get_event_loop().run_forever()
</code></pre>

<p>El paradigma de programación utilizado en este ejemplo (basado en el 
módulo <a href="https://docs.python.org/3/library/asyncio.html">asyncio</a>) queda fuera
del propósito de la práctica (aunque se invita al alumno a estudiarlo, ya
que aporta importantes ventajas a nivel de sencillez de desarrollo en 
aplicaciones de red). En cualquier caso, el anterior servidor ejecuta
una (co)rutina manejadora <code>hello</code> para cada conexión <em>websocket</em> establecida; 
además, se cierra dicha conexión cuando dicha (co)rutina finaliza.</p>
<p>Concretamente, las funciones de interés en este caso son:</p>
<pre><code class="python">await websockets.server.serve(ws_handler, host=None, port=None, # ...
</code></pre>

<p>Crea, incializa y devuelve un objeto <em>servidor Websocket</em> asociado al 
host y puerto seleccionados. En un contexto de programación asíncrona (como
el del ejemplo, el servidor finaliza automáticamente al salir de dicho contexto).</p>
<p>Cuando un cliente conecta al host y puerto específicados, se acepta la conexión,
que es tratada por la (co)rutina <code>ws_handler</code> (en el ejemplo, <code>hello</code>). Antes
de delegar la conexión a la (co)rutina, se lleva a cabo el <em>handshake</em> de 
apertura <em>websocket</em>.</p>
<pre><code class="python">await recv()
</code></pre>

<p>Recibe el siguiente mensaje, devolviendo una cadena si el <em>frame</em> recibido
es de texto, o un <em>array</em> de bytes si es binario.</p>
<pre><code class="python">await send(message)
</code></pre>

<p>Envía un mensaje. <code>message</code> puede er una cadena, o un array de bytes. En 
el primer caso, se envía un <em>frame</em> de texto; en el segundo caso, 
un <em>frame</em> binario.</p>
<p>A continuación se muestra un ejemplo de cliente <em>websocket</em> para interactuar
con el anterior servidor:</p>
<pre><code class="python">#!/usr/bin/env python

import asyncio
import websockets

async def hello():
    uri = &quot;ws://localhost:8765&quot;
    async with websockets.connect(uri) as websocket:
        name = input(&quot;What's your name? &quot;)

        await websocket.send(name)
        print(f&quot;&gt; {name}&quot;)

        greeting = await websocket.recv()
        print(f&quot;&lt; {greeting}&quot;)

asyncio.get_event_loop().run_until_complete(hello())
</code></pre>

<p>El código en este caso es sencillo, ya que únicamente se basa en la planificación
(ejecución) de una (co)rutina llamada <code>hello</code>, que establece una conexión con
un servidor <em>websocket</em> vía <code>connect</code>, enviando y recibiendo un par de mensajes.</p>
<pre><code class="python">await websockets.client.connect(uri, # ...
</code></pre>

<p>Conecta con un servidor <em>websocket</em> en la URI determinada. La conexión se cierra
al abandonar el contexto asíncrono (es decir, la (co)rutina <code>hello</code>).</p>
<div class="admonition danger">
<p class="admonition-title">Tarea entregable</p>
<p>Ejecuta el servidor en una terminal de tu máquina virtual, y a continuación
el cliente en otra. Analiza el tráfico intercambiado y responde a las siguientes
preguntas:</p>
<ol>
<li>¿En qué protocolo de capa de transporte se basa la comunicación vía Websockets?</li>
<li>En la fase de <em>handshake</em>, ¿qué peticiones HTTP se intercambian? Analiza
sus emisores y destinatarios, e investiga el cometido principal de cada uno de
los campos de sus encabezados (fíjate principalmente en el campo <em>Upgrade</em> y 
los campos específicos para Websockets).</li>
<li>En la fase de intercambio de datos, ¿qué <em>opcode</em> se especifica en el encabezado
de cada paquete? ¿Por qué?</li>
<li>¿Se envían los datos en claro o cifrados?</li>
<li>¿Qué <em>opcode</em> se añade en los mensajes de cierre de conexión?</li>
</ol>
</div>
<h2 id="interactuando-con-un-navegador-web">Interactuando con un navegador web</h2>
<p>Aunque fuera del interés de esta práctica, es conveniente observar una de las
ventajas de <em>websockets</em>: el envío asíncrono bidireccional de información, y 
observarlo a través de un navegador web convencional (la mayoría de navegadores
modernos soportan <em>websockets</em> a través de <em>scripts Javascript</em>).</p>
<p>En este caso, simplemente observa la interacción de un servidor <em>websocket</em> 
que envía mensajes que incluyen la hora actual separados un número aleatorio
de tiempo entre ellos:</p>
<pre><code class="python">#!/usr/bin/env python

# WS server that sends messages at random intervals

import asyncio
import datetime
import random
import websockets

async def time(websocket, path):
    while True:
        now = datetime.datetime.utcnow().isoformat() + &quot;Z&quot;
        await websocket.send(now)
        await asyncio.sleep(random.random() * 3)

start_server = websockets.serve(time, &quot;127.0.0.1&quot;, 5678)

asyncio.get_event_loop().run_until_complete(start_server)
asyncio.get_event_loop().run_forever()
</code></pre>

<p>Con un cliente (una página HTML) que establece la conexión vía <em>websockets</em>,
y muestra en la misma un elemento de texto con la marca de tiempo recibida 
tras la recepción de cada mensaje:</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;WebSocket demo&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;script&gt;
            var ws = new WebSocket(&quot;ws://127.0.0.1:5678/&quot;),
                messages = document.createElement('ul');
            ws.onmessage = function (event) {
                var messages = document.getElementsByTagName('ul')[0],
                    message = document.createElement('li'),
                    content = document.createTextNode(event.data);
                message.appendChild(content);
                messages.appendChild(message);
            };
            document.body.appendChild(messages);
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<div class="admonition note">
<p class="admonition-title">Tarea</p>
<p>Ejecuta el servidor en tu máquina virtual y, tras guardar el código fuente
del cliente en un fichero <code>cliente.html</code>, ábrelo con un navegador. Observa
como la página se actualiza a medida que recibe mensajes a través del 
socket. Si quieres, puedes observar el intercambio de mensajes. ¿Qué ocurre
si, en otra pestaña, vuelves a abrir la página cliente?</p>
</div>
<h2 id="un-ejemplo-mas-complejo-sincronizacion-entre-multiples-clientes">Un ejemplo más complejo: sincronización entre múltiples clientes</h2>
<p>Un servidor <em>websocket</em> puede recibir eventos desde distintos clientes, procesarlos
para, por ejemplo, mantener actualizado un estado a nivel de aplicación, y 
sincronizar dicho estado entre todos los clientes conectados, enviándoles mensajes
de forma asíncrona a través del socket bidireccional, a modo de "notificaciones
<em>push</em>".</p>
<p>A continuación, se muestra el código de un servidor que mantiene dos tipos 
de información de estado siempre actualizada: el valor de un contador
(<code>STATE</code>), que puede
ser modificado por los clientes conectados sumando o restando uno a su valor
a través de mensajes enviados por el <em>socket</em>; y el número de clientes 
conectados (<code>USERS</code>).</p>
<pre><code class="python">#!/usr/bin/env python

import asyncio
import json
import logging
import websockets

logging.basicConfig()

STATE = {&quot;value&quot;: 0}

USERS = set()


def state_event():
    return json.dumps({&quot;type&quot;: &quot;state&quot;, **STATE})


def users_event():
    return json.dumps({&quot;type&quot;: &quot;users&quot;, &quot;count&quot;: len(USERS)})


async def notify_state():
    if USERS:  # asyncio.wait doesn't accept an empty list
        message = state_event()
        await asyncio.wait([user.send(message) for user in USERS])


async def notify_users():
    if USERS:  # asyncio.wait doesn't accept an empty list
        message = users_event()
        await asyncio.wait([user.send(message) for user in USERS])


async def register(websocket):
    USERS.add(websocket)
    await notify_users()


async def unregister(websocket):
    USERS.remove(websocket)
    await notify_users()


async def counter(websocket, path):
    # register(websocket) sends user_event() to websocket
    await register(websocket)
    try:
        await websocket.send(state_event())
        async for message in websocket:
            data = json.loads(message)
            if data[&quot;action&quot;] == &quot;minus&quot;:
                STATE[&quot;value&quot;] -= 1
                await notify_state()
            elif data[&quot;action&quot;] == &quot;plus&quot;:
                STATE[&quot;value&quot;] += 1
                await notify_state()
            else:
                logging.error(&quot;unsupported event: {}&quot;, data)
    finally:
        await unregister(websocket)


start_server = websockets.serve(counter, &quot;localhost&quot;, 6789)

asyncio.get_event_loop().run_until_complete(start_server)
asyncio.get_event_loop().run_forever()
</code></pre>

<p>Observa el código del servidor. </p>
<p>El manejador <code>counter</code> procesa cada conexión
entrante, registrando a su entrada a un nuevo cliente en el sistema (<code>register</code>)
y desregistrándolo antes de finalizar (<code>unregister</code>). Ante cada registro
o desregistro, se notifica a los usuarios este hecho, enviando a cada
cliente un pequeño texto en formato JSON cuyo contenido es:</p>
<pre><code class="json">{&quot;type&quot;: &quot;users&quot;, &quot;count&quot;: usuarios}
</code></pre>

<p>Es decir, un mensaje con dos campos (veremos JSON en la próxima práctica):
campo <code>type</code>, con valor fijo <code>users</code>, y campo <code>count</code>, con un valor entero 
que indica el número de clientes conectados.</p>
<p>A continuación, para cada mensaje recibido a través del socket, éste se procesa,
esperando también un fichero JSON con la acción que el cliente solicita (sumar
o restar 1 al contador), por ejemplo:</p>
<pre><code class="json"> {&quot;action&quot;: &quot;minus&quot;}
</code></pre>

<p>o</p>
<pre><code class="json"> {&quot;action&quot;: &quot;plus&quot;}
</code></pre>

<p>En función de la acción solicitada, el servidor actualiza el valor de <code>STATE</code>,
y envía (rutina <code>notify_state</code>) dicho valor actualizado a TODOS los clientes
conectados mediante un pequeño mensaje de texto en formato JSON:</p>
<pre><code class="json">{&quot;type&quot;: &quot;state&quot;, &quot;value&quot;: VALOR}
</code></pre>

<p>La parte cliente sigue la misma filosofía, utilizando de nuevo el navegador
como plataforma para visualizar la interacción con el cliente. El código HTML
que puedes abrir en tu navegador es el siguiente:</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;WebSocket demo&lt;/title&gt;
        &lt;style type=&quot;text/css&quot;&gt;
            body {
                font-family: &quot;Courier New&quot;, sans-serif;
                text-align: center;
            }
            .buttons {
                font-size: 4em;
                display: flex;
                justify-content: center;
            }
            .button, .value {
                line-height: 1;
                padding: 2rem;
                margin: 2rem;
                border: medium solid;
                min-height: 1em;
                min-width: 1em;
            }
            .button {
                cursor: pointer;
                user-select: none;
            }
            .minus {
                color: red;
            }
            .plus {
                color: green;
            }
            .value {
                min-width: 2em;
            }
            .state {
                font-size: 2em;
            }
        &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div class=&quot;buttons&quot;&gt;
            &lt;div class=&quot;minus button&quot;&gt;-&lt;/div&gt;
            &lt;div class=&quot;value&quot;&gt;?&lt;/div&gt;
            &lt;div class=&quot;plus button&quot;&gt;+&lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;state&quot;&gt;
            &lt;span class=&quot;users&quot;&gt;?&lt;/span&gt; online
        &lt;/div&gt;
        &lt;script&gt;
            var minus = document.querySelector('.minus'),
                plus = document.querySelector('.plus'),
                value = document.querySelector('.value'),
                users = document.querySelector('.users'),
                websocket = new WebSocket(&quot;ws://127.0.0.1:6789/&quot;);
            minus.onclick = function (event) {
                websocket.send(JSON.stringify({action: 'minus'}));
            }
            plus.onclick = function (event) {
                websocket.send(JSON.stringify({action: 'plus'}));
            }
            websocket.onmessage = function (event) {
                data = JSON.parse(event.data);
                switch (data.type) {
                    case 'state':
                        value.textContent = data.value;
                        break;
                    case 'users':
                        users.textContent = (
                            data.count.toString() + &quot; user&quot; +
                            (data.count == 1 ? &quot;&quot; : &quot;s&quot;));
                        break;
                    default:
                        console.error(
                            &quot;unsupported event&quot;, data);
                }
            };
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>Observa cómo el <em>script</em> envía mensajes de suma o resta en formato JSON acorde
al esperado por el servidor, y procesa los mensajes de entrada actualizando
la información mostrada en pantalla recibida acerca del valor del contador
actualizado y número de usuarios.</p>
<div class="admonition note">
<p class="admonition-title">Tarea</p>
<p>Ejecuta el servidor en tu máquina virtual, y múltiples clientes en distintas
ventanas/pestañas del navegador (con ventanas lo verás mejor). Interactúa
desde un cliente aumentando o reduciendo el valor del contador, y observa
cómo dicho valor es actualizado (a través del servidor) en el resto de
clientes abiertos. Conecta y desconecta nuevos clientes y observa también
como el campo correspondiente en la página web se actualiza correctamente. 
Si quieres, puedes analizar el tráfico <em>Websockets</em> generado vía 
Wireshark.</p>
</div>
<h2 id="websockets-en-el-esp32">Websockets en el ESP32</h2>
<p>El soporte a nivel de cliente para el protocolo <em>websockets</em> está integrado
en ESP-IDF a travésd el componente <em>websocket client</em>, cuya documentación
puede consultarse a través de este <a href="https://docs.espressif.com/projects/esp-idf/en/stable/api-reference/protocols/esp_websocket_client.html#">enlace</a>.</p>
<p>El componente <em>websocket client</em> ofrece soporte para el protocolo <em>websocket</em>
sobre TCP y también, opcionalmente, sobre TLS. Como todos los componentes
en ESP-IDF, el componente <em>websocket</em> emite eventos que pueden ser tratados
por parte de la aplicación, entre los cuales destacan:</p>
<ul>
<li><code>WEBSOCKET_EVENT_CONNECTED</code>: se emite una vez el cliente se ha conectado
  al servidor, sin intercambio de datos.</li>
<li><code>WEBSOCKET_EVENT_DISCONNECTED</code>: se emite en el instante de la desconexión
  entre cliente y servidor.</li>
<li><code>WEBSOCKET_EVENT_DATA</code>: se emite al recibir datos desde el servidor.</li>
</ul>
<p>Este último evento es de especial interés para nosotros, ya que accarrea la
construcción de una estructura de tipo <code>esp_websocket_event_data_t</code> en la que
se almacena el mensaje recibido desde el servidor (tanto en sus campos de
control como de datos). Algunos campos de interés dentro de la estructura son:</p>
<ul>
<li><code>const char * data_ptr</code>: puntero a los datos recibidos (<em>payload</em>).</li>
<li><code>data_len</code>: tamaño (en bytes) de los datos recibidos.</li>
<li><code>op_code</code>: código de operación asociado al mensaje recibido.</li>
</ul>
<p>La documentación del componente ofrece información sobre campos adicionales,
de menor interés para nosotros.</p>
<p>Observemos el código de una posible función manejadora de eventos del componente
<em>websocket</em>:</p>
<pre><code class="c">static void websocket_event_handler(void *handler_args, esp_event_base_t base, int32_t event_id, void *event_data)
{
    esp_websocket_event_data_t *data = (esp_websocket_event_data_t *)event_data;
    switch (event_id) {
    case WEBSOCKET_EVENT_CONNECTED:
        ESP_LOGI(TAG, &quot;WEBSOCKET_EVENT_CONNECTED&quot;);
        break;
    case WEBSOCKET_EVENT_DISCONNECTED:
        ESP_LOGI(TAG, &quot;WEBSOCKET_EVENT_DISCONNECTED&quot;);
        break;
    case WEBSOCKET_EVENT_DATA:
        ESP_LOGI(TAG, &quot;WEBSOCKET_EVENT_DATA&quot;);
        ESP_LOGI(TAG, &quot;Received opcode=%d&quot;, data-&gt;op_code);
        if (data-&gt;op_code == 0x08 &amp;&amp; data-&gt;data_len == 2) {
            ESP_LOGW(TAG, &quot;Received closed message with code=%d&quot;, 256*data-&gt;data_ptr[0] + data-&gt;data_ptr[1]);
        } else {
            ESP_LOGW(TAG, &quot;Received=%.*s&quot;, data-&gt;data_len, (char *)data-&gt;data_ptr);
        }
        ESP_LOGW(TAG, &quot;Total payload length=%d, data_len=%d, current payload offset=%d\r\n&quot;, data-&gt;payload_len, data-&gt;data_len, data-&gt;payload_offset);

        xTimerReset(shutdown_signal_timer, portMAX_DELAY);
        break;
    case WEBSOCKET_EVENT_ERROR:
        ESP_LOGI(TAG, &quot;WEBSOCKET_EVENT_ERROR&quot;);
        break;
    }
}
</code></pre>

<p>Observa el código. En función del parámetro <code>event_id</code>, el manejador toma
un camino de ejecución u otro. Centrémonos en la recepción de un evento de
tipo <code>ẀEBSOCKET_EVENT_DATA</code>; a través de los distintos campos de la estructura
de información recibida (<code>event_data</code>), es posible:</p>
<ol>
<li>Obtener y mostrar el código de la operación (<code>op_code</code>).</li>
<li>Mostrar el contenido del mensaje recibido   (<code>data_ptr</code>).</li>
<li>Mostrar el tamaño del mensaje recibido (<code>data_len</code> y <code>payload_len</code>).</li>
</ol>
<div class="admonition nota">
<p class="admonition-title">Preguntas</p>
<ul>
<li>¿Cuál es la diferencia entre los campos <code>data_len</code> y <code>payload_len</code>?</li>
<li>¿Por qué el programa realiza un tratamiento especial cuando 
<code>op_code == 8</code>?</li>
</ul>
</div>
<p>Dada la anterior función manejadora, la inicialización de un cliente
<em>websockets</em> en el ESP32 es sencilla, y se resume en los siguientes pasos:</p>
<ul>
<li><strong>Configuración de URI (host + puerto)</strong></li>
</ul>
<pre><code class="c">esp_websocket_client_config_t websocket_cfg = {};
websocket_cfg.uri = &quot;ws://localhost:123&quot;;
esp_websocket_client_handle_t client = esp_websocket_client_init(&amp;websocket_cfg);
</code></pre>

<ul>
<li><strong>Asociación de manejador a eventos <em>Websocket</em></strong></li>
</ul>
<pre><code class="c">esp_websocket_register_events(client, WEBSOCKET_EVENT_ANY, websocket_event_handler, (void *)client);
</code></pre>

<ul>
<li><strong>Inicialización del cliente</strong></li>
</ul>
<pre><code class="c">esp_websocket_client_start(client);
</code></pre>

<p>A partir de este punto, la interacción con el servidor se puede realizar en 
base a funciones de envío de texto o binario:</p>
<pre><code class="c">int esp_websocket_client_send(esp_websocket_client_handle_tclient, const char *data, int len, TickType_t timeout)

esp_websocket_client_send_bin(esp_websocket_client_handle_tclient, const char *data, int len, TickType_t timeout)
</code></pre>

<p>No existen funciones de recepción, ya que ésta es implícita y se notifica vía
eventos.</p>
<h3 id="ejemplo-basico-cliente-echo">Ejemplo básico: cliente <em>echo</em></h3>
<p>Veremos en primer lugar un ejemplo completo de cliente ejecutado sobre
el ESP32. En este punto, configura, compila, flashea y monitoriza el ejemplo
<code>examples/protocols/websockets</code>.</p>
<p>El ejemplo simplemente conecta con un servidor <em>echo</em> <em>Websockets</em> en la nube
(disponible en <code>ws://websockets.org</code>). Dicho servidor simplemente espera, por
parte de cada cliente, el envío a través de la conexión de una cadena, 
respondiendo con la misma cadena en sentido contrario, siempre usando el 
mismo <em>socket</em>.</p>
<div class="admonition nota">
<p class="admonition-title">Tarea</p>
<p>Observa el código del ejemplo y su ejecución. Determina cuál es el
funcionamiento del ejemplo, y comprueba que los fragmentos de código 
anteriores tienen su función dentro del código completo. ¿Cómo implementa
el programa la espera limitada en tiempo si no se recibe ningún paquete
tras cierto período?</p>
</div>
<h2 id="ejercicio-entregable-comunicacion-asincrona">Ejercicio entregable: Comunicación asíncrona</h2>
<p>El objetivo del ejercicio entregable es conseguir que el ESP32 se comunique con
el servidor Python que se probó en la sección anterior, y que implementaba 
comunicación bidireccional para mantener y difundir el estado interno (contador
y número de clientes conectados) entre todos los clientes conectados.</p>
<p>Para ello, se pide modificar el ejemplo de cliente <em>echo</em> para que:</p>
<ul>
<li>El cliente conecte con el servidor Python especificando su IP y puerto.</li>
<li>El cliente sea cien por cien pasivo, es decir, no envíe nunca mensajes 
al servidor.</li>
<li>La función de manejo de paquetes recibidos trate de forma especial el tipo de
mensajes esperado por parte del servidor. Recuerda que se pueden recibir dos
tipos de mensajes de texto:</li>
<li>Mensajes de estado:</li>
</ul>
<pre><code class="json">{&quot;type&quot;: &quot;users&quot;, &quot;count&quot;: usuarios}
</code></pre>

<ul>
<li>Mensajes de usuarios:</li>
</ul>
<pre><code class="json">{&quot;type&quot;: &quot;state&quot;, &quot;value&quot;: VALOR}
</code></pre>

<p>Observa que ambos mensajes, pese a ser recibidos como texto, corresponden con
una representación JSON de la información. Para tratarla desde ESP-IDF, 
puedes hacer uso del componente cJSON del <em>framework</em>. Por ejemplo, para 
tratar un mensaje de entrada de tipo "state", podríamos añadir la siguiente
secuencia de código en nuestro manejador:</p>
<pre><code class="c">#include &quot;cJSON.h&quot;

// ...

if( data-&gt;op_code == 1 ) { // Text frame only.
  cJSON *root = cJSON_Parse((char*)data-&gt;data_ptr);
  char *type = cJSON_GetObjectItem(root,&quot;type&quot;)-&gt;valuestring;
  ESP_LOGI(TAG, &quot;type=%s&quot;,type);

  int field = 0;

  if( strcmp( type, &quot;state&quot; ) == 0) {
    field = cJSON_GetObjectItem(root,&quot;value&quot;)-&gt;valueint;
    ESP_LOGI(TAG, &quot;value=%d&quot;,field);
  }
}
</code></pre>

<div class="admonition danger">
<p class="admonition-title">Tarea entregable</p>
<p>Modifica el <em>firmware</em> de ejemplo <em>websockets</em> para que pueda comunicarse
en modo lectura con el servidor Python que mantiene y publicita estado, cuyo
código se te proporciona. El programa ESP-IDF, al menos, mostará por pantalla
un mensaje con los datos asociados cada vez que se reciban paquetes de tipo
texto (<em>state</em> o <em>users</em>). También mostrará un mensaje cada vez que el 
servidor envíe un mensaje de tipo <em>ping</em> o <em>pong</em> (para ello, consulta
el RFC que describe el protocolo para determinar el <em>opcode</em> asociado).</p>
<p>Para comprobar el funcionamiento de la solución, arranca el servidor y al
menos dos clientes web. Cuando arranques el ESP32, ambos deberán incrementar
el número de clientes reportado, en respuesta al mensaje enviado por el 
servidor. Cuando cualquiera de los clientes web incremente el valor del 
contador, el ESP32 recibirá un mensaje con el valor actualizado, del mismo
modo que cuando cierres uno de los navegadores web.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Tarea opcional</p>
<p>Modifica el código para que el cliente, periódicamente, envíe un mensaje
de petición de suma o resta siguiendo las especificaciones y tipos de
mensaje que se explicaron anteriormente.</p>
</div></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../js/base.js" defer></script>
        <script src="../../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
