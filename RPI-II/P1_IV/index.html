<!DOCTYPE html>
<html lang="en" data-bs-theme="light">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>Práctica 1 (Apéndice). Programación con sockets en Python - Master IoT UCM - Prácticas RPI/ANIOT/LSI (24/25)</title>
        <link href="../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../css/fontawesome.min.css" rel="stylesheet">
        <link href="../../css/brands.min.css" rel="stylesheet">
        <link href="../../css/solid.min.css" rel="stylesheet">
        <link href="../../css/v4-font-face.min.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link id="hljs-light" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" >
        <link id="hljs-dark" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css" disabled>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script>hljs.highlightAll();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../..">Master IoT UCM - Prácticas RPI/ANIOT/LSI (24/25)</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-bs-toggle="collapse" data-bs-target="#navbar-collapse" aria-controls="navbar-collapse" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="nav-item">
                                <a href="../.." class="nav-link">Calendario</a>
                            </li>
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown"  aria-expanded="false">RPI-I</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../RPI-I/P1/" class="dropdown-item">Práctica 1</a>
</li>
                                    
<li>
    <a href="../../RPI-I/P1b/index.md" class="dropdown-item">Práctica 1 (segunda parte)</a>
</li>
                                    
<li>
    <a href="../../RPI-I/P2/" class="dropdown-item">Práctica 2</a>
</li>
                                    
<li>
    <a href="../../RPI-I/P3/" class="dropdown-item">Práctica 3</a>
</li>
                                    
<li>
    <a href="../../RPI-I/P4/" class="dropdown-item">Práctica 4</a>
</li>
                                    
<li>
    <a href="../../RPI-I/P5/" class="dropdown-item">Práctica 5</a>
</li>
                                    
<li>
    <a href="../../RPI-I/P6/" class="dropdown-item">Práctica 6</a>
</li>
                                    
<li>
    <a href="../../RPI-I/P7/" class="dropdown-item">Práctica 7</a>
</li>
                                    
<li>
    <a href="../../RPI-I/P8/" class="dropdown-item">Práctica 8</a>
</li>
                                </ul>
                            </li>
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown"  aria-expanded="false">RPI-II</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../P1_I/" class="dropdown-item">Práctica 1 (I)</a>
</li>
                                    
<li>
    <a href="../P1_III/" class="dropdown-item">Práctica 1 (II)</a>
</li>
                                    
<li>
    <a href="../P2/" class="dropdown-item">Práctica 2</a>
</li>
                                    
<li>
    <a href="../P3/" class="dropdown-item">Práctica 3</a>
</li>
                                    
<li>
    <a href="../P4/" class="dropdown-item">Práctica 4</a>
</li>
                                    
<li>
    <a href="../P5/" class="dropdown-item">Práctica 5 (I)</a>
</li>
                                    
<li>
    <a href="../P5_II/" class="dropdown-item">Práctica 5 (II)</a>
</li>
                                    
<li>
    <a href="../P6/" class="dropdown-item">Práctica 6</a>
</li>
                                    
<li>
    <a href="../P7/" class="dropdown-item">Práctica 7</a>
</li>
                                    
<li>
    <a href="../P8/" class="dropdown-item">Práctica 8</a>
</li>
                                </ul>
                            </li>
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown"  aria-expanded="false">ANIOT</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../ANIOT/P1/" class="dropdown-item">Práctica 1</a>
</li>
                                    
<li>
    <a href="../../ANIOT/P2/" class="dropdown-item">Práctica 2</a>
</li>
                                    
<li>
    <a href="../../ANIOT/P3/" class="dropdown-item">Práctica 3</a>
</li>
                                    
<li>
    <a href="../../ANIOT/P4/" class="dropdown-item">Práctica 4</a>
</li>
                                    
<li>
    <a href="../../ANIOT/P5/" class="dropdown-item">Práctica 5</a>
</li>
                                    
<li>
    <a href="../../ANIOT/P6/" class="dropdown-item">Práctica 6</a>
</li>
                                    
<li>
    <a href="../../ANIOT/P7/" class="dropdown-item">Práctica 7</a>
</li>
                                    
<li>
    <a href="../../ANIOT/P7/index2/" class="dropdown-item">Práctica 7 (adicional)</a>
</li>
                                    
<li>
    <a href="../../ANIOT/P8/" class="dropdown-item">Práctica 8</a>
</li>
                                </ul>
                            </li>
                            <li class="nav-item dropdown">
                                <a href="#" class="nav-link dropdown-toggle" role="button" data-bs-toggle="dropdown"  aria-expanded="false">LSI</a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../LSI/Lab0/" class="dropdown-item">Práctica 0</a>
</li>
                                    
<li>
    <a href="../../LSI/Lab1/" class="dropdown-item">Práctica 1</a>
</li>
                                    
<li>
    <a href="../../LSI/Lab2/" class="dropdown-item">Práctica 2</a>
</li>
                                    
<li>
    <a href="../../LSI/Lab3/" class="dropdown-item">Práctica 3</a>
</li>
                                    
<li>
    <a href="../../LSI/Lab4/" class="dropdown-item">Práctica 4</a>
</li>
                                    
<li>
    <a href="../../LSI/Lab5/" class="dropdown-item">Práctica 5</a>
</li>
                                </ul>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ms-md-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-bs-toggle="modal" data-bs-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-bs-toggle="collapse" data-bs-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-body-tertiary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-bs-level="1"><a href="#practica-1-apendice-programacion-con-sockets-en-python" class="nav-link">Práctica 1 (Apéndice). Programación con sockets en Python</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#objetivos" class="nav-link">Objetivos</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#la-api-de-sockets-en-python" class="nav-link">La API de sockets en Python</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#sockets-tcp" class="nav-link">Sockets TCP</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#clienteservidor-echo-tcp" class="nav-link">Cliente/servidor echo TCP</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#ejecucion-del-cliente-y-servidor-echo" class="nav-link">Ejecución del cliente y servidor echo</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#herramientas-para-observar-el-estado-del-socket" class="nav-link">Herramientas para observar el estado del socket</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#capturas-de-trafico-via-wireshark" class="nav-link">Capturas de tráfico vía Wireshark</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#sockets-udp" class="nav-link">Sockets UDP</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#envio-de-datos-binarios-a-traves-de-sockets" class="nav-link">Envío de datos binarios a través de sockets</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#tarea" class="nav-link">Tarea</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#ejemplo-de-sistema-clienteservidor-multi-hilo" class="nav-link">Ejemplo de sistema cliente/servidor multi-hilo</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#tarea-opcional" class="nav-link">Tarea opcional</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#tarea-opcional_1" class="nav-link">Tarea opcional</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="practica-1-apendice-programacion-con-sockets-en-python">Práctica 1 (Apéndice). Programación con sockets en Python</h1>
<h2 id="objetivos">Objetivos</h2>
<ul>
<li>Familiarizarse con la API de <em>sockets</em> en Python.</li>
<li>Desarrollar esquemas básicos de sistemas cliente/servidor TCP y UDP
  utilizando Python.</li>
<li>Ser capaces de analizar el tráfico generado en una conexión TCP y UDP a 
  través de Wireshark.</li>
<li>Diseñar un protocolo de capa de aplicación para simular una aplicación
  cliente/servidor utilizando TCP y UDP.</li>
<li>Observar la diferencia en tráfico generado para una misma aplicación
  utilizando TCP y UDP.</li>
<li>Implementar servidores multi-hilo en Python.</li>
</ul>
<div class="admonition danger">
<p class="admonition-title">Nota</p>
<p>Ofrecemos esta práctica como anexo y referencia para complementar los contenidos
ofrecidos en la Práctica 1. Su comprensión y desarrollo es opcional, aunque puede
ser de utilidad para alumnos con poca experiencia en el lenguaje C o en programación
con sockets, o para prototipar rápidamente sistemas cliente/servidor utilizando Python.</p>
</div>
<h2 id="la-api-de-sockets-en-python">La API de sockets en Python</h2>
<p>El <a href="https://docs.python.org/3/library/socket.html">módulo socket</a> de Python 
proporciona una interfaz completa para trabajar con la <a href="https://en.wikipedia.org/wiki/Berkeley_sockets">API de sockets
de Berkeley</a>. En la presente
práctica, trabajaremos exclusivamente con esta API para desarrollar
aplicaciones cliente/servidor utilizando los protocolos TCP y UDP.</p>
<p>Las funciones y métodos principales de la API de sockets son:</p>
<ul>
<li><code>socket()</code> - </li>
<li><code>bind()</code> - </li>
<li><code>listen()</code> - </li>
<li><code>accept()</code> - </li>
<li><code>connect()</code> - </li>
<li><code>connect_ex()</code> - </li>
<li><code>send()</code> - </li>
<li><code>recv()</code> - </li>
<li><code>close()</code> - </li>
</ul>
<p>Python prorpociona una API consistente y completa mapeada directamente
a las anteriores llamadas al sistema, típicamente escritas en lenguaje C. 
Como parte de su biblioteca estándar, Python también proporciona clases que
facilitan el trabajo con las funciones de bajo nivel. Aunque no lo cubriremos,
el <a href="https://docs.python.org/3/library/socketserver.html">módulo socketserver</a>
proporciona una forma sencilla de crear servidores de red. Existen también
numerosos módulos disponibles para implementar protocolos de alto nivel (por
ejemplo HTTP o SMTP), véase <a href="https://docs.python.org/3/library/internet.html"></a>.</p>
<h2 id="sockets-tcp">Sockets TCP</h2>
<p>En Python, los <em>sockets</em> TCP se crean en Python utilizando <code>socket.socket()</code>,
especificando el tipo de <em>socket</em> como <code>socket.SOCK_STREAM</code>. El protocolo
de control de transmisión (TCP) se caracteriza por dos rasgos principales:</p>
<ul>
<li>
<p><strong>Es confiable</strong>: se implementan mecanismos de detección de pérdidas en la
red y reenvío de paquetes perdidos.</p>
</li>
<li>
<p><strong>Garantiza una entrega de paquetes en orden</strong>: los datos se entregan a las
capas superiores (aplicaciones) en el mismo orden en el que fueron enviados.</p>
</li>
</ul>
<p>En contra, los <em>sockets</em> UDP se crean a través de <code>socket.SOCK_DGRAM</code>, y no
son confiables ni garantizan la entrega de paquetes en orden. Por tanto, es
el desarrollador de aplicaciones quien, en caso de así desearlo en el diseño
de la aplicación, debe implementar estos mecanismos de forma específica.</p>
<p>En el siguiente diagrama se muestra la secuencia típica de invocaciones a 
la API de <em>sockets</em> para TCP:</p>
<p><img alt="foo" src="img/sockets-tcp-flow.png" /></p>
<p>En la figura, la columna de la izquierda representa al servidor, mientras que
la columna de la derecha representa al cliente en la conexión TCP. Observa
las invocaciones necesarias para configurar un <em>socket</em> a la escucha de 
conexiones entrantes:</p>
<ul>
<li><code>socket()</code></li>
<li><code>bind()</code></li>
<li><code>listen()</code></li>
<li><code>accept()</code></li>
</ul>
<p>En este extremo, un <em>socket</em> escucha (<em>listen</em>) potenciales conexiones entrantes
desde clientes. Cuando un cliente solicita conectar, el servidor acepta 
(<em>accept</em>) la conexión, completándola.</p>
<p>El cliente invoca a <code>connect()</code> para establecer una conexión con el servidor
e inicia el proceso de conexión a tres vías (<em>three-way connection</em>). </p>
<p>Una vez establecida la conexión, los datos se intercambian entre cliente y 
servidor a través de invocaciones a <code>send()</code> y <code>recv()</code>. </p>
<p>Finalmente, el <em>socket</em> se destruye (esto es, la conexión entre ambos extremos
se cierra) a través de una invocación a <code>close()</code> en cada extremo.</p>
<h2 id="clienteservidor-echo-tcp">Cliente/servidor <em>echo</em> TCP</h2>
<p>Veamos un ejemplo sencillo para crear un par cliente-servidor. En este caso,
el servidor simplemente responderá con la misma cadena que reciba desde el
cliente.</p>
<h3 id="servidor-echo">Servidor <em>echo</em></h3>
<pre><code class="language-python">#!/usr/bin/env python3

#### servidor_echo.py

import socket

HOST = '127.0.0.1'  # Interfaz estándar de loopback (localhost)
PORT = 65432        # Puerto de escucha (los puertos mayores a 1023 son no privilegiados)

with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.bind((HOST, PORT))
    s.listen()
    conn, addr = s.accept()
    with conn:
        print('Conectado ', addr)
        while True:
            data = conn.recv(1024)
            if not data:
                break
            conn.sendall(data)
</code></pre>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>De momento, no importa si no entiendes todas las líneas en el anterior 
código. Simplemente se trata de un punto de partida para desarrollar un 
servidor sencillo. Sin embargo, es conveniente que copies el código en 
un fichero de texto (por ejemplo, llamado <code>servidor_echo.py</code>) para que 
podeamos probarlo.</p>
</div>
<p>Veamos línea a línea las partes más importantes del anterior código. </p>
<p><code>socket.socket()</code> crea un objeto <em>socket</em>. Observa que, al crearse a través
de una construcción <code>with</code>, no es necesario invocar explícitamente a 
<code>s.close()</code>, aunque debes tener en cuenta que el objeto es destruido al 
finalizar la construcción:</p>
<pre><code class="language-python">with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    pass  # Es posible usar el socket win invocar a s.close().
</code></pre>
<p>Los argumentos que se proporcionan a <code>socket()</code> especifican la familia de
direcciones (<code>AF_INET</code>) y tipo de <em>socket</em> (<code>SOCK_STREAM</code>). 
<code>AF_INET</code> es la familia de direcciones de Internet para IPv4. 
<code>SOCK_STREAM</code> es el tipo de <em>socket</em> que permite la creación de conexiones
TCP.</p>
<p><code>bind()</code> se utiliza para asociar el socket a una interfaz de red y número de
puerto específicos:</p>
<pre><code class="language-python">HOST = '127.0.0.1'  # Interfaz estándar de loopback (localhost)
PORT = 65432        # Puerto de escucha (los puertos mayores a 1023 son no privilegiados)

# ...

s.bind((HOST, PORT))
</code></pre>
<p>Los valores proporcionados a <code>bind()</code> dependen de la familia de direcciones 
seleccionada para el <em>socket</em>. En este ejemplo, al utilizar <code>AF_INET</code>, 
espera una tupla con únicamente dos valores <em>(host, puerto)</em>.</p>
<p>Para determinar el <em>host</em>, es posible utilizar un nombre de <em>host</em>, una 
dirección IP o una cadena vacía. Si utilizamos una dirección IP, ésta debe
ser especificarse mediante una cadena que contenga una dirección IPv4 bien
formada. La dirección 127.0.0.1 es la dirección IPv4 estándar para la 
interfaz de <em>loopback</em>, por lo que únicamente procesos que estén ejecutándose
en el propio <em>host</em> podrán comunicar con el servidor. Si proporcionamos una
cadena vacía, el servidro aceptará conexiones entrantes a través de todas
las interfaces IPv4 disponibles en el sistema.</p>
<p>El número de puerto (<em>port</em>) se especifica con un valor entero entre 1 y 65535,
y espcifica el puerto (en este caso, TCP) a través del cual el servidor aceptará
conexiones desde los clientes. La mayoría de sistemas requieren permisos de
superusuario para escuchar a través de los puertos (<em>well-known</em>), es decir, 
con valor inferior a 1024.</p>
<p>Continuando con el ejemplo, <code>listen()</code> posibilita que un servidor pueda, en el
futuro, aceptar (<code>accept()</code>) conexiones entrantes. En otras palabras, pone a
la escucha al <em>socket</em>:</p>
<pre><code class="language-python">s.listen()
conn, addr = s.accept()
</code></pre>
<p>La invocación a <code>accept()</code> <strong>bloquea</strong> el proceso y espera a una conexión
entrante. Cuando un cliente conecta, devuelve un objeto <code>socket</code> que representa
la conexión, así como una tupla (<code>addr</code>) que contiene la dirección del cliente.
Concretamente, esta tupla contiene los valores <code>(host, port)</code> que almacenan
la dirección IPv4 y puerto del cliente que solicita la conexión.</p>
<p>Observa que, en el ejemplo, <code>conn</code> es el objeto <em>socket</em> que usaremos para 
comunicar con el cliente:</p>
<pre><code class="language-python">conn, addr = s.accept()
with conn:
    print('Conectado ', addr)
    while True:
        data = conn.recv(1024)
        if not data:
            break
        conn.sendall(data)
</code></pre>
<p>Tras obtener el objeto devuelto por <code>accept()</code>, diseñamos el servidor como un
bucle infinito que invoca repetidamente a llamadas <strong>bloqueantes</strong> a 
<code>conn.recv()</code>. Así, leemos los datos enviados por el cliente y los reenviamos
sin modificación utilizando <code>conn.sendall()</code>.</p>
<p>Si <code>conn.recv()</code> devuelve un objeto de tipo <code>bytes</code> vacío (<code>b''</code>) significa
que el cliente cerró la conexión, en cuyo caso el bucle termina, destruyéndose
el <em>socket</em> al salir de la sentencia <code>with</code>.</p>
<h3 id="cliente-echo">Cliente <em>echo</em></h3>
<p>Veamos a continuación la estructura general del cliente (puedes usar, por 
ejemplo, <code>cliente_echo.py</code> como nombre para el fichero):</p>
<pre><code class="language-python">#!/usr/bin/env python3

### cliente_echo.py

import socket

HOST = '127.0.0.1'  # IP del servidor
PORT = 65432        # Puerto de escucha del servidor

with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.connect((HOST, PORT))
    s.sendall(b'Hola, mundo')
    data = s.recv(1024)

print('Recibido ', repr(data))
</code></pre>
<p>En comparación con el servidor, la estructura del cliente es más simple;
simplemente crea un nuevo objeto <em>socket</em>, conecta con el servidor e invoca
a <code>s.sendall()</code> para enviar el mensaje. Finalmente, espera la recepción de 
la respuesta utilizando <code>s.recv()</code> y la imprime por pantalla.</p>
<h2 id="ejecucion-del-cliente-y-servidor-echo">Ejecución del cliente y servidor echo</h2>
<p>A continuación, ejecutaremos cliente y servidor para observar el estado de 
las conexiones durante su ciclo de vida. </p>
<p>Ejecuta en una terminal el servidor:</p>
<pre><code class="language-bash">$ python3 ./servidor_echo.py
</code></pre>
<p>Como ves, la terminal se bloquea (de hecho, el servidor permanece en 
estado bloqueado) en la invocación:</p>
<pre><code class="language-python">conn, addr = s.accept()
</code></pre>
<p>Realmente, el servidor está esperando a que haya conexiones entrantes por parte
de un cliente. Abre otra terminal y ejecuta el cliente:</p>
<pre><code class="language-bash">$ python3 cliente_echo.py
Recibido 'Hola, mundo'
</code></pre>
<p>En la ventana del servidor, deberías ver algo similar a:</p>
<pre><code class="language-bash">$ python3 ./servidor_echo.py
Conectado ('127.0.0.1, 61234')
</code></pre>
<p>En esta salida, el servidor ha mostrado por pantalla la tupla devuelta por
<code>s.accept()</code>, que incluye la dirección IP y el número de puerto TCP. Dicho
número de puerto (en el ejemplo anterior, 61234) es seleccionado aleatoriamente
por el sistema operativo y puede variar en tu ejecución.</p>
<h2 id="herramientas-para-observar-el-estado-del-socket">Herramientas para observar el estado del socket</h2>
<p>Podemos utilizar la herramienta <em>netstat</em> para observar el estado actual de 
los sockets en cualquier sistema operativo (macOS, Linux e incluso Windows). Por
ejemplo, esta sería la salida de <code>netstat</code> en Linux tras ejecutar el servidor:</p>
<pre><code class="language-bash">netstat -an | grep 65432
Conexiones activas de Internet (servidores y establecidos)
Proto  Recib Enviad Dirección local         Dirección remota       Estado
tcp        0      0 127.0.0.1:65432         0.0.0.0:*               ESCUCHAR
</code></pre>
<p>Observa que hemos filtrado la salida de la orden <code>netcat</code> según el número de 
puerto utilizado. Observa el valor de las columnas <em>Proto, Dirección local</em> y 
<em>Estado</em>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Otra forma de observar el estado de las conexiones es a través de la orden
<code>lsof -i -n</code>. Ejecútala y observa su salida.</p>
</div>
<h2 id="capturas-de-trafico-via-wireshark">Capturas de tráfico vía Wireshark</h2>
<p>Wireshark es una herramienta de código abierto ampliamente utilizada para 
analizar protocolos de comunicación de red en cualquiera de las capas de la pila 
TCP/IP (como también en otros protocolos). Wireshark implementa un amplio 
abanico de filtros para definir criterios de búsqueda en las capturas de
tráfico, aunque de momento, en nuestro caso, no será necesario utilizar filtros
específicos.</p>
<p>Para arrancar Wireshark en la máquina virtual proporcionada (o en cualquier
instalación básica Linux), teclea en tu terminal:</p>
<pre><code class="language-bash">$ sudo wireshark
</code></pre>
<p>Tras el arranque, podemos comenzar una nueva captura de tráfico a través
del menú <code>Capture</code>, opción <code>Start</code>. La pantalla de selección de interfaz 
nos permitirá definir en qué interfaz de red se realizará la captura. En 
nuestro caso, ya que vamos a comunicar dos procesos en la misma máquina, 
elegiremos la interfaz de <em>Loopback</em> (lo) y comenzaremos la captura.</p>
<div class="admonition note">
<p class="admonition-title">Tarea</p>
<p>Arranca Wireshark y prepara una captura sobre la interfaz de <em>loopback</em>.
Ejecuta el servidor <em>echo</em> TCP y el cliente correspondiente, y analiza
el tráfico generado. Especialmente, fíjate en el proceso de establecimiento
de conexión en tres vías, paquetes de <em>Acknowledge</em> tras el envío de cada
mensaje y, en general, en cualquier otro aspecto que consideres de interés.</p>
</div>
<h2 id="sockets-udp">Sockets UDP</h2>
<p>La creación y gestión de <em>sockets</em> UDP en Python resulta todavía más sencilla.
Observa el siguiente código, que crea un servidor UDP utilizando la API
de <em>sockets</em> Python:</p>
<pre><code class="language-python">import socket

udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
udp_socket.bind((&quot;localhost&quot;, 5005))

data = udp_socket.recv(512)
print(data)
</code></pre>
<p>Primero, importamos la biblioteca <code>socket</code> de recepción, igual
que en el caso de TCP. Obviamente, en este caso el tipo de <em>socket</em> pasa a ser
<code>socket.DOCK_DGRAM</code>, para indicar que deseamos utilizar UDP en la comunicación.</p>
<p>El programa espera a la recepción de un paquete utilizando el método bloqueante
<code>recv</code>, cuyo único parámetro indica el número máximo de bytes que deseamos
recibir. Cuando un paquete llega al socket, el metodo <code>recv</code> devolverá un 
<em>array</em> de bytes, que será almacenado en la variable que deseemos.</p>
<p>El envío de datos a través de un <em>socket</em> UDP es también sencillo:</p>
<pre><code class="language-python">import socket

udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
udp_socket.bind((&quot;localhost&quot;, 0))

data = b&quot;Hola, mundo!&quot;
udp_socket.sendto(data,(&quot;localhost&quot;, 5005))
</code></pre>
<p>Observa que, en este caso, asociamos (<em>bind</em>) el socket a un puerto especificado
como 0. Este valor especial indica al sistema operativo que elija para la 
transimisión un puerto <em>origen</em> aleatorio de entre los disponibles en el sistema.</p>
<p>A continuación, creamos los datos a enviar y  los enviamos utilizando el método
<code>sendto()</code>. Este método tomados argumentos: datos a enviar, y precisamente la
dirección de envío. Los datos enviados a través del socket deben formar parte
de un <em>array de bytes</em> (por ello, la cadena a enviar viene precedida por el
carácter <code>b</code>).</p>
<div class="admonition note">
<p class="admonition-title">Tarea</p>
<p>Comprueba que, efectivamente, los códigos de envío y recepción 
a través de UDP funcionan como se espera. </p>
</div>
<div class="admonition warning">
<p class="admonition-title">Nota</p>
<p>Desde la versión 3 de Python, las cadenas se codifican utilizando Unicode.
Al contrario que ASCII, conde cada caracter tiene una representación
en byte directa, Unicode utiliza enteros par representar cada caracter, que
deben ser codificados para obtener una representación en forma de byte.
Uno de esos esquemas de codificación es UTF-8. Por ejemplo, el siguiente 
código muestra cómo codificar una cadena Unicode en una representación de
bytes:</p>
<p><code>cadena= "Hola"
data = cadena.encode("UTF-8")
print(data, type(data))</code></p>
<p>lo cual genera</p>
<p><code>b"Hola" &lt;class 'bytes'&gt;</code></p>
<p>que puede ya ser enviado directamente por red.</p>
</div>
<p>Hasta este punto, los programas UDP han sido totalmente unidireccionales en el
envío/recepción de datos, pero obviamente, un socket UDP es un canal de 
comunicación bidireccional.</p>
<div class="admonition note">
<p class="admonition-title">Tarea</p>
<p>Implementa una funcionalidad similar al servidor <em>echo</em> que vimos para 
TCP, pero utilizando en este caso UDP. Realiza una captura de tráfico 
en <em>Wireshark</em> similar a la realizada en el caso de TCP, y observa las
principales diferencias entre ellas a nivel de tráfico generado.</p>
</div>
<h2 id="envio-de-datos-binarios-a-traves-de-sockets">Envío de datos binarios a través de sockets</h2>
<p>Hasta este punto, hemos visto únicamente cómo enviar cadenas de texto a través
de sockets TCP o UDP, pero es muy probable que sea necesario (o conveniente),
en ocasiones, enviar datos directamente en formato binario (por ejemplo, 
valores numéricos en punto flotante o enteros). Utilizando el módulo 
<code>struct</code> de Python podemos especificar qué tipo o tipos de datos se almacenan
en una secuencia de bytes y cómo decodificarlos. También es posible especificar
en qué lugar de la secuencia se alojan dichos datos, permitiendo el empaquetado 
de múltiples datos de distintos tipos de forma sencilla, y su posterior 
decodificación en el otro extremo de la comunicación.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Para todos los detalles del módulo <code>struct</code>, consulta la página oficial de
<a href="https://docs.python.org/3/library/struct.html">documentación</a>.</p>
</div>
<p>El módulo <code>struct</code> proporciona dos métodos de interés: <code>pack</code> y <code>unpack</code>.</p>
<p>La siguiente sentencia:</p>
<pre><code class="language-python">struct.pack(&quot;&gt;iii&quot;, 1, 2, 3)
</code></pre>
<p>utiliza el método <code>pack</code> para realizar un empaquetado de datos. Concretamente, 
observa como el método recibe dos parámetros:</p>
<ul>
<li>
<p>En primer lugar, el parámetro de formato <em>"&gt;iii"</em>. Define como debe 
  codificarse cada valor en la secuencia de bytes. El primer carácter 
  indica el <em>endianness</em> utilizado, en este caso <em>big endian</em> (utilizaríamos "&gt;" 
  para <em>big endian</em>, "&lt;" para <em>little endian</em> y "=" para <em>network</em> (big) endian).</p>
</li>
<li>
<p>En segundo lugar, los valores a empaquetar.</p>
</li>
</ul>
<p>Observa que el formato, además, incluye el número y tipo de los datos a 
empaquetar (en este caso, tres valores detipo entero). Para otros tipos
de datos, consulta la documentación del módulo.</p>
<p>Desempaquetar los datos enviados en el extremo opuesto es intuitivo:</p>
<pre><code class="language-python">a, b, c = struct.unpack( &quot;&gt;iii&quot; )
</code></pre>
<p>A continuación, mostramos un ejemplo de sistema cliente/servidor TCP que hace
uso del módulo <code>struct</code> para realizar el envío de dos datos enteros y uno
flotante entre un cliente y un servidor.</p>
<pre><code class="language-python">
# Cliente

import binascii                                                                             
import socket                                                                               
import struct                                                                               
import sys                                                                                  

# Socket TCP                                                                                
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)                                    
server_address = ('localhost', 10001)                                                       
sock.connect(server_address)                                                                

packed_data = struct.pack(&quot;=iif&quot;, 1, 4, 2.7)                                                

try:                                                                                        
    # Envio de datos                                                                        
    print('Enviando &quot;%s&quot;' % binascii.hexlify(packed_data))                                  
    sock.sendall(packed_data)                                                               

finally:                                                                                    
    print('Cerrando socket')                                                                
    sock.close()                                                                            
</code></pre>
<pre><code class="language-python">
# Servidor

import binascii                                                                             
import socket                                                                               
import struct                                                                               
import sys                                                                                  

# Socket TCP                                                                                
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)                                    
server_address = ('localhost', 10001)                                                       
sock.bind(server_address)                                                                   
sock.listen(1)                                                                              

while True:                                                                                 
    print('Esperando conexiones entrantes')                                                 
    connection, client_address = sock.accept()                                              
    try:                                                                                    
        data = connection.recv(1024)                                                        
        print('Recibido &quot;%s&quot;' % binascii.hexlify(data))                                     

        unpacked_data = struct.unpack(&quot;=iif&quot;, data)                                         
        print('Desempaquetado:', unpacked_data)                                             

    finally:                                                                                
        connection.close()
</code></pre>
<div class="admonition note">
<p class="admonition-title">Tarea</p>
<p>Ejecuta el anterior sistema cliente servidor y analiza el tráfico generado,
en busca de los datos binarios empaquetados. Experimenta con otros tipos
de datos y <em>endianess</em> y observa las diferencias.</p>
</div>
<h2 id="tarea">Tarea</h2>
<div class="admonition danger">
<p class="admonition-title">Tarea</p>
<p>Se pide diseñar un sistema cliente/servidor programado en Python, que 
simule el envío de un conjunto de datos sensorizados desde un cliente
hacia un servidor. El protocolo a utilizar (formato de datos enviado
por la red a nivel de aplicación) 
debe ser propuesto por el propio alumno y descrito previamente
al desarrollo. Se valorará el uso de múltiples tipos de datos tanto en
el envío de datos sensorizados como de posibles respuestas por parte
del servidor. Se desarrollará una versión utilizando TCP y otra
equivalente usando UDP. El cliente enviará los datos de forma periódica y se
éstos generarán de modo aleatorio.</p>
<p>A modo de entrega, se solicitan los códigos desarrollados, así como un 
análisis del tráfico generado, considerando la sobrecarga (en bytes 
reales enviados) introducida por cada protocolo de capa de transporte.</p>
</div>
<h2 id="ejemplo-de-sistema-clienteservidor-multi-hilo">Ejemplo de sistema cliente/servidor multi-hilo</h2>
<p>Los ejemplos anteriormente descritos, aunque funcionales, adolecen en su diseño
de una característica esencial: el servidor deja de atender peticiones entrantes
mientras trata cada nuevo envío por parte del cliente. Los siguientes ejemplos
muestran implementaciones sencillas con soporte multi-hilo para un sistema
cliente/servidor escrito en Python. </p>
<pre><code class="language-python"># Servidor TCP concurrente

import socket, threading

class ClientThread(threading.Thread):
    def __init__(self,clientAddress,clientsocket):
        threading.Thread.__init__(self)
        self.csocket = clientsocket
        print (&quot;Nueva conexion anyadida: &quot;, clientAddress)
    def run(self):
        print (&quot;Conexion desde: &quot;, clientAddress)
        #self.csocket.send(bytes(&quot;Hi, This is from Server..&quot;,'utf-8'))
        msg = ''
        while True:
            data = self.csocket.recv(2048)
            msg = data.decode()

            if msg=='bye':
              break

            print (&quot;Desde el cliente&quot;, msg)
            self.csocket.send(bytes(msg,'UTF-8'))

        print (&quot;Cliente &quot;, clientAddress , &quot; desconectado...&quot;)

LOCALHOST = &quot;127.0.0.1&quot;
PORT = 8080

server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
server.bind((LOCALHOST, PORT))

print(&quot;Servidor arrancado...&quot;)
print(&quot;Esperando petición de clientes...&quot;)

server.listen(1)

while True:
    clientsock, clientAddress = server.accept()
    newthread = ClientThread(clientAddress, clientsock)
    newthread.start()
</code></pre>
<pre><code class="language-python"># Cliente TCP. El envío de la cadena bye indica petición de desconexión.

import socket

SERVER = &quot;127.0.0.1&quot;
PORT = 8080

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client.connect((SERVER, PORT))
client.sendall(bytes(&quot;Hola, soy un cliente!!&quot;,'UTF-8'))

while True:
  in_data =  client.recv(1024)

  print(&quot;Desde el servidor :&quot; ,in_data.decode())
  out_data = input()
  client.sendall(bytes(out_data,'UTF-8'))

  if out_data=='end':
    break

client.close()
</code></pre>
<div class="admonition note">
<p class="admonition-title">Tarea</p>
<p>Estudia el código del servidor concurrente y observa cómo gestiona la 
creación de hilos para atender cada petición entrante. Conecta simultáneamente
múltiples clientes y observa el estado de los sockets mediante las herramientas
correspondientes.</p>
</div>
<h2 id="tarea-opcional">Tarea opcional</h2>
<div class="admonition danger">
<p class="admonition-title">Tarea opcional</p>
<p>Modifica tu primer entregable para considerar una implementación multihilo
del servidor TCP, siguiendo las directrices de los códigos de ejemplo 
anteriormente proporcionados.</p>
</div>
<h2 id="tarea-opcional_1">Tarea opcional</h2>
<div class="admonition danger">
<p class="admonition-title">Tarea opcional</p>
<p>Modifica el protocolo de envío para que tu aplicación cliente/servidor 
UDP garantice en la medida de lo posible la recepción de los paquetes
enviados desde el cliente, así como su recepción en orden. Vuelve a analizar
el tráfico necesario en este caso comparado con una comunicación básica 
basada en TCP (donde sí se garantizan, a nivel de transporte, dichas
características).</p>
</div></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../../js/bootstrap.bundle.min.js"></script>
        <script>
            var base_url = "../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../js/base.js"></script>
        <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
        <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
        <script src="../../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
